{"version":3,"file":"vendor-react-reconciler.js","sources":["../node_modules/react-reconciler/cjs/react-reconciler-constants.development.js","../node_modules/react-reconciler/constants.js","../node_modules/react-reconciler/cjs/react-reconciler.development.js","../node_modules/react-reconciler/index.js"],"sourcesContent":["/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar SyncLane =\n/*                        */\n1;\nvar InputContinuousLane =\n/*            */\n4;\nvar DefaultLane =\n/*                    */\n16;\nvar IdleLane =\n/*                       */\n536870912;\n\nvar DiscreteEventPriority = SyncLane;\nvar ContinuousEventPriority = InputContinuousLane;\nvar DefaultEventPriority = DefaultLane;\nvar IdleEventPriority = IdleLane;\n\nvar LegacyRoot = 0;\nvar ConcurrentRoot = 1;\n\nexports.ConcurrentRoot = ConcurrentRoot;\nexports.ContinuousEventPriority = ContinuousEventPriority;\nexports.DefaultEventPriority = DefaultEventPriority;\nexports.DiscreteEventPriority = DiscreteEventPriority;\nexports.IdleEventPriority = IdleEventPriority;\nexports.LegacyRoot = LegacyRoot;\n  })();\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-reconciler-constants.production.min.js');\n} else {\n  module.exports = require('./cjs/react-reconciler-constants.development.js');\n}\n","/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  module.exports = function $$$reconciler($$$hostConfig) {\n    var exports = {};\n'use strict';\n\nvar React = require('react');\nvar Scheduler = require('scheduler');\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nvar suppressWarning = false;\nfunction setSuppressWarning(newSuppressWarning) {\n  {\n    suppressWarning = newSuppressWarning;\n  }\n} // In DEV, calls to console.warn and console.error get replaced\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\n\nfunction warn(format) {\n  {\n    if (!suppressWarning) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      printWarning('warn', format, args);\n    }\n  }\n}\nfunction error(format) {\n  {\n    if (!suppressWarning) {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\nvar assign = Object.assign;\n\n/**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */\nfunction get(key) {\n  return key._reactInternals;\n}\nfunction set(key, value) {\n  key._reactInternals = value;\n}\n\n// -----------------------------------------------------------------------------\nvar enablePersistentOffscreenHostContainer = false; // -----------------------------------------------------------------------------\n// the react-reconciler package.\n\nvar enableNewReconciler = false; // Support legacy Primer support on internal FB www\n\nvar enableLazyContextPropagation = false; // FB-only usage. The new API has different semantics.\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n\nvar enableSuspenseAvoidThisFallback = false; // Enables unstable_avoidThisFallback feature in Fizz\nvar warnAboutStringRefs = false; // -----------------------------------------------------------------------------\n// Debugging and DevTools\n// -----------------------------------------------------------------------------\n// Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n// for an experimental timeline tool.\n\nvar enableSchedulingProfiler = true; // Helps identify side effects in render-phase lifecycle hooks and setState\n\nvar enableProfilerTimer = true; // Record durations for commit and passive effects phases.\n\nvar enableProfilerCommitHooks = true; // Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\n\nvar FunctionComponent = 0;\nvar ClassComponent = 1;\nvar IndeterminateComponent = 2; // Before we know whether it is function or class\n\nvar HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n\nvar HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n\nvar HostComponent = 5;\nvar HostText = 6;\nvar Fragment = 7;\nvar Mode = 8;\nvar ContextConsumer = 9;\nvar ContextProvider = 10;\nvar ForwardRef = 11;\nvar Profiler = 12;\nvar SuspenseComponent = 13;\nvar MemoComponent = 14;\nvar SimpleMemoComponent = 15;\nvar LazyComponent = 16;\nvar IncompleteClassComponent = 17;\nvar DehydratedFragment = 18;\nvar SuspenseListComponent = 19;\nvar ScopeComponent = 21;\nvar OffscreenComponent = 22;\nvar LegacyHiddenComponent = 23;\nvar CacheComponent = 24;\nvar TracingMarkerComponent = 25;\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_SCOPE_TYPE = Symbol.for('react.scope');\nvar REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nfunction getWrappedName$1(outerType, innerType, wrapperName) {\n  var functionName = innerType.displayName || innerType.name || '';\n  return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n} // Keep in sync with shared/getComponentNameFromType\n\n\nfunction getContextName$1(type) {\n  return type.displayName || 'Context';\n}\n\nfunction getComponentNameFromFiber(fiber) {\n  var tag = fiber.tag,\n      type = fiber.type;\n\n  switch (tag) {\n    case CacheComponent:\n      return 'Cache';\n\n    case ContextConsumer:\n      var context = type;\n      return getContextName$1(context) + '.Consumer';\n\n    case ContextProvider:\n      var provider = type;\n      return getContextName$1(provider._context) + '.Provider';\n\n    case DehydratedFragment:\n      return 'DehydratedFragment';\n\n    case ForwardRef:\n      return getWrappedName$1(type, type.render, 'ForwardRef');\n\n    case Fragment:\n      return 'Fragment';\n\n    case HostComponent:\n      // Host component type is the display name (e.g. \"div\", \"View\")\n      return type;\n\n    case HostPortal:\n      return 'Portal';\n\n    case HostRoot:\n      return 'Root';\n\n    case HostText:\n      return 'Text';\n\n    case LazyComponent:\n      // Name comes from the type in this case; we don't have a tag.\n      return getComponentNameFromType(type);\n\n    case Mode:\n      if (type === REACT_STRICT_MODE_TYPE) {\n        // Don't be less specific than shared/getComponentNameFromType\n        return 'StrictMode';\n      }\n\n      return 'Mode';\n\n    case OffscreenComponent:\n      return 'Offscreen';\n\n    case Profiler:\n      return 'Profiler';\n\n    case ScopeComponent:\n      return 'Scope';\n\n    case SuspenseComponent:\n      return 'Suspense';\n\n    case SuspenseListComponent:\n      return 'SuspenseList';\n\n    case TracingMarkerComponent:\n      return 'TracingMarker';\n    // The display name for this tags come from the user-provided type:\n\n    case ClassComponent:\n    case FunctionComponent:\n    case IncompleteClassComponent:\n    case IndeterminateComponent:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      if (typeof type === 'function') {\n        return type.displayName || type.name || null;\n      }\n\n      if (typeof type === 'string') {\n        return type;\n      }\n\n      break;\n\n  }\n\n  return null;\n}\n\n// Don't change these two values. They're used by React Dev Tools.\nvar NoFlags =\n/*                      */\n0;\nvar PerformedWork =\n/*                */\n1; // You can change the rest (and add more).\n\nvar Placement =\n/*                    */\n2;\nvar Update =\n/*                       */\n4;\nvar PlacementAndUpdate =\n/*           */\nPlacement | Update;\nvar ChildDeletion =\n/*                */\n16;\nvar ContentReset =\n/*                 */\n32;\nvar Callback =\n/*                     */\n64;\nvar DidCapture =\n/*                   */\n128;\nvar ForceClientRender =\n/*            */\n256;\nvar Ref =\n/*                          */\n512;\nvar Snapshot =\n/*                     */\n1024;\nvar Passive =\n/*                      */\n2048;\nvar Hydrating =\n/*                    */\n4096;\nvar HydratingAndUpdate =\n/*           */\nHydrating | Update;\nvar Visibility =\n/*                   */\n8192;\nvar StoreConsistency =\n/*             */\n16384;\nvar LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency; // Union of all commit flags (flags with the lifetime of a particular commit)\n\nvar HostEffectMask =\n/*               */\n32767; // These are not really side effects, but we still reuse this field.\n\nvar Incomplete =\n/*                   */\n32768;\nvar ShouldCapture =\n/*                */\n65536;\nvar ForceUpdateForLegacySuspense =\n/* */\n131072;\nvar Forked =\n/*                       */\n1048576; // Static tags describe aspects of a fiber that are not specific to a render,\n// e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n// This enables us to defer more work in the unmount case,\n// since we can defer traversing the tree during layout to look for Passive effects,\n// and instead rely on the static flag as a signal that there may be cleanup work.\n\nvar RefStatic =\n/*                    */\n2097152;\nvar LayoutStatic =\n/*                 */\n4194304;\nvar PassiveStatic =\n/*                */\n8388608; // These flags allow us to traverse to fibers that have effects on mount\n// without traversing the entire tree after every commit for\n// double invoking\n\nvar MountLayoutDev =\n/*               */\n16777216;\nvar MountPassiveDev =\n/*              */\n33554432; // Groups of flags that are used in the commit phase to skip over trees that\n// don't contain effects, by checking subtreeFlags.\n\nvar BeforeMutationMask = // TODO: Remove Update flag from before mutation phase by re-landing Visibility\n// flag logic (see #20043)\nUpdate | Snapshot | ( 0);\nvar MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;\nvar LayoutMask = Update | Callback | Ref | Visibility; // TODO: Split into PassiveMountMask and PassiveUnmountMask\n\nvar PassiveMask = Passive | ChildDeletion; // Union of tags that don't get reset on clones.\n// This allows certain concepts to persist without recalculating them,\n// e.g. whether a subtree contains passive effects or portals.\n\nvar StaticMask = LayoutStatic | PassiveStatic | RefStatic;\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nfunction getNearestMountedFiber(fiber) {\n  var node = fiber;\n  var nearestMounted = fiber;\n\n  if (!fiber.alternate) {\n    // If there is no alternate, this might be a new tree that isn't inserted\n    // yet. If it is, then it will have a pending insertion effect on it.\n    var nextNode = node;\n\n    do {\n      node = nextNode;\n\n      if ((node.flags & (Placement | Hydrating)) !== NoFlags) {\n        // This is an insertion or in-progress hydration. The nearest possible\n        // mounted fiber is the parent but we need to continue to figure out\n        // if that one is still mounted.\n        nearestMounted = node.return;\n      }\n\n      nextNode = node.return;\n    } while (nextNode);\n  } else {\n    while (node.return) {\n      node = node.return;\n    }\n  }\n\n  if (node.tag === HostRoot) {\n    // TODO: Check if this was a nested HostRoot when used with\n    // renderContainerIntoSubtree.\n    return nearestMounted;\n  } // If we didn't hit the root, that means that we're in an disconnected tree\n  // that has been unmounted.\n\n\n  return null;\n}\nfunction isFiberMounted(fiber) {\n  return getNearestMountedFiber(fiber) === fiber;\n}\nfunction isMounted(component) {\n  {\n    var owner = ReactCurrentOwner.current;\n\n    if (owner !== null && owner.tag === ClassComponent) {\n      var ownerFiber = owner;\n      var instance = ownerFiber.stateNode;\n\n      if (!instance._warnedAboutRefsInRender) {\n        error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentNameFromFiber(ownerFiber) || 'A component');\n      }\n\n      instance._warnedAboutRefsInRender = true;\n    }\n  }\n\n  var fiber = get(component);\n\n  if (!fiber) {\n    return false;\n  }\n\n  return getNearestMountedFiber(fiber) === fiber;\n}\n\nfunction assertIsMounted(fiber) {\n  if (getNearestMountedFiber(fiber) !== fiber) {\n    throw new Error('Unable to find node on an unmounted component.');\n  }\n}\n\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n\n  if (!alternate) {\n    // If there is no alternate, then we only need to check if it is mounted.\n    var nearestMounted = getNearestMountedFiber(fiber);\n\n    if (nearestMounted === null) {\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (nearestMounted !== fiber) {\n      return null;\n    }\n\n    return fiber;\n  } // If we have two possible branches, we'll walk backwards up to the root\n  // to see what path the root points to. On the way we may hit one of the\n  // special cases and we'll deal with them.\n\n\n  var a = fiber;\n  var b = alternate;\n\n  while (true) {\n    var parentA = a.return;\n\n    if (parentA === null) {\n      // We're at the root.\n      break;\n    }\n\n    var parentB = parentA.alternate;\n\n    if (parentB === null) {\n      // There is no alternate. This is an unusual case. Currently, it only\n      // happens when a Suspense component is hidden. An extra fragment fiber\n      // is inserted in between the Suspense fiber and its children. Skip\n      // over this extra fragment fiber and proceed to the next parent.\n      var nextParent = parentA.return;\n\n      if (nextParent !== null) {\n        a = b = nextParent;\n        continue;\n      } // If there's no parent, we're at the root.\n\n\n      break;\n    } // If both copies of the parent fiber point to the same child, we can\n    // assume that the child is current. This happens when we bailout on low\n    // priority: the bailed out fiber's child reuses the current child.\n\n\n    if (parentA.child === parentB.child) {\n      var child = parentA.child;\n\n      while (child) {\n        if (child === a) {\n          // We've determined that A is the current branch.\n          assertIsMounted(parentA);\n          return fiber;\n        }\n\n        if (child === b) {\n          // We've determined that B is the current branch.\n          assertIsMounted(parentA);\n          return alternate;\n        }\n\n        child = child.sibling;\n      } // We should never have an alternate for any mounting node. So the only\n      // way this could possibly happen is if this was unmounted, if at all.\n\n\n      throw new Error('Unable to find node on an unmounted component.');\n    }\n\n    if (a.return !== b.return) {\n      // The return pointer of A and the return pointer of B point to different\n      // fibers. We assume that return pointers never criss-cross, so A must\n      // belong to the child set of A.return, and B must belong to the child\n      // set of B.return.\n      a = parentA;\n      b = parentB;\n    } else {\n      // The return pointers point to the same fiber. We'll have to use the\n      // default, slow path: scan the child sets of each parent alternate to see\n      // which child belongs to which set.\n      //\n      // Search parent A's child set\n      var didFindChild = false;\n      var _child = parentA.child;\n\n      while (_child) {\n        if (_child === a) {\n          didFindChild = true;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n\n        if (_child === b) {\n          didFindChild = true;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n\n        _child = _child.sibling;\n      }\n\n      if (!didFindChild) {\n        // Search parent B's child set\n        _child = parentB.child;\n\n        while (_child) {\n          if (_child === a) {\n            didFindChild = true;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n\n          if (_child === b) {\n            didFindChild = true;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n\n          _child = _child.sibling;\n        }\n\n        if (!didFindChild) {\n          throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');\n        }\n      }\n    }\n\n    if (a.alternate !== b) {\n      throw new Error(\"Return fibers should always be each others' alternates. \" + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n  } // If the root is not a host container, we're in a disconnected tree. I.e.\n  // unmounted.\n\n\n  if (a.tag !== HostRoot) {\n    throw new Error('Unable to find node on an unmounted component.');\n  }\n\n  if (a.stateNode.current === a) {\n    // We've determined that A is the current branch.\n    return fiber;\n  } // Otherwise B has to be current branch.\n\n\n  return alternate;\n}\nfunction findCurrentHostFiber(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\n}\n\nfunction findCurrentHostFiberImpl(node) {\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  if (node.tag === HostComponent || node.tag === HostText) {\n    return node;\n  }\n\n  var child = node.child;\n\n  while (child !== null) {\n    var match = findCurrentHostFiberImpl(child);\n\n    if (match !== null) {\n      return match;\n    }\n\n    child = child.sibling;\n  }\n\n  return null;\n}\n\nfunction findCurrentHostFiberWithNoPortals(parent) {\n  var currentParent = findCurrentFiberUsingSlowPath(parent);\n  return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\n}\n\nfunction findCurrentHostFiberWithNoPortalsImpl(node) {\n  // Next we'll drill down this component to find the first HostComponent/Text.\n  if (node.tag === HostComponent || node.tag === HostText) {\n    return node;\n  }\n\n  var child = node.child;\n\n  while (child !== null) {\n    if (child.tag !== HostPortal) {\n      var match = findCurrentHostFiberWithNoPortalsImpl(child);\n\n      if (match !== null) {\n        return match;\n      }\n    }\n\n    child = child.sibling;\n  }\n\n  return null;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// This is a host config that's used for the `react-reconciler` package on npm.\n// It is only used by third-party renderers.\n//\n// Its API lets you pass the host config as an argument.\n// However, inside the `react-reconciler` we treat host config as a module.\n// This file is a shim between two worlds.\n//\n// It works because the `react-reconciler` bundle is wrapped in something like:\n//\n// module.exports = function ($$$config) {\n//   /* reconciler code */\n// }\n//\n// So `$$$config` looks like a global variable, but it's\n// really an argument to a top-level wrapping function.\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\n// eslint-disable-line no-undef\nvar getPublicInstance = $$$hostConfig.getPublicInstance;\nvar getRootHostContext = $$$hostConfig.getRootHostContext;\nvar getChildHostContext = $$$hostConfig.getChildHostContext;\nvar prepareForCommit = $$$hostConfig.prepareForCommit;\nvar resetAfterCommit = $$$hostConfig.resetAfterCommit;\nvar createInstance = $$$hostConfig.createInstance;\nvar appendInitialChild = $$$hostConfig.appendInitialChild;\nvar finalizeInitialChildren = $$$hostConfig.finalizeInitialChildren;\nvar prepareUpdate = $$$hostConfig.prepareUpdate;\nvar shouldSetTextContent = $$$hostConfig.shouldSetTextContent;\nvar createTextInstance = $$$hostConfig.createTextInstance;\nvar scheduleTimeout = $$$hostConfig.scheduleTimeout;\nvar cancelTimeout = $$$hostConfig.cancelTimeout;\nvar noTimeout = $$$hostConfig.noTimeout;\nvar now = $$$hostConfig.now;\nvar isPrimaryRenderer = $$$hostConfig.isPrimaryRenderer;\nvar warnsIfNotActing = $$$hostConfig.warnsIfNotActing;\nvar supportsMutation = $$$hostConfig.supportsMutation;\nvar supportsPersistence = $$$hostConfig.supportsPersistence;\nvar supportsHydration = $$$hostConfig.supportsHydration;\nvar getInstanceFromNode = $$$hostConfig.getInstanceFromNode;\nvar beforeActiveInstanceBlur = $$$hostConfig.beforeActiveInstanceBlur;\nvar afterActiveInstanceBlur = $$$hostConfig.afterActiveInstanceBlur;\nvar preparePortalMount = $$$hostConfig.preparePortalMount;\nvar prepareScopeUpdate = $$$hostConfig.preparePortalMount;\nvar getInstanceFromScope = $$$hostConfig.getInstanceFromScope;\nvar getCurrentEventPriority = $$$hostConfig.getCurrentEventPriority;\nvar detachDeletedInstance = $$$hostConfig.detachDeletedInstance; // -------------------\n//      Microtasks\n//     (optional)\n// -------------------\n\nvar supportsMicrotasks = $$$hostConfig.supportsMicrotasks;\nvar scheduleMicrotask = $$$hostConfig.scheduleMicrotask; // -------------------\n//      Test selectors\n//     (optional)\n// -------------------\n\nvar supportsTestSelectors = $$$hostConfig.supportsTestSelectors;\nvar findFiberRoot = $$$hostConfig.findFiberRoot;\nvar getBoundingRect = $$$hostConfig.getBoundingRect;\nvar getTextContent = $$$hostConfig.getTextContent;\nvar isHiddenSubtree = $$$hostConfig.isHiddenSubtree;\nvar matchAccessibilityRole = $$$hostConfig.matchAccessibilityRole;\nvar setFocusIfFocusable = $$$hostConfig.setFocusIfFocusable;\nvar setupIntersectionObserver = $$$hostConfig.setupIntersectionObserver; // -------------------\n//      Mutation\n//     (optional)\n// -------------------\n\nvar appendChild = $$$hostConfig.appendChild;\nvar appendChildToContainer = $$$hostConfig.appendChildToContainer;\nvar commitTextUpdate = $$$hostConfig.commitTextUpdate;\nvar commitMount = $$$hostConfig.commitMount;\nvar commitUpdate = $$$hostConfig.commitUpdate;\nvar insertBefore = $$$hostConfig.insertBefore;\nvar insertInContainerBefore = $$$hostConfig.insertInContainerBefore;\nvar removeChild = $$$hostConfig.removeChild;\nvar removeChildFromContainer = $$$hostConfig.removeChildFromContainer;\nvar resetTextContent = $$$hostConfig.resetTextContent;\nvar hideInstance = $$$hostConfig.hideInstance;\nvar hideTextInstance = $$$hostConfig.hideTextInstance;\nvar unhideInstance = $$$hostConfig.unhideInstance;\nvar unhideTextInstance = $$$hostConfig.unhideTextInstance;\nvar clearContainer = $$$hostConfig.clearContainer; // -------------------\n//     Persistence\n//     (optional)\n// -------------------\n\nvar cloneInstance = $$$hostConfig.cloneInstance;\nvar createContainerChildSet = $$$hostConfig.createContainerChildSet;\nvar appendChildToContainerChildSet = $$$hostConfig.appendChildToContainerChildSet;\nvar finalizeContainerChildren = $$$hostConfig.finalizeContainerChildren;\nvar replaceContainerChildren = $$$hostConfig.replaceContainerChildren;\nvar getOffscreenContainerType = $$$hostConfig.getOffscreenContainerType;\nvar getOffscreenContainerProps = $$$hostConfig.getOffscreenContainerProps;\nvar cloneHiddenInstance = $$$hostConfig.cloneHiddenInstance;\nvar cloneHiddenTextInstance = $$$hostConfig.cloneHiddenTextInstance; // -------------------\n//     Hydration\n//     (optional)\n// -------------------\n\nvar canHydrateInstance = $$$hostConfig.canHydrateInstance;\nvar canHydrateTextInstance = $$$hostConfig.canHydrateTextInstance;\nvar canHydrateSuspenseInstance = $$$hostConfig.canHydrateSuspenseInstance;\nvar isSuspenseInstancePending = $$$hostConfig.isSuspenseInstancePending;\nvar isSuspenseInstanceFallback = $$$hostConfig.isSuspenseInstanceFallback;\nvar registerSuspenseInstanceRetry = $$$hostConfig.registerSuspenseInstanceRetry;\nvar getNextHydratableSibling = $$$hostConfig.getNextHydratableSibling;\nvar getFirstHydratableChild = $$$hostConfig.getFirstHydratableChild;\nvar getFirstHydratableChildWithinContainer = $$$hostConfig.getFirstHydratableChildWithinContainer;\nvar getFirstHydratableChildWithinSuspenseInstance = $$$hostConfig.getFirstHydratableChildWithinSuspenseInstance;\nvar hydrateInstance = $$$hostConfig.hydrateInstance;\nvar hydrateTextInstance = $$$hostConfig.hydrateTextInstance;\nvar hydrateSuspenseInstance = $$$hostConfig.hydrateSuspenseInstance;\nvar getNextHydratableInstanceAfterSuspenseInstance = $$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance;\nvar commitHydratedContainer = $$$hostConfig.commitHydratedContainer;\nvar commitHydratedSuspenseInstance = $$$hostConfig.commitHydratedSuspenseInstance;\nvar clearSuspenseBoundary = $$$hostConfig.clearSuspenseBoundary;\nvar clearSuspenseBoundaryFromContainer = $$$hostConfig.clearSuspenseBoundaryFromContainer;\nvar shouldDeleteUnhydratedTailInstances = $$$hostConfig.shouldDeleteUnhydratedTailInstances;\nvar didNotMatchHydratedContainerTextInstance = $$$hostConfig.didNotMatchHydratedContainerTextInstance;\nvar didNotMatchHydratedTextInstance = $$$hostConfig.didNotMatchHydratedTextInstance;\nvar didNotHydrateInstanceWithinContainer = $$$hostConfig.didNotHydrateInstanceWithinContainer;\nvar didNotHydrateInstanceWithinSuspenseInstance = $$$hostConfig.didNotHydrateInstanceWithinSuspenseInstance;\nvar didNotHydrateInstance = $$$hostConfig.didNotHydrateInstance;\nvar didNotFindHydratableInstanceWithinContainer = $$$hostConfig.didNotFindHydratableInstanceWithinContainer;\nvar didNotFindHydratableTextInstanceWithinContainer = $$$hostConfig.didNotFindHydratableTextInstanceWithinContainer;\nvar didNotFindHydratableSuspenseInstanceWithinContainer = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinContainer;\nvar didNotFindHydratableInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableInstanceWithinSuspenseInstance;\nvar didNotFindHydratableTextInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableTextInstanceWithinSuspenseInstance;\nvar didNotFindHydratableSuspenseInstanceWithinSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance;\nvar didNotFindHydratableInstance = $$$hostConfig.didNotFindHydratableInstance;\nvar didNotFindHydratableTextInstance = $$$hostConfig.didNotFindHydratableTextInstance;\nvar didNotFindHydratableSuspenseInstance = $$$hostConfig.didNotFindHydratableSuspenseInstance;\nvar errorHydratingContainer = $$$hostConfig.errorHydratingContainer;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\n\nfunction describeClassComponentFrame(ctor, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(ctor, true);\n  }\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar valueStack = [];\nvar fiberStack;\n\n{\n  fiberStack = [];\n}\n\nvar index = -1;\n\nfunction createCursor(defaultValue) {\n  return {\n    current: defaultValue\n  };\n}\n\nfunction pop(cursor, fiber) {\n  if (index < 0) {\n    {\n      error('Unexpected pop.');\n    }\n\n    return;\n  }\n\n  {\n    if (fiber !== fiberStack[index]) {\n      error('Unexpected Fiber popped.');\n    }\n  }\n\n  cursor.current = valueStack[index];\n  valueStack[index] = null;\n\n  {\n    fiberStack[index] = null;\n  }\n\n  index--;\n}\n\nfunction push(cursor, value, fiber) {\n  index++;\n  valueStack[index] = cursor.current;\n\n  {\n    fiberStack[index] = fiber;\n  }\n\n  cursor.current = value;\n}\n\nvar warnedAboutMissingGetChildContext;\n\n{\n  warnedAboutMissingGetChildContext = {};\n}\n\nvar emptyContextObject = {};\n\n{\n  Object.freeze(emptyContextObject);\n} // A cursor to the current merged context object on the stack.\n\n\nvar contextStackCursor = createCursor(emptyContextObject); // A cursor to a boolean indicating whether the context has changed.\n\nvar didPerformWorkStackCursor = createCursor(false); // Keep track of the previous context object that was on the stack.\n// We use this to get access to the parent context after we have already\n// pushed the next context provider, and now need to merge their contexts.\n\nvar previousContext = emptyContextObject;\n\nfunction getUnmaskedContext(workInProgress, Component, didPushOwnContextIfProvider) {\n  {\n    if (didPushOwnContextIfProvider && isContextProvider(Component)) {\n      // If the fiber is a context provider itself, when we read its context\n      // we may have already pushed its own child context on the stack. A context\n      // provider should not \"see\" its own child context. Therefore we read the\n      // previous (parent) context instead for a context provider.\n      return previousContext;\n    }\n\n    return contextStackCursor.current;\n  }\n}\n\nfunction cacheContext(workInProgress, unmaskedContext, maskedContext) {\n  {\n    var instance = workInProgress.stateNode;\n    instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;\n    instance.__reactInternalMemoizedMaskedChildContext = maskedContext;\n  }\n}\n\nfunction getMaskedContext(workInProgress, unmaskedContext) {\n  {\n    var type = workInProgress.type;\n    var contextTypes = type.contextTypes;\n\n    if (!contextTypes) {\n      return emptyContextObject;\n    } // Avoid recreating masked context unless unmasked context has changed.\n    // Failing to do this will result in unnecessary calls to componentWillReceiveProps.\n    // This may trigger infinite loops if componentWillReceiveProps calls setState.\n\n\n    var instance = workInProgress.stateNode;\n\n    if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {\n      return instance.__reactInternalMemoizedMaskedChildContext;\n    }\n\n    var context = {};\n\n    for (var key in contextTypes) {\n      context[key] = unmaskedContext[key];\n    }\n\n    {\n      var name = getComponentNameFromFiber(workInProgress) || 'Unknown';\n      checkPropTypes(contextTypes, context, 'context', name);\n    } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n    // Context is created before the class component is instantiated so check for instance.\n\n\n    if (instance) {\n      cacheContext(workInProgress, unmaskedContext, context);\n    }\n\n    return context;\n  }\n}\n\nfunction hasContextChanged() {\n  {\n    return didPerformWorkStackCursor.current;\n  }\n}\n\nfunction isContextProvider(type) {\n  {\n    var childContextTypes = type.childContextTypes;\n    return childContextTypes !== null && childContextTypes !== undefined;\n  }\n}\n\nfunction popContext(fiber) {\n  {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction popTopLevelContextObject(fiber) {\n  {\n    pop(didPerformWorkStackCursor, fiber);\n    pop(contextStackCursor, fiber);\n  }\n}\n\nfunction pushTopLevelContextObject(fiber, context, didChange) {\n  {\n    if (contextStackCursor.current !== emptyContextObject) {\n      throw new Error('Unexpected context found on stack. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    push(contextStackCursor, context, fiber);\n    push(didPerformWorkStackCursor, didChange, fiber);\n  }\n}\n\nfunction processChildContext(fiber, type, parentContext) {\n  {\n    var instance = fiber.stateNode;\n    var childContextTypes = type.childContextTypes; // TODO (bvaughn) Replace this behavior with an invariant() in the future.\n    // It has only been added in Fiber to match the (unintentional) behavior in Stack.\n\n    if (typeof instance.getChildContext !== 'function') {\n      {\n        var componentName = getComponentNameFromFiber(fiber) || 'Unknown';\n\n        if (!warnedAboutMissingGetChildContext[componentName]) {\n          warnedAboutMissingGetChildContext[componentName] = true;\n\n          error('%s.childContextTypes is specified but there is no getChildContext() method ' + 'on the instance. You can either define getChildContext() on %s or remove ' + 'childContextTypes from it.', componentName, componentName);\n        }\n      }\n\n      return parentContext;\n    }\n\n    var childContext = instance.getChildContext();\n\n    for (var contextKey in childContext) {\n      if (!(contextKey in childContextTypes)) {\n        throw new Error((getComponentNameFromFiber(fiber) || 'Unknown') + \".getChildContext(): key \\\"\" + contextKey + \"\\\" is not defined in childContextTypes.\");\n      }\n    }\n\n    {\n      var name = getComponentNameFromFiber(fiber) || 'Unknown';\n      checkPropTypes(childContextTypes, childContext, 'child context', name);\n    }\n\n    return assign({}, parentContext, childContext);\n  }\n}\n\nfunction pushContextProvider(workInProgress) {\n  {\n    var instance = workInProgress.stateNode; // We push the context as early as possible to ensure stack integrity.\n    // If the instance does not exist yet, we will push null at first,\n    // and replace it on the stack later when invalidating the context.\n\n    var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject; // Remember the parent context so we can merge with it later.\n    // Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.\n\n    previousContext = contextStackCursor.current;\n    push(contextStackCursor, memoizedMergedChildContext, workInProgress);\n    push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress);\n    return true;\n  }\n}\n\nfunction invalidateContextProvider(workInProgress, type, didChange) {\n  {\n    var instance = workInProgress.stateNode;\n\n    if (!instance) {\n      throw new Error('Expected to have an instance by this point. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    if (didChange) {\n      // Merge parent and own context.\n      // Skip this if we're not updating due to sCU.\n      // This avoids unnecessarily recomputing memoized values.\n      var mergedContext = processChildContext(workInProgress, type, previousContext);\n      instance.__reactInternalMemoizedMergedChildContext = mergedContext; // Replace the old (or empty) context with the new one.\n      // It is important to unwind the context in the reverse order.\n\n      pop(didPerformWorkStackCursor, workInProgress);\n      pop(contextStackCursor, workInProgress); // Now push the new context and mark that it has changed.\n\n      push(contextStackCursor, mergedContext, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    } else {\n      pop(didPerformWorkStackCursor, workInProgress);\n      push(didPerformWorkStackCursor, didChange, workInProgress);\n    }\n  }\n}\n\nfunction findCurrentUnmaskedContext(fiber) {\n  {\n    // Currently this is only used with renderSubtreeIntoContainer; not sure if it\n    // makes sense elsewhere\n    if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {\n      throw new Error('Expected subtree parent to be a mounted class component. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    var node = fiber;\n\n    do {\n      switch (node.tag) {\n        case HostRoot:\n          return node.stateNode.context;\n\n        case ClassComponent:\n          {\n            var Component = node.type;\n\n            if (isContextProvider(Component)) {\n              return node.stateNode.__reactInternalMemoizedMergedChildContext;\n            }\n\n            break;\n          }\n      }\n\n      node = node.return;\n    } while (node !== null);\n\n    throw new Error('Found unexpected detached subtree parent. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n}\n\nvar LegacyRoot = 0;\nvar ConcurrentRoot = 1;\n\nvar NoMode =\n/*                         */\n0; // TODO: Remove ConcurrentMode by reading from the root tag instead\n\nvar ConcurrentMode =\n/*                 */\n1;\nvar ProfileMode =\n/*                    */\n2;\nvar StrictLegacyMode =\n/*               */\n8;\nvar StrictEffectsMode =\n/*              */\n16;\n\n// TODO: This is pretty well supported by browsers. Maybe we can drop it.\nvar clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n// Based on:\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\nvar log = Math.log;\nvar LN2 = Math.LN2;\n\nfunction clz32Fallback(x) {\n  var asUint = x >>> 0;\n\n  if (asUint === 0) {\n    return 32;\n  }\n\n  return 31 - (log(asUint) / LN2 | 0) | 0;\n}\n\n// If those values are changed that package should be rebuilt and redeployed.\n\nvar TotalLanes = 31;\nvar NoLanes =\n/*                        */\n0;\nvar NoLane =\n/*                          */\n0;\nvar SyncLane =\n/*                        */\n1;\nvar InputContinuousHydrationLane =\n/*    */\n2;\nvar InputContinuousLane =\n/*            */\n4;\nvar DefaultHydrationLane =\n/*            */\n8;\nvar DefaultLane =\n/*                    */\n16;\nvar TransitionHydrationLane =\n/*                */\n32;\nvar TransitionLanes =\n/*                       */\n4194240;\nvar TransitionLane1 =\n/*                        */\n64;\nvar TransitionLane2 =\n/*                        */\n128;\nvar TransitionLane3 =\n/*                        */\n256;\nvar TransitionLane4 =\n/*                        */\n512;\nvar TransitionLane5 =\n/*                        */\n1024;\nvar TransitionLane6 =\n/*                        */\n2048;\nvar TransitionLane7 =\n/*                        */\n4096;\nvar TransitionLane8 =\n/*                        */\n8192;\nvar TransitionLane9 =\n/*                        */\n16384;\nvar TransitionLane10 =\n/*                       */\n32768;\nvar TransitionLane11 =\n/*                       */\n65536;\nvar TransitionLane12 =\n/*                       */\n131072;\nvar TransitionLane13 =\n/*                       */\n262144;\nvar TransitionLane14 =\n/*                       */\n524288;\nvar TransitionLane15 =\n/*                       */\n1048576;\nvar TransitionLane16 =\n/*                       */\n2097152;\nvar RetryLanes =\n/*                            */\n130023424;\nvar RetryLane1 =\n/*                             */\n4194304;\nvar RetryLane2 =\n/*                             */\n8388608;\nvar RetryLane3 =\n/*                             */\n16777216;\nvar RetryLane4 =\n/*                             */\n33554432;\nvar RetryLane5 =\n/*                             */\n67108864;\nvar SomeRetryLane = RetryLane1;\nvar SelectiveHydrationLane =\n/*          */\n134217728;\nvar NonIdleLanes =\n/*                                 */\n268435455;\nvar IdleHydrationLane =\n/*               */\n268435456;\nvar IdleLane =\n/*                       */\n536870912;\nvar OffscreenLane =\n/*                   */\n1073741824; // This function is used for the experimental timeline (react-devtools-timeline)\n// It should be kept in sync with the Lanes values above.\n\nfunction getLabelForLane(lane) {\n  {\n    if (lane & SyncLane) {\n      return 'Sync';\n    }\n\n    if (lane & InputContinuousHydrationLane) {\n      return 'InputContinuousHydration';\n    }\n\n    if (lane & InputContinuousLane) {\n      return 'InputContinuous';\n    }\n\n    if (lane & DefaultHydrationLane) {\n      return 'DefaultHydration';\n    }\n\n    if (lane & DefaultLane) {\n      return 'Default';\n    }\n\n    if (lane & TransitionHydrationLane) {\n      return 'TransitionHydration';\n    }\n\n    if (lane & TransitionLanes) {\n      return 'Transition';\n    }\n\n    if (lane & RetryLanes) {\n      return 'Retry';\n    }\n\n    if (lane & SelectiveHydrationLane) {\n      return 'SelectiveHydration';\n    }\n\n    if (lane & IdleHydrationLane) {\n      return 'IdleHydration';\n    }\n\n    if (lane & IdleLane) {\n      return 'Idle';\n    }\n\n    if (lane & OffscreenLane) {\n      return 'Offscreen';\n    }\n  }\n}\nvar NoTimestamp = -1;\nvar nextTransitionLane = TransitionLane1;\nvar nextRetryLane = RetryLane1;\n\nfunction getHighestPriorityLanes(lanes) {\n  switch (getHighestPriorityLane(lanes)) {\n    case SyncLane:\n      return SyncLane;\n\n    case InputContinuousHydrationLane:\n      return InputContinuousHydrationLane;\n\n    case InputContinuousLane:\n      return InputContinuousLane;\n\n    case DefaultHydrationLane:\n      return DefaultHydrationLane;\n\n    case DefaultLane:\n      return DefaultLane;\n\n    case TransitionHydrationLane:\n      return TransitionHydrationLane;\n\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return lanes & TransitionLanes;\n\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      return lanes & RetryLanes;\n\n    case SelectiveHydrationLane:\n      return SelectiveHydrationLane;\n\n    case IdleHydrationLane:\n      return IdleHydrationLane;\n\n    case IdleLane:\n      return IdleLane;\n\n    case OffscreenLane:\n      return OffscreenLane;\n\n    default:\n      {\n        error('Should have found matching lanes. This is a bug in React.');\n      } // This shouldn't be reachable, but as a fallback, return the entire bitmask.\n\n\n      return lanes;\n  }\n}\n\nfunction getNextLanes(root, wipLanes) {\n  // Early bailout if there's no pending work left.\n  var pendingLanes = root.pendingLanes;\n\n  if (pendingLanes === NoLanes) {\n    return NoLanes;\n  }\n\n  var nextLanes = NoLanes;\n  var suspendedLanes = root.suspendedLanes;\n  var pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,\n  // even if the work is suspended.\n\n  var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n\n  if (nonIdlePendingLanes !== NoLanes) {\n    var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n\n    if (nonIdleUnblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n    } else {\n      var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n\n      if (nonIdlePingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n      }\n    }\n  } else {\n    // The only remaining work is Idle.\n    var unblockedLanes = pendingLanes & ~suspendedLanes;\n\n    if (unblockedLanes !== NoLanes) {\n      nextLanes = getHighestPriorityLanes(unblockedLanes);\n    } else {\n      if (pingedLanes !== NoLanes) {\n        nextLanes = getHighestPriorityLanes(pingedLanes);\n      }\n    }\n  }\n\n  if (nextLanes === NoLanes) {\n    // This should only be reachable if we're suspended\n    // TODO: Consider warning in this path if a fallback timer is not scheduled.\n    return NoLanes;\n  } // If we're already in the middle of a render, switching lanes will interrupt\n  // it and we'll lose our progress. We should only do this if the new lanes are\n  // higher priority.\n\n\n  if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n  // bother waiting until the root is complete.\n  (wipLanes & suspendedLanes) === NoLanes) {\n    var nextLane = getHighestPriorityLane(nextLanes);\n    var wipLane = getHighestPriorityLane(wipLanes);\n\n    if ( // Tests whether the next lane is equal or lower priority than the wip\n    // one. This works because the bits decrease in priority as you go left.\n    nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The\n    // only difference between default updates and transition updates is that\n    // default updates do not support refresh transitions.\n    nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\n      // Keep working on the existing in-progress tree. Do not interrupt.\n      return wipLanes;\n    }\n  }\n\n  if ((nextLanes & InputContinuousLane) !== NoLanes) {\n    // When updates are sync by default, we entangle continuous priority updates\n    // and default updates, so they render in the same batch. The only reason\n    // they use separate lanes is because continuous updates should interrupt\n    // transitions, but default updates should not.\n    nextLanes |= pendingLanes & DefaultLane;\n  } // Check for entangled lanes and add them to the batch.\n  //\n  // A lane is said to be entangled with another when it's not allowed to render\n  // in a batch that does not also include the other lane. Typically we do this\n  // when multiple updates have the same source, and we only want to respond to\n  // the most recent event from that source.\n  //\n  // Note that we apply entanglements *after* checking for partial work above.\n  // This means that if a lane is entangled during an interleaved event while\n  // it's already rendering, we won't interrupt it. This is intentional, since\n  // entanglement is usually \"best effort\": we'll try our best to render the\n  // lanes in the same batch, but it's not worth throwing out partially\n  // completed work in order to do it.\n  // TODO: Reconsider this. The counter-argument is that the partial work\n  // represents an intermediate state, which we don't want to show to the user.\n  // And by spending extra time finishing it, we're increasing the amount of\n  // time it takes to show the final state, which is what they are actually\n  // waiting for.\n  //\n  // For those exceptions where entanglement is semantically important, like\n  // useMutableSource, we should ensure that there is no partial work at the\n  // time we apply the entanglement.\n\n\n  var entangledLanes = root.entangledLanes;\n\n  if (entangledLanes !== NoLanes) {\n    var entanglements = root.entanglements;\n    var lanes = nextLanes & entangledLanes;\n\n    while (lanes > 0) {\n      var index = pickArbitraryLaneIndex(lanes);\n      var lane = 1 << index;\n      nextLanes |= entanglements[index];\n      lanes &= ~lane;\n    }\n  }\n\n  return nextLanes;\n}\nfunction getMostRecentEventTime(root, lanes) {\n  var eventTimes = root.eventTimes;\n  var mostRecentEventTime = NoTimestamp;\n\n  while (lanes > 0) {\n    var index = pickArbitraryLaneIndex(lanes);\n    var lane = 1 << index;\n    var eventTime = eventTimes[index];\n\n    if (eventTime > mostRecentEventTime) {\n      mostRecentEventTime = eventTime;\n    }\n\n    lanes &= ~lane;\n  }\n\n  return mostRecentEventTime;\n}\n\nfunction computeExpirationTime(lane, currentTime) {\n  switch (lane) {\n    case SyncLane:\n    case InputContinuousHydrationLane:\n    case InputContinuousLane:\n      // User interactions should expire slightly more quickly.\n      //\n      // NOTE: This is set to the corresponding constant as in Scheduler.js.\n      // When we made it larger, a product metric in www regressed, suggesting\n      // there's a user interaction that's being starved by a series of\n      // synchronous updates. If that theory is correct, the proper solution is\n      // to fix the starvation. However, this scenario supports the idea that\n      // expiration times are an important safeguard when starvation\n      // does happen.\n      return currentTime + 250;\n\n    case DefaultHydrationLane:\n    case DefaultLane:\n    case TransitionHydrationLane:\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n      return currentTime + 5000;\n\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      // TODO: Retries should be allowed to expire if they are CPU bound for\n      // too long, but when I made this change it caused a spike in browser\n      // crashes. There must be some other underlying bug; not super urgent but\n      // ideally should figure out why and fix it. Unfortunately we don't have\n      // a repro for the crashes, only detected via production metrics.\n      return NoTimestamp;\n\n    case SelectiveHydrationLane:\n    case IdleHydrationLane:\n    case IdleLane:\n    case OffscreenLane:\n      // Anything idle priority or lower should never expire.\n      return NoTimestamp;\n\n    default:\n      {\n        error('Should have found matching lanes. This is a bug in React.');\n      }\n\n      return NoTimestamp;\n  }\n}\n\nfunction markStarvedLanesAsExpired(root, currentTime) {\n  // TODO: This gets called every time we yield. We can optimize by storing\n  // the earliest expiration time on the root. Then use that to quickly bail out\n  // of this function.\n  var pendingLanes = root.pendingLanes;\n  var suspendedLanes = root.suspendedLanes;\n  var pingedLanes = root.pingedLanes;\n  var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their\n  // expiration time. If so, we'll assume the update is being starved and mark\n  // it as expired to force it to finish.\n\n  var lanes = pendingLanes;\n\n  while (lanes > 0) {\n    var index = pickArbitraryLaneIndex(lanes);\n    var lane = 1 << index;\n    var expirationTime = expirationTimes[index];\n\n    if (expirationTime === NoTimestamp) {\n      // Found a pending lane with no expiration time. If it's not suspended, or\n      // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n      // using the current time.\n      if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n        // Assumes timestamps are monotonically increasing.\n        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n      }\n    } else if (expirationTime <= currentTime) {\n      // This lane expired\n      root.expiredLanes |= lane;\n    }\n\n    lanes &= ~lane;\n  }\n} // This returns the highest priority pending lanes regardless of whether they\n// are suspended.\n\nfunction getHighestPriorityPendingLanes(root) {\n  return getHighestPriorityLanes(root.pendingLanes);\n}\nfunction getLanesToRetrySynchronouslyOnError(root) {\n  var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n\n  if (everythingButOffscreen !== NoLanes) {\n    return everythingButOffscreen;\n  }\n\n  if (everythingButOffscreen & OffscreenLane) {\n    return OffscreenLane;\n  }\n\n  return NoLanes;\n}\nfunction includesSyncLane(lanes) {\n  return (lanes & SyncLane) !== NoLanes;\n}\nfunction includesNonIdleWork(lanes) {\n  return (lanes & NonIdleLanes) !== NoLanes;\n}\nfunction includesOnlyRetries(lanes) {\n  return (lanes & RetryLanes) === lanes;\n}\nfunction includesOnlyTransitions(lanes) {\n  return (lanes & TransitionLanes) === lanes;\n}\nfunction includesBlockingLane(root, lanes) {\n\n  var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n  return (lanes & SyncDefaultLanes) !== NoLanes;\n}\nfunction includesExpiredLane(root, lanes) {\n  // This is a separate check from includesBlockingLane because a lane can\n  // expire after a render has already started.\n  return (lanes & root.expiredLanes) !== NoLanes;\n}\nfunction isTransitionLane(lane) {\n  return (lane & TransitionLanes) !== 0;\n}\nfunction claimNextTransitionLane() {\n  // Cycle through the lanes, assigning each new transition to the next lane.\n  // In most cases, this means every transition gets its own lane, until we\n  // run out of lanes and cycle back to the beginning.\n  var lane = nextTransitionLane;\n  nextTransitionLane <<= 1;\n\n  if ((nextTransitionLane & TransitionLanes) === 0) {\n    nextTransitionLane = TransitionLane1;\n  }\n\n  return lane;\n}\nfunction claimNextRetryLane() {\n  var lane = nextRetryLane;\n  nextRetryLane <<= 1;\n\n  if ((nextRetryLane & RetryLanes) === 0) {\n    nextRetryLane = RetryLane1;\n  }\n\n  return lane;\n}\nfunction getHighestPriorityLane(lanes) {\n  return lanes & -lanes;\n}\nfunction pickArbitraryLane(lanes) {\n  // This wrapper function gets inlined. Only exists so to communicate that it\n  // doesn't matter which bit is selected; you can pick any bit without\n  // affecting the algorithms where its used. Here I'm using\n  // getHighestPriorityLane because it requires the fewest operations.\n  return getHighestPriorityLane(lanes);\n}\n\nfunction pickArbitraryLaneIndex(lanes) {\n  return 31 - clz32(lanes);\n}\n\nfunction laneToIndex(lane) {\n  return pickArbitraryLaneIndex(lane);\n}\n\nfunction includesSomeLane(a, b) {\n  return (a & b) !== NoLanes;\n}\nfunction isSubsetOfLanes(set, subset) {\n  return (set & subset) === subset;\n}\nfunction mergeLanes(a, b) {\n  return a | b;\n}\nfunction removeLanes(set, subset) {\n  return set & ~subset;\n}\nfunction intersectLanes(a, b) {\n  return a & b;\n} // Seems redundant, but it changes the type from a single lane (used for\n// updates) to a group of lanes (used for flushing work).\n\nfunction laneToLanes(lane) {\n  return lane;\n}\nfunction higherPriorityLane(a, b) {\n  // This works because the bit ranges decrease in priority as you go left.\n  return a !== NoLane && a < b ? a : b;\n}\nfunction createLaneMap(initial) {\n  // Intentionally pushing one by one.\n  // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n  var laneMap = [];\n\n  for (var i = 0; i < TotalLanes; i++) {\n    laneMap.push(initial);\n  }\n\n  return laneMap;\n}\nfunction markRootUpdated(root, updateLane, eventTime) {\n  root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update\n  // could unblock them. Clear the suspended lanes so that we can try rendering\n  // them again.\n  //\n  // TODO: We really only need to unsuspend only lanes that are in the\n  // `subtreeLanes` of the updated fiber, or the update lanes of the return\n  // path. This would exclude suspended updates in an unrelated sibling tree,\n  // since there's no way for this update to unblock it.\n  //\n  // We don't do this if the incoming update is idle, because we never process\n  // idle updates until after all the regular updates have finished; there's no\n  // way it could unblock a transition.\n\n  if (updateLane !== IdleLane) {\n    root.suspendedLanes = NoLanes;\n    root.pingedLanes = NoLanes;\n  }\n\n  var eventTimes = root.eventTimes;\n  var index = laneToIndex(updateLane); // We can always overwrite an existing timestamp because we prefer the most\n  // recent event, and we assume time is monotonically increasing.\n\n  eventTimes[index] = eventTime;\n}\nfunction markRootSuspended(root, suspendedLanes) {\n  root.suspendedLanes |= suspendedLanes;\n  root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n\n  var expirationTimes = root.expirationTimes;\n  var lanes = suspendedLanes;\n\n  while (lanes > 0) {\n    var index = pickArbitraryLaneIndex(lanes);\n    var lane = 1 << index;\n    expirationTimes[index] = NoTimestamp;\n    lanes &= ~lane;\n  }\n}\nfunction markRootPinged(root, pingedLanes, eventTime) {\n  root.pingedLanes |= root.suspendedLanes & pingedLanes;\n}\nfunction markRootFinished(root, remainingLanes) {\n  var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n  root.pendingLanes = remainingLanes; // Let's try everything again\n\n  root.suspendedLanes = 0;\n  root.pingedLanes = 0;\n  root.expiredLanes &= remainingLanes;\n  root.mutableReadLanes &= remainingLanes;\n  root.entangledLanes &= remainingLanes;\n  var entanglements = root.entanglements;\n  var eventTimes = root.eventTimes;\n  var expirationTimes = root.expirationTimes; // Clear the lanes that no longer have pending work\n\n  var lanes = noLongerPendingLanes;\n\n  while (lanes > 0) {\n    var index = pickArbitraryLaneIndex(lanes);\n    var lane = 1 << index;\n    entanglements[index] = NoLanes;\n    eventTimes[index] = NoTimestamp;\n    expirationTimes[index] = NoTimestamp;\n    lanes &= ~lane;\n  }\n}\nfunction markRootEntangled(root, entangledLanes) {\n  // In addition to entangling each of the given lanes with each other, we also\n  // have to consider _transitive_ entanglements. For each lane that is already\n  // entangled with *any* of the given lanes, that lane is now transitively\n  // entangled with *all* the given lanes.\n  //\n  // Translated: If C is entangled with A, then entangling A with B also\n  // entangles C with B.\n  //\n  // If this is hard to grasp, it might help to intentionally break this\n  // function and look at the tests that fail in ReactTransition-test.js. Try\n  // commenting out one of the conditions below.\n  var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n  var entanglements = root.entanglements;\n  var lanes = rootEntangledLanes;\n\n  while (lanes) {\n    var index = pickArbitraryLaneIndex(lanes);\n    var lane = 1 << index;\n\n    if ( // Is this one of the newly entangled lanes?\n    lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?\n    entanglements[index] & entangledLanes) {\n      entanglements[index] |= entangledLanes;\n    }\n\n    lanes &= ~lane;\n  }\n}\nfunction getBumpedLaneForHydration(root, renderLanes) {\n  var renderLane = getHighestPriorityLane(renderLanes);\n  var lane;\n\n  switch (renderLane) {\n    case InputContinuousLane:\n      lane = InputContinuousHydrationLane;\n      break;\n\n    case DefaultLane:\n      lane = DefaultHydrationLane;\n      break;\n\n    case TransitionLane1:\n    case TransitionLane2:\n    case TransitionLane3:\n    case TransitionLane4:\n    case TransitionLane5:\n    case TransitionLane6:\n    case TransitionLane7:\n    case TransitionLane8:\n    case TransitionLane9:\n    case TransitionLane10:\n    case TransitionLane11:\n    case TransitionLane12:\n    case TransitionLane13:\n    case TransitionLane14:\n    case TransitionLane15:\n    case TransitionLane16:\n    case RetryLane1:\n    case RetryLane2:\n    case RetryLane3:\n    case RetryLane4:\n    case RetryLane5:\n      lane = TransitionHydrationLane;\n      break;\n\n    case IdleLane:\n      lane = IdleHydrationLane;\n      break;\n\n    default:\n      // Everything else is already either a hydration lane, or shouldn't\n      // be retried at a hydration lane.\n      lane = NoLane;\n      break;\n  } // Check if the lane we chose is suspended. If so, that indicates that we\n  // already attempted and failed to hydrate at that level. Also check if we're\n  // already rendering that lane, which is rare but could happen.\n\n\n  if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n    // Give up trying to hydrate and fall back to client render.\n    return NoLane;\n  }\n\n  return lane;\n}\nfunction addFiberToLanesMap(root, fiber, lanes) {\n\n  if (!isDevToolsPresent) {\n    return;\n  }\n\n  var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n\n  while (lanes > 0) {\n    var index = laneToIndex(lanes);\n    var lane = 1 << index;\n    var updaters = pendingUpdatersLaneMap[index];\n    updaters.add(fiber);\n    lanes &= ~lane;\n  }\n}\nfunction movePendingFibersToMemoized(root, lanes) {\n\n  if (!isDevToolsPresent) {\n    return;\n  }\n\n  var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n  var memoizedUpdaters = root.memoizedUpdaters;\n\n  while (lanes > 0) {\n    var index = laneToIndex(lanes);\n    var lane = 1 << index;\n    var updaters = pendingUpdatersLaneMap[index];\n\n    if (updaters.size > 0) {\n      updaters.forEach(function (fiber) {\n        var alternate = fiber.alternate;\n\n        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n          memoizedUpdaters.add(fiber);\n        }\n      });\n      updaters.clear();\n    }\n\n    lanes &= ~lane;\n  }\n}\n\nvar DiscreteEventPriority = SyncLane;\nvar ContinuousEventPriority = InputContinuousLane;\nvar DefaultEventPriority = DefaultLane;\nvar IdleEventPriority = IdleLane;\nvar currentUpdatePriority = NoLane;\nfunction getCurrentUpdatePriority() {\n  return currentUpdatePriority;\n}\nfunction setCurrentUpdatePriority(newPriority) {\n  currentUpdatePriority = newPriority;\n}\nfunction runWithPriority(priority, fn) {\n  var previousPriority = currentUpdatePriority;\n\n  try {\n    currentUpdatePriority = priority;\n    return fn();\n  } finally {\n    currentUpdatePriority = previousPriority;\n  }\n}\nfunction higherEventPriority(a, b) {\n  return a !== 0 && a < b ? a : b;\n}\nfunction lowerEventPriority(a, b) {\n  return a === 0 || a > b ? a : b;\n}\nfunction isHigherEventPriority(a, b) {\n  return a !== 0 && a < b;\n}\nfunction lanesToEventPriority(lanes) {\n  var lane = getHighestPriorityLane(lanes);\n\n  if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\n    return DiscreteEventPriority;\n  }\n\n  if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\n    return ContinuousEventPriority;\n  }\n\n  if (includesNonIdleWork(lane)) {\n    return DefaultEventPriority;\n  }\n\n  return IdleEventPriority;\n}\n\n// This module only exists as an ESM wrapper around the external CommonJS\nvar scheduleCallback = Scheduler.unstable_scheduleCallback;\nvar cancelCallback = Scheduler.unstable_cancelCallback;\nvar shouldYield = Scheduler.unstable_shouldYield;\nvar requestPaint = Scheduler.unstable_requestPaint;\nvar now$1 = Scheduler.unstable_now;\nvar ImmediatePriority = Scheduler.unstable_ImmediatePriority;\nvar UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;\nvar NormalPriority = Scheduler.unstable_NormalPriority;\nvar IdlePriority = Scheduler.unstable_IdlePriority;\n// this doesn't actually exist on the scheduler, but it *does*\n// on scheduler/unstable_mock, which we'll need for internal testing\nvar unstable_yieldValue = Scheduler.unstable_yieldValue;\nvar unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;\n\nvar rendererID = null;\nvar injectedHook = null;\nvar injectedProfilingHooks = null;\nvar hasLoggedError = false;\nvar isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';\nfunction injectInternals(internals) {\n  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n    // No DevTools\n    return false;\n  }\n\n  var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n\n  if (hook.isDisabled) {\n    // This isn't a real property on the hook, but it can be set to opt out\n    // of DevTools integration and associated warnings and logs.\n    // https://github.com/facebook/react/issues/3877\n    return true;\n  }\n\n  if (!hook.supportsFiber) {\n    {\n      error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://reactjs.org/link/react-devtools');\n    } // DevTools exists, even though it doesn't support Fiber.\n\n\n    return true;\n  }\n\n  try {\n    if (enableSchedulingProfiler) {\n      // Conditionally inject these hooks only if Timeline profiler is supported by this build.\n      // This gives DevTools a way to feature detect that isn't tied to version number\n      // (since profiling and timeline are controlled by different feature flags).\n      internals = assign({}, internals, {\n        getLaneLabelMap: getLaneLabelMap,\n        injectProfilingHooks: injectProfilingHooks\n      });\n    }\n\n    rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.\n\n    injectedHook = hook;\n  } catch (err) {\n    // Catch all errors because it is unsafe to throw during initialization.\n    {\n      error('React instrumentation encountered an error: %s.', err);\n    }\n  }\n\n  if (hook.checkDCE) {\n    // This is the real DevTools.\n    return true;\n  } else {\n    // This is likely a hook installed by Fast Refresh runtime.\n    return false;\n  }\n}\nfunction onScheduleRoot(root, children) {\n  {\n    if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {\n      try {\n        injectedHook.onScheduleFiberRoot(rendererID, root, children);\n      } catch (err) {\n        if ( !hasLoggedError) {\n          hasLoggedError = true;\n\n          error('React instrumentation encountered an error: %s', err);\n        }\n      }\n    }\n  }\n}\nfunction onCommitRoot(root, eventPriority) {\n  if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {\n    try {\n      var didError = (root.current.flags & DidCapture) === DidCapture;\n\n      if (enableProfilerTimer) {\n        var schedulerPriority;\n\n        switch (eventPriority) {\n          case DiscreteEventPriority:\n            schedulerPriority = ImmediatePriority;\n            break;\n\n          case ContinuousEventPriority:\n            schedulerPriority = UserBlockingPriority;\n            break;\n\n          case DefaultEventPriority:\n            schedulerPriority = NormalPriority;\n            break;\n\n          case IdleEventPriority:\n            schedulerPriority = IdlePriority;\n            break;\n\n          default:\n            schedulerPriority = NormalPriority;\n            break;\n        }\n\n        injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n      } else {\n        injectedHook.onCommitFiberRoot(rendererID, root, undefined, didError);\n      }\n    } catch (err) {\n      {\n        if (!hasLoggedError) {\n          hasLoggedError = true;\n\n          error('React instrumentation encountered an error: %s', err);\n        }\n      }\n    }\n  }\n}\nfunction onPostCommitRoot(root) {\n  if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === 'function') {\n    try {\n      injectedHook.onPostCommitFiberRoot(rendererID, root);\n    } catch (err) {\n      {\n        if (!hasLoggedError) {\n          hasLoggedError = true;\n\n          error('React instrumentation encountered an error: %s', err);\n        }\n      }\n    }\n  }\n}\nfunction onCommitUnmount(fiber) {\n  if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {\n    try {\n      injectedHook.onCommitFiberUnmount(rendererID, fiber);\n    } catch (err) {\n      {\n        if (!hasLoggedError) {\n          hasLoggedError = true;\n\n          error('React instrumentation encountered an error: %s', err);\n        }\n      }\n    }\n  }\n}\nfunction setIsStrictModeForDevtools(newIsStrictMode) {\n  {\n    if (typeof unstable_yieldValue === 'function') {\n      // We're in a test because Scheduler.unstable_yieldValue only exists\n      // in SchedulerMock. To reduce the noise in strict mode tests,\n      // suppress warnings and disable scheduler yielding during the double render\n      unstable_setDisableYieldValue(newIsStrictMode);\n      setSuppressWarning(newIsStrictMode);\n    }\n\n    if (injectedHook && typeof injectedHook.setStrictMode === 'function') {\n      try {\n        injectedHook.setStrictMode(rendererID, newIsStrictMode);\n      } catch (err) {\n        {\n          if (!hasLoggedError) {\n            hasLoggedError = true;\n\n            error('React instrumentation encountered an error: %s', err);\n          }\n        }\n      }\n    }\n  }\n} // Profiler API hooks\n\nfunction injectProfilingHooks(profilingHooks) {\n  injectedProfilingHooks = profilingHooks;\n}\n\nfunction getLaneLabelMap() {\n  {\n    var map = new Map();\n    var lane = 1;\n\n    for (var index = 0; index < TotalLanes; index++) {\n      var label = getLabelForLane(lane);\n      map.set(lane, label);\n      lane *= 2;\n    }\n\n    return map;\n  }\n}\n\nfunction markCommitStarted(lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === 'function') {\n      injectedProfilingHooks.markCommitStarted(lanes);\n    }\n  }\n}\nfunction markCommitStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === 'function') {\n      injectedProfilingHooks.markCommitStopped();\n    }\n  }\n}\nfunction markComponentRenderStarted(fiber) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === 'function') {\n      injectedProfilingHooks.markComponentRenderStarted(fiber);\n    }\n  }\n}\nfunction markComponentRenderStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === 'function') {\n      injectedProfilingHooks.markComponentRenderStopped();\n    }\n  }\n}\nfunction markComponentPassiveEffectMountStarted(fiber) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === 'function') {\n      injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);\n    }\n  }\n}\nfunction markComponentPassiveEffectMountStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === 'function') {\n      injectedProfilingHooks.markComponentPassiveEffectMountStopped();\n    }\n  }\n}\nfunction markComponentPassiveEffectUnmountStarted(fiber) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === 'function') {\n      injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);\n    }\n  }\n}\nfunction markComponentPassiveEffectUnmountStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === 'function') {\n      injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();\n    }\n  }\n}\nfunction markComponentLayoutEffectMountStarted(fiber) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === 'function') {\n      injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);\n    }\n  }\n}\nfunction markComponentLayoutEffectMountStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === 'function') {\n      injectedProfilingHooks.markComponentLayoutEffectMountStopped();\n    }\n  }\n}\nfunction markComponentLayoutEffectUnmountStarted(fiber) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === 'function') {\n      injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);\n    }\n  }\n}\nfunction markComponentLayoutEffectUnmountStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === 'function') {\n      injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();\n    }\n  }\n}\nfunction markComponentErrored(fiber, thrownValue, lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === 'function') {\n      injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);\n    }\n  }\n}\nfunction markComponentSuspended(fiber, wakeable, lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === 'function') {\n      injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);\n    }\n  }\n}\nfunction markLayoutEffectsStarted(lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === 'function') {\n      injectedProfilingHooks.markLayoutEffectsStarted(lanes);\n    }\n  }\n}\nfunction markLayoutEffectsStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === 'function') {\n      injectedProfilingHooks.markLayoutEffectsStopped();\n    }\n  }\n}\nfunction markPassiveEffectsStarted(lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === 'function') {\n      injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n    }\n  }\n}\nfunction markPassiveEffectsStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === 'function') {\n      injectedProfilingHooks.markPassiveEffectsStopped();\n    }\n  }\n}\nfunction markRenderStarted(lanes) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === 'function') {\n      injectedProfilingHooks.markRenderStarted(lanes);\n    }\n  }\n}\nfunction markRenderYielded() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === 'function') {\n      injectedProfilingHooks.markRenderYielded();\n    }\n  }\n}\nfunction markRenderStopped() {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === 'function') {\n      injectedProfilingHooks.markRenderStopped();\n    }\n  }\n}\nfunction markRenderScheduled(lane) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === 'function') {\n      injectedProfilingHooks.markRenderScheduled(lane);\n    }\n  }\n}\nfunction markForceUpdateScheduled(fiber, lane) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === 'function') {\n      injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);\n    }\n  }\n}\nfunction markStateUpdateScheduled(fiber, lane) {\n  {\n    if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === 'function') {\n      injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n    }\n  }\n}\n\n/**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */\nfunction is(x, y) {\n  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n  ;\n}\n\nvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\nvar syncQueue = null;\nvar includesLegacySyncCallbacks = false;\nvar isFlushingSyncQueue = false;\nfunction scheduleSyncCallback(callback) {\n  // Push this callback into an internal queue. We'll flush these either in\n  // the next tick, or earlier if something calls `flushSyncCallbackQueue`.\n  if (syncQueue === null) {\n    syncQueue = [callback];\n  } else {\n    // Push onto existing queue. Don't need to schedule a callback because\n    // we already scheduled one when we created the queue.\n    syncQueue.push(callback);\n  }\n}\nfunction scheduleLegacySyncCallback(callback) {\n  includesLegacySyncCallbacks = true;\n  scheduleSyncCallback(callback);\n}\nfunction flushSyncCallbacksOnlyInLegacyMode() {\n  // Only flushes the queue if there's a legacy sync callback scheduled.\n  // TODO: There's only a single type of callback: performSyncOnWorkOnRoot. So\n  // it might make more sense for the queue to be a list of roots instead of a\n  // list of generic callbacks. Then we can have two: one for legacy roots, one\n  // for concurrent roots. And this method would only flush the legacy ones.\n  if (includesLegacySyncCallbacks) {\n    flushSyncCallbacks();\n  }\n}\nfunction flushSyncCallbacks() {\n  if (!isFlushingSyncQueue && syncQueue !== null) {\n    // Prevent re-entrance.\n    isFlushingSyncQueue = true;\n    var i = 0;\n    var previousUpdatePriority = getCurrentUpdatePriority();\n\n    try {\n      var isSync = true;\n      var queue = syncQueue; // TODO: Is this necessary anymore? The only user code that runs in this\n      // queue is in the render or commit phases.\n\n      setCurrentUpdatePriority(DiscreteEventPriority);\n\n      for (; i < queue.length; i++) {\n        var callback = queue[i];\n\n        do {\n          callback = callback(isSync);\n        } while (callback !== null);\n      }\n\n      syncQueue = null;\n      includesLegacySyncCallbacks = false;\n    } catch (error) {\n      // If something throws, leave the remaining callbacks on the queue.\n      if (syncQueue !== null) {\n        syncQueue = syncQueue.slice(i + 1);\n      } // Resume flushing in the next tick\n\n\n      scheduleCallback(ImmediatePriority, flushSyncCallbacks);\n      throw error;\n    } finally {\n      setCurrentUpdatePriority(previousUpdatePriority);\n      isFlushingSyncQueue = false;\n    }\n  }\n\n  return null;\n}\n\n// This is imported by the event replaying implementation in React DOM. It's\n// in a separate file to break a circular dependency between the renderer and\n// the reconciler.\nfunction isRootDehydrated(root) {\n  var currentState = root.current.memoizedState;\n  return currentState.isDehydrated;\n}\n\nvar ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;\nvar NoTransition = null;\nfunction requestCurrentTransition() {\n  return ReactCurrentBatchConfig.transition;\n}\n\n/**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */\n\nfunction shallowEqual(objA, objB) {\n  if (objectIs(objA, objB)) {\n    return true;\n  }\n\n  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n    return false;\n  }\n\n  var keysA = Object.keys(objA);\n  var keysB = Object.keys(objB);\n\n  if (keysA.length !== keysB.length) {\n    return false;\n  } // Test for A's keys different from B.\n\n\n  for (var i = 0; i < keysA.length; i++) {\n    var currentKey = keysA[i];\n\n    if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction describeFiber(fiber) {\n  var owner =  fiber._debugOwner ? fiber._debugOwner.type : null ;\n  var source =  fiber._debugSource ;\n\n  switch (fiber.tag) {\n    case HostComponent:\n      return describeBuiltInComponentFrame(fiber.type);\n\n    case LazyComponent:\n      return describeBuiltInComponentFrame('Lazy');\n\n    case SuspenseComponent:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case SuspenseListComponent:\n      return describeBuiltInComponentFrame('SuspenseList');\n\n    case FunctionComponent:\n    case IndeterminateComponent:\n    case SimpleMemoComponent:\n      return describeFunctionComponentFrame(fiber.type);\n\n    case ForwardRef:\n      return describeFunctionComponentFrame(fiber.type.render);\n\n    case ClassComponent:\n      return describeClassComponentFrame(fiber.type);\n\n    default:\n      return '';\n  }\n}\n\nfunction getStackByFiberInDevAndProd(workInProgress) {\n  try {\n    var info = '';\n    var node = workInProgress;\n\n    do {\n      info += describeFiber(node);\n      node = node.return;\n    } while (node);\n\n    return info;\n  } catch (x) {\n    return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\n  }\n}\n\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\nvar current = null;\nvar isRendering = false;\nfunction getCurrentFiberOwnerNameInDevOrNull() {\n  {\n    if (current === null) {\n      return null;\n    }\n\n    var owner = current._debugOwner;\n\n    if (owner !== null && typeof owner !== 'undefined') {\n      return getComponentNameFromFiber(owner);\n    }\n  }\n\n  return null;\n}\n\nfunction getCurrentFiberStackInDev() {\n  {\n    if (current === null) {\n      return '';\n    } // Safe because if current fiber exists, we are reconciling,\n    // and it is guaranteed to be the work-in-progress version.\n\n\n    return getStackByFiberInDevAndProd(current);\n  }\n}\n\nfunction resetCurrentFiber() {\n  {\n    ReactDebugCurrentFrame$1.getCurrentStack = null;\n    current = null;\n    isRendering = false;\n  }\n}\nfunction setCurrentFiber(fiber) {\n  {\n    ReactDebugCurrentFrame$1.getCurrentStack = getCurrentFiberStackInDev;\n    current = fiber;\n    isRendering = false;\n  }\n}\nfunction setIsRendering(rendering) {\n  {\n    isRendering = rendering;\n  }\n}\n\nvar ReactStrictModeWarnings = {\n  recordUnsafeLifecycleWarnings: function (fiber, instance) {},\n  flushPendingUnsafeLifecycleWarnings: function () {},\n  recordLegacyContextWarning: function (fiber, instance) {},\n  flushLegacyContextWarning: function () {},\n  discardPendingWarnings: function () {}\n};\n\n{\n  var findStrictRoot = function (fiber) {\n    var maybeStrictRoot = null;\n    var node = fiber;\n\n    while (node !== null) {\n      if (node.mode & StrictLegacyMode) {\n        maybeStrictRoot = node;\n      }\n\n      node = node.return;\n    }\n\n    return maybeStrictRoot;\n  };\n\n  var setToSortedString = function (set) {\n    var array = [];\n    set.forEach(function (value) {\n      array.push(value);\n    });\n    return array.sort().join(', ');\n  };\n\n  var pendingComponentWillMountWarnings = [];\n  var pendingUNSAFE_ComponentWillMountWarnings = [];\n  var pendingComponentWillReceivePropsWarnings = [];\n  var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n  var pendingComponentWillUpdateWarnings = [];\n  var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.\n\n  var didWarnAboutUnsafeLifecycles = new Set();\n\n  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function (fiber, instance) {\n    // Dedupe strategy: Warn once per component.\n    if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n      return;\n    }\n\n    if (typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.\n    instance.componentWillMount.__suppressDeprecationWarning !== true) {\n      pendingComponentWillMountWarnings.push(fiber);\n    }\n\n    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === 'function') {\n      pendingUNSAFE_ComponentWillMountWarnings.push(fiber);\n    }\n\n    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n      pendingComponentWillReceivePropsWarnings.push(fiber);\n    }\n\n    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n      pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);\n    }\n\n    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n      pendingComponentWillUpdateWarnings.push(fiber);\n    }\n\n    if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {\n      pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function () {\n    // We do an initial pass to gather component names\n    var componentWillMountUniqueNames = new Set();\n\n    if (pendingComponentWillMountWarnings.length > 0) {\n      pendingComponentWillMountWarnings.forEach(function (fiber) {\n        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingComponentWillMountWarnings = [];\n    }\n\n    var UNSAFE_componentWillMountUniqueNames = new Set();\n\n    if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {\n      pendingUNSAFE_ComponentWillMountWarnings.forEach(function (fiber) {\n        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingUNSAFE_ComponentWillMountWarnings = [];\n    }\n\n    var componentWillReceivePropsUniqueNames = new Set();\n\n    if (pendingComponentWillReceivePropsWarnings.length > 0) {\n      pendingComponentWillReceivePropsWarnings.forEach(function (fiber) {\n        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingComponentWillReceivePropsWarnings = [];\n    }\n\n    var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n\n    if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {\n      pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function (fiber) {\n        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n    }\n\n    var componentWillUpdateUniqueNames = new Set();\n\n    if (pendingComponentWillUpdateWarnings.length > 0) {\n      pendingComponentWillUpdateWarnings.forEach(function (fiber) {\n        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingComponentWillUpdateWarnings = [];\n    }\n\n    var UNSAFE_componentWillUpdateUniqueNames = new Set();\n\n    if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {\n      pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function (fiber) {\n        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutUnsafeLifecycles.add(fiber.type);\n      });\n      pendingUNSAFE_ComponentWillUpdateWarnings = [];\n    } // Finally, we flush all the warnings\n    // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\n\n\n    if (UNSAFE_componentWillMountUniqueNames.size > 0) {\n      var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n\n      error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '\\nPlease update the following components: %s', sortedNames);\n    }\n\n    if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {\n      var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);\n\n      error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, \" + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n' + '\\nPlease update the following components: %s', _sortedNames);\n    }\n\n    if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {\n      var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);\n\n      error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '\\nPlease update the following components: %s', _sortedNames2);\n    }\n\n    if (componentWillMountUniqueNames.size > 0) {\n      var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);\n\n      warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames3);\n    }\n\n    if (componentWillReceivePropsUniqueNames.size > 0) {\n      var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);\n\n      warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, refactor your \" + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames4);\n    }\n\n    if (componentWillUpdateUniqueNames.size > 0) {\n      var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);\n\n      warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://reactjs.org/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames5);\n    }\n  };\n\n  var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.\n\n  var didWarnAboutLegacyContext = new Set();\n\n  ReactStrictModeWarnings.recordLegacyContextWarning = function (fiber, instance) {\n    var strictRoot = findStrictRoot(fiber);\n\n    if (strictRoot === null) {\n      error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n\n      return;\n    } // Dedup strategy: Warn once per component.\n\n\n    if (didWarnAboutLegacyContext.has(fiber.type)) {\n      return;\n    }\n\n    var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n\n    if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {\n      if (warningsForRoot === undefined) {\n        warningsForRoot = [];\n        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n      }\n\n      warningsForRoot.push(fiber);\n    }\n  };\n\n  ReactStrictModeWarnings.flushLegacyContextWarning = function () {\n    pendingLegacyContextWarning.forEach(function (fiberArray, strictRoot) {\n      if (fiberArray.length === 0) {\n        return;\n      }\n\n      var firstFiber = fiberArray[0];\n      var uniqueNames = new Set();\n      fiberArray.forEach(function (fiber) {\n        uniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n        didWarnAboutLegacyContext.add(fiber.type);\n      });\n      var sortedNames = setToSortedString(uniqueNames);\n\n      try {\n        setCurrentFiber(firstFiber);\n\n        error('Legacy context API has been detected within a strict-mode tree.' + '\\n\\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here: https://reactjs.org/link/legacy-context', sortedNames);\n      } finally {\n        resetCurrentFiber();\n      }\n    });\n  };\n\n  ReactStrictModeWarnings.discardPendingWarnings = function () {\n    pendingComponentWillMountWarnings = [];\n    pendingUNSAFE_ComponentWillMountWarnings = [];\n    pendingComponentWillReceivePropsWarnings = [];\n    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n    pendingComponentWillUpdateWarnings = [];\n    pendingUNSAFE_ComponentWillUpdateWarnings = [];\n    pendingLegacyContextWarning = new Map();\n  };\n}\n\n/*\n * The `'' + value` pattern (used in in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object';\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\nfunction checkPropStringCoercion(value, propName) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided `%s` prop is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', propName, typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nfunction resolveDefaultProps(Component, baseProps) {\n  if (Component && Component.defaultProps) {\n    // Resolve default props. Taken from ReactElement\n    var props = assign({}, baseProps);\n    var defaultProps = Component.defaultProps;\n\n    for (var propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n\n    return props;\n  }\n\n  return baseProps;\n}\n\nvar valueCursor = createCursor(null);\nvar rendererSigil;\n\n{\n  // Use this to detect multiple renderers using the same context\n  rendererSigil = {};\n}\n\nvar currentlyRenderingFiber = null;\nvar lastContextDependency = null;\nvar lastFullyObservedContext = null;\nvar isDisallowedContextReadInDEV = false;\nfunction resetContextDependencies() {\n  // This is called right before React yields execution, to ensure `readContext`\n  // cannot be called outside the render phase.\n  currentlyRenderingFiber = null;\n  lastContextDependency = null;\n  lastFullyObservedContext = null;\n\n  {\n    isDisallowedContextReadInDEV = false;\n  }\n}\nfunction enterDisallowedContextReadInDEV() {\n  {\n    isDisallowedContextReadInDEV = true;\n  }\n}\nfunction exitDisallowedContextReadInDEV() {\n  {\n    isDisallowedContextReadInDEV = false;\n  }\n}\nfunction pushProvider(providerFiber, context, nextValue) {\n  if (isPrimaryRenderer) {\n    push(valueCursor, context._currentValue, providerFiber);\n    context._currentValue = nextValue;\n\n    {\n      if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n      }\n\n      context._currentRenderer = rendererSigil;\n    }\n  } else {\n    push(valueCursor, context._currentValue2, providerFiber);\n    context._currentValue2 = nextValue;\n\n    {\n      if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n      }\n\n      context._currentRenderer2 = rendererSigil;\n    }\n  }\n}\nfunction popProvider(context, providerFiber) {\n  var currentValue = valueCursor.current;\n  pop(valueCursor, providerFiber);\n\n  if (isPrimaryRenderer) {\n    {\n      context._currentValue = currentValue;\n    }\n  } else {\n    {\n      context._currentValue2 = currentValue;\n    }\n  }\n}\nfunction scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n  // Update the child lanes of all the ancestors, including the alternates.\n  var node = parent;\n\n  while (node !== null) {\n    var alternate = node.alternate;\n\n    if (!isSubsetOfLanes(node.childLanes, renderLanes)) {\n      node.childLanes = mergeLanes(node.childLanes, renderLanes);\n\n      if (alternate !== null) {\n        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n      }\n    } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {\n      alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n    }\n\n    if (node === propagationRoot) {\n      break;\n    }\n\n    node = node.return;\n  }\n\n  {\n    if (node !== propagationRoot) {\n      error('Expected to find the propagation root when scheduling context work. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n  }\n}\nfunction propagateContextChange(workInProgress, context, renderLanes) {\n  {\n    propagateContextChange_eager(workInProgress, context, renderLanes);\n  }\n}\n\nfunction propagateContextChange_eager(workInProgress, context, renderLanes) {\n\n  var fiber = workInProgress.child;\n\n  if (fiber !== null) {\n    // Set the return pointer of the child to the work-in-progress fiber.\n    fiber.return = workInProgress;\n  }\n\n  while (fiber !== null) {\n    var nextFiber = void 0; // Visit this fiber.\n\n    var list = fiber.dependencies;\n\n    if (list !== null) {\n      nextFiber = fiber.child;\n      var dependency = list.firstContext;\n\n      while (dependency !== null) {\n        // Check if the context matches.\n        if (dependency.context === context) {\n          // Match! Schedule an update on this fiber.\n          if (fiber.tag === ClassComponent) {\n            // Schedule a force update on the work-in-progress.\n            var lane = pickArbitraryLane(renderLanes);\n            var update = createUpdate(NoTimestamp, lane);\n            update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the\n            // update to the current fiber, too, which means it will persist even if\n            // this render is thrown away. Since it's a race condition, not sure it's\n            // worth fixing.\n            // Inlined `enqueueUpdate` to remove interleaved update check\n\n            var updateQueue = fiber.updateQueue;\n\n            if (updateQueue === null) ; else {\n              var sharedQueue = updateQueue.shared;\n              var pending = sharedQueue.pending;\n\n              if (pending === null) {\n                // This is the first update. Create a circular list.\n                update.next = update;\n              } else {\n                update.next = pending.next;\n                pending.next = update;\n              }\n\n              sharedQueue.pending = update;\n            }\n          }\n\n          fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n          var alternate = fiber.alternate;\n\n          if (alternate !== null) {\n            alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n          }\n\n          scheduleContextWorkOnParentPath(fiber.return, renderLanes, workInProgress); // Mark the updated lanes on the list, too.\n\n          list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the\n          // dependency list.\n\n          break;\n        }\n\n        dependency = dependency.next;\n      }\n    } else if (fiber.tag === ContextProvider) {\n      // Don't scan deeper if this is a matching provider\n      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n    } else if ( fiber.tag === DehydratedFragment) {\n      // If a dehydrated suspense boundary is in this subtree, we don't know\n      // if it will have any context consumers in it. The best we can do is\n      // mark it as having updates.\n      var parentSuspense = fiber.return;\n\n      if (parentSuspense === null) {\n        throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');\n      }\n\n      parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);\n      var _alternate = parentSuspense.alternate;\n\n      if (_alternate !== null) {\n        _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes);\n      } // This is intentionally passing this fiber as the parent\n      // because we want to schedule this fiber as having work\n      // on its children. We'll use the childLanes on\n      // this fiber to indicate that a context has changed.\n\n\n      scheduleContextWorkOnParentPath(parentSuspense, renderLanes, workInProgress);\n      nextFiber = fiber.sibling;\n    } else {\n      // Traverse down.\n      nextFiber = fiber.child;\n    }\n\n    if (nextFiber !== null) {\n      // Set the return pointer of the child to the work-in-progress fiber.\n      nextFiber.return = fiber;\n    } else {\n      // No child. Traverse to next sibling.\n      nextFiber = fiber;\n\n      while (nextFiber !== null) {\n        if (nextFiber === workInProgress) {\n          // We're back to the root of this subtree. Exit.\n          nextFiber = null;\n          break;\n        }\n\n        var sibling = nextFiber.sibling;\n\n        if (sibling !== null) {\n          // Set the return pointer of the sibling to the work-in-progress fiber.\n          sibling.return = nextFiber.return;\n          nextFiber = sibling;\n          break;\n        } // No more siblings. Traverse up.\n\n\n        nextFiber = nextFiber.return;\n      }\n    }\n\n    fiber = nextFiber;\n  }\n}\nfunction prepareToReadContext(workInProgress, renderLanes) {\n  currentlyRenderingFiber = workInProgress;\n  lastContextDependency = null;\n  lastFullyObservedContext = null;\n  var dependencies = workInProgress.dependencies;\n\n  if (dependencies !== null) {\n    {\n      var firstContext = dependencies.firstContext;\n\n      if (firstContext !== null) {\n        if (includesSomeLane(dependencies.lanes, renderLanes)) {\n          // Context list has a pending update. Mark that this fiber performed work.\n          markWorkInProgressReceivedUpdate();\n        } // Reset the work-in-progress list\n\n\n        dependencies.firstContext = null;\n      }\n    }\n  }\n}\nfunction readContext(context) {\n  {\n    // This warning would fire if you read context inside a Hook like useMemo.\n    // Unlike the class check below, it's not enforced in production for perf.\n    if (isDisallowedContextReadInDEV) {\n      error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n    }\n  }\n\n  var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n\n  if (lastFullyObservedContext === context) ; else {\n    var contextItem = {\n      context: context,\n      memoizedValue: value,\n      next: null\n    };\n\n    if (lastContextDependency === null) {\n      if (currentlyRenderingFiber === null) {\n        throw new Error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n      } // This is the first dependency for this component. Create a new list.\n\n\n      lastContextDependency = contextItem;\n      currentlyRenderingFiber.dependencies = {\n        lanes: NoLanes,\n        firstContext: contextItem\n      };\n    } else {\n      // Append a new context item.\n      lastContextDependency = lastContextDependency.next = contextItem;\n    }\n  }\n\n  return value;\n}\n\n// An array of all update queues that received updates during the current\n// render. When this render exits, either because it finishes or because it is\n// interrupted, the interleaved updates will be transferred onto the main part\n// of the queue.\nvar interleavedQueues = null;\nfunction pushInterleavedQueue(queue) {\n  if (interleavedQueues === null) {\n    interleavedQueues = [queue];\n  } else {\n    interleavedQueues.push(queue);\n  }\n}\nfunction enqueueInterleavedUpdates() {\n  // Transfer the interleaved updates onto the main queue. Each queue has a\n  // `pending` field and an `interleaved` field. When they are not null, they\n  // point to the last node in a circular linked list. We need to append the\n  // interleaved list to the end of the pending list by joining them into a\n  // single, circular list.\n  if (interleavedQueues !== null) {\n    for (var i = 0; i < interleavedQueues.length; i++) {\n      var queue = interleavedQueues[i];\n      var lastInterleavedUpdate = queue.interleaved;\n\n      if (lastInterleavedUpdate !== null) {\n        queue.interleaved = null;\n        var firstInterleavedUpdate = lastInterleavedUpdate.next;\n        var lastPendingUpdate = queue.pending;\n\n        if (lastPendingUpdate !== null) {\n          var firstPendingUpdate = lastPendingUpdate.next;\n          lastPendingUpdate.next = firstInterleavedUpdate;\n          lastInterleavedUpdate.next = firstPendingUpdate;\n        }\n\n        queue.pending = lastInterleavedUpdate;\n      }\n    }\n\n    interleavedQueues = null;\n  }\n}\n\nvar UpdateState = 0;\nvar ReplaceState = 1;\nvar ForceUpdate = 2;\nvar CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n// It should only be read right after calling `processUpdateQueue`, via\n// `checkHasForceUpdateAfterProcessing`.\n\nvar hasForceUpdate = false;\nvar didWarnUpdateInsideUpdate;\nvar currentlyProcessingQueue;\n\n{\n  didWarnUpdateInsideUpdate = false;\n  currentlyProcessingQueue = null;\n}\n\nfunction initializeUpdateQueue(fiber) {\n  var queue = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: {\n      pending: null,\n      interleaved: null,\n      lanes: NoLanes\n    },\n    effects: null\n  };\n  fiber.updateQueue = queue;\n}\nfunction cloneUpdateQueue(current, workInProgress) {\n  // Clone the update queue from current. Unless it's already a clone.\n  var queue = workInProgress.updateQueue;\n  var currentQueue = current.updateQueue;\n\n  if (queue === currentQueue) {\n    var clone = {\n      baseState: currentQueue.baseState,\n      firstBaseUpdate: currentQueue.firstBaseUpdate,\n      lastBaseUpdate: currentQueue.lastBaseUpdate,\n      shared: currentQueue.shared,\n      effects: currentQueue.effects\n    };\n    workInProgress.updateQueue = clone;\n  }\n}\nfunction createUpdate(eventTime, lane) {\n  var update = {\n    eventTime: eventTime,\n    lane: lane,\n    tag: UpdateState,\n    payload: null,\n    callback: null,\n    next: null\n  };\n  return update;\n}\nfunction enqueueUpdate(fiber, update, lane) {\n  var updateQueue = fiber.updateQueue;\n\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    return;\n  }\n\n  var sharedQueue = updateQueue.shared;\n\n  if (isInterleavedUpdate(fiber)) {\n    var interleaved = sharedQueue.interleaved;\n\n    if (interleaved === null) {\n      // This is the first update. Create a circular list.\n      update.next = update; // At the end of the current render, this queue's interleaved updates will\n      // be transferred to the pending queue.\n\n      pushInterleavedQueue(sharedQueue);\n    } else {\n      update.next = interleaved.next;\n      interleaved.next = update;\n    }\n\n    sharedQueue.interleaved = update;\n  } else {\n    var pending = sharedQueue.pending;\n\n    if (pending === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      update.next = pending.next;\n      pending.next = update;\n    }\n\n    sharedQueue.pending = update;\n  }\n\n  {\n    if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n      error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.');\n\n      didWarnUpdateInsideUpdate = true;\n    }\n  }\n}\nfunction entangleTransitions(root, fiber, lane) {\n  var updateQueue = fiber.updateQueue;\n\n  if (updateQueue === null) {\n    // Only occurs if the fiber has been unmounted.\n    return;\n  }\n\n  var sharedQueue = updateQueue.shared;\n\n  if (isTransitionLane(lane)) {\n    var queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must\n    // have finished. We can remove them from the shared queue, which represents\n    // a superset of the actually pending lanes. In some cases we may entangle\n    // more than we need to, but that's OK. In fact it's worse if we *don't*\n    // entangle when we should.\n\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n\n    var newQueueLanes = mergeLanes(queueLanes, lane);\n    sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n\n    markRootEntangled(root, newQueueLanes);\n  }\n}\nfunction enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n  // Captured updates are updates that are thrown by a child during the render\n  // phase. They should be discarded if the render is aborted. Therefore,\n  // we should only put them on the work-in-progress queue, not the current one.\n  var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.\n\n  var current = workInProgress.alternate;\n\n  if (current !== null) {\n    var currentQueue = current.updateQueue;\n\n    if (queue === currentQueue) {\n      // The work-in-progress queue is the same as current. This happens when\n      // we bail out on a parent fiber that then captures an error thrown by\n      // a child. Since we want to append the update only to the work-in\n      // -progress queue, we need to clone the updates. We usually clone during\n      // processUpdateQueue, but that didn't happen in this case because we\n      // skipped over the parent when we bailed out.\n      var newFirst = null;\n      var newLast = null;\n      var firstBaseUpdate = queue.firstBaseUpdate;\n\n      if (firstBaseUpdate !== null) {\n        // Loop through the updates and clone them.\n        var update = firstBaseUpdate;\n\n        do {\n          var clone = {\n            eventTime: update.eventTime,\n            lane: update.lane,\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n            next: null\n          };\n\n          if (newLast === null) {\n            newFirst = newLast = clone;\n          } else {\n            newLast.next = clone;\n            newLast = clone;\n          }\n\n          update = update.next;\n        } while (update !== null); // Append the captured update the end of the cloned list.\n\n\n        if (newLast === null) {\n          newFirst = newLast = capturedUpdate;\n        } else {\n          newLast.next = capturedUpdate;\n          newLast = capturedUpdate;\n        }\n      } else {\n        // There are no base updates.\n        newFirst = newLast = capturedUpdate;\n      }\n\n      queue = {\n        baseState: currentQueue.baseState,\n        firstBaseUpdate: newFirst,\n        lastBaseUpdate: newLast,\n        shared: currentQueue.shared,\n        effects: currentQueue.effects\n      };\n      workInProgress.updateQueue = queue;\n      return;\n    }\n  } // Append the update to the end of the list.\n\n\n  var lastBaseUpdate = queue.lastBaseUpdate;\n\n  if (lastBaseUpdate === null) {\n    queue.firstBaseUpdate = capturedUpdate;\n  } else {\n    lastBaseUpdate.next = capturedUpdate;\n  }\n\n  queue.lastBaseUpdate = capturedUpdate;\n}\n\nfunction getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n  switch (update.tag) {\n    case ReplaceState:\n      {\n        var payload = update.payload;\n\n        if (typeof payload === 'function') {\n          // Updater function\n          {\n            enterDisallowedContextReadInDEV();\n          }\n\n          var nextState = payload.call(instance, prevState, nextProps);\n\n          {\n            if ( workInProgress.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n\n              try {\n                payload.call(instance, prevState, nextProps);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n\n            exitDisallowedContextReadInDEV();\n          }\n\n          return nextState;\n        } // State object\n\n\n        return payload;\n      }\n\n    case CaptureUpdate:\n      {\n        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;\n      }\n    // Intentional fallthrough\n\n    case UpdateState:\n      {\n        var _payload = update.payload;\n        var partialState;\n\n        if (typeof _payload === 'function') {\n          // Updater function\n          {\n            enterDisallowedContextReadInDEV();\n          }\n\n          partialState = _payload.call(instance, prevState, nextProps);\n\n          {\n            if ( workInProgress.mode & StrictLegacyMode) {\n              setIsStrictModeForDevtools(true);\n\n              try {\n                _payload.call(instance, prevState, nextProps);\n              } finally {\n                setIsStrictModeForDevtools(false);\n              }\n            }\n\n            exitDisallowedContextReadInDEV();\n          }\n        } else {\n          // Partial state object\n          partialState = _payload;\n        }\n\n        if (partialState === null || partialState === undefined) {\n          // Null and undefined are treated as no-ops.\n          return prevState;\n        } // Merge the partial state and the previous state.\n\n\n        return assign({}, prevState, partialState);\n      }\n\n    case ForceUpdate:\n      {\n        hasForceUpdate = true;\n        return prevState;\n      }\n  }\n\n  return prevState;\n}\n\nfunction processUpdateQueue(workInProgress, props, instance, renderLanes) {\n  // This is always non-null on a ClassComponent or HostRoot\n  var queue = workInProgress.updateQueue;\n  hasForceUpdate = false;\n\n  {\n    currentlyProcessingQueue = queue.shared;\n  }\n\n  var firstBaseUpdate = queue.firstBaseUpdate;\n  var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.\n\n  var pendingQueue = queue.shared.pending;\n\n  if (pendingQueue !== null) {\n    queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first\n    // and last so that it's non-circular.\n\n    var lastPendingUpdate = pendingQueue;\n    var firstPendingUpdate = lastPendingUpdate.next;\n    lastPendingUpdate.next = null; // Append pending updates to base queue\n\n    if (lastBaseUpdate === null) {\n      firstBaseUpdate = firstPendingUpdate;\n    } else {\n      lastBaseUpdate.next = firstPendingUpdate;\n    }\n\n    lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then\n    // we need to transfer the updates to that queue, too. Because the base\n    // queue is a singly-linked list with no cycles, we can append to both\n    // lists and take advantage of structural sharing.\n    // TODO: Pass `current` as argument\n\n    var current = workInProgress.alternate;\n\n    if (current !== null) {\n      // This is always non-null on a ClassComponent or HostRoot\n      var currentQueue = current.updateQueue;\n      var currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n\n      if (currentLastBaseUpdate !== lastBaseUpdate) {\n        if (currentLastBaseUpdate === null) {\n          currentQueue.firstBaseUpdate = firstPendingUpdate;\n        } else {\n          currentLastBaseUpdate.next = firstPendingUpdate;\n        }\n\n        currentQueue.lastBaseUpdate = lastPendingUpdate;\n      }\n    }\n  } // These values may change as we process the queue.\n\n\n  if (firstBaseUpdate !== null) {\n    // Iterate through the list of updates to compute the result.\n    var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n    // from the original lanes.\n\n    var newLanes = NoLanes;\n    var newBaseState = null;\n    var newFirstBaseUpdate = null;\n    var newLastBaseUpdate = null;\n    var update = firstBaseUpdate;\n\n    do {\n      var updateLane = update.lane;\n      var updateEventTime = update.eventTime;\n\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        var clone = {\n          eventTime: updateEventTime,\n          lane: updateLane,\n          tag: update.tag,\n          payload: update.payload,\n          callback: update.callback,\n          next: null\n        };\n\n        if (newLastBaseUpdate === null) {\n          newFirstBaseUpdate = newLastBaseUpdate = clone;\n          newBaseState = newState;\n        } else {\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        } // Update the remaining priority in the queue.\n\n\n        newLanes = mergeLanes(newLanes, updateLane);\n      } else {\n        // This update does have sufficient priority.\n        if (newLastBaseUpdate !== null) {\n          var _clone = {\n            eventTime: updateEventTime,\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n            next: null\n          };\n          newLastBaseUpdate = newLastBaseUpdate.next = _clone;\n        } // Process this update.\n\n\n        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\n        var callback = update.callback;\n\n        if (callback !== null && // If the update was already committed, we should not queue its\n        // callback again.\n        update.lane !== NoLane) {\n          workInProgress.flags |= Callback;\n          var effects = queue.effects;\n\n          if (effects === null) {\n            queue.effects = [update];\n          } else {\n            effects.push(update);\n          }\n        }\n      }\n\n      update = update.next;\n\n      if (update === null) {\n        pendingQueue = queue.shared.pending;\n\n        if (pendingQueue === null) {\n          break;\n        } else {\n          // An update was scheduled from inside a reducer. Add the new\n          // pending updates to the end of the list and keep processing.\n          var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we\n          // unravel them when transferring them to the base queue.\n\n          var _firstPendingUpdate = _lastPendingUpdate.next;\n          _lastPendingUpdate.next = null;\n          update = _firstPendingUpdate;\n          queue.lastBaseUpdate = _lastPendingUpdate;\n          queue.shared.pending = null;\n        }\n      }\n    } while (true);\n\n    if (newLastBaseUpdate === null) {\n      newBaseState = newState;\n    }\n\n    queue.baseState = newBaseState;\n    queue.firstBaseUpdate = newFirstBaseUpdate;\n    queue.lastBaseUpdate = newLastBaseUpdate; // Interleaved updates are stored on a separate queue. We aren't going to\n    // process them during this render, but we do need to track which lanes\n    // are remaining.\n\n    var lastInterleaved = queue.shared.interleaved;\n\n    if (lastInterleaved !== null) {\n      var interleaved = lastInterleaved;\n\n      do {\n        newLanes = mergeLanes(newLanes, interleaved.lane);\n        interleaved = interleaved.next;\n      } while (interleaved !== lastInterleaved);\n    } else if (firstBaseUpdate === null) {\n      // `queue.lanes` is used for entangling transitions. We can set it back to\n      // zero once the queue is empty.\n      queue.shared.lanes = NoLanes;\n    } // Set the remaining expiration time to be whatever is remaining in the queue.\n    // This should be fine because the only two other things that contribute to\n    // expiration time are props and context. We're already in the middle of the\n    // begin phase by the time we start processing the queue, so we've already\n    // dealt with the props. Context in components that specify\n    // shouldComponentUpdate is tricky; but we'll have to account for\n    // that regardless.\n\n\n    markSkippedUpdateLanes(newLanes);\n    workInProgress.lanes = newLanes;\n    workInProgress.memoizedState = newState;\n  }\n\n  {\n    currentlyProcessingQueue = null;\n  }\n}\n\nfunction callCallback(callback, context) {\n  if (typeof callback !== 'function') {\n    throw new Error('Invalid argument passed as callback. Expected a function. Instead ' + (\"received: \" + callback));\n  }\n\n  callback.call(context);\n}\n\nfunction resetHasForceUpdateBeforeProcessing() {\n  hasForceUpdate = false;\n}\nfunction checkHasForceUpdateAfterProcessing() {\n  return hasForceUpdate;\n}\nfunction commitUpdateQueue(finishedWork, finishedQueue, instance) {\n  // Commit the effects\n  var effects = finishedQueue.effects;\n  finishedQueue.effects = null;\n\n  if (effects !== null) {\n    for (var i = 0; i < effects.length; i++) {\n      var effect = effects[i];\n      var callback = effect.callback;\n\n      if (callback !== null) {\n        effect.callback = null;\n        callCallback(callback, instance);\n      }\n    }\n  }\n}\n\nvar fakeInternalInstance = {}; // React.Component uses a shared frozen object by default.\n// We'll use it to determine whether we need to initialize legacy refs.\n\nvar emptyRefsObject = new React.Component().refs;\nvar didWarnAboutStateAssignmentForComponent;\nvar didWarnAboutUninitializedState;\nvar didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\nvar didWarnAboutLegacyLifecyclesAndDerivedState;\nvar didWarnAboutUndefinedDerivedState;\nvar warnOnUndefinedDerivedState;\nvar warnOnInvalidCallback;\nvar didWarnAboutDirectlyAssigningPropsToState;\nvar didWarnAboutContextTypeAndContextTypes;\nvar didWarnAboutInvalidateContextType;\n\n{\n  didWarnAboutStateAssignmentForComponent = new Set();\n  didWarnAboutUninitializedState = new Set();\n  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n  didWarnAboutDirectlyAssigningPropsToState = new Set();\n  didWarnAboutUndefinedDerivedState = new Set();\n  didWarnAboutContextTypeAndContextTypes = new Set();\n  didWarnAboutInvalidateContextType = new Set();\n  var didWarnOnInvalidCallback = new Set();\n\n  warnOnInvalidCallback = function (callback, callerName) {\n    if (callback === null || typeof callback === 'function') {\n      return;\n    }\n\n    var key = callerName + '_' + callback;\n\n    if (!didWarnOnInvalidCallback.has(key)) {\n      didWarnOnInvalidCallback.add(key);\n\n      error('%s(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callerName, callback);\n    }\n  };\n\n  warnOnUndefinedDerivedState = function (type, partialState) {\n    if (partialState === undefined) {\n      var componentName = getComponentNameFromType(type) || 'Component';\n\n      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n        didWarnAboutUndefinedDerivedState.add(componentName);\n\n        error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n      }\n    }\n  }; // This is so gross but it's at least non-critical and can be removed if\n  // it causes problems. This is meant to give a nicer error message for\n  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n  // ...)) which otherwise throws a \"_processChildContext is not a function\"\n  // exception.\n\n\n  Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n    enumerable: false,\n    value: function () {\n      throw new Error('_processChildContext is not available in React 16+. This likely ' + 'means you have multiple copies of React and are attempting to nest ' + 'a React 15 tree inside a React 16 tree using ' + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + 'to make sure you have only one copy of React (and ideally, switch ' + 'to ReactDOM.createPortal).');\n    }\n  });\n  Object.freeze(fakeInternalInstance);\n}\n\nfunction applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n  var prevState = workInProgress.memoizedState;\n  var partialState = getDerivedStateFromProps(nextProps, prevState);\n\n  {\n    if ( workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        // Invoke the function an extra time to help detect side-effects.\n        partialState = getDerivedStateFromProps(nextProps, prevState);\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n\n    warnOnUndefinedDerivedState(ctor, partialState);\n  } // Merge the partial state and the previous state.\n\n\n  var memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n  workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\n  // base state.\n\n  if (workInProgress.lanes === NoLanes) {\n    // Queue is always non-null for classes\n    var updateQueue = workInProgress.updateQueue;\n    updateQueue.baseState = memoizedState;\n  }\n}\n\nvar classComponentUpdater = {\n  isMounted: isMounted,\n  enqueueSetState: function (inst, payload, callback) {\n    var fiber = get(inst);\n    var eventTime = requestEventTime();\n    var lane = requestUpdateLane(fiber);\n    var update = createUpdate(eventTime, lane);\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, 'setState');\n      }\n\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitions(root, fiber, lane);\n    }\n\n    {\n      markStateUpdateScheduled(fiber, lane);\n    }\n  },\n  enqueueReplaceState: function (inst, payload, callback) {\n    var fiber = get(inst);\n    var eventTime = requestEventTime();\n    var lane = requestUpdateLane(fiber);\n    var update = createUpdate(eventTime, lane);\n    update.tag = ReplaceState;\n    update.payload = payload;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, 'replaceState');\n      }\n\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitions(root, fiber, lane);\n    }\n\n    {\n      markStateUpdateScheduled(fiber, lane);\n    }\n  },\n  enqueueForceUpdate: function (inst, callback) {\n    var fiber = get(inst);\n    var eventTime = requestEventTime();\n    var lane = requestUpdateLane(fiber);\n    var update = createUpdate(eventTime, lane);\n    update.tag = ForceUpdate;\n\n    if (callback !== undefined && callback !== null) {\n      {\n        warnOnInvalidCallback(callback, 'forceUpdate');\n      }\n\n      update.callback = callback;\n    }\n\n    enqueueUpdate(fiber, update);\n    var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitions(root, fiber, lane);\n    }\n\n    {\n      markForceUpdateScheduled(fiber, lane);\n    }\n  }\n};\n\nfunction checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n  var instance = workInProgress.stateNode;\n\n  if (typeof instance.shouldComponentUpdate === 'function') {\n    var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n\n    {\n      if ( workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          // Invoke the function an extra time to help detect side-effects.\n          shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n\n      if (shouldUpdate === undefined) {\n        error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentNameFromType(ctor) || 'Component');\n      }\n    }\n\n    return shouldUpdate;\n  }\n\n  if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n    return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n  }\n\n  return true;\n}\n\nfunction checkClassInstance(workInProgress, ctor, newProps) {\n  var instance = workInProgress.stateNode;\n\n  {\n    var name = getComponentNameFromType(ctor) || 'Component';\n    var renderPresent = instance.render;\n\n    if (!renderPresent) {\n      if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n        error('%s(...): No `render` method found on the returned component ' + 'instance: did you accidentally return an object from the constructor?', name);\n      } else {\n        error('%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', name);\n      }\n    }\n\n    if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n      error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n    }\n\n    if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n    }\n\n    if (instance.propTypes) {\n      error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n    }\n\n    if (instance.contextType) {\n      error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);\n    }\n\n    {\n      if (instance.contextTypes) {\n        error('contextTypes was defined as an instance property on %s. Use a static ' + 'property to define contextTypes instead.', name);\n      }\n\n      if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {\n        didWarnAboutContextTypeAndContextTypes.add(ctor);\n\n        error('%s declares both contextTypes and contextType static properties. ' + 'The legacy contextTypes property will be ignored.', name);\n      }\n    }\n\n    if (typeof instance.componentShouldUpdate === 'function') {\n      error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n    }\n\n    if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n      error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentNameFromType(ctor) || 'A pure component');\n    }\n\n    if (typeof instance.componentDidUnmount === 'function') {\n      error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n    }\n\n    if (typeof instance.componentDidReceiveProps === 'function') {\n      error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n    }\n\n    if (typeof instance.componentWillRecieveProps === 'function') {\n      error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n    }\n\n    if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\n      error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);\n    }\n\n    var hasMutatedProps = instance.props !== newProps;\n\n    if (instance.props !== undefined && hasMutatedProps) {\n      error('%s(...): When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name, name);\n    }\n\n    if (instance.defaultProps) {\n      error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n\n      error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentNameFromType(ctor));\n    }\n\n    if (typeof instance.getDerivedStateFromProps === 'function') {\n      error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n    }\n\n    if (typeof instance.getDerivedStateFromError === 'function') {\n      error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n    }\n\n    if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\n      error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);\n    }\n\n    var _state = instance.state;\n\n    if (_state && (typeof _state !== 'object' || isArray(_state))) {\n      error('%s.state: must be set to an object or null', name);\n    }\n\n    if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {\n      error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);\n    }\n  }\n}\n\nfunction adoptClassInstance(workInProgress, instance) {\n  instance.updater = classComponentUpdater;\n  workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n\n  set(instance, workInProgress);\n\n  {\n    instance._reactInternalInstance = fakeInternalInstance;\n  }\n}\n\nfunction constructClassInstance(workInProgress, ctor, props) {\n  var isLegacyContextConsumer = false;\n  var unmaskedContext = emptyContextObject;\n  var context = emptyContextObject;\n  var contextType = ctor.contextType;\n\n  {\n    if ('contextType' in ctor) {\n      var isValid = // Allow null for conditional declaration\n      contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined; // Not a <Context.Consumer>\n\n      if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n        didWarnAboutInvalidateContextType.add(ctor);\n        var addendum = '';\n\n        if (contextType === undefined) {\n          addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';\n        } else if (typeof contextType !== 'object') {\n          addendum = ' However, it is set to a ' + typeof contextType + '.';\n        } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {\n          addendum = ' Did you accidentally pass the Context.Provider instead?';\n        } else if (contextType._context !== undefined) {\n          // <Context.Consumer>\n          addendum = ' Did you accidentally pass the Context.Consumer instead?';\n        } else {\n          addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';\n        }\n\n        error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentNameFromType(ctor) || 'Component', addendum);\n      }\n    }\n  }\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    context = readContext(contextType);\n  } else {\n    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    var contextTypes = ctor.contextTypes;\n    isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;\n    context = isLegacyContextConsumer ? getMaskedContext(workInProgress, unmaskedContext) : emptyContextObject;\n  }\n\n  var instance = new ctor(props, context); // Instantiate twice to help detect side-effects.\n\n  {\n    if ( workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        instance = new ctor(props, context); // eslint-disable-line no-new\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n  }\n\n  var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n  adoptClassInstance(workInProgress, instance);\n\n  {\n    if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n      var componentName = getComponentNameFromType(ctor) || 'Component';\n\n      if (!didWarnAboutUninitializedState.has(componentName)) {\n        didWarnAboutUninitializedState.add(componentName);\n\n        error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);\n      }\n    } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n    // Warn about these lifecycles if they are present.\n    // Don't warn about react-lifecycles-compat polyfilled methods though.\n\n\n    if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n      var foundWillMountName = null;\n      var foundWillReceivePropsName = null;\n      var foundWillUpdateName = null;\n\n      if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n        foundWillMountName = 'componentWillMount';\n      } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        foundWillMountName = 'UNSAFE_componentWillMount';\n      }\n\n      if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n        foundWillReceivePropsName = 'componentWillReceiveProps';\n      } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n      }\n\n      if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n        foundWillUpdateName = 'componentWillUpdate';\n      } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n      }\n\n      if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n        var _componentName = getComponentNameFromType(ctor) || 'Component';\n\n        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n\n        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n\n          error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://reactjs.org/link/unsafe-component-lifecycles', _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : '', foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : '', foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : '');\n        }\n      }\n    }\n  } // Cache unmasked context so we can avoid recreating masked context unless necessary.\n  // ReactFiberContext usually updates this cache but can't for newly-created instances.\n\n\n  if (isLegacyContextConsumer) {\n    cacheContext(workInProgress, unmaskedContext, context);\n  }\n\n  return instance;\n}\n\nfunction callComponentWillMount(workInProgress, instance) {\n  var oldState = instance.state;\n\n  if (typeof instance.componentWillMount === 'function') {\n    instance.componentWillMount();\n  }\n\n  if (typeof instance.UNSAFE_componentWillMount === 'function') {\n    instance.UNSAFE_componentWillMount();\n  }\n\n  if (oldState !== instance.state) {\n    {\n      error('%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentNameFromFiber(workInProgress) || 'Component');\n    }\n\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n}\n\nfunction callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n  var oldState = instance.state;\n\n  if (typeof instance.componentWillReceiveProps === 'function') {\n    instance.componentWillReceiveProps(newProps, nextContext);\n  }\n\n  if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n  }\n\n  if (instance.state !== oldState) {\n    {\n      var componentName = getComponentNameFromFiber(workInProgress) || 'Component';\n\n      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n        didWarnAboutStateAssignmentForComponent.add(componentName);\n\n        error('%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n      }\n    }\n\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n  }\n} // Invokes the mount life-cycles on a previously never rendered instance.\n\n\nfunction mountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n  {\n    checkClassInstance(workInProgress, ctor, newProps);\n  }\n\n  var instance = workInProgress.stateNode;\n  instance.props = newProps;\n  instance.state = workInProgress.memoizedState;\n  instance.refs = emptyRefsObject;\n  initializeUpdateQueue(workInProgress);\n  var contextType = ctor.contextType;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    instance.context = readContext(contextType);\n  } else {\n    var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    instance.context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  {\n    if (instance.state === newProps) {\n      var componentName = getComponentNameFromType(ctor) || 'Component';\n\n      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n\n        error('%s: It is not recommended to assign props directly to state ' + \"because updates to props won't be reflected in state. \" + 'In most cases, it is better to use props directly.', componentName);\n      }\n    }\n\n    if (workInProgress.mode & StrictLegacyMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n    }\n\n    {\n      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n    }\n  }\n\n  instance.state = workInProgress.memoizedState;\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    instance.state = workInProgress.memoizedState;\n  } // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n\n  if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n    callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n    // process them now.\n\n    processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n    instance.state = workInProgress.memoizedState;\n  }\n\n  if (typeof instance.componentDidMount === 'function') {\n    var fiberFlags = Update;\n\n    {\n      fiberFlags |= LayoutStatic;\n    }\n\n    if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n      fiberFlags |= MountLayoutDev;\n    }\n\n    workInProgress.flags |= fiberFlags;\n  }\n}\n\nfunction resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n  var instance = workInProgress.stateNode;\n  var oldProps = workInProgress.memoizedProps;\n  instance.props = oldProps;\n  var oldContext = instance.context;\n  var contextType = ctor.contextType;\n  var nextContext = emptyContextObject;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else {\n    var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);\n  }\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (oldProps !== newProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n  var oldState = workInProgress.memoizedState;\n  var newState = instance.state = oldState;\n  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n  newState = workInProgress.memoizedState;\n\n  if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      var fiberFlags = Update;\n\n      {\n        fiberFlags |= LayoutStatic;\n      }\n\n      if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n        fiberFlags |= MountLayoutDev;\n      }\n\n      workInProgress.flags |= fiberFlags;\n    }\n\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n      if (typeof instance.componentWillMount === 'function') {\n        instance.componentWillMount();\n      }\n\n      if (typeof instance.UNSAFE_componentWillMount === 'function') {\n        instance.UNSAFE_componentWillMount();\n      }\n    }\n\n    if (typeof instance.componentDidMount === 'function') {\n      var _fiberFlags = Update;\n\n      {\n        _fiberFlags |= LayoutStatic;\n      }\n\n      if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n        _fiberFlags |= MountLayoutDev;\n      }\n\n      workInProgress.flags |= _fiberFlags;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidMount === 'function') {\n      var _fiberFlags2 = Update;\n\n      {\n        _fiberFlags2 |= LayoutStatic;\n      }\n\n      if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n        _fiberFlags2 |= MountLayoutDev;\n      }\n\n      workInProgress.flags |= _fiberFlags2;\n    } // If shouldComponentUpdate returned false, we should still update the\n    // memoized state to indicate that this work can be reused.\n\n\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  } // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n\n\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n  return shouldUpdate;\n} // Invokes the update life-cycles and returns false if it shouldn't rerender.\n\n\nfunction updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {\n  var instance = workInProgress.stateNode;\n  cloneUpdateQueue(current, workInProgress);\n  var unresolvedOldProps = workInProgress.memoizedProps;\n  var oldProps = workInProgress.type === workInProgress.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress.type, unresolvedOldProps);\n  instance.props = oldProps;\n  var unresolvedNewProps = workInProgress.pendingProps;\n  var oldContext = instance.context;\n  var contextType = ctor.contextType;\n  var nextContext = emptyContextObject;\n\n  if (typeof contextType === 'object' && contextType !== null) {\n    nextContext = readContext(contextType);\n  } else {\n    var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);\n    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);\n  }\n\n  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n  var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n  // ever the previously attempted to render - not the \"current\". However,\n  // during componentDidUpdate we pass the \"current\" props.\n  // In order to support react-lifecycles-compat polyfilled components,\n  // Unsafe lifecycles should not be invoked for components using the new APIs.\n\n  if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n    if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n      callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n    }\n  }\n\n  resetHasForceUpdateBeforeProcessing();\n  var oldState = workInProgress.memoizedState;\n  var newState = instance.state = oldState;\n  processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n  newState = workInProgress.memoizedState;\n\n  if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !(enableLazyContextPropagation   )) {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Update;\n      }\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Snapshot;\n      }\n    }\n\n    return false;\n  }\n\n  if (typeof getDerivedStateFromProps === 'function') {\n    applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n    newState = workInProgress.memoizedState;\n  }\n\n  var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,\n  // both before and after `shouldComponentUpdate` has been called. Not ideal,\n  // but I'm loath to refactor this function. This only happens for memoized\n  // components so it's not that common.\n  enableLazyContextPropagation   ;\n\n  if (shouldUpdate) {\n    // In order to support react-lifecycles-compat polyfilled components,\n    // Unsafe lifecycles should not be invoked for components using the new APIs.\n    if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n      if (typeof instance.componentWillUpdate === 'function') {\n        instance.componentWillUpdate(newProps, newState, nextContext);\n      }\n\n      if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n      }\n    }\n\n    if (typeof instance.componentDidUpdate === 'function') {\n      workInProgress.flags |= Update;\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      workInProgress.flags |= Snapshot;\n    }\n  } else {\n    // If an update was already in progress, we should schedule an Update\n    // effect even though we're bailing out, so that cWU/cDU are called.\n    if (typeof instance.componentDidUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Update;\n      }\n    }\n\n    if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n      if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n        workInProgress.flags |= Snapshot;\n      }\n    } // If shouldComponentUpdate returned false, we should still update the\n    // memoized props/state to indicate that this work can be reused.\n\n\n    workInProgress.memoizedProps = newProps;\n    workInProgress.memoizedState = newState;\n  } // Update the existing instance's state, props, and context pointers even\n  // if shouldComponentUpdate returns false.\n\n\n  instance.props = newProps;\n  instance.state = newState;\n  instance.context = nextContext;\n  return shouldUpdate;\n}\n\n// TODO: Use the unified fiber stack module instead of this local one?\n// Intentionally not using it yet to derisk the initial implementation, because\n// the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n// rather the ids be wrong than crash the whole reconciler.\nvar forkStack = [];\nvar forkStackIndex = 0;\nvar treeForkProvider = null;\nvar treeForkCount = 0;\nvar idStack = [];\nvar idStackIndex = 0;\nvar treeContextProvider = null;\nvar treeContextId = 1;\nvar treeContextOverflow = '';\nfunction isForkedChild(workInProgress) {\n  warnIfNotHydrating();\n  return (workInProgress.flags & Forked) !== NoFlags;\n}\nfunction getForksAtLevel(workInProgress) {\n  warnIfNotHydrating();\n  return treeForkCount;\n}\nfunction getTreeId() {\n  var overflow = treeContextOverflow;\n  var idWithLeadingBit = treeContextId;\n  var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n  return id.toString(32) + overflow;\n}\nfunction pushTreeFork(workInProgress, totalChildren) {\n  // This is called right after we reconcile an array (or iterator) of child\n  // fibers, because that's the only place where we know how many children in\n  // the whole set without doing extra work later, or storing addtional\n  // information on the fiber.\n  //\n  // That's why this function is separate from pushTreeId  it's called during\n  // the render phase of the fork parent, not the child, which is where we push\n  // the other context values.\n  //\n  // In the Fizz implementation this is much simpler because the child is\n  // rendered in the same callstack as the parent.\n  //\n  // It might be better to just add a `forks` field to the Fiber type. It would\n  // make this module simpler.\n  warnIfNotHydrating();\n  forkStack[forkStackIndex++] = treeForkCount;\n  forkStack[forkStackIndex++] = treeForkProvider;\n  treeForkProvider = workInProgress;\n  treeForkCount = totalChildren;\n}\nfunction pushTreeId(workInProgress, totalChildren, index) {\n  warnIfNotHydrating();\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n  treeContextProvider = workInProgress;\n  var baseIdWithLeadingBit = treeContextId;\n  var baseOverflow = treeContextOverflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n  // of the id; we use it to account for leading 0s.\n\n  var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n  var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n  var slot = index + 1;\n  var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n  // consideration the leading 1 we use to mark the end of the sequence.\n\n  if (length > 30) {\n    // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n    // This branch assumes the length of the base id is greater than 5; it won't\n    // work for smaller ids, because you need 5 bits per character.\n    //\n    // We encode the id in multiple steps: first the base id, then the\n    // remaining digits.\n    //\n    // Each 5 bit sequence corresponds to a single base 32 character. So for\n    // example, if the current id is 23 bits long, we can convert 20 of those\n    // bits into a string of 4 characters, with 3 bits left over.\n    //\n    // First calculate how many bits in the base id represent a complete\n    // sequence of characters.\n    var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n\n    var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n\n    var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n\n    var restOfBaseId = baseId >> numberOfOverflowBits;\n    var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n    // we made more room, this time it won't overflow.\n\n    var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n    var restOfNewBits = slot << restOfBaseLength;\n    var id = restOfNewBits | restOfBaseId;\n    var overflow = newOverflow + baseOverflow;\n    treeContextId = 1 << restOfLength | id;\n    treeContextOverflow = overflow;\n  } else {\n    // Normal path\n    var newBits = slot << baseLength;\n\n    var _id = newBits | baseId;\n\n    var _overflow = baseOverflow;\n    treeContextId = 1 << length | _id;\n    treeContextOverflow = _overflow;\n  }\n}\nfunction pushMaterializedTreeId(workInProgress) {\n  warnIfNotHydrating(); // This component materialized an id. This will affect any ids that appear\n  // in its children.\n\n  var returnFiber = workInProgress.return;\n\n  if (returnFiber !== null) {\n    var numberOfForks = 1;\n    var slotIndex = 0;\n    pushTreeFork(workInProgress, numberOfForks);\n    pushTreeId(workInProgress, numberOfForks, slotIndex);\n  }\n}\n\nfunction getBitLength(number) {\n  return 32 - clz32(number);\n}\n\nfunction getLeadingBit(id) {\n  return 1 << getBitLength(id) - 1;\n}\n\nfunction popTreeContext(workInProgress) {\n  // Restore the previous values.\n  // This is a bit more complicated than other context-like modules in Fiber\n  // because the same Fiber may appear on the stack multiple times and for\n  // different reasons. We have to keep popping until the work-in-progress is\n  // no longer at the top of the stack.\n  while (workInProgress === treeForkProvider) {\n    treeForkProvider = forkStack[--forkStackIndex];\n    forkStack[forkStackIndex] = null;\n    treeForkCount = forkStack[--forkStackIndex];\n    forkStack[forkStackIndex] = null;\n  }\n\n  while (workInProgress === treeContextProvider) {\n    treeContextProvider = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n    treeContextOverflow = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n    treeContextId = idStack[--idStackIndex];\n    idStack[idStackIndex] = null;\n  }\n}\nfunction getSuspendedTreeContext() {\n  warnIfNotHydrating();\n\n  if (treeContextProvider !== null) {\n    return {\n      id: treeContextId,\n      overflow: treeContextOverflow\n    };\n  } else {\n    return null;\n  }\n}\nfunction restoreSuspendedTreeContext(workInProgress, suspendedContext) {\n  warnIfNotHydrating();\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n  treeContextId = suspendedContext.id;\n  treeContextOverflow = suspendedContext.overflow;\n  treeContextProvider = workInProgress;\n}\n\nfunction warnIfNotHydrating() {\n  {\n    if (!getIsHydrating()) {\n      error('Expected to be hydrating. This is a bug in React. Please file ' + 'an issue.');\n    }\n  }\n}\n\n// This may have been an insertion or a hydration.\n\nvar hydrationParentFiber = null;\nvar nextHydratableInstance = null;\nvar isHydrating = false;\nvar didSuspend = false; // Hydration errors that were thrown inside this boundary\n\nvar hydrationErrors = null;\n\nfunction warnIfHydrating() {\n  {\n    if (isHydrating) {\n      error('We should not be hydrating here. This is a bug in React. Please file a bug.');\n    }\n  }\n}\n\nfunction markDidSuspendWhileHydratingDEV() {\n  {\n    didSuspend = true;\n  }\n}\n\nfunction enterHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  var parentInstance = fiber.stateNode.containerInfo;\n  nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  hydrationErrors = null;\n  didSuspend = false;\n  return true;\n}\n\nfunction reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n  hydrationParentFiber = fiber;\n  isHydrating = true;\n  hydrationErrors = null;\n  didSuspend = false;\n\n  if (treeContext !== null) {\n    restoreSuspendedTreeContext(fiber, treeContext);\n  }\n\n  return true;\n}\n\nfunction warnUnhydratedInstance(returnFiber, instance) {\n  {\n    switch (returnFiber.tag) {\n      case HostRoot:\n        didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);\n        break;\n\n      case HostComponent:\n        didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance);\n        break;\n\n      case SuspenseComponent:\n        var suspenseState = returnFiber.memoizedState;\n        if (suspenseState.dehydrated !== null) didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);\n        break;\n    }\n  }\n}\n\nfunction deleteHydratableInstance(returnFiber, instance) {\n  warnUnhydratedInstance(returnFiber, instance);\n  var childToDelete = createFiberFromHostInstanceForDeletion();\n  childToDelete.stateNode = instance;\n  childToDelete.return = returnFiber;\n  var deletions = returnFiber.deletions;\n\n  if (deletions === null) {\n    returnFiber.deletions = [childToDelete];\n    returnFiber.flags |= ChildDeletion;\n  } else {\n    deletions.push(childToDelete);\n  }\n}\n\nfunction warnNonhydratedInstance(returnFiber, fiber) {\n  {\n    if (didSuspend) {\n      // Inside a boundary that already suspended. We're currently rendering the\n      // siblings of a suspended node. The mismatch may be due to the missing\n      // data, so it's probably a false positive.\n      return;\n    }\n\n    switch (returnFiber.tag) {\n      case HostRoot:\n        {\n          var parentContainer = returnFiber.stateNode.containerInfo;\n\n          switch (fiber.tag) {\n            case HostComponent:\n              var type = fiber.type;\n              var props = fiber.pendingProps;\n              didNotFindHydratableInstanceWithinContainer(parentContainer, type, props);\n              break;\n\n            case HostText:\n              var text = fiber.pendingProps;\n              didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer);\n              break;\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          var parentType = returnFiber.type;\n          var parentProps = returnFiber.memoizedProps;\n          var parentInstance = returnFiber.stateNode;\n\n          switch (fiber.tag) {\n            case HostComponent:\n              var _type = fiber.type;\n              var _props = fiber.pendingProps;\n              didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props);\n              break;\n\n            case HostText:\n              var _text = fiber.pendingProps;\n              didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstance(parentType, parentProps, parentInstance);\n              break;\n          }\n\n          break;\n        }\n\n      case SuspenseComponent:\n        {\n          var suspenseState = returnFiber.memoizedState;\n          var _parentInstance = suspenseState.dehydrated;\n          if (_parentInstance !== null) switch (fiber.tag) {\n            case HostComponent:\n              var _type2 = fiber.type;\n              var _props2 = fiber.pendingProps;\n              didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2, _props2);\n              break;\n\n            case HostText:\n              var _text2 = fiber.pendingProps;\n              didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);\n              break;\n\n            case SuspenseComponent:\n              didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(_parentInstance);\n              break;\n          }\n          break;\n        }\n\n      default:\n        return;\n    }\n  }\n}\n\nfunction insertNonHydratedInstance(returnFiber, fiber) {\n  fiber.flags = fiber.flags & ~Hydrating | Placement;\n  warnNonhydratedInstance(returnFiber, fiber);\n}\n\nfunction tryHydrate(fiber, nextInstance) {\n  switch (fiber.tag) {\n    case HostComponent:\n      {\n        var type = fiber.type;\n        var props = fiber.pendingProps;\n        var instance = canHydrateInstance(nextInstance, type, props);\n\n        if (instance !== null) {\n          fiber.stateNode = instance;\n          hydrationParentFiber = fiber;\n          nextHydratableInstance = getFirstHydratableChild(instance);\n          return true;\n        }\n\n        return false;\n      }\n\n    case HostText:\n      {\n        var text = fiber.pendingProps;\n        var textInstance = canHydrateTextInstance(nextInstance, text);\n\n        if (textInstance !== null) {\n          fiber.stateNode = textInstance;\n          hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.\n\n          nextHydratableInstance = null;\n          return true;\n        }\n\n        return false;\n      }\n\n    case SuspenseComponent:\n      {\n        {\n          var suspenseInstance = canHydrateSuspenseInstance(nextInstance);\n\n          if (suspenseInstance !== null) {\n            var suspenseState = {\n              dehydrated: suspenseInstance,\n              treeContext: getSuspendedTreeContext(),\n              retryLane: OffscreenLane\n            };\n            fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.\n            // This simplifies the code for getHostSibling and deleting nodes,\n            // since it doesn't have to consider all Suspense boundaries and\n            // check if they're dehydrated ones or not.\n\n            var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n            dehydratedFragment.return = fiber;\n            fiber.child = dehydratedFragment;\n            hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into\n            // it during the first pass. Instead, we'll reenter it later.\n\n            nextHydratableInstance = null;\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n    default:\n      return false;\n  }\n}\n\nfunction shouldClientRenderOnMismatch(fiber) {\n  return  (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;\n}\n\nfunction throwOnHydrationMismatch(fiber) {\n  throw new Error('Hydration failed because the initial UI does not match what was ' + 'rendered on the server.');\n}\n\nfunction tryToClaimNextHydratableInstance(fiber) {\n  if (!isHydrating) {\n    return;\n  }\n\n  var nextInstance = nextHydratableInstance;\n\n  if (!nextInstance) {\n    if (shouldClientRenderOnMismatch(fiber)) {\n      warnNonhydratedInstance(hydrationParentFiber, fiber);\n      throwOnHydrationMismatch();\n    } // Nothing to hydrate. Make it an insertion.\n\n\n    insertNonHydratedInstance(hydrationParentFiber, fiber);\n    isHydrating = false;\n    hydrationParentFiber = fiber;\n    return;\n  }\n\n  var firstAttemptedInstance = nextInstance;\n\n  if (!tryHydrate(fiber, nextInstance)) {\n    if (shouldClientRenderOnMismatch(fiber)) {\n      warnNonhydratedInstance(hydrationParentFiber, fiber);\n      throwOnHydrationMismatch();\n    } // If we can't hydrate this instance let's try the next one.\n    // We use this as a heuristic. It's based on intuition and not data so it\n    // might be flawed or unnecessary.\n\n\n    nextInstance = getNextHydratableSibling(firstAttemptedInstance);\n    var prevHydrationParentFiber = hydrationParentFiber;\n\n    if (!nextInstance || !tryHydrate(fiber, nextInstance)) {\n      // Nothing to hydrate. Make it an insertion.\n      insertNonHydratedInstance(hydrationParentFiber, fiber);\n      isHydrating = false;\n      hydrationParentFiber = fiber;\n      return;\n    } // We matched the next one, we'll now assume that the first one was\n    // superfluous and we'll delete it. Since we can't eagerly delete it\n    // we'll have to schedule a deletion. To do that, this node needs a dummy\n    // fiber associated with it.\n\n\n    deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);\n  }\n}\n\nfunction prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var instance = fiber.stateNode;\n  var shouldWarnIfMismatchDev = !didSuspend;\n  var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev); // TODO: Type this specific to this type of component.\n\n  fiber.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n  // is a new ref we mark this as an update.\n\n  if (updatePayload !== null) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction prepareToHydrateHostTextInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostTextInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var textInstance = fiber.stateNode;\n  var textContent = fiber.memoizedProps;\n  var shouldWarnIfMismatchDev = !didSuspend;\n  var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber, shouldWarnIfMismatchDev);\n\n  if (shouldUpdate) {\n    // We assume that prepareToHydrateHostTextInstance is called in a context where the\n    // hydration parent is the parent host component of this host text.\n    var returnFiber = hydrationParentFiber;\n\n    if (returnFiber !== null) {\n      var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;\n\n      switch (returnFiber.tag) {\n        case HostRoot:\n          {\n            var parentContainer = returnFiber.stateNode.containerInfo;\n            didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, // TODO: Delete this argument when we remove the legacy root API.\n            isConcurrentMode);\n            break;\n          }\n\n        case HostComponent:\n          {\n            var parentType = returnFiber.type;\n            var parentProps = returnFiber.memoizedProps;\n            var parentInstance = returnFiber.stateNode;\n            didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, // TODO: Delete this argument when we remove the legacy root API.\n            isConcurrentMode);\n            break;\n          }\n      }\n    }\n  }\n\n  return shouldUpdate;\n}\n\nfunction prepareToHydrateHostSuspenseInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected prepareToHydrateHostSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var suspenseState = fiber.memoizedState;\n  var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  hydrateSuspenseInstance(suspenseInstance, fiber);\n}\n\nfunction skipPastDehydratedSuspenseInstance(fiber) {\n  if (!supportsHydration) {\n    throw new Error('Expected skipPastDehydratedSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  var suspenseState = fiber.memoizedState;\n  var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n\n  if (!suspenseInstance) {\n    throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n  }\n\n  return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n}\n\nfunction popToNextHostParent(fiber) {\n  var parent = fiber.return;\n\n  while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {\n    parent = parent.return;\n  }\n\n  hydrationParentFiber = parent;\n}\n\nfunction popHydrationState(fiber) {\n  if (!supportsHydration) {\n    return false;\n  }\n\n  if (fiber !== hydrationParentFiber) {\n    // We're deeper than the current hydration context, inside an inserted\n    // tree.\n    return false;\n  }\n\n  if (!isHydrating) {\n    // If we're not currently hydrating but we're in a hydration context, then\n    // we were an insertion and now need to pop up reenter hydration of our\n    // siblings.\n    popToNextHostParent(fiber);\n    isHydrating = true;\n    return false;\n  } // If we have any remaining hydratable nodes, we need to delete them now.\n  // We only do this deeper than head and body since they tend to have random\n  // other nodes in them. We also ignore components with pure text content in\n  // side of them. We also don't delete anything inside the root container.\n\n\n  if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n    var nextInstance = nextHydratableInstance;\n\n    if (nextInstance) {\n      if (shouldClientRenderOnMismatch(fiber)) {\n        warnIfUnhydratedTailNodes(fiber);\n        throwOnHydrationMismatch();\n      } else {\n        while (nextInstance) {\n          deleteHydratableInstance(fiber, nextInstance);\n          nextInstance = getNextHydratableSibling(nextInstance);\n        }\n      }\n    }\n  }\n\n  popToNextHostParent(fiber);\n\n  if (fiber.tag === SuspenseComponent) {\n    nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n  } else {\n    nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n  }\n\n  return true;\n}\n\nfunction hasUnhydratedTailNodes() {\n  return isHydrating && nextHydratableInstance !== null;\n}\n\nfunction warnIfUnhydratedTailNodes(fiber) {\n  var nextInstance = nextHydratableInstance;\n\n  while (nextInstance) {\n    warnUnhydratedInstance(fiber, nextInstance);\n    nextInstance = getNextHydratableSibling(nextInstance);\n  }\n}\n\nfunction resetHydrationState() {\n  if (!supportsHydration) {\n    return;\n  }\n\n  hydrationParentFiber = null;\n  nextHydratableInstance = null;\n  isHydrating = false;\n  didSuspend = false;\n}\n\nfunction upgradeHydrationErrorsToRecoverable() {\n  if (hydrationErrors !== null) {\n    // Successfully completed a forced client render. The errors that occurred\n    // during the hydration attempt are now recovered. We will log them in\n    // commit phase, once the entire tree has finished.\n    queueRecoverableErrors(hydrationErrors);\n    hydrationErrors = null;\n  }\n}\n\nfunction getIsHydrating() {\n  return isHydrating;\n}\n\nfunction queueHydrationError(error) {\n  if (hydrationErrors === null) {\n    hydrationErrors = [error];\n  } else {\n    hydrationErrors.push(error);\n  }\n}\n\nvar didWarnAboutMaps;\nvar didWarnAboutGenerators;\nvar didWarnAboutStringRefs;\nvar ownerHasKeyUseWarning;\nvar ownerHasFunctionTypeWarning;\n\nvar warnForMissingKey = function (child, returnFiber) {};\n\n{\n  didWarnAboutMaps = false;\n  didWarnAboutGenerators = false;\n  didWarnAboutStringRefs = {};\n  /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */\n\n  ownerHasKeyUseWarning = {};\n  ownerHasFunctionTypeWarning = {};\n\n  warnForMissingKey = function (child, returnFiber) {\n    if (child === null || typeof child !== 'object') {\n      return;\n    }\n\n    if (!child._store || child._store.validated || child.key != null) {\n      return;\n    }\n\n    if (typeof child._store !== 'object') {\n      throw new Error('React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n    }\n\n    child._store.validated = true;\n    var componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasKeyUseWarning[componentName]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[componentName] = true;\n\n    error('Each child in a list should have a unique ' + '\"key\" prop. See https://reactjs.org/link/warning-keys for ' + 'more information.');\n  };\n}\n\nfunction coerceRef(returnFiber, current, element) {\n  var mixedRef = element.ref;\n\n  if (mixedRef !== null && typeof mixedRef !== 'function' && typeof mixedRef !== 'object') {\n    {\n      // TODO: Clean this up once we turn on the string ref warning for\n      // everyone, because the strict mode case will no longer be relevant\n      if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs\n      // because these cannot be automatically converted to an arrow function\n      // using a codemod. Therefore, we don't have to warn about string refs again.\n      !(element._owner && element._self && element._owner.stateNode !== element._self)) {\n        var componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n        if (!didWarnAboutStringRefs[componentName]) {\n          {\n            error('A string ref, \"%s\", has been found within a strict mode tree. ' + 'String refs are a source of potential bugs and should be avoided. ' + 'We recommend using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', mixedRef);\n          }\n\n          didWarnAboutStringRefs[componentName] = true;\n        }\n      }\n    }\n\n    if (element._owner) {\n      var owner = element._owner;\n      var inst;\n\n      if (owner) {\n        var ownerFiber = owner;\n\n        if (ownerFiber.tag !== ClassComponent) {\n          throw new Error('Function components cannot have string refs. ' + 'We recommend using useRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref');\n        }\n\n        inst = ownerFiber.stateNode;\n      }\n\n      if (!inst) {\n        throw new Error(\"Missing owner for string ref \" + mixedRef + \". This error is likely caused by a \" + 'bug in React. Please file an issue.');\n      } // Assigning this to a const so Flow knows it won't change in the closure\n\n\n      var resolvedInst = inst;\n\n      {\n        checkPropStringCoercion(mixedRef, 'ref');\n      }\n\n      var stringRef = '' + mixedRef; // Check if previous string ref matches new string ref\n\n      if (current !== null && current.ref !== null && typeof current.ref === 'function' && current.ref._stringRef === stringRef) {\n        return current.ref;\n      }\n\n      var ref = function (value) {\n        var refs = resolvedInst.refs;\n\n        if (refs === emptyRefsObject) {\n          // This is a lazy pooled frozen object, so we need to initialize.\n          refs = resolvedInst.refs = {};\n        }\n\n        if (value === null) {\n          delete refs[stringRef];\n        } else {\n          refs[stringRef] = value;\n        }\n      };\n\n      ref._stringRef = stringRef;\n      return ref;\n    } else {\n      if (typeof mixedRef !== 'string') {\n        throw new Error('Expected ref to be a function, a string, an object returned by React.createRef(), or null.');\n      }\n\n      if (!element._owner) {\n        throw new Error(\"Element ref was specified as a string (\" + mixedRef + \") but no owner was set. This could happen for one of\" + ' the following reasons:\\n' + '1. You may be adding a ref to a function component\\n' + \"2. You may be adding a ref to a component that was not created inside a component's render method\\n\" + '3. You have multiple copies of React loaded\\n' + 'See https://reactjs.org/link/refs-must-have-owner for more information.');\n      }\n    }\n  }\n\n  return mixedRef;\n}\n\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  var childString = Object.prototype.toString.call(newChild);\n  throw new Error(\"Objects are not valid as a React child (found: \" + (childString === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : childString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n}\n\nfunction warnOnFunctionType(returnFiber) {\n  {\n    var componentName = getComponentNameFromFiber(returnFiber) || 'Component';\n\n    if (ownerHasFunctionTypeWarning[componentName]) {\n      return;\n    }\n\n    ownerHasFunctionTypeWarning[componentName] = true;\n\n    error('Functions are not valid as a React child. This may happen if ' + 'you return a Component instead of <Component /> from render. ' + 'Or maybe you meant to call this function rather than return it.');\n  }\n}\n\nfunction resolveLazy(lazyType) {\n  var payload = lazyType._payload;\n  var init = lazyType._init;\n  return init(payload);\n} // This wrapper function exists because I expect to clone the code in each path\n// to be able to optimize each path individually by branching early. This needs\n// a compiler or we can do it manually. Helpers that don't need this branching\n// live outside of this function.\n\n\nfunction ChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return;\n    }\n\n    var deletions = returnFiber.deletions;\n\n    if (deletions === null) {\n      returnFiber.deletions = [childToDelete];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(childToDelete);\n    }\n  }\n\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) {\n      // Noop.\n      return null;\n    } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n    // assuming that after the first child we've already added everything.\n\n\n    var childToDelete = currentFirstChild;\n\n    while (childToDelete !== null) {\n      deleteChild(returnFiber, childToDelete);\n      childToDelete = childToDelete.sibling;\n    }\n\n    return null;\n  }\n\n  function mapRemainingChildren(returnFiber, currentFirstChild) {\n    // Add the remaining children to a temporary map so that we can find them by\n    // keys quickly. Implicit (null) keys get added to this set with their index\n    // instead.\n    var existingChildren = new Map();\n    var existingChild = currentFirstChild;\n\n    while (existingChild !== null) {\n      if (existingChild.key !== null) {\n        existingChildren.set(existingChild.key, existingChild);\n      } else {\n        existingChildren.set(existingChild.index, existingChild);\n      }\n\n      existingChild = existingChild.sibling;\n    }\n\n    return existingChildren;\n  }\n\n  function useFiber(fiber, pendingProps) {\n    // We currently set sibling to null and index to 0 here because it is easy\n    // to forget to do before returning it. E.g. for the single child case.\n    var clone = createWorkInProgress(fiber, pendingProps);\n    clone.index = 0;\n    clone.sibling = null;\n    return clone;\n  }\n\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n\n    if (!shouldTrackSideEffects) {\n      // During hydration, the useId algorithm needs to know which fibers are\n      // part of a list of children (arrays, iterators).\n      newFiber.flags |= Forked;\n      return lastPlacedIndex;\n    }\n\n    var current = newFiber.alternate;\n\n    if (current !== null) {\n      var oldIndex = current.index;\n\n      if (oldIndex < lastPlacedIndex) {\n        // This is a move.\n        newFiber.flags |= Placement;\n        return lastPlacedIndex;\n      } else {\n        // This item can stay in place.\n        return oldIndex;\n      }\n    } else {\n      // This is an insertion.\n      newFiber.flags |= Placement;\n      return lastPlacedIndex;\n    }\n  }\n\n  function placeSingleChild(newFiber) {\n    // This is simpler for the single child case. We only need to do a\n    // placement for inserting new children.\n    if (shouldTrackSideEffects && newFiber.alternate === null) {\n      newFiber.flags |= Placement;\n    }\n\n    return newFiber;\n  }\n\n  function updateTextNode(returnFiber, current, textContent, lanes) {\n    if (current === null || current.tag !== HostText) {\n      // Insert\n      var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, textContent);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateElement(returnFiber, current, element, lanes) {\n    var elementType = element.type;\n\n    if (elementType === REACT_FRAGMENT_TYPE) {\n      return updateFragment(returnFiber, current, element.props.children, lanes, element.key);\n    }\n\n    if (current !== null) {\n      if (current.elementType === elementType || ( // Keep this check inline so it only runs on the false path:\n       isCompatibleFamilyForHotReloading(current, element) ) || // Lazy types should reconcile their resolved type.\n      // We need to do this after the Hot Reloading check above,\n      // because hot reloading has different semantics than prod because\n      // it doesn't resuspend. So we can't let the call below suspend.\n       typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {\n        // Move based on index\n        var existing = useFiber(current, element.props);\n        existing.ref = coerceRef(returnFiber, current, element);\n        existing.return = returnFiber;\n\n        {\n          existing._debugSource = element._source;\n          existing._debugOwner = element._owner;\n        }\n\n        return existing;\n      }\n    } // Insert\n\n\n    var created = createFiberFromElement(element, returnFiber.mode, lanes);\n    created.ref = coerceRef(returnFiber, current, element);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function updatePortal(returnFiber, current, portal, lanes) {\n    if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n      // Insert\n      var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, portal.children || []);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function updateFragment(returnFiber, current, fragment, lanes, key) {\n    if (current === null || current.tag !== Fragment) {\n      // Insert\n      var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      // Update\n      var existing = useFiber(current, fragment);\n      existing.return = returnFiber;\n      return existing;\n    }\n  }\n\n  function createChild(returnFiber, newChild, lanes) {\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);\n      created.return = returnFiber;\n      return created;\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n\n            _created.ref = coerceRef(returnFiber, null, newChild);\n            _created.return = returnFiber;\n            return _created;\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n\n            _created2.return = returnFiber;\n            return _created2;\n          }\n\n        case REACT_LAZY_TYPE:\n          {\n            {\n              var payload = newChild._payload;\n              var init = newChild._init;\n              return createChild(returnFiber, init(payload), lanes);\n            }\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n\n        _created3.return = returnFiber;\n        return _created3;\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n    // Update the fiber if the keys match, otherwise return null.\n    var key = oldFiber !== null ? oldFiber.key : null;\n\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      // Text nodes don't have keys. If the previous node is implicitly keyed\n      // we can continue to replace it without aborting even if it is not a text\n      // node.\n      if (key !== null) {\n        return null;\n      }\n\n      return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            if (newChild.key === key) {\n              return updateElement(returnFiber, oldFiber, newChild, lanes);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            if (newChild.key === key) {\n              return updatePortal(returnFiber, oldFiber, newChild, lanes);\n            } else {\n              return null;\n            }\n          }\n\n        case REACT_LAZY_TYPE:\n          {\n            {\n              var payload = newChild._payload;\n              var init = newChild._init;\n              return updateSlot(returnFiber, oldFiber, init(payload), lanes);\n            }\n          }\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        if (key !== null) {\n          return null;\n        }\n\n        return updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n\n  function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      // Text nodes don't have keys, so we neither have to check the old nor\n      // new node for the key. If both are text nodes, they match.\n      var matchedFiber = existingChildren.get(newIdx) || null;\n      return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes);\n    }\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          {\n            var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n            return updateElement(returnFiber, _matchedFiber, newChild, lanes);\n          }\n\n        case REACT_PORTAL_TYPE:\n          {\n            var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n\n            return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);\n          }\n\n        case REACT_LAZY_TYPE:\n          {\n            var payload = newChild._payload;\n            var init = newChild._init;\n            return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);\n          }\n\n      }\n\n      if (isArray(newChild) || getIteratorFn(newChild)) {\n        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n\n        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Warns if there is a duplicate or missing key\n   */\n\n\n  function warnOnInvalidKey(child, knownKeys, returnFiber) {\n    {\n      if (typeof child !== 'object' || child === null) {\n        return knownKeys;\n      }\n\n      switch (child.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n        case REACT_PORTAL_TYPE:\n          warnForMissingKey(child, returnFiber);\n          var key = child.key;\n\n          if (typeof key !== 'string') {\n            break;\n          }\n\n          if (knownKeys === null) {\n            knownKeys = new Set();\n            knownKeys.add(key);\n            break;\n          }\n\n          if (!knownKeys.has(key)) {\n            knownKeys.add(key);\n            break;\n          }\n\n          error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted  the behavior is unsupported and ' + 'could change in a future version.', key);\n\n          break;\n\n        case REACT_LAZY_TYPE:\n          {\n            var payload = child._payload;\n            var init = child._init;\n            warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n            break;\n          }\n      }\n    }\n\n    return knownKeys;\n  }\n\n  function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {\n    // This algorithm can't optimize by searching from both ends since we\n    // don't have backpointers on fibers. I'm trying to see how far we can get\n    // with that model. If it ends up not being worth the tradeoffs, we can\n    // add it later.\n    // Even with a two ended optimization, we'd want to optimize for the case\n    // where there are few changes and brute force the comparison instead of\n    // going for the Map. It'd like to explore hitting that path first in\n    // forward-only mode and only go for the Map once we notice that we need\n    // lots of look ahead. This doesn't handle reversal as well as two ended\n    // search but that's unusual. Besides, for the two ended optimization to\n    // work on Iterables, we'd need to copy the whole set.\n    // In this first iteration, we'll just live with hitting the bad case\n    // (adding everything to a Map) in for every insert/move.\n    // If you change this code, also update reconcileChildrenIterator() which\n    // uses the same algorithm.\n    {\n      // First, validate keys.\n      var knownKeys = null;\n\n      for (var i = 0; i < newChildren.length; i++) {\n        var child = newChildren[i];\n        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n      }\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n\n    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (newIdx === newChildren.length) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n\n      if (getIsHydrating()) {\n        var numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; newIdx < newChildren.length; newIdx++) {\n        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);\n\n        if (_newFiber === null) {\n          continue;\n        }\n\n        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber;\n        } else {\n          previousNewFiber.sibling = _newFiber;\n        }\n\n        previousNewFiber = _newFiber;\n      }\n\n      if (getIsHydrating()) {\n        var _numberOfForks = newIdx;\n        pushTreeFork(returnFiber, _numberOfForks);\n      }\n\n      return resultingFirstChild;\n    } // Add all children to a key map for quick lookups.\n\n\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; newIdx < newChildren.length; newIdx++) {\n      var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);\n\n      if (_newFiber2 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber2.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber2;\n        } else {\n          previousNewFiber.sibling = _newFiber2;\n        }\n\n        previousNewFiber = _newFiber2;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    if (getIsHydrating()) {\n      var _numberOfForks2 = newIdx;\n      pushTreeFork(returnFiber, _numberOfForks2);\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {\n    // This is the same implementation as reconcileChildrenArray(),\n    // but using the iterator instead.\n    var iteratorFn = getIteratorFn(newChildrenIterable);\n\n    if (typeof iteratorFn !== 'function') {\n      throw new Error('An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');\n    }\n\n    {\n      // We don't support rendering Generators because it's a mutation.\n      // See https://github.com/facebook/react/issues/12995\n      if (typeof Symbol === 'function' && // $FlowFixMe Flow doesn't know about toStringTag\n      newChildrenIterable[Symbol.toStringTag] === 'Generator') {\n        if (!didWarnAboutGenerators) {\n          error('Using Generators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. Keep in mind ' + 'you might need to polyfill these features for older browsers.');\n        }\n\n        didWarnAboutGenerators = true;\n      } // Warn about using Maps as children\n\n\n      if (newChildrenIterable.entries === iteratorFn) {\n        if (!didWarnAboutMaps) {\n          error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n        }\n\n        didWarnAboutMaps = true;\n      } // First, validate keys.\n      // We'll get a different iterator later for the main pass.\n\n\n      var _newChildren = iteratorFn.call(newChildrenIterable);\n\n      if (_newChildren) {\n        var knownKeys = null;\n\n        var _step = _newChildren.next();\n\n        for (; !_step.done; _step = _newChildren.next()) {\n          var child = _step.value;\n          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n        }\n      }\n    }\n\n    var newChildren = iteratorFn.call(newChildrenIterable);\n\n    if (newChildren == null) {\n      throw new Error('An iterable object provided no iterator.');\n    }\n\n    var resultingFirstChild = null;\n    var previousNewFiber = null;\n    var oldFiber = currentFirstChild;\n    var lastPlacedIndex = 0;\n    var newIdx = 0;\n    var nextOldFiber = null;\n    var step = newChildren.next();\n\n    for (; oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {\n      if (oldFiber.index > newIdx) {\n        nextOldFiber = oldFiber;\n        oldFiber = null;\n      } else {\n        nextOldFiber = oldFiber.sibling;\n      }\n\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n\n      if (newFiber === null) {\n        // TODO: This breaks on empty slots like null children. That's\n        // unfortunate because it triggers the slow path all the time. We need\n        // a better way to communicate whether this was a miss or null,\n        // boolean, undefined, etc.\n        if (oldFiber === null) {\n          oldFiber = nextOldFiber;\n        }\n\n        break;\n      }\n\n      if (shouldTrackSideEffects) {\n        if (oldFiber && newFiber.alternate === null) {\n          // We matched the slot, but we didn't reuse the existing fiber, so we\n          // need to delete the existing child.\n          deleteChild(returnFiber, oldFiber);\n        }\n      }\n\n      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n\n      if (previousNewFiber === null) {\n        // TODO: Move out of the loop. This only happens for the first run.\n        resultingFirstChild = newFiber;\n      } else {\n        // TODO: Defer siblings if we're not at the right index for this slot.\n        // I.e. if we had null values before, then we want to defer this\n        // for each null value. However, we also don't want to call updateSlot\n        // with the previous one.\n        previousNewFiber.sibling = newFiber;\n      }\n\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n\n    if (step.done) {\n      // We've reached the end of the new children. We can delete the rest.\n      deleteRemainingChildren(returnFiber, oldFiber);\n\n      if (getIsHydrating()) {\n        var numberOfForks = newIdx;\n        pushTreeFork(returnFiber, numberOfForks);\n      }\n\n      return resultingFirstChild;\n    }\n\n    if (oldFiber === null) {\n      // If we don't have any more existing children we can choose a fast path\n      // since the rest will all be insertions.\n      for (; !step.done; newIdx++, step = newChildren.next()) {\n        var _newFiber3 = createChild(returnFiber, step.value, lanes);\n\n        if (_newFiber3 === null) {\n          continue;\n        }\n\n        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          // TODO: Move out of the loop. This only happens for the first run.\n          resultingFirstChild = _newFiber3;\n        } else {\n          previousNewFiber.sibling = _newFiber3;\n        }\n\n        previousNewFiber = _newFiber3;\n      }\n\n      if (getIsHydrating()) {\n        var _numberOfForks3 = newIdx;\n        pushTreeFork(returnFiber, _numberOfForks3);\n      }\n\n      return resultingFirstChild;\n    } // Add all children to a key map for quick lookups.\n\n\n    var existingChildren = mapRemainingChildren(returnFiber, oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n\n    for (; !step.done; newIdx++, step = newChildren.next()) {\n      var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);\n\n      if (_newFiber4 !== null) {\n        if (shouldTrackSideEffects) {\n          if (_newFiber4.alternate !== null) {\n            // The new fiber is a work in progress, but if there exists a\n            // current, that means that we reused the fiber. We need to delete\n            // it from the child list so that we don't add it to the deletion\n            // list.\n            existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n          }\n        }\n\n        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n\n        if (previousNewFiber === null) {\n          resultingFirstChild = _newFiber4;\n        } else {\n          previousNewFiber.sibling = _newFiber4;\n        }\n\n        previousNewFiber = _newFiber4;\n      }\n    }\n\n    if (shouldTrackSideEffects) {\n      // Any existing children that weren't consumed above were deleted. We need\n      // to add them to the deletion list.\n      existingChildren.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    }\n\n    if (getIsHydrating()) {\n      var _numberOfForks4 = newIdx;\n      pushTreeFork(returnFiber, _numberOfForks4);\n    }\n\n    return resultingFirstChild;\n  }\n\n  function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n    // There's no need to check for keys on text nodes since we don't have a\n    // way to define them.\n    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n      // We already have an existing node so let's just update it and delete\n      // the rest.\n      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n      var existing = useFiber(currentFirstChild, textContent);\n      existing.return = returnFiber;\n      return existing;\n    } // The existing first child is not a text node so we need to create one\n    // and delete the existing ones.\n\n\n    deleteRemainingChildren(returnFiber, currentFirstChild);\n    var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  }\n\n  function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {\n    var key = element.key;\n    var child = currentFirstChild;\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        var elementType = element.type;\n\n        if (elementType === REACT_FRAGMENT_TYPE) {\n          if (child.tag === Fragment) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            var existing = useFiber(child, element.props.children);\n            existing.return = returnFiber;\n\n            {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n\n            return existing;\n          }\n        } else {\n          if (child.elementType === elementType || ( // Keep this check inline so it only runs on the false path:\n           isCompatibleFamilyForHotReloading(child, element) ) || // Lazy types should reconcile their resolved type.\n          // We need to do this after the Hot Reloading check above,\n          // because hot reloading has different semantics than prod because\n          // it doesn't resuspend. So we can't let the call below suspend.\n           typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n\n            var _existing = useFiber(child, element.props);\n\n            _existing.ref = coerceRef(returnFiber, child, element);\n            _existing.return = returnFiber;\n\n            {\n              _existing._debugSource = element._source;\n              _existing._debugOwner = element._owner;\n            }\n\n            return _existing;\n          }\n        } // Didn't match.\n\n\n        deleteRemainingChildren(returnFiber, child);\n        break;\n      } else {\n        deleteChild(returnFiber, child);\n      }\n\n      child = child.sibling;\n    }\n\n    if (element.type === REACT_FRAGMENT_TYPE) {\n      var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n      created.return = returnFiber;\n      return created;\n    } else {\n      var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\n\n      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);\n      _created4.return = returnFiber;\n      return _created4;\n    }\n  }\n\n  function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {\n    var key = portal.key;\n    var child = currentFirstChild;\n\n    while (child !== null) {\n      // TODO: If key === null and child.key === null, then this only applies to\n      // the first item in the list.\n      if (child.key === key) {\n        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n          deleteRemainingChildren(returnFiber, child.sibling);\n          var existing = useFiber(child, portal.children || []);\n          existing.return = returnFiber;\n          return existing;\n        } else {\n          deleteRemainingChildren(returnFiber, child);\n          break;\n        }\n      } else {\n        deleteChild(returnFiber, child);\n      }\n\n      child = child.sibling;\n    }\n\n    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n    created.return = returnFiber;\n    return created;\n  } // This API will tag the children with the side-effect of the reconciliation\n  // itself. They will be added to the side-effect list as we pass through the\n  // children and the parent.\n\n\n  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n    // This function is not recursive.\n    // If the top level item is an array, we treat it as a set of children,\n    // not as a fragment. Nested arrays on the other hand will be treated as\n    // fragment nodes. Recursion happens at the normal flow.\n    // Handle top level unkeyed fragments as if they were arrays.\n    // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n    // We treat the ambiguous cases above the same.\n    var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n\n    if (isUnkeyedTopLevelFragment) {\n      newChild = newChild.props.children;\n    } // Handle object types\n\n\n    if (typeof newChild === 'object' && newChild !== null) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_PORTAL_TYPE:\n          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n\n        case REACT_LAZY_TYPE:\n          {\n            var payload = newChild._payload;\n            var init = newChild._init; // TODO: This function is supposed to be non-recursive.\n\n            return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);\n          }\n\n      }\n\n      if (isArray(newChild)) {\n        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      if (getIteratorFn(newChild)) {\n        return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);\n      }\n\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n\n    if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number') {\n      return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));\n    }\n\n    {\n      if (typeof newChild === 'function') {\n        warnOnFunctionType(returnFiber);\n      }\n    } // Remaining cases are all treated as empty.\n\n\n    return deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n\n  return reconcileChildFibers;\n}\n\nvar reconcileChildFibers = ChildReconciler(true);\nvar mountChildFibers = ChildReconciler(false);\nfunction cloneChildFibers(current, workInProgress) {\n  if (current !== null && workInProgress.child !== current.child) {\n    throw new Error('Resuming work not yet implemented.');\n  }\n\n  if (workInProgress.child === null) {\n    return;\n  }\n\n  var currentChild = workInProgress.child;\n  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n  workInProgress.child = newChild;\n  newChild.return = workInProgress;\n\n  while (currentChild.sibling !== null) {\n    currentChild = currentChild.sibling;\n    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n    newChild.return = workInProgress;\n  }\n\n  newChild.sibling = null;\n} // Reset a workInProgress child set to prepare it for a second pass.\n\nfunction resetChildFibers(workInProgress, lanes) {\n  var child = workInProgress.child;\n\n  while (child !== null) {\n    resetWorkInProgress(child, lanes);\n    child = child.sibling;\n  }\n}\n\nvar NO_CONTEXT = {};\nvar contextStackCursor$1 = createCursor(NO_CONTEXT);\nvar contextFiberStackCursor = createCursor(NO_CONTEXT);\nvar rootInstanceStackCursor = createCursor(NO_CONTEXT);\n\nfunction requiredContext(c) {\n  if (c === NO_CONTEXT) {\n    throw new Error('Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n  }\n\n  return c;\n}\n\nfunction getRootHostContainer() {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  return rootInstance;\n}\n\nfunction pushHostContainer(fiber, nextRootInstance) {\n  // Push current root instance onto the stack;\n  // This allows us to reset root when portals are popped.\n  push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n\n  push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\n  // However, we can't just call getRootHostContext() and push it because\n  // we'd have a different number of entries on the stack depending on\n  // whether getRootHostContext() throws somewhere in renderer code or not.\n  // So we push an empty value first. This lets us safely unwind on errors.\n\n  push(contextStackCursor$1, NO_CONTEXT, fiber);\n  var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\n\n  pop(contextStackCursor$1, fiber);\n  push(contextStackCursor$1, nextRootContext, fiber);\n}\n\nfunction popHostContainer(fiber) {\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n  pop(rootInstanceStackCursor, fiber);\n}\n\nfunction getHostContext() {\n  var context = requiredContext(contextStackCursor$1.current);\n  return context;\n}\n\nfunction pushHostContext(fiber) {\n  var rootInstance = requiredContext(rootInstanceStackCursor.current);\n  var context = requiredContext(contextStackCursor$1.current);\n  var nextContext = getChildHostContext(context, fiber.type, rootInstance); // Don't push this Fiber's context unless it's unique.\n\n  if (context === nextContext) {\n    return;\n  } // Track the context and the Fiber that provided it.\n  // This enables us to pop only Fibers that provide unique contexts.\n\n\n  push(contextFiberStackCursor, fiber, fiber);\n  push(contextStackCursor$1, nextContext, fiber);\n}\n\nfunction popHostContext(fiber) {\n  // Do not pop unless this Fiber provided the current context.\n  // pushHostContext() only pushes Fibers that provide unique contexts.\n  if (contextFiberStackCursor.current !== fiber) {\n    return;\n  }\n\n  pop(contextStackCursor$1, fiber);\n  pop(contextFiberStackCursor, fiber);\n}\n\nvar DefaultSuspenseContext = 0; // The Suspense Context is split into two parts. The lower bits is\n// inherited deeply down the subtree. The upper bits only affect\n// this immediate suspense boundary and gets reset each new\n// boundary or suspense list.\n\nvar SubtreeSuspenseContextMask = 1; // Subtree Flags:\n// InvisibleParentSuspenseContext indicates that one of our parent Suspense\n// boundaries is not currently showing visible main content.\n// Either because it is already showing a fallback or is not mounted at all.\n// We can use this to determine if it is desirable to trigger a fallback at\n// the parent. If not, then we might need to trigger undesirable boundaries\n// and/or suspend the commit to avoid hiding the parent content.\n\nvar InvisibleParentSuspenseContext = 1; // Shallow Flags:\n// ForceSuspenseFallback can be used by SuspenseList to force newly added\n// items into their fallback state during one of the render passes.\n\nvar ForceSuspenseFallback = 2;\nvar suspenseStackCursor = createCursor(DefaultSuspenseContext);\nfunction hasSuspenseContext(parentContext, flag) {\n  return (parentContext & flag) !== 0;\n}\nfunction setDefaultShallowSuspenseContext(parentContext) {\n  return parentContext & SubtreeSuspenseContextMask;\n}\nfunction setShallowSuspenseContext(parentContext, shallowContext) {\n  return parentContext & SubtreeSuspenseContextMask | shallowContext;\n}\nfunction addSubtreeSuspenseContext(parentContext, subtreeContext) {\n  return parentContext | subtreeContext;\n}\nfunction pushSuspenseContext(fiber, newContext) {\n  push(suspenseStackCursor, newContext, fiber);\n}\nfunction popSuspenseContext(fiber) {\n  pop(suspenseStackCursor, fiber);\n}\n\nfunction shouldCaptureSuspense(workInProgress, hasInvisibleParent) {\n  // If it was the primary children that just suspended, capture and render the\n  // fallback. Otherwise, don't capture and bubble to the next boundary.\n  var nextState = workInProgress.memoizedState;\n\n  if (nextState !== null) {\n    if (nextState.dehydrated !== null) {\n      // A dehydrated boundary always captures.\n      return true;\n    }\n\n    return false;\n  }\n\n  var props = workInProgress.memoizedProps; // Regular boundaries always capture.\n\n  {\n    return true;\n  } // If it's a boundary we should avoid, then we prefer to bubble up to the\n}\nfunction findFirstSuspended(row) {\n  var node = row;\n\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      var state = node.memoizedState;\n\n      if (state !== null) {\n        var dehydrated = state.dehydrated;\n\n        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n          return node;\n        }\n      }\n    } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n    // keep track of whether it suspended or not.\n    node.memoizedProps.revealOrder !== undefined) {\n      var didSuspend = (node.flags & DidCapture) !== NoFlags;\n\n      if (didSuspend) {\n        return node;\n      }\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === row) {\n      return null;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === row) {\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n\n  return null;\n}\n\nvar NoFlags$1 =\n/*   */\n0; // Represents whether effect should fire.\n\nvar HasEffect =\n/* */\n1; // Represents the phase in which the effect (not the clean-up) fires.\n\nvar Insertion =\n/*  */\n2;\nvar Layout =\n/*    */\n4;\nvar Passive$1 =\n/*   */\n8;\n\n// and should be reset before starting a new render.\n// This tracks which mutable sources need to be reset after a render.\n\nvar workInProgressSources = [];\nfunction resetWorkInProgressVersions() {\n  for (var i = 0; i < workInProgressSources.length; i++) {\n    var mutableSource = workInProgressSources[i];\n\n    if (isPrimaryRenderer) {\n      mutableSource._workInProgressVersionPrimary = null;\n    } else {\n      mutableSource._workInProgressVersionSecondary = null;\n    }\n  }\n\n  workInProgressSources.length = 0;\n}\n// This ensures that the version used for server rendering matches the one\n// that is eventually read during hydration.\n// If they don't match there's a potential tear and a full deopt render is required.\n\nfunction registerMutableSourceForHydration(root, mutableSource) {\n  var getVersion = mutableSource._getVersion;\n  var version = getVersion(mutableSource._source); // TODO Clear this data once all pending hydration work is finished.\n  // Retaining it forever may interfere with GC.\n\n  if (root.mutableSourceEagerHydrationData == null) {\n    root.mutableSourceEagerHydrationData = [mutableSource, version];\n  } else {\n    root.mutableSourceEagerHydrationData.push(mutableSource, version);\n  }\n}\n\nvar ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher,\n    ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;\nvar didWarnAboutMismatchedHooksForComponent;\nvar didWarnUncachedGetSnapshot;\n\n{\n  didWarnAboutMismatchedHooksForComponent = new Set();\n}\n\n// These are set right before calling the component.\nvar renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from\n// the work-in-progress hook.\n\nvar currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n// current hook list is the list that belongs to the current fiber. The\n// work-in-progress hook list is a new list that will be added to the\n// work-in-progress fiber.\n\nvar currentHook = null;\nvar workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\n// does not get reset if we do another render pass; only when we're completely\n// finished evaluating this component. This is an optimization so we know\n// whether we need to clear render phase updates after a throw.\n\nvar didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This\n// gets reset after each attempt.\n// TODO: Maybe there's some way to consolidate this with\n// `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\n\nvar didScheduleRenderPhaseUpdateDuringThisPass = false; // Counts the number of useId hooks in this component.\n\nvar localIdCounter = 0; // Used for ids that are generated completely client-side (i.e. not during\n// hydration). This counter is global, so client ids are not stable across\n// render attempts.\n\nvar globalClientIdCounter = 0;\nvar RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n\nvar currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n// The list stores the order of hooks used during the initial render (mount).\n// Subsequent renders (updates) reference this list.\n\nvar hookTypesDev = null;\nvar hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n// the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n// When true, such Hooks will always be \"remounted\". Only used during hot reload.\n\nvar ignorePreviousDependencies = false;\n\nfunction mountHookTypesDev() {\n  {\n    var hookName = currentHookNameInDev;\n\n    if (hookTypesDev === null) {\n      hookTypesDev = [hookName];\n    } else {\n      hookTypesDev.push(hookName);\n    }\n  }\n}\n\nfunction updateHookTypesDev() {\n  {\n    var hookName = currentHookNameInDev;\n\n    if (hookTypesDev !== null) {\n      hookTypesUpdateIndexDev++;\n\n      if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n        warnOnHookMismatchInDev(hookName);\n      }\n    }\n  }\n}\n\nfunction checkDepsAreArrayDev(deps) {\n  {\n    if (deps !== undefined && deps !== null && !isArray(deps)) {\n      // Verify deps, but only on mount to avoid extra checks.\n      // It's unlikely their type would change as usually you define them inline.\n      error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);\n    }\n  }\n}\n\nfunction warnOnHookMismatchInDev(currentHookName) {\n  {\n    var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n\n    if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n      didWarnAboutMismatchedHooksForComponent.add(componentName);\n\n      if (hookTypesDev !== null) {\n        var table = '';\n        var secondColumnStart = 30;\n\n        for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {\n          var oldHookName = hookTypesDev[i];\n          var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n          var row = i + 1 + \". \" + oldHookName; // Extra space so second column lines up\n          // lol @ IE not supporting String#repeat\n\n          while (row.length < secondColumnStart) {\n            row += ' ';\n          }\n\n          row += newHookName + '\\n';\n          table += row;\n        }\n\n        error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\\n\\n' + '   Previous render            Next render\\n' + '   ------------------------------------------------------\\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n', componentName, table);\n      }\n    }\n  }\n}\n\nfunction throwInvalidHookError() {\n  throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.');\n}\n\nfunction areHookInputsEqual(nextDeps, prevDeps) {\n  {\n    if (ignorePreviousDependencies) {\n      // Only true when this component is being hot reloaded.\n      return false;\n    }\n  }\n\n  if (prevDeps === null) {\n    {\n      error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);\n    }\n\n    return false;\n  }\n\n  {\n    // Don't bother comparing lengths in prod because these arrays should be\n    // passed inline.\n    if (nextDeps.length !== prevDeps.length) {\n      error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\\n\\n' + 'Previous: %s\\n' + 'Incoming: %s', currentHookNameInDev, \"[\" + prevDeps.join(', ') + \"]\", \"[\" + nextDeps.join(', ') + \"]\");\n    }\n  }\n\n  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {\n    if (objectIs(nextDeps[i], prevDeps[i])) {\n      continue;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nfunction renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n  renderLanes = nextRenderLanes;\n  currentlyRenderingFiber$1 = workInProgress;\n\n  {\n    hookTypesDev = current !== null ? current._debugHookTypes : null;\n    hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n\n    ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n  }\n\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.lanes = NoLanes; // The following should have already been reset\n  // currentHook = null;\n  // workInProgressHook = null;\n  // didScheduleRenderPhaseUpdate = false;\n  // localIdCounter = 0;\n  // TODO Warn if no hooks are used at all during mount, then some are used during update.\n  // Currently we will identify the update render as a mount because memoizedState === null.\n  // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n  // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n  // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n  // so memoizedState would be null during updates and mounts.\n\n  {\n    if (current !== null && current.memoizedState !== null) {\n      ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;\n    } else if (hookTypesDev !== null) {\n      // This dispatcher handles an edge case where a component is updating,\n      // but no stateful hooks have been used.\n      // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n      // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n      // This dispatcher does that.\n      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;\n    } else {\n      ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;\n    }\n  }\n\n  var children = Component(props, secondArg); // Check if there was a render phase update\n\n  if (didScheduleRenderPhaseUpdateDuringThisPass) {\n    // Keep rendering in a loop for as long as render phase updates continue to\n    // be scheduled. Use a counter to prevent infinite loops.\n    var numberOfReRenders = 0;\n\n    do {\n      didScheduleRenderPhaseUpdateDuringThisPass = false;\n      localIdCounter = 0;\n\n      if (numberOfReRenders >= RE_RENDER_LIMIT) {\n        throw new Error('Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');\n      }\n\n      numberOfReRenders += 1;\n\n      {\n        // Even when hot reloading, allow dependencies to stabilize\n        // after first render to prevent infinite render phase updates.\n        ignorePreviousDependencies = false;\n      } // Start over from the beginning of the list\n\n\n      currentHook = null;\n      workInProgressHook = null;\n      workInProgress.updateQueue = null;\n\n      {\n        // Also validate hook order for cascading updates.\n        hookTypesUpdateIndexDev = -1;\n      }\n\n      ReactCurrentDispatcher$1.current =  HooksDispatcherOnRerenderInDEV ;\n      children = Component(props, secondArg);\n    } while (didScheduleRenderPhaseUpdateDuringThisPass);\n  } // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n\n\n  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n\n  {\n    workInProgress._debugHookTypes = hookTypesDev;\n  } // This check uses currentHook so that it works the same in DEV and prod bundles.\n  // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n\n\n  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n  renderLanes = NoLanes;\n  currentlyRenderingFiber$1 = null;\n  currentHook = null;\n  workInProgressHook = null;\n\n  {\n    currentHookNameInDev = null;\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last\n    // render. If this fires, it suggests that we incorrectly reset the static\n    // flags in some other part of the codebase. This has happened before, for\n    // example, in the SuspenseList implementation.\n\n    if (current !== null && (current.flags & StaticMask) !== (workInProgress.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird\n    // and creates false positives. To make this work in legacy mode, we'd\n    // need to mark fibers that commit in an incomplete state, somehow. For\n    // now I'll disable the warning that most of the bugs that would trigger\n    // it are either exclusive to concurrent mode or exist in both.\n    (current.mode & ConcurrentMode) !== NoMode) {\n      error('Internal React error: Expected static flag was missing. Please ' + 'notify the React team.');\n    }\n  }\n\n  didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook\n  // localIdCounter = 0;\n\n  if (didRenderTooFewHooks) {\n    throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');\n  }\n\n  return children;\n}\nfunction checkDidRenderIdHook() {\n  // This should be called immediately after every renderWithHooks call.\n  // Conceptually, it's part of the return value of renderWithHooks; it's only a\n  // separate function to avoid using an array tuple.\n  var didRenderIdHook = localIdCounter !== 0;\n  localIdCounter = 0;\n  return didRenderIdHook;\n}\nfunction bailoutHooks(current, workInProgress, lanes) {\n  workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the\n  // complete phase (bubbleProperties).\n\n  if ( (workInProgress.mode & StrictEffectsMode) !== NoMode) {\n    workInProgress.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);\n  } else {\n    workInProgress.flags &= ~(Passive | Update);\n  }\n\n  current.lanes = removeLanes(current.lanes, lanes);\n}\nfunction resetHooksAfterThrow() {\n  // We can assume the previous dispatcher is always this one, since we set it\n  // at the beginning of the render phase and there's no re-entrance.\n  ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;\n\n  if (didScheduleRenderPhaseUpdate) {\n    // There were render phase updates. These are only valid for this render\n    // phase, which we are now aborting. Remove the updates from the queues so\n    // they do not persist to the next render. Do not remove updates from hooks\n    // that weren't processed.\n    //\n    // Only reset the updates from the queue if it has a clone. If it does\n    // not have a clone, that means it wasn't processed, and the updates were\n    // scheduled before we entered the render phase.\n    var hook = currentlyRenderingFiber$1.memoizedState;\n\n    while (hook !== null) {\n      var queue = hook.queue;\n\n      if (queue !== null) {\n        queue.pending = null;\n      }\n\n      hook = hook.next;\n    }\n\n    didScheduleRenderPhaseUpdate = false;\n  }\n\n  renderLanes = NoLanes;\n  currentlyRenderingFiber$1 = null;\n  currentHook = null;\n  workInProgressHook = null;\n\n  {\n    hookTypesDev = null;\n    hookTypesUpdateIndexDev = -1;\n    currentHookNameInDev = null;\n    isUpdatingOpaqueValueInRenderPhase = false;\n  }\n\n  didScheduleRenderPhaseUpdateDuringThisPass = false;\n  localIdCounter = 0;\n}\n\nfunction mountWorkInProgressHook() {\n  var hook = {\n    memoizedState: null,\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n    next: null\n  };\n\n  if (workInProgressHook === null) {\n    // This is the first hook in the list\n    currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;\n  } else {\n    // Append to the end of the list\n    workInProgressHook = workInProgressHook.next = hook;\n  }\n\n  return workInProgressHook;\n}\n\nfunction updateWorkInProgressHook() {\n  // This function is used both for updates and for re-renders triggered by a\n  // render phase update. It assumes there is either a current hook we can\n  // clone, or a work-in-progress hook from a previous render pass that we can\n  // use as a base. When we reach the end of the base list, we must switch to\n  // the dispatcher used for mounts.\n  var nextCurrentHook;\n\n  if (currentHook === null) {\n    var current = currentlyRenderingFiber$1.alternate;\n\n    if (current !== null) {\n      nextCurrentHook = current.memoizedState;\n    } else {\n      nextCurrentHook = null;\n    }\n  } else {\n    nextCurrentHook = currentHook.next;\n  }\n\n  var nextWorkInProgressHook;\n\n  if (workInProgressHook === null) {\n    nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;\n  } else {\n    nextWorkInProgressHook = workInProgressHook.next;\n  }\n\n  if (nextWorkInProgressHook !== null) {\n    // There's already a work-in-progress. Reuse it.\n    workInProgressHook = nextWorkInProgressHook;\n    nextWorkInProgressHook = workInProgressHook.next;\n    currentHook = nextCurrentHook;\n  } else {\n    // Clone from the current hook.\n    if (nextCurrentHook === null) {\n      throw new Error('Rendered more hooks than during the previous render.');\n    }\n\n    currentHook = nextCurrentHook;\n    var newHook = {\n      memoizedState: currentHook.memoizedState,\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n      next: null\n    };\n\n    if (workInProgressHook === null) {\n      // This is the first hook in the list.\n      currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;\n    } else {\n      // Append to the end of the list.\n      workInProgressHook = workInProgressHook.next = newHook;\n    }\n  }\n\n  return workInProgressHook;\n}\n\nfunction createFunctionComponentUpdateQueue() {\n  return {\n    lastEffect: null,\n    stores: null\n  };\n}\n\nfunction basicStateReducer(state, action) {\n  // $FlowFixMe: Flow doesn't like mixed types\n  return typeof action === 'function' ? action(state) : action;\n}\n\nfunction mountReducer(reducer, initialArg, init) {\n  var hook = mountWorkInProgressHook();\n  var initialState;\n\n  if (init !== undefined) {\n    initialState = init(initialArg);\n  } else {\n    initialState = initialArg;\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  var queue = {\n    pending: null,\n    interleaved: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: reducer,\n    lastRenderedState: initialState\n  };\n  hook.queue = queue;\n  var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateReducer(reducer, initialArg, init) {\n  var hook = updateWorkInProgressHook();\n  var queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n  }\n\n  queue.lastRenderedReducer = reducer;\n  var current = currentHook; // The last rebase update that is NOT part of the base state.\n\n  var baseQueue = current.baseQueue; // The last pending update that hasn't been processed yet.\n\n  var pendingQueue = queue.pending;\n\n  if (pendingQueue !== null) {\n    // We have new updates that haven't been processed yet.\n    // We'll add them to the base queue.\n    if (baseQueue !== null) {\n      // Merge the pending queue and the base queue.\n      var baseFirst = baseQueue.next;\n      var pendingFirst = pendingQueue.next;\n      baseQueue.next = pendingFirst;\n      pendingQueue.next = baseFirst;\n    }\n\n    {\n      if (current.baseQueue !== baseQueue) {\n        // Internal invariant that should never happen, but feasibly could in\n        // the future if we implement resuming, or some form of that.\n        error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');\n      }\n    }\n\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n\n  if (baseQueue !== null) {\n    // We have a queue to process.\n    var first = baseQueue.next;\n    var newState = current.baseState;\n    var newBaseState = null;\n    var newBaseQueueFirst = null;\n    var newBaseQueueLast = null;\n    var update = first;\n\n    do {\n      var updateLane = update.lane;\n\n      if (!isSubsetOfLanes(renderLanes, updateLane)) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        var clone = {\n          lane: updateLane,\n          action: update.action,\n          hasEagerState: update.hasEagerState,\n          eagerState: update.eagerState,\n          next: null\n        };\n\n        if (newBaseQueueLast === null) {\n          newBaseQueueFirst = newBaseQueueLast = clone;\n          newBaseState = newState;\n        } else {\n          newBaseQueueLast = newBaseQueueLast.next = clone;\n        } // Update the remaining priority in the queue.\n        // TODO: Don't need to accumulate this. Instead, we can remove\n        // renderLanes from the original lanes.\n\n\n        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);\n        markSkippedUpdateLanes(updateLane);\n      } else {\n        // This update does have sufficient priority.\n        if (newBaseQueueLast !== null) {\n          var _clone = {\n            // This update is going to be committed so we never want uncommit\n            // it. Using NoLane works because 0 is a subset of all bitmasks, so\n            // this will never be skipped by the check above.\n            lane: NoLane,\n            action: update.action,\n            hasEagerState: update.hasEagerState,\n            eagerState: update.eagerState,\n            next: null\n          };\n          newBaseQueueLast = newBaseQueueLast.next = _clone;\n        } // Process this update.\n\n\n        if (update.hasEagerState) {\n          // If this update is a state update (not a reducer) and was processed eagerly,\n          // we can use the eagerly computed state\n          newState = update.eagerState;\n        } else {\n          var action = update.action;\n          newState = reducer(newState, action);\n        }\n      }\n\n      update = update.next;\n    } while (update !== null && update !== first);\n\n    if (newBaseQueueLast === null) {\n      newBaseState = newState;\n    } else {\n      newBaseQueueLast.next = newBaseQueueFirst;\n    } // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n\n\n    if (!objectIs(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState;\n    hook.baseState = newBaseState;\n    hook.baseQueue = newBaseQueueLast;\n    queue.lastRenderedState = newState;\n  } // Interleaved updates are stored on a separate queue. We aren't going to\n  // process them during this render, but we do need to track which lanes\n  // are remaining.\n\n\n  var lastInterleaved = queue.interleaved;\n\n  if (lastInterleaved !== null) {\n    var interleaved = lastInterleaved;\n\n    do {\n      var interleavedLane = interleaved.lane;\n      currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);\n      markSkippedUpdateLanes(interleavedLane);\n      interleaved = interleaved.next;\n    } while (interleaved !== lastInterleaved);\n  } else if (baseQueue === null) {\n    // `queue.lanes` is used for entangling transitions. We can set it back to\n    // zero once the queue is empty.\n    queue.lanes = NoLanes;\n  }\n\n  var dispatch = queue.dispatch;\n  return [hook.memoizedState, dispatch];\n}\n\nfunction rerenderReducer(reducer, initialArg, init) {\n  var hook = updateWorkInProgressHook();\n  var queue = hook.queue;\n\n  if (queue === null) {\n    throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n  }\n\n  queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\n  // work-in-progress hook.\n\n  var dispatch = queue.dispatch;\n  var lastRenderPhaseUpdate = queue.pending;\n  var newState = hook.memoizedState;\n\n  if (lastRenderPhaseUpdate !== null) {\n    // The queue doesn't persist past this render pass.\n    queue.pending = null;\n    var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n    var update = firstRenderPhaseUpdate;\n\n    do {\n      // Process this render phase update. We don't have to check the\n      // priority because it will always be the same as the current\n      // render's.\n      var action = update.action;\n      newState = reducer(newState, action);\n      update = update.next;\n    } while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\n    // different from the current state.\n\n\n    if (!objectIs(newState, hook.memoizedState)) {\n      markWorkInProgressReceivedUpdate();\n    }\n\n    hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n    // the base state unless the queue is empty.\n    // TODO: Not sure if this is the desired semantics, but it's what we\n    // do for gDSFP. I can't remember why.\n\n    if (hook.baseQueue === null) {\n      hook.baseState = newState;\n    }\n\n    queue.lastRenderedState = newState;\n  }\n\n  return [newState, dispatch];\n}\n\nfunction mountMutableSource(source, getSnapshot, subscribe) {\n  {\n    return undefined;\n  }\n}\n\nfunction updateMutableSource(source, getSnapshot, subscribe) {\n  {\n    return undefined;\n  }\n}\n\nfunction mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  var fiber = currentlyRenderingFiber$1;\n  var hook = mountWorkInProgressHook();\n  var nextSnapshot;\n  var isHydrating = getIsHydrating();\n\n  if (isHydrating) {\n    if (getServerSnapshot === undefined) {\n      throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');\n    }\n\n    nextSnapshot = getServerSnapshot();\n\n    {\n      if (!didWarnUncachedGetSnapshot) {\n        if (nextSnapshot !== getServerSnapshot()) {\n          error('The result of getServerSnapshot should be cached to avoid an infinite loop');\n\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    }\n  } else {\n    nextSnapshot = getSnapshot();\n\n    {\n      if (!didWarnUncachedGetSnapshot) {\n        var cachedSnapshot = getSnapshot();\n\n        if (!objectIs(nextSnapshot, cachedSnapshot)) {\n          error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n          didWarnUncachedGetSnapshot = true;\n        }\n      }\n    } // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n    //\n    // We won't do this if we're hydrating server-rendered content, because if\n    // the content is stale, it's already visible anyway. Instead we'll patch\n    // it up in a passive effect.\n\n\n    var root = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  } // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n\n\n  hook.memoizedState = nextSnapshot;\n  var inst = {\n    value: nextSnapshot,\n    getSnapshot: getSnapshot\n  };\n  hook.queue = inst; // Schedule an effect to subscribe to the store.\n\n  mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]); // Schedule an effect to update the mutable instance fields. We will update\n  // this whenever subscribe, getSnapshot, or value changes. Because there's no\n  // clean-up function, and we track the deps correctly, we can call pushEffect\n  // directly, without storing any additional state. For the same reason, we\n  // don't need to set a static flag, either.\n  // TODO: We can move this to the passive phase once we add a pre-commit\n  // consistency check. See the next comment.\n\n  fiber.flags |= Passive;\n  pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);\n  return nextSnapshot;\n}\n\nfunction updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  var fiber = currentlyRenderingFiber$1;\n  var hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the\n  // normal rules of React, and only works because store updates are\n  // always synchronous.\n\n  var nextSnapshot = getSnapshot();\n\n  {\n    if (!didWarnUncachedGetSnapshot) {\n      var cachedSnapshot = getSnapshot();\n\n      if (!objectIs(nextSnapshot, cachedSnapshot)) {\n        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n        didWarnUncachedGetSnapshot = true;\n      }\n    }\n  }\n\n  var prevSnapshot = hook.memoizedState;\n  var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);\n\n  if (snapshotChanged) {\n    hook.memoizedState = nextSnapshot;\n    markWorkInProgressReceivedUpdate();\n  }\n\n  var inst = hook.queue;\n  updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]); // Whenever getSnapshot or subscribe changes, we need to check in the\n  // commit phase if there was an interleaved mutation. In concurrent mode\n  // this can happen all the time, but even in synchronous mode, an earlier\n  // effect may have mutated the store.\n\n  if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by\n  // checking whether we scheduled a subscription effect above.\n  workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {\n    fiber.flags |= Passive;\n    pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null); // Unless we're rendering a blocking lane, schedule a consistency check.\n    // Right before committing, we will walk the tree and check if any of the\n    // stores were mutated.\n\n    var root = getWorkInProgressRoot();\n\n    if (root === null) {\n      throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n    }\n\n    if (!includesBlockingLane(root, renderLanes)) {\n      pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n    }\n  }\n\n  return nextSnapshot;\n}\n\nfunction pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n  fiber.flags |= StoreConsistency;\n  var check = {\n    getSnapshot: getSnapshot,\n    value: renderedSnapshot\n  };\n  var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n    componentUpdateQueue.stores = [check];\n  } else {\n    var stores = componentUpdateQueue.stores;\n\n    if (stores === null) {\n      componentUpdateQueue.stores = [check];\n    } else {\n      stores.push(check);\n    }\n  }\n}\n\nfunction updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n  // These are updated in the passive phase\n  inst.value = nextSnapshot;\n  inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could\n  // have been in an event that fired before the passive effects, or it could\n  // have been in a layout effect. In that case, we would have used the old\n  // snapsho and getSnapshot values to bail out. We need to check one more time.\n\n  if (checkIfSnapshotChanged(inst)) {\n    // Force a re-render.\n    forceStoreRerender(fiber);\n  }\n}\n\nfunction subscribeToStore(fiber, inst, subscribe) {\n  var handleStoreChange = function () {\n    // The store changed. Check if the snapshot changed since the last time we\n    // read from the store.\n    if (checkIfSnapshotChanged(inst)) {\n      // Force a re-render.\n      forceStoreRerender(fiber);\n    }\n  }; // Subscribe to the store and return a clean-up function.\n\n\n  return subscribe(handleStoreChange);\n}\n\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  var prevValue = inst.value;\n\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(prevValue, nextValue);\n  } catch (error) {\n    return true;\n  }\n}\n\nfunction forceStoreRerender(fiber) {\n  scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n}\n\nfunction mountState(initialState) {\n  var hook = mountWorkInProgressHook();\n\n  if (typeof initialState === 'function') {\n    // $FlowFixMe: Flow doesn't like mixed types\n    initialState = initialState();\n  }\n\n  hook.memoizedState = hook.baseState = initialState;\n  var queue = {\n    pending: null,\n    interleaved: null,\n    lanes: NoLanes,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: initialState\n  };\n  hook.queue = queue;\n  var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n  return [hook.memoizedState, dispatch];\n}\n\nfunction updateState(initialState) {\n  return updateReducer(basicStateReducer);\n}\n\nfunction rerenderState(initialState) {\n  return rerenderReducer(basicStateReducer);\n}\n\nfunction pushEffect(tag, create, destroy, deps) {\n  var effect = {\n    tag: tag,\n    create: create,\n    destroy: destroy,\n    deps: deps,\n    // Circular\n    next: null\n  };\n  var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n\n  if (componentUpdateQueue === null) {\n    componentUpdateQueue = createFunctionComponentUpdateQueue();\n    currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n    componentUpdateQueue.lastEffect = effect.next = effect;\n  } else {\n    var lastEffect = componentUpdateQueue.lastEffect;\n\n    if (lastEffect === null) {\n      componentUpdateQueue.lastEffect = effect.next = effect;\n    } else {\n      var firstEffect = lastEffect.next;\n      lastEffect.next = effect;\n      effect.next = firstEffect;\n      componentUpdateQueue.lastEffect = effect;\n    }\n  }\n\n  return effect;\n}\n\nfunction mountRef(initialValue) {\n  var hook = mountWorkInProgressHook();\n\n  {\n    var _ref2 = {\n      current: initialValue\n    };\n    hook.memoizedState = _ref2;\n    return _ref2;\n  }\n}\n\nfunction updateRef(initialValue) {\n  var hook = updateWorkInProgressHook();\n  return hook.memoizedState;\n}\n\nfunction mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n  var hook = mountWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  currentlyRenderingFiber$1.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);\n}\n\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n  var hook = updateWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  var destroy = undefined;\n\n  if (currentHook !== null) {\n    var prevEffect = currentHook.memoizedState;\n    destroy = prevEffect.destroy;\n\n    if (nextDeps !== null) {\n      var prevDeps = prevEffect.deps;\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);\n        return;\n      }\n    }\n  }\n\n  currentlyRenderingFiber$1.flags |= fiberFlags;\n  hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);\n}\n\nfunction mountEffect(create, deps) {\n  if ( (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n    return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);\n  } else {\n    return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);\n  }\n}\n\nfunction updateEffect(create, deps) {\n  return updateEffectImpl(Passive, Passive$1, create, deps);\n}\n\nfunction mountInsertionEffect(create, deps) {\n  return mountEffectImpl(Update, Insertion, create, deps);\n}\n\nfunction updateInsertionEffect(create, deps) {\n  return updateEffectImpl(Update, Insertion, create, deps);\n}\n\nfunction mountLayoutEffect(create, deps) {\n  var fiberFlags = Update;\n\n  {\n    fiberFlags |= LayoutStatic;\n  }\n\n  if ( (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n    fiberFlags |= MountLayoutDev;\n  }\n\n  return mountEffectImpl(fiberFlags, Layout, create, deps);\n}\n\nfunction updateLayoutEffect(create, deps) {\n  return updateEffectImpl(Update, Layout, create, deps);\n}\n\nfunction imperativeHandleEffect(create, ref) {\n  if (typeof ref === 'function') {\n    var refCallback = ref;\n\n    var _inst = create();\n\n    refCallback(_inst);\n    return function () {\n      refCallback(null);\n    };\n  } else if (ref !== null && ref !== undefined) {\n    var refObject = ref;\n\n    {\n      if (!refObject.hasOwnProperty('current')) {\n        error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');\n      }\n    }\n\n    var _inst2 = create();\n\n    refObject.current = _inst2;\n    return function () {\n      refObject.current = null;\n    };\n  }\n}\n\nfunction mountImperativeHandle(ref, create, deps) {\n  {\n    if (typeof create !== 'function') {\n      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n    }\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  var fiberFlags = Update;\n\n  {\n    fiberFlags |= LayoutStatic;\n  }\n\n  if ( (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n    fiberFlags |= MountLayoutDev;\n  }\n\n  return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction updateImperativeHandle(ref, create, deps) {\n  {\n    if (typeof create !== 'function') {\n      error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n    }\n  } // TODO: If deps are provided, should we skip comparing the ref itself?\n\n\n  var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;\n  return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n}\n\nfunction mountDebugValue(value, formatterFn) {// This hook is normally a no-op.\n  // The react-debug-hooks package injects its own implementation\n  // so that e.g. DevTools can display custom hook values.\n}\n\nvar updateDebugValue = mountDebugValue;\n\nfunction mountCallback(callback, deps) {\n  var hook = mountWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction updateCallback(callback, deps) {\n  var hook = updateWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  var prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      var prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}\n\nfunction mountMemo(nextCreate, deps) {\n  var hook = mountWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  var nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction updateMemo(nextCreate, deps) {\n  var hook = updateWorkInProgressHook();\n  var nextDeps = deps === undefined ? null : deps;\n  var prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    // Assume these are defined. If they're not, areHookInputsEqual will warn.\n    if (nextDeps !== null) {\n      var prevDeps = prevState[1];\n\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  var nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n  return nextValue;\n}\n\nfunction mountDeferredValue(value) {\n  var _mountState = mountState(value),\n      prevValue = _mountState[0],\n      setValue = _mountState[1];\n\n  mountEffect(function () {\n    var prevTransition = ReactCurrentBatchConfig$1.transition;\n    ReactCurrentBatchConfig$1.transition = {};\n\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig$1.transition = prevTransition;\n    }\n  }, [value]);\n  return prevValue;\n}\n\nfunction updateDeferredValue(value) {\n  var _updateState = updateState(),\n      prevValue = _updateState[0],\n      setValue = _updateState[1];\n\n  updateEffect(function () {\n    var prevTransition = ReactCurrentBatchConfig$1.transition;\n    ReactCurrentBatchConfig$1.transition = {};\n\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig$1.transition = prevTransition;\n    }\n  }, [value]);\n  return prevValue;\n}\n\nfunction rerenderDeferredValue(value) {\n  var _rerenderState = rerenderState(),\n      prevValue = _rerenderState[0],\n      setValue = _rerenderState[1];\n\n  updateEffect(function () {\n    var prevTransition = ReactCurrentBatchConfig$1.transition;\n    ReactCurrentBatchConfig$1.transition = {};\n\n    try {\n      setValue(value);\n    } finally {\n      ReactCurrentBatchConfig$1.transition = prevTransition;\n    }\n  }, [value]);\n  return prevValue;\n}\n\nfunction startTransition(setPending, callback, options) {\n  var previousPriority = getCurrentUpdatePriority();\n  setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n  setPending(true);\n  var prevTransition = ReactCurrentBatchConfig$1.transition;\n  ReactCurrentBatchConfig$1.transition = {};\n  var currentTransition = ReactCurrentBatchConfig$1.transition;\n\n  {\n    ReactCurrentBatchConfig$1.transition._updatedFibers = new Set();\n  }\n\n  try {\n    setPending(false);\n    callback();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$1.transition = prevTransition;\n\n    {\n      if (prevTransition === null && currentTransition._updatedFibers) {\n        var updatedFibersCount = currentTransition._updatedFibers.size;\n\n        if (updatedFibersCount > 10) {\n          warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n        }\n\n        currentTransition._updatedFibers.clear();\n      }\n    }\n  }\n}\n\nfunction mountTransition() {\n  var _mountState2 = mountState(false),\n      isPending = _mountState2[0],\n      setPending = _mountState2[1]; // The `start` method never changes.\n\n\n  var start = startTransition.bind(null, setPending);\n  var hook = mountWorkInProgressHook();\n  hook.memoizedState = start;\n  return [isPending, start];\n}\n\nfunction updateTransition() {\n  var _updateState2 = updateState(),\n      isPending = _updateState2[0];\n\n  var hook = updateWorkInProgressHook();\n  var start = hook.memoizedState;\n  return [isPending, start];\n}\n\nfunction rerenderTransition() {\n  var _rerenderState2 = rerenderState(),\n      isPending = _rerenderState2[0];\n\n  var hook = updateWorkInProgressHook();\n  var start = hook.memoizedState;\n  return [isPending, start];\n}\n\nvar isUpdatingOpaqueValueInRenderPhase = false;\nfunction getIsUpdatingOpaqueValueInRenderPhaseInDEV() {\n  {\n    return isUpdatingOpaqueValueInRenderPhase;\n  }\n}\n\nfunction mountId() {\n  var hook = mountWorkInProgressHook();\n  var root = getWorkInProgressRoot(); // TODO: In Fizz, id generation is specific to each server config. Maybe we\n  // should do this in Fiber, too? Deferring this decision for now because\n  // there's no other place to store the prefix except for an internal field on\n  // the public createRoot object, which the fiber tree does not currently have\n  // a reference to.\n\n  var identifierPrefix = root.identifierPrefix;\n  var id;\n\n  if (getIsHydrating()) {\n    var treeId = getTreeId(); // Use a captial R prefix for server-generated ids.\n\n    id = ':' + identifierPrefix + 'R' + treeId; // Unless this is the first id at this level, append a number at the end\n    // that represents the position of this useId hook among all the useId\n    // hooks for this fiber.\n\n    var localId = localIdCounter++;\n\n    if (localId > 0) {\n      id += 'H' + localId.toString(32);\n    }\n\n    id += ':';\n  } else {\n    // Use a lowercase r prefix for client-generated ids.\n    var globalClientId = globalClientIdCounter++;\n    id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':';\n  }\n\n  hook.memoizedState = id;\n  return id;\n}\n\nfunction updateId() {\n  var hook = updateWorkInProgressHook();\n  var id = hook.memoizedState;\n  return id;\n}\n\nfunction dispatchReducerAction(fiber, queue, action) {\n  {\n    if (typeof arguments[3] === 'function') {\n      error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n    }\n  }\n\n  var lane = requestUpdateLane(fiber);\n  var update = {\n    lane: lane,\n    action: action,\n    hasEagerState: false,\n    eagerState: null,\n    next: null\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    enqueueUpdate$1(fiber, queue, update);\n    var eventTime = requestEventTime();\n    var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane);\n}\n\nfunction dispatchSetState(fiber, queue, action) {\n  {\n    if (typeof arguments[3] === 'function') {\n      error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n    }\n  }\n\n  var lane = requestUpdateLane(fiber);\n  var update = {\n    lane: lane,\n    action: action,\n    hasEagerState: false,\n    eagerState: null,\n    next: null\n  };\n\n  if (isRenderPhaseUpdate(fiber)) {\n    enqueueRenderPhaseUpdate(queue, update);\n  } else {\n    enqueueUpdate$1(fiber, queue, update);\n    var alternate = fiber.alternate;\n\n    if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n      // The queue is currently empty, which means we can eagerly compute the\n      // next state before entering the render phase. If the new state is the\n      // same as the current state, we may be able to bail out entirely.\n      var lastRenderedReducer = queue.lastRenderedReducer;\n\n      if (lastRenderedReducer !== null) {\n        var prevDispatcher;\n\n        {\n          prevDispatcher = ReactCurrentDispatcher$1.current;\n          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n        }\n\n        try {\n          var currentState = queue.lastRenderedState;\n          var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n          // it, on the update object. If the reducer hasn't changed by the\n          // time we enter the render phase, then the eager state can be used\n          // without calling the reducer again.\n\n          update.hasEagerState = true;\n          update.eagerState = eagerState;\n\n          if (objectIs(eagerState, currentState)) {\n            // Fast path. We can bail out without scheduling React to re-render.\n            // It's still possible that we'll need to rebase this update later,\n            // if the component re-renders for a different reason and by that\n            // time the reducer has changed.\n            return;\n          }\n        } catch (error) {// Suppress the error. It will throw again in the render phase.\n        } finally {\n          {\n            ReactCurrentDispatcher$1.current = prevDispatcher;\n          }\n        }\n      }\n    }\n\n    var eventTime = requestEventTime();\n    var root = scheduleUpdateOnFiber(fiber, lane, eventTime);\n\n    if (root !== null) {\n      entangleTransitionUpdate(root, queue, lane);\n    }\n  }\n\n  markUpdateInDevTools(fiber, lane);\n}\n\nfunction isRenderPhaseUpdate(fiber) {\n  var alternate = fiber.alternate;\n  return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;\n}\n\nfunction enqueueRenderPhaseUpdate(queue, update) {\n  // This is a render phase update. Stash it in a lazily-created map of\n  // queue -> linked list of updates. After this render pass, we'll restart\n  // and apply the stashed updates on top of the work-in-progress hook.\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n  var pending = queue.pending;\n\n  if (pending === null) {\n    // This is the first update. Create a circular list.\n    update.next = update;\n  } else {\n    update.next = pending.next;\n    pending.next = update;\n  }\n\n  queue.pending = update;\n}\n\nfunction enqueueUpdate$1(fiber, queue, update, lane) {\n  if (isInterleavedUpdate(fiber)) {\n    var interleaved = queue.interleaved;\n\n    if (interleaved === null) {\n      // This is the first update. Create a circular list.\n      update.next = update; // At the end of the current render, this queue's interleaved updates will\n      // be transferred to the pending queue.\n\n      pushInterleavedQueue(queue);\n    } else {\n      update.next = interleaved.next;\n      interleaved.next = update;\n    }\n\n    queue.interleaved = update;\n  } else {\n    var pending = queue.pending;\n\n    if (pending === null) {\n      // This is the first update. Create a circular list.\n      update.next = update;\n    } else {\n      update.next = pending.next;\n      pending.next = update;\n    }\n\n    queue.pending = update;\n  }\n}\n\nfunction entangleTransitionUpdate(root, queue, lane) {\n  if (isTransitionLane(lane)) {\n    var queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they\n    // must have finished. We can remove them from the shared queue, which\n    // represents a superset of the actually pending lanes. In some cases we\n    // may entangle more than we need to, but that's OK. In fact it's worse if\n    // we *don't* entangle when we should.\n\n    queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n\n    var newQueueLanes = mergeLanes(queueLanes, lane);\n    queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n    // the lane finished since the last time we entangled it. So we need to\n    // entangle it again, just to be sure.\n\n    markRootEntangled(root, newQueueLanes);\n  }\n}\n\nfunction markUpdateInDevTools(fiber, lane, action) {\n\n  {\n    markStateUpdateScheduled(fiber, lane);\n  }\n}\n\nvar ContextOnlyDispatcher = {\n  readContext: readContext,\n  useCallback: throwInvalidHookError,\n  useContext: throwInvalidHookError,\n  useEffect: throwInvalidHookError,\n  useImperativeHandle: throwInvalidHookError,\n  useInsertionEffect: throwInvalidHookError,\n  useLayoutEffect: throwInvalidHookError,\n  useMemo: throwInvalidHookError,\n  useReducer: throwInvalidHookError,\n  useRef: throwInvalidHookError,\n  useState: throwInvalidHookError,\n  useDebugValue: throwInvalidHookError,\n  useDeferredValue: throwInvalidHookError,\n  useTransition: throwInvalidHookError,\n  useMutableSource: throwInvalidHookError,\n  useSyncExternalStore: throwInvalidHookError,\n  useId: throwInvalidHookError,\n  unstable_isNewReconciler: enableNewReconciler\n};\n\nvar HooksDispatcherOnMountInDEV = null;\nvar HooksDispatcherOnMountWithHookTypesInDEV = null;\nvar HooksDispatcherOnUpdateInDEV = null;\nvar HooksDispatcherOnRerenderInDEV = null;\nvar InvalidNestedHooksDispatcherOnMountInDEV = null;\nvar InvalidNestedHooksDispatcherOnUpdateInDEV = null;\nvar InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n\n{\n  var warnInvalidContextAccess = function () {\n    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n  };\n\n  var warnInvalidHookAccess = function () {\n    error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://reactjs.org/link/rules-of-hooks');\n  };\n\n  HooksDispatcherOnMountInDEV = {\n    readContext: function (context) {\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      mountHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      mountHookTypesDev();\n      checkDepsAreArrayDev(deps);\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      mountHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      mountHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      mountHookTypesDev();\n      return mountDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      mountHookTypesDev();\n      return mountTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      mountHookTypesDev();\n      return mountMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      mountHookTypesDev();\n      return mountId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  HooksDispatcherOnMountWithHookTypesInDEV = {\n    readContext: function (context) {\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return mountDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return mountDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return mountTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return mountMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return mountId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  HooksDispatcherOnUpdateInDEV = {\n    readContext: function (context) {\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef();\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return updateTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  HooksDispatcherOnRerenderInDEV = {\n    readContext: function (context) {\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      updateHookTypesDev();\n      return updateRef();\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;\n\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      updateHookTypesDev();\n      return updateDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      updateHookTypesDev();\n      return updateMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      updateHookTypesDev();\n      return updateId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  InvalidNestedHooksDispatcherOnMountInDEV = {\n    readContext: function (context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountRef(initialValue);\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;\n\n      try {\n        return mountState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      mountHookTypesDev();\n      return mountId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  InvalidNestedHooksDispatcherOnUpdateInDEV = {\n    readContext: function (context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef();\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n\n  InvalidNestedHooksDispatcherOnRerenderInDEV = {\n    readContext: function (context) {\n      warnInvalidContextAccess();\n      return readContext(context);\n    },\n    useCallback: function (callback, deps) {\n      currentHookNameInDev = 'useCallback';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateCallback(callback, deps);\n    },\n    useContext: function (context) {\n      currentHookNameInDev = 'useContext';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return readContext(context);\n    },\n    useEffect: function (create, deps) {\n      currentHookNameInDev = 'useEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateEffect(create, deps);\n    },\n    useImperativeHandle: function (ref, create, deps) {\n      currentHookNameInDev = 'useImperativeHandle';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateImperativeHandle(ref, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      currentHookNameInDev = 'useInsertionEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateInsertionEffect(create, deps);\n    },\n    useLayoutEffect: function (create, deps) {\n      currentHookNameInDev = 'useLayoutEffect';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateLayoutEffect(create, deps);\n    },\n    useMemo: function (create, deps) {\n      currentHookNameInDev = 'useMemo';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return updateMemo(create, deps);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useReducer: function (reducer, initialArg, init) {\n      currentHookNameInDev = 'useReducer';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return rerenderReducer(reducer, initialArg, init);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useRef: function (initialValue) {\n      currentHookNameInDev = 'useRef';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateRef();\n    },\n    useState: function (initialState) {\n      currentHookNameInDev = 'useState';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      var prevDispatcher = ReactCurrentDispatcher$1.current;\n      ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;\n\n      try {\n        return rerenderState(initialState);\n      } finally {\n        ReactCurrentDispatcher$1.current = prevDispatcher;\n      }\n    },\n    useDebugValue: function (value, formatterFn) {\n      currentHookNameInDev = 'useDebugValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateDebugValue();\n    },\n    useDeferredValue: function (value) {\n      currentHookNameInDev = 'useDeferredValue';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderDeferredValue(value);\n    },\n    useTransition: function () {\n      currentHookNameInDev = 'useTransition';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return rerenderTransition();\n    },\n    useMutableSource: function (source, getSnapshot, subscribe) {\n      currentHookNameInDev = 'useMutableSource';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateMutableSource();\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      currentHookNameInDev = 'useSyncExternalStore';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateSyncExternalStore(subscribe, getSnapshot);\n    },\n    useId: function () {\n      currentHookNameInDev = 'useId';\n      warnInvalidHookAccess();\n      updateHookTypesDev();\n      return updateId();\n    },\n    unstable_isNewReconciler: enableNewReconciler\n  };\n}\n\nvar now$2 = Scheduler.unstable_now;\nvar commitTime = 0;\nvar layoutEffectStartTime = -1;\nvar profilerStartTime = -1;\nvar passiveEffectStartTime = -1;\n/**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */\n\nvar currentUpdateIsNested = false;\nvar nestedUpdateScheduled = false;\n\nfunction isCurrentUpdateNested() {\n  return currentUpdateIsNested;\n}\n\nfunction markNestedUpdateScheduled() {\n  {\n    nestedUpdateScheduled = true;\n  }\n}\n\nfunction resetNestedUpdateFlag() {\n  {\n    currentUpdateIsNested = false;\n    nestedUpdateScheduled = false;\n  }\n}\n\nfunction syncNestedUpdateFlag() {\n  {\n    currentUpdateIsNested = nestedUpdateScheduled;\n    nestedUpdateScheduled = false;\n  }\n}\n\nfunction getCommitTime() {\n  return commitTime;\n}\n\nfunction recordCommitTime() {\n\n  commitTime = now$2();\n}\n\nfunction startProfilerTimer(fiber) {\n\n  profilerStartTime = now$2();\n\n  if (fiber.actualStartTime < 0) {\n    fiber.actualStartTime = now$2();\n  }\n}\n\nfunction stopProfilerTimerIfRunning(fiber) {\n\n  profilerStartTime = -1;\n}\n\nfunction stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n\n  if (profilerStartTime >= 0) {\n    var elapsedTime = now$2() - profilerStartTime;\n    fiber.actualDuration += elapsedTime;\n\n    if (overrideBaseTime) {\n      fiber.selfBaseDuration = elapsedTime;\n    }\n\n    profilerStartTime = -1;\n  }\n}\n\nfunction recordLayoutEffectDuration(fiber) {\n\n  if (layoutEffectStartTime >= 0) {\n    var elapsedTime = now$2() - layoutEffectStartTime;\n    layoutEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n    // Or the root (for the DevTools Profiler to read)\n\n    var parentFiber = fiber.return;\n\n    while (parentFiber !== null) {\n      switch (parentFiber.tag) {\n        case HostRoot:\n          var root = parentFiber.stateNode;\n          root.effectDuration += elapsedTime;\n          return;\n\n        case Profiler:\n          var parentStateNode = parentFiber.stateNode;\n          parentStateNode.effectDuration += elapsedTime;\n          return;\n      }\n\n      parentFiber = parentFiber.return;\n    }\n  }\n}\n\nfunction recordPassiveEffectDuration(fiber) {\n\n  if (passiveEffectStartTime >= 0) {\n    var elapsedTime = now$2() - passiveEffectStartTime;\n    passiveEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n    // Or the root (for the DevTools Profiler to read)\n\n    var parentFiber = fiber.return;\n\n    while (parentFiber !== null) {\n      switch (parentFiber.tag) {\n        case HostRoot:\n          var root = parentFiber.stateNode;\n\n          if (root !== null) {\n            root.passiveEffectDuration += elapsedTime;\n          }\n\n          return;\n\n        case Profiler:\n          var parentStateNode = parentFiber.stateNode;\n\n          if (parentStateNode !== null) {\n            // Detached fibers have their state node cleared out.\n            // In this case, the return pointer is also cleared out,\n            // so we won't be able to report the time spent in this Profiler's subtree.\n            parentStateNode.passiveEffectDuration += elapsedTime;\n          }\n\n          return;\n      }\n\n      parentFiber = parentFiber.return;\n    }\n  }\n}\n\nfunction startLayoutEffectTimer() {\n\n  layoutEffectStartTime = now$2();\n}\n\nfunction startPassiveEffectTimer() {\n\n  passiveEffectStartTime = now$2();\n}\n\nfunction transferActualDuration(fiber) {\n  // Transfer time spent rendering these children so we don't lose it\n  // after we rerender. This is used as a helper in special cases\n  // where we should count the work of multiple passes.\n  var child = fiber.child;\n\n  while (child) {\n    fiber.actualDuration += child.actualDuration;\n    child = child.sibling;\n  }\n}\n\nfunction createCapturedValue(value, source) {\n  // If the value is an error, call this function immediately after it is thrown\n  // so the stack is accurate.\n  return {\n    value: value,\n    source: source,\n    stack: getStackByFiberInDevAndProd(source)\n  };\n}\n\n// This module is forked in different environments.\n// By default, return `true` to log errors to the console.\n// Forks can return `false` if this isn't desirable.\nfunction showErrorDialog(boundary, errorInfo) {\n  return true;\n}\n\nfunction logCapturedError(boundary, errorInfo) {\n  try {\n    var logError = showErrorDialog(boundary, errorInfo); // Allow injected showErrorDialog() to prevent default console.error logging.\n    // This enables renderers like ReactNative to better manage redbox behavior.\n\n    if (logError === false) {\n      return;\n    }\n\n    var error = errorInfo.value;\n\n    if (true) {\n      var source = errorInfo.source;\n      var stack = errorInfo.stack;\n      var componentStack = stack !== null ? stack : ''; // Browsers support silencing uncaught errors by calling\n      // `preventDefault()` in window `error` handler.\n      // We record this information as an expando on the error.\n\n      if (error != null && error._suppressLogging) {\n        if (boundary.tag === ClassComponent) {\n          // The error is recoverable and was silenced.\n          // Ignore it and don't print the stack addendum.\n          // This is handy for testing error boundaries without noise.\n          return;\n        } // The error is fatal. Since the silencing might have\n        // been accidental, we'll surface it anyway.\n        // However, the browser would have silenced the original error\n        // so we'll print it first, and then print the stack addendum.\n\n\n        console['error'](error); // Don't transform to our wrapper\n        // For a more detailed description of this block, see:\n        // https://github.com/facebook/react/pull/13384\n      }\n\n      var componentName = source ? getComponentNameFromFiber(source) : null;\n      var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component:\" : 'The above error occurred in one of your React components:';\n      var errorBoundaryMessage;\n\n      if (boundary.tag === HostRoot) {\n        errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.';\n      } else {\n        var errorBoundaryName = getComponentNameFromFiber(boundary) || 'Anonymous';\n        errorBoundaryMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + errorBoundaryName + \".\");\n      }\n\n      var combinedMessage = componentNameMessage + \"\\n\" + componentStack + \"\\n\\n\" + (\"\" + errorBoundaryMessage); // In development, we provide our own message with just the component stack.\n      // We don't include the original error message and JS stack because the browser\n      // has already printed it. Even if the application swallows the error, it is still\n      // displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.\n\n      console['error'](combinedMessage); // Don't transform to our wrapper\n    } else {\n      // In production, we print the error directly.\n      // This will include the message, the JS stack, and anything the browser wants to show.\n      // We pass the error object instead of custom message so that the browser displays the error natively.\n      console['error'](error); // Don't transform to our wrapper\n    }\n  } catch (e) {\n    // This method must not throw, or React internal state will get messed up.\n    // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n    // we want to report this error outside of the normal stack as a last resort.\n    // https://github.com/facebook/react/issues/13188\n    setTimeout(function () {\n      throw e;\n    });\n  }\n}\n\nvar PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;\n\nfunction createRootErrorUpdate(fiber, errorInfo, lane) {\n  var update = createUpdate(NoTimestamp, lane); // Unmount the root by rendering null.\n\n  update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n  update.payload = {\n    element: null\n  };\n  var error = errorInfo.value;\n\n  update.callback = function () {\n    onUncaughtError(error);\n    logCapturedError(fiber, errorInfo);\n  };\n\n  return update;\n}\n\nfunction createClassErrorUpdate(fiber, errorInfo, lane) {\n  var update = createUpdate(NoTimestamp, lane);\n  update.tag = CaptureUpdate;\n  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n\n  if (typeof getDerivedStateFromError === 'function') {\n    var error$1 = errorInfo.value;\n\n    update.payload = function () {\n      return getDerivedStateFromError(error$1);\n    };\n\n    update.callback = function () {\n      {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n\n      logCapturedError(fiber, errorInfo);\n    };\n  }\n\n  var inst = fiber.stateNode;\n\n  if (inst !== null && typeof inst.componentDidCatch === 'function') {\n    update.callback = function callback() {\n      {\n        markFailedErrorBoundaryForHotReloading(fiber);\n      }\n\n      logCapturedError(fiber, errorInfo);\n\n      if (typeof getDerivedStateFromError !== 'function') {\n        // To preserve the preexisting retry behavior of error boundaries,\n        // we keep track of which ones already failed during this batch.\n        // This gets reset before we yield back to the browser.\n        // TODO: Warn in strict mode if getDerivedStateFromError is\n        // not defined.\n        markLegacyErrorBoundaryAsFailed(this);\n      }\n\n      var error$1 = errorInfo.value;\n      var stack = errorInfo.stack;\n      this.componentDidCatch(error$1, {\n        componentStack: stack !== null ? stack : ''\n      });\n\n      {\n        if (typeof getDerivedStateFromError !== 'function') {\n          // If componentDidCatch is the only error boundary method defined,\n          // then it needs to call setState to recover from errors.\n          // If no state update is scheduled then the boundary will swallow the error.\n          if (!includesSomeLane(fiber.lanes, SyncLane)) {\n            error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentNameFromFiber(fiber) || 'Unknown');\n          }\n        }\n      }\n    };\n  }\n\n  return update;\n}\n\nfunction attachPingListener(root, wakeable, lanes) {\n  // Attach a ping listener\n  //\n  // The data might resolve before we have a chance to commit the fallback. Or,\n  // in the case of a refresh, we'll never commit a fallback. So we need to\n  // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n  // try rendering the tree again.\n  //\n  // Only attach a listener if one does not already exist for the lanes\n  // we're currently rendering (which acts like a \"thread ID\" here).\n  //\n  // We only need to do this in concurrent mode. Legacy Suspense always\n  // commits fallbacks synchronously, so there are no pings.\n  var pingCache = root.pingCache;\n  var threadIDs;\n\n  if (pingCache === null) {\n    pingCache = root.pingCache = new PossiblyWeakMap$1();\n    threadIDs = new Set();\n    pingCache.set(wakeable, threadIDs);\n  } else {\n    threadIDs = pingCache.get(wakeable);\n\n    if (threadIDs === undefined) {\n      threadIDs = new Set();\n      pingCache.set(wakeable, threadIDs);\n    }\n  }\n\n  if (!threadIDs.has(lanes)) {\n    // Memoize using the thread ID to prevent redundant listeners.\n    threadIDs.add(lanes);\n    var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n\n    {\n      if (isDevToolsPresent) {\n        // If we have pending work still, restore the original updaters\n        restorePendingUpdaters(root, lanes);\n      }\n    }\n\n    wakeable.then(ping, ping);\n  }\n}\n\nfunction attachRetryListener(suspenseBoundary, root, wakeable, lanes) {\n  // Retry listener\n  //\n  // If the fallback does commit, we need to attach a different type of\n  // listener. This one schedules an update on the Suspense boundary to turn\n  // the fallback state off.\n  //\n  // Stash the wakeable on the boundary fiber so we can access it in the\n  // commit phase.\n  //\n  // When the wakeable resolves, we'll attempt to render the boundary\n  // again (\"retry\").\n  var wakeables = suspenseBoundary.updateQueue;\n\n  if (wakeables === null) {\n    var updateQueue = new Set();\n    updateQueue.add(wakeable);\n    suspenseBoundary.updateQueue = updateQueue;\n  } else {\n    wakeables.add(wakeable);\n  }\n}\n\nfunction resetSuspendedComponent(sourceFiber, rootRenderLanes) {\n  // A legacy mode Suspense quirk, only relevant to hook components.\n\n\n  var tag = sourceFiber.tag;\n\n  if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {\n    var currentSource = sourceFiber.alternate;\n\n    if (currentSource) {\n      sourceFiber.updateQueue = currentSource.updateQueue;\n      sourceFiber.memoizedState = currentSource.memoizedState;\n      sourceFiber.lanes = currentSource.lanes;\n    } else {\n      sourceFiber.updateQueue = null;\n      sourceFiber.memoizedState = null;\n    }\n  }\n}\n\nfunction getNearestSuspenseBoundaryToCapture(returnFiber) {\n  var node = returnFiber;\n\n  do {\n    if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {\n      return node;\n    } // This boundary already captured during this render. Continue to the next\n    // boundary.\n\n\n    node = node.return;\n  } while (node !== null);\n\n  return null;\n}\n\nfunction markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {\n  // This marks a Suspense boundary so that when we're unwinding the stack,\n  // it captures the suspended \"exception\" and does a second (fallback) pass.\n  if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {\n    // Legacy Mode Suspense\n    //\n    // If the boundary is in legacy mode, we should *not*\n    // suspend the commit. Pretend as if the suspended component rendered\n    // null and keep rendering. When the Suspense boundary completes,\n    // we'll do a second pass to render the fallback.\n    if (suspenseBoundary === returnFiber) {\n      // Special case where we suspended while reconciling the children of\n      // a Suspense boundary's inner Offscreen wrapper fiber. This happens\n      // when a React.lazy component is a direct child of a\n      // Suspense boundary.\n      //\n      // Suspense boundaries are implemented as multiple fibers, but they\n      // are a single conceptual unit. The legacy mode behavior where we\n      // pretend the suspended fiber committed as `null` won't work,\n      // because in this case the \"suspended\" fiber is the inner\n      // Offscreen wrapper.\n      //\n      // Because the contents of the boundary haven't started rendering\n      // yet (i.e. nothing in the tree has partially rendered) we can\n      // switch to the regular, concurrent mode behavior: mark the\n      // boundary with ShouldCapture and enter the unwind phase.\n      suspenseBoundary.flags |= ShouldCapture;\n    } else {\n      suspenseBoundary.flags |= DidCapture;\n      sourceFiber.flags |= ForceUpdateForLegacySuspense; // We're going to commit this fiber even though it didn't complete.\n      // But we shouldn't call any lifecycle methods or callbacks. Remove\n      // all lifecycle effect tags.\n\n      sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);\n\n      if (supportsPersistence && enablePersistentOffscreenHostContainer) {\n        // Another legacy Suspense quirk. In persistent mode, if this is the\n        // initial mount, override the props of the host container to hide\n        // its contents.\n        var currentSuspenseBoundary = suspenseBoundary.alternate;\n\n        if (currentSuspenseBoundary === null) {\n          var offscreenFiber = suspenseBoundary.child;\n          var offscreenContainer = offscreenFiber.child;\n\n          if (offscreenContainer !== null) {\n            var children = offscreenContainer.memoizedProps.children;\n            var containerProps = getOffscreenContainerProps('hidden', children);\n            offscreenContainer.pendingProps = containerProps;\n            offscreenContainer.memoizedProps = containerProps;\n          }\n        }\n      }\n\n      if (sourceFiber.tag === ClassComponent) {\n        var currentSourceFiber = sourceFiber.alternate;\n\n        if (currentSourceFiber === null) {\n          // This is a new mount. Change the tag so it's not mistaken for a\n          // completed class component. For example, we should not call\n          // componentWillUnmount if it is deleted.\n          sourceFiber.tag = IncompleteClassComponent;\n        } else {\n          // When we try rendering again, we should not reuse the current fiber,\n          // since it's known to be in an inconsistent state. Use a force update to\n          // prevent a bail out.\n          var update = createUpdate(NoTimestamp, SyncLane);\n          update.tag = ForceUpdate;\n          enqueueUpdate(sourceFiber, update);\n        }\n      } // The source fiber did not complete. Mark it with Sync priority to\n      // indicate that it still has pending work.\n\n\n      sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);\n    }\n\n    return suspenseBoundary;\n  } // Confirmed that the boundary is in a concurrent mode tree. Continue\n  // with the normal suspend path.\n  //\n  // After this we'll use a set of heuristics to determine whether this\n  // render pass will run to completion or restart or \"suspend\" the commit.\n  // The actual logic for this is spread out in different places.\n  //\n  // This first principle is that if we're going to suspend when we complete\n  // a root, then we should also restart if we get an update or ping that\n  // might unsuspend it, and vice versa. The only reason to suspend is\n  // because you think you might want to restart before committing. However,\n  // it doesn't make sense to restart only while in the period we're suspended.\n  //\n  // Restarting too aggressively is also not good because it starves out any\n  // intermediate loading state. So we use heuristics to determine when.\n  // Suspense Heuristics\n  //\n  // If nothing threw a Promise or all the same fallbacks are already showing,\n  // then don't suspend/restart.\n  //\n  // If this is an initial render of a new tree of Suspense boundaries and\n  // those trigger a fallback, then don't suspend/restart. We want to ensure\n  // that we can show the initial loading state as quickly as possible.\n  //\n  // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n  // a fallback, then we should always suspend/restart. Transitions apply\n  // to this case. If none is defined, JND is used instead.\n  //\n  // If we're already showing a fallback and it gets \"retried\", allowing us to show\n  // another level, but there's still an inner boundary that would show a fallback,\n  // then we suspend/restart for 500ms since the last time we showed a fallback\n  // anywhere in the tree. This effectively throttles progressive loading into a\n  // consistent train of commits. This also gives us an opportunity to restart to\n  // get to the completed state slightly earlier.\n  //\n  // If there's ambiguity due to batching it's resolved in preference of:\n  // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n  //\n  // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n  // ensure that new initial loading states can commit as soon as possible.\n\n\n  suspenseBoundary.flags |= ShouldCapture; // TODO: I think we can remove this, since we now use `DidCapture` in\n  // the begin phase to prevent an early bailout.\n\n  suspenseBoundary.lanes = rootRenderLanes;\n  return suspenseBoundary;\n}\n\nfunction throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n  // The source fiber did not complete.\n  sourceFiber.flags |= Incomplete;\n\n  {\n    if (isDevToolsPresent) {\n      // If we have pending work still, restore the original updaters\n      restorePendingUpdaters(root, rootRenderLanes);\n    }\n  }\n\n  if (value !== null && typeof value === 'object' && typeof value.then === 'function') {\n    // This is a wakeable. The component suspended.\n    var wakeable = value;\n    resetSuspendedComponent(sourceFiber);\n\n\n    var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);\n\n    if (suspenseBoundary !== null) {\n      suspenseBoundary.flags &= ~ForceClientRender;\n      markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // We only attach ping listeners in concurrent mode. Legacy Suspense always\n      // commits fallbacks synchronously, so there are no pings.\n\n      if (suspenseBoundary.mode & ConcurrentMode) {\n        attachPingListener(root, wakeable, rootRenderLanes);\n      }\n\n      attachRetryListener(suspenseBoundary, root, wakeable);\n      return;\n    } else {\n      // No boundary was found. Unless this is a sync update, this is OK.\n      // We can suspend and wait for more data to arrive.\n      if (!includesSyncLane(rootRenderLanes)) {\n        // This is not a sync update. Suspend. Since we're not activating a\n        // Suspense boundary, this will unwind all the way to the root without\n        // performing a second pass to render a fallback. (This is arguably how\n        // refresh transitions should work, too, since we're not going to commit\n        // the fallbacks anyway.)\n        //\n        // This case also applies to initial hydration.\n        attachPingListener(root, wakeable, rootRenderLanes);\n        renderDidSuspendDelayIfPossible();\n        return;\n      } // This is a sync/discrete update. We treat this case like an error\n      // because discrete renders are expected to produce a complete tree\n      // synchronously to maintain consistency with external state.\n\n\n      var uncaughtSuspenseError = new Error('A component suspended while responding to synchronous input. This ' + 'will cause the UI to be replaced with a loading indicator. To ' + 'fix, updates that suspend should be wrapped ' + 'with startTransition.'); // If we're outside a transition, fall through to the regular error path.\n      // The error will be caught by the nearest suspense boundary.\n\n      value = uncaughtSuspenseError;\n    }\n  } else {\n    // This is a regular error, not a Suspense wakeable.\n    if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {\n      markDidSuspendWhileHydratingDEV();\n\n      var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber); // If the error was thrown during hydration, we may be able to recover by\n      // discarding the dehydrated content and switching to a client render.\n      // Instead of surfacing the error, find the nearest Suspense boundary\n      // and render it again without hydration.\n\n\n      if (_suspenseBoundary !== null) {\n        if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {\n          // Set a flag to indicate that we should try rendering the normal\n          // children again, not the fallback.\n          _suspenseBoundary.flags |= ForceClientRender;\n        }\n\n        markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Even though the user may not be affected by this error, we should\n        // still log it so it can be fixed.\n\n        queueHydrationError(value);\n        return;\n      }\n    }\n  } // We didn't find a boundary that could handle this type of exception. Start\n  // over and traverse parent path again, this time treating the exception\n  // as an error.\n\n\n  renderDidError(value);\n  value = createCapturedValue(value, sourceFiber);\n  var workInProgress = returnFiber;\n\n  do {\n    switch (workInProgress.tag) {\n      case HostRoot:\n        {\n          var _errorInfo = value;\n          workInProgress.flags |= ShouldCapture;\n          var lane = pickArbitraryLane(rootRenderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane);\n          var update = createRootErrorUpdate(workInProgress, _errorInfo, lane);\n          enqueueCapturedUpdate(workInProgress, update);\n          return;\n        }\n\n      case ClassComponent:\n        // Capture and retry\n        var errorInfo = value;\n        var ctor = workInProgress.type;\n        var instance = workInProgress.stateNode;\n\n        if ((workInProgress.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n          workInProgress.flags |= ShouldCapture;\n\n          var _lane = pickArbitraryLane(rootRenderLanes);\n\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane); // Schedule the error boundary to re-render using updated state\n\n          var _update = createClassErrorUpdate(workInProgress, errorInfo, _lane);\n\n          enqueueCapturedUpdate(workInProgress, _update);\n          return;\n        }\n\n        break;\n    }\n\n    workInProgress = workInProgress.return;\n  } while (workInProgress !== null);\n}\n\nfunction getSuspendedCache() {\n  {\n    return null;\n  } // This function is called when a Suspense boundary suspends. It returns the\n}\n\nfunction markUpdate(workInProgress) {\n  // Tag the fiber with an update effect. This turns a Placement into\n  // a PlacementAndUpdate.\n  workInProgress.flags |= Update;\n}\n\nfunction markRef(workInProgress) {\n  workInProgress.flags |= Ref;\n\n  {\n    workInProgress.flags |= RefStatic;\n  }\n}\n\nfunction hadNoMutationsEffects(current, completedWork) {\n  var didBailout = current !== null && current.child === completedWork.child;\n\n  if (didBailout) {\n    return true;\n  }\n\n  if ((completedWork.flags & ChildDeletion) !== NoFlags) {\n    return false;\n  } // TODO: If we move the `hadNoMutationsEffects` call after `bubbleProperties`\n  // then we only have to check the `completedWork.subtreeFlags`.\n\n\n  var child = completedWork.child;\n\n  while (child !== null) {\n    if ((child.flags & MutationMask) !== NoFlags || (child.subtreeFlags & MutationMask) !== NoFlags) {\n      return false;\n    }\n\n    child = child.sibling;\n  }\n\n  return true;\n}\n\nvar appendAllChildren;\nvar updateHostContainer;\nvar updateHostComponent;\nvar updateHostText;\n\nif (supportsMutation) {\n  // Mutation mode\n  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n\n    while (node !== null) {\n      if (node.tag === HostComponent || node.tag === HostText) {\n        appendInitialChild(parent, node.stateNode);\n      } else if (node.tag === HostPortal) ; else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function (current, workInProgress) {// Noop\n  };\n\n  updateHostComponent = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    // If we have an alternate, that means this is an update and we need to\n    // schedule a side-effect to do the updates.\n    var oldProps = current.memoizedProps;\n\n    if (oldProps === newProps) {\n      // In mutation mode, this is sufficient for a bailout because\n      // we won't touch this node even if children changed.\n      return;\n    } // If we get updated because one of our children updated, we don't\n    // have newProps so we'll have to reuse them.\n    // TODO: Split the update API as separate for the props vs. children.\n    // Even better would be if children weren't special cased at all tho.\n\n\n    var instance = workInProgress.stateNode;\n    var currentHostContext = getHostContext(); // TODO: Experiencing an error where oldProps is null. Suggests a host\n    // component is hitting the resume path. Figure out why. Possibly\n    // related to `hidden`.\n\n    var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext); // TODO: Type this specific to this type of component.\n\n    workInProgress.updateQueue = updatePayload; // If the update payload indicates that there is a change or if there\n    // is a new ref we mark this as an update. All the work is done in commitWork.\n\n    if (updatePayload) {\n      markUpdate(workInProgress);\n    }\n  };\n\n  updateHostText = function (current, workInProgress, oldText, newText) {\n    // If the text differs, mark it as an update. All the work in done in commitWork.\n    if (oldText !== newText) {\n      markUpdate(workInProgress);\n    }\n  };\n} else if (supportsPersistence) {\n  // Persistent host tree mode\n  appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n       if (node.tag === HostComponent) {\n        var instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          var props = node.memoizedProps;\n          var type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendInitialChild(parent, instance);\n      } else if (node.tag === HostText) {\n        var _instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          var text = node.memoizedProps;\n          _instance = cloneHiddenTextInstance(_instance, text, node);\n        }\n\n        appendInitialChild(parent, _instance);\n      } else if (node.tag === HostPortal) ; else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        var child = node.child;\n\n        if (child !== null) {\n          child.return = node;\n        }\n\n        {\n          appendAllChildren(parent, node, true, true);\n        }\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n\n\n      node = node;\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }; // An unfortunate fork of appendAllChildren because we have two different parent types.\n\n\n  var appendAllChildrenToContainer = function (containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n    // We only have the top Fiber that was created but we need recurse down its\n    // children to find all the terminal nodes.\n    var node = workInProgress.child;\n\n    while (node !== null) {\n      // eslint-disable-next-line no-labels\n       if (node.tag === HostComponent) {\n        var instance = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          var props = node.memoizedProps;\n          var type = node.type;\n          instance = cloneHiddenInstance(instance, type, props, node);\n        }\n\n        appendChildToContainerChildSet(containerChildSet, instance);\n      } else if (node.tag === HostText) {\n        var _instance2 = node.stateNode;\n\n        if (needsVisibilityToggle && isHidden) {\n          // This child is inside a timed out tree. Hide it.\n          var text = node.memoizedProps;\n          _instance2 = cloneHiddenTextInstance(_instance2, text, node);\n        }\n\n        appendChildToContainerChildSet(containerChildSet, _instance2);\n      } else if (node.tag === HostPortal) ; else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n        // The children in this boundary are hidden. Toggle their visibility\n        // before appending.\n        var child = node.child;\n\n        if (child !== null) {\n          child.return = node;\n        }\n\n        {\n          appendAllChildrenToContainer(containerChildSet, node, true, true);\n        }\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      } // $FlowFixMe This is correct but Flow is confused by the labeled break.\n\n\n      node = node;\n\n      if (node === workInProgress) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === workInProgress) {\n          return;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  };\n\n  updateHostContainer = function (current, workInProgress) {\n    var portalOrRoot = workInProgress.stateNode;\n    var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n\n    if (childrenUnchanged) ; else {\n      var container = portalOrRoot.containerInfo;\n      var newChildSet = createContainerChildSet(container); // If children might have changed, we have to add them all to the set.\n\n      appendAllChildrenToContainer(newChildSet, workInProgress, false, false);\n      portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.\n\n      markUpdate(workInProgress);\n      finalizeContainerChildren(container, newChildSet);\n    }\n  };\n\n  updateHostComponent = function (current, workInProgress, type, newProps, rootContainerInstance) {\n    var currentInstance = current.stateNode;\n    var oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.\n    // This guarantees that we can reuse all of them.\n\n    var childrenUnchanged = hadNoMutationsEffects(current, workInProgress);\n\n    if (childrenUnchanged && oldProps === newProps) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n\n    var recyclableInstance = workInProgress.stateNode;\n    var currentHostContext = getHostContext();\n    var updatePayload = null;\n\n    if (oldProps !== newProps) {\n      updatePayload = prepareUpdate(recyclableInstance, type, oldProps, newProps, rootContainerInstance, currentHostContext);\n    }\n\n    if (childrenUnchanged && updatePayload === null) {\n      // No changes, just reuse the existing instance.\n      // Note that this might release a previous clone.\n      workInProgress.stateNode = currentInstance;\n      return;\n    }\n\n    var newInstance = cloneInstance(currentInstance, updatePayload, type, oldProps, newProps, workInProgress, childrenUnchanged, recyclableInstance);\n\n    if (finalizeInitialChildren(newInstance, type, newProps, rootContainerInstance, currentHostContext)) {\n      markUpdate(workInProgress);\n    }\n\n    workInProgress.stateNode = newInstance;\n\n    if (childrenUnchanged) {\n      // If there are no other effects in this tree, we need to flag this node as having one.\n      // Even though we're not going to use it for anything.\n      // Otherwise parents won't know that there are new children to propagate upwards.\n      markUpdate(workInProgress);\n    } else {\n      // If children might have changed, we have to add them all to the set.\n      appendAllChildren(newInstance, workInProgress, false, false);\n    }\n  };\n\n  updateHostText = function (current, workInProgress, oldText, newText) {\n    if (oldText !== newText) {\n      // If the text content differs, we'll create a new text instance for it.\n      var rootContainerInstance = getRootHostContainer();\n      var currentHostContext = getHostContext();\n      workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n      // This lets the parents know that at least one of their children has changed.\n\n      markUpdate(workInProgress);\n    } else {\n      workInProgress.stateNode = current.stateNode;\n    }\n  };\n} else {\n  // No host operations\n  updateHostContainer = function (current, workInProgress) {// Noop\n  };\n\n  updateHostComponent = function (current, workInProgress, type, newProps, rootContainerInstance) {// Noop\n  };\n\n  updateHostText = function (current, workInProgress, oldText, newText) {// Noop\n  };\n}\n\nfunction cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n  if (getIsHydrating()) {\n    // If we're hydrating, we should consume as many items as we can\n    // so we don't leave any behind.\n    return;\n  }\n\n  switch (renderState.tailMode) {\n    case 'hidden':\n      {\n        // Any insertions at the end of the tail list after this point\n        // should be invisible. If there are already mounted boundaries\n        // anything before them are not considered for collapsing.\n        // Therefore we need to go through the whole tail to find if\n        // there are any.\n        var tailNode = renderState.tail;\n        var lastTailNode = null;\n\n        while (tailNode !== null) {\n          if (tailNode.alternate !== null) {\n            lastTailNode = tailNode;\n          }\n\n          tailNode = tailNode.sibling;\n        } // Next we're simply going to delete all insertions after the\n        // last rendered item.\n\n\n        if (lastTailNode === null) {\n          // All remaining items in the tail are insertions.\n          renderState.tail = null;\n        } else {\n          // Detach the insertion after the last node that was already\n          // inserted.\n          lastTailNode.sibling = null;\n        }\n\n        break;\n      }\n\n    case 'collapsed':\n      {\n        // Any insertions at the end of the tail list after this point\n        // should be invisible. If there are already mounted boundaries\n        // anything before them are not considered for collapsing.\n        // Therefore we need to go through the whole tail to find if\n        // there are any.\n        var _tailNode = renderState.tail;\n        var _lastTailNode = null;\n\n        while (_tailNode !== null) {\n          if (_tailNode.alternate !== null) {\n            _lastTailNode = _tailNode;\n          }\n\n          _tailNode = _tailNode.sibling;\n        } // Next we're simply going to delete all insertions after the\n        // last rendered item.\n\n\n        if (_lastTailNode === null) {\n          // All remaining items in the tail are insertions.\n          if (!hasRenderedATailFallback && renderState.tail !== null) {\n            // We suspended during the head. We want to show at least one\n            // row at the tail. So we'll keep on and cut off the rest.\n            renderState.tail.sibling = null;\n          } else {\n            renderState.tail = null;\n          }\n        } else {\n          // Detach the insertion after the last node that was already\n          // inserted.\n          _lastTailNode.sibling = null;\n        }\n\n        break;\n      }\n  }\n}\n\nfunction bubbleProperties(completedWork) {\n  var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n  var newChildLanes = NoLanes;\n  var subtreeFlags = NoFlags;\n\n  if (!didBailout) {\n    // Bubble up the earliest expiration time.\n    if ( (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      var actualDuration = completedWork.actualDuration;\n      var treeBaseDuration = completedWork.selfBaseDuration;\n      var child = completedWork.child;\n\n      while (child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n        subtreeFlags |= child.subtreeFlags;\n        subtreeFlags |= child.flags; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n        // When work is done, it should bubble to the parent's actualDuration. If\n        // the fiber has not been cloned though, (meaning no work was done), then\n        // this value will reflect the amount of time spent working on a previous\n        // render. In that case it should not bubble. We determine whether it was\n        // cloned by comparing the child pointer.\n\n        actualDuration += child.actualDuration;\n        treeBaseDuration += child.treeBaseDuration;\n        child = child.sibling;\n      }\n\n      completedWork.actualDuration = actualDuration;\n      completedWork.treeBaseDuration = treeBaseDuration;\n    } else {\n      var _child = completedWork.child;\n\n      while (_child !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));\n        subtreeFlags |= _child.subtreeFlags;\n        subtreeFlags |= _child.flags; // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n\n        _child.return = completedWork;\n        _child = _child.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  } else {\n    // Bubble up the earliest expiration time.\n    if ( (completedWork.mode & ProfileMode) !== NoMode) {\n      // In profiling mode, resetChildExpirationTime is also used to reset\n      // profiler durations.\n      var _treeBaseDuration = completedWork.selfBaseDuration;\n      var _child2 = completedWork.child;\n\n      while (_child2 !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n\n        subtreeFlags |= _child2.subtreeFlags & StaticMask;\n        subtreeFlags |= _child2.flags & StaticMask;\n        _treeBaseDuration += _child2.treeBaseDuration;\n        _child2 = _child2.sibling;\n      }\n\n      completedWork.treeBaseDuration = _treeBaseDuration;\n    } else {\n      var _child3 = completedWork.child;\n\n      while (_child3 !== null) {\n        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n        // so we should bubble those up even during a bailout. All the other\n        // flags have a lifetime only of a single render + commit, so we should\n        // ignore them.\n\n        subtreeFlags |= _child3.subtreeFlags & StaticMask;\n        subtreeFlags |= _child3.flags & StaticMask; // Update the return pointer so the tree is consistent. This is a code\n        // smell because it assumes the commit phase is never concurrent with\n        // the render phase. Will address during refactor to alternate model.\n\n        _child3.return = completedWork;\n        _child3 = _child3.sibling;\n      }\n    }\n\n    completedWork.subtreeFlags |= subtreeFlags;\n  }\n\n  completedWork.childLanes = newChildLanes;\n  return didBailout;\n}\n\nfunction completeWork(current, workInProgress, renderLanes) {\n  var newProps = workInProgress.pendingProps; // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n\n  popTreeContext(workInProgress);\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n    case LazyComponent:\n    case SimpleMemoComponent:\n    case FunctionComponent:\n    case ForwardRef:\n    case Fragment:\n    case Mode:\n    case Profiler:\n    case ContextConsumer:\n    case MemoComponent:\n      bubbleProperties(workInProgress);\n      return null;\n\n    case ClassComponent:\n      {\n        var Component = workInProgress.type;\n\n        if (isContextProvider(Component)) {\n          popContext(workInProgress);\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case HostRoot:\n      {\n        var fiberRoot = workInProgress.stateNode;\n\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        resetWorkInProgressVersions();\n\n        if (fiberRoot.pendingContext) {\n          fiberRoot.context = fiberRoot.pendingContext;\n          fiberRoot.pendingContext = null;\n        }\n\n        if (current === null || current.child === null) {\n          // If we hydrated, pop so that we can delete any remaining children\n          // that weren't hydrated.\n          var wasHydrated = popHydrationState(workInProgress);\n\n          if (wasHydrated) {\n            // If we hydrated, then we'll need to schedule an update for\n            // the commit side-effects on the root.\n            markUpdate(workInProgress);\n          } else {\n            if (current !== null) {\n              var prevState = current.memoizedState;\n\n              if ( // Check if this is a client root\n              !prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)\n              (workInProgress.flags & ForceClientRender) !== NoFlags) {\n                // Schedule an effect to clear this container at the start of the\n                // next commit. This handles the case of React rendering into a\n                // container with previous children. It's also safe to do for\n                // updates too, because current.child would only be null if the\n                // previous render was null (so the container would already\n                // be empty).\n                workInProgress.flags |= Snapshot; // If this was a forced client render, there may have been\n                // recoverable errors during first hydration attempt. If so, add\n                // them to a queue so we can log them in the commit phase.\n\n                upgradeHydrationErrorsToRecoverable();\n              }\n            }\n          }\n        }\n\n        updateHostContainer(current, workInProgress);\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case HostComponent:\n      {\n        popHostContext(workInProgress);\n        var rootContainerInstance = getRootHostContainer();\n        var type = workInProgress.type;\n\n        if (current !== null && workInProgress.stateNode != null) {\n          updateHostComponent(current, workInProgress, type, newProps, rootContainerInstance);\n\n          if (current.ref !== workInProgress.ref) {\n            markRef(workInProgress);\n          }\n        } else {\n          if (!newProps) {\n            if (workInProgress.stateNode === null) {\n              throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            } // This can happen when we abort work.\n\n\n            bubbleProperties(workInProgress);\n            return null;\n          }\n\n          var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n          // \"stack\" as the parent. Then append children as we go in beginWork\n          // or completeWork depending on whether we want to add them top->down or\n          // bottom->up. Top->down is faster in IE11.\n\n          var _wasHydrated = popHydrationState(workInProgress);\n\n          if (_wasHydrated) {\n            // TODO: Move this and createInstance step into the beginPhase\n            // to consolidate.\n            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) {\n              // If changes to the hydrated node need to be applied at the\n              // commit-phase we mark this as such.\n              markUpdate(workInProgress);\n            }\n          } else {\n            var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);\n            appendAllChildren(instance, workInProgress, false, false);\n            workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.\n            // (eg DOM renderer supports auto-focus for certain elements).\n            // Make sure such renderers get scheduled for later work.\n\n            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance, currentHostContext)) {\n              markUpdate(workInProgress);\n            }\n          }\n\n          if (workInProgress.ref !== null) {\n            // If there is a ref on a host node we need to schedule a callback\n            markRef(workInProgress);\n          }\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case HostText:\n      {\n        var newText = newProps;\n\n        if (current && workInProgress.stateNode != null) {\n          var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n          // to schedule a side-effect to do the updates.\n\n          updateHostText(current, workInProgress, oldText, newText);\n        } else {\n          if (typeof newText !== 'string') {\n            if (workInProgress.stateNode === null) {\n              throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n            } // This can happen when we abort work.\n\n          }\n\n          var _rootContainerInstance = getRootHostContainer();\n\n          var _currentHostContext = getHostContext();\n\n          var _wasHydrated2 = popHydrationState(workInProgress);\n\n          if (_wasHydrated2) {\n            if (prepareToHydrateHostTextInstance(workInProgress)) {\n              markUpdate(workInProgress);\n            }\n          } else {\n            workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress);\n          }\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case SuspenseComponent:\n      {\n        popSuspenseContext(workInProgress);\n        var nextState = workInProgress.memoizedState;\n\n        {\n          if ( hasUnhydratedTailNodes() && (workInProgress.mode & ConcurrentMode) !== NoMode && (workInProgress.flags & DidCapture) === NoFlags) {\n            warnIfUnhydratedTailNodes(workInProgress);\n            resetHydrationState();\n            workInProgress.flags |= ForceClientRender | Incomplete | ShouldCapture;\n            return workInProgress;\n          }\n\n          if (nextState !== null && nextState.dehydrated !== null) {\n            // We might be inside a hydration state the first time we're picking up this\n            // Suspense boundary, and also after we've reentered it for further hydration.\n            var _wasHydrated3 = popHydrationState(workInProgress);\n\n            if (current === null) {\n              if (!_wasHydrated3) {\n                throw new Error('A dehydrated suspense component was completed without a hydrated node. ' + 'This is probably a bug in React.');\n              }\n\n              prepareToHydrateHostSuspenseInstance(workInProgress);\n              bubbleProperties(workInProgress);\n\n              {\n                if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                  var isTimedOutSuspense = nextState !== null;\n\n                  if (isTimedOutSuspense) {\n                    // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                    var primaryChildFragment = workInProgress.child;\n\n                    if (primaryChildFragment !== null) {\n                      // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                      workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                    }\n                  }\n                }\n              }\n\n              return null;\n            } else {\n              // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n              // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n              resetHydrationState();\n\n              if ((workInProgress.flags & DidCapture) === NoFlags) {\n                // This boundary did not suspend so it's now hydrated and unsuspended.\n                workInProgress.memoizedState = null;\n              } // If nothing suspended, we need to schedule an effect to mark this boundary\n              // as having hydrated so events know that they're free to be invoked.\n              // It's also a signal to replay events and the suspense callback.\n              // If something suspended, schedule an effect to attach retry listeners.\n              // So we might as well always mark this.\n\n\n              workInProgress.flags |= Update;\n              bubbleProperties(workInProgress);\n\n              {\n                if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                  var _isTimedOutSuspense = nextState !== null;\n\n                  if (_isTimedOutSuspense) {\n                    // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                    var _primaryChildFragment = workInProgress.child;\n\n                    if (_primaryChildFragment !== null) {\n                      // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                      workInProgress.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;\n                    }\n                  }\n                }\n              }\n\n              return null;\n            }\n          } // Successfully completed this tree. If this was a forced client render,\n          // there may have been recoverable errors during first hydration\n          // attempt. If so, add them to a queue so we can log them in the\n          // commit phase.\n\n\n          upgradeHydrationErrorsToRecoverable();\n        }\n\n        if ((workInProgress.flags & DidCapture) !== NoFlags) {\n          // Something suspended. Re-render with the fallback children.\n          workInProgress.lanes = renderLanes; // Do not reset the effect list.\n\n          if ( (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          } // Don't bubble properties in this case.\n\n\n          return workInProgress;\n        }\n\n        var nextDidTimeout = nextState !== null;\n        var prevDidTimeout = false;\n\n        if (current === null) {\n          popHydrationState(workInProgress);\n        } else {\n          var _prevState = current.memoizedState;\n          prevDidTimeout = _prevState !== null;\n        }\n        // an effect to toggle the subtree's visibility. When we switch from\n        // fallback -> primary, the inner Offscreen fiber schedules this effect\n        // as part of its normal complete phase. But when we switch from\n        // primary -> fallback, the inner Offscreen fiber does not have a complete\n        // phase. So we need to schedule its effect here.\n        //\n        // We also use this flag to connect/disconnect the effects, but the same\n        // logic applies: when re-connecting, the Offscreen fiber's complete\n        // phase will handle scheduling the effect. It's only when the fallback\n        // is active that we have to do anything special.\n\n\n        if (nextDidTimeout && !prevDidTimeout) {\n          var _offscreenFiber = workInProgress.child;\n          _offscreenFiber.flags |= Visibility; // TODO: This will still suspend a synchronous tree if anything\n          // in the concurrent tree already suspended during this render.\n          // This is a known bug.\n\n          if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n            // TODO: Move this back to throwException because this is too late\n            // if this is a large tree which is common for initial loads. We\n            // don't know if we should restart a render or not until we get\n            // this marker, and this is too late.\n            // If this render already had a ping or lower pri updates,\n            // and this is the first time we know we're going to suspend we\n            // should be able to immediately restart from within throwException.\n            var hasInvisibleChildContext = current === null && (workInProgress.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);\n\n            if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {\n              // If this was in an invisible tree or a new render, then showing\n              // this boundary is ok.\n              renderDidSuspend();\n            } else {\n              // Otherwise, we're going to have to hide content so we should\n              // suspend for longer if possible.\n              renderDidSuspendDelayIfPossible();\n            }\n          }\n        }\n\n        var wakeables = workInProgress.updateQueue;\n\n        if (wakeables !== null) {\n          // Schedule an effect to attach a retry listener to the promise.\n          // TODO: Move to passive phase\n          workInProgress.flags |= Update;\n        }\n\n        bubbleProperties(workInProgress);\n\n        {\n          if ((workInProgress.mode & ProfileMode) !== NoMode) {\n            if (nextDidTimeout) {\n              // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n              var _primaryChildFragment2 = workInProgress.child;\n\n              if (_primaryChildFragment2 !== null) {\n                // $FlowFixMe Flow doesn't support type casting in combination with the -= operator\n                workInProgress.treeBaseDuration -= _primaryChildFragment2.treeBaseDuration;\n              }\n            }\n          }\n        }\n\n        return null;\n      }\n\n    case HostPortal:\n      popHostContainer(workInProgress);\n      updateHostContainer(current, workInProgress);\n\n      if (current === null) {\n        preparePortalMount(workInProgress.stateNode.containerInfo);\n      }\n\n      bubbleProperties(workInProgress);\n      return null;\n\n    case ContextProvider:\n      // Pop provider fiber\n      var context = workInProgress.type._context;\n      popProvider(context, workInProgress);\n      bubbleProperties(workInProgress);\n      return null;\n\n    case IncompleteClassComponent:\n      {\n        // Same as class component case. I put it down here so that the tags are\n        // sequential to ensure this switch is compiled to a jump table.\n        var _Component = workInProgress.type;\n\n        if (isContextProvider(_Component)) {\n          popContext(workInProgress);\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case SuspenseListComponent:\n      {\n        popSuspenseContext(workInProgress);\n        var renderState = workInProgress.memoizedState;\n\n        if (renderState === null) {\n          // We're running in the default, \"independent\" mode.\n          // We don't do anything in this mode.\n          bubbleProperties(workInProgress);\n          return null;\n        }\n\n        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags;\n        var renderedTail = renderState.rendering;\n\n        if (renderedTail === null) {\n          // We just rendered the head.\n          if (!didSuspendAlready) {\n            // This is the first pass. We need to figure out if anything is still\n            // suspended in the rendered set.\n            // If new content unsuspended, but there's still some content that\n            // didn't. Then we need to do a second pass that forces everything\n            // to keep showing their fallbacks.\n            // We might be suspended if something in this render pass suspended, or\n            // something in the previous committed pass suspended. Otherwise,\n            // there's no chance so we can skip the expensive call to\n            // findFirstSuspended.\n            var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags);\n\n            if (!cannotBeSuspended) {\n              var row = workInProgress.child;\n\n              while (row !== null) {\n                var suspended = findFirstSuspended(row);\n\n                if (suspended !== null) {\n                  didSuspendAlready = true;\n                  workInProgress.flags |= DidCapture;\n                  cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\n                  // part of the second pass. In that case nothing will subscribe to\n                  // its thenables. Instead, we'll transfer its thenables to the\n                  // SuspenseList so that it can retry if they resolve.\n                  // There might be multiple of these in the list but since we're\n                  // going to wait for all of them anyway, it doesn't really matter\n                  // which ones gets to ping. In theory we could get clever and keep\n                  // track of how many dependencies remain but it gets tricky because\n                  // in the meantime, we can add/remove/change items and dependencies.\n                  // We might bail out of the loop before finding any but that\n                  // doesn't matter since that means that the other boundaries that\n                  // we did find already has their listeners attached.\n\n                  var newThenables = suspended.updateQueue;\n\n                  if (newThenables !== null) {\n                    workInProgress.updateQueue = newThenables;\n                    workInProgress.flags |= Update;\n                  } // Rerender the whole list, but this time, we'll force fallbacks\n                  // to stay in place.\n                  // Reset the effect flags before doing the second pass since that's now invalid.\n                  // Reset the child fibers to their original state.\n\n\n                  workInProgress.subtreeFlags = NoFlags;\n                  resetChildFibers(workInProgress, renderLanes); // Set up the Suspense Context to force suspense and immediately\n                  // rerender the children.\n\n                  pushSuspenseContext(workInProgress, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback)); // Don't bubble properties in this case.\n\n                  return workInProgress.child;\n                }\n\n                row = row.sibling;\n              }\n            }\n\n            if (renderState.tail !== null && now$1() > getRenderTargetTime()) {\n              // We have already passed our CPU deadline but we still have rows\n              // left in the tail. We'll just give up further attempts to render\n              // the main content and only render fallbacks.\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true;\n              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n              // to get it started back up to attempt the next item. While in terms\n              // of priority this work has the same priority as this current render,\n              // it's not part of the same transition once the transition has\n              // committed. If it's sync, we still want to yield so that it can be\n              // painted. Conceptually, this is really the same as pinging.\n              // We can use any RetryLane even if it's the one currently rendering\n              // since we're leaving it behind on this node.\n\n              workInProgress.lanes = SomeRetryLane;\n            }\n          } else {\n            cutOffTailIfNeeded(renderState, false);\n          } // Next we're going to render the tail.\n\n        } else {\n          // Append the rendered row to the child list.\n          if (!didSuspendAlready) {\n            var _suspended = findFirstSuspended(renderedTail);\n\n            if (_suspended !== null) {\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\n              // get lost if this row ends up dropped during a second pass.\n\n              var _newThenables = _suspended.updateQueue;\n\n              if (_newThenables !== null) {\n                workInProgress.updateQueue = _newThenables;\n                workInProgress.flags |= Update;\n              }\n\n              cutOffTailIfNeeded(renderState, true); // This might have been modified.\n\n              if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.\n              ) {\n                  // We're done.\n                  bubbleProperties(workInProgress);\n                  return null;\n                }\n            } else if ( // The time it took to render last row is greater than the remaining\n            // time we have to render. So rendering one more row would likely\n            // exceed it.\n            now$1() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {\n              // We have now passed our CPU deadline and we'll just give up further\n              // attempts to render the main content and only render fallbacks.\n              // The assumption is that this is usually faster.\n              workInProgress.flags |= DidCapture;\n              didSuspendAlready = true;\n              cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n              // to get it started back up to attempt the next item. While in terms\n              // of priority this work has the same priority as this current render,\n              // it's not part of the same transition once the transition has\n              // committed. If it's sync, we still want to yield so that it can be\n              // painted. Conceptually, this is really the same as pinging.\n              // We can use any RetryLane even if it's the one currently rendering\n              // since we're leaving it behind on this node.\n\n              workInProgress.lanes = SomeRetryLane;\n            }\n          }\n\n          if (renderState.isBackwards) {\n            // The effect list of the backwards tail will have been added\n            // to the end. This breaks the guarantee that life-cycles fire in\n            // sibling order but that isn't a strong guarantee promised by React.\n            // Especially since these might also just pop in during future commits.\n            // Append to the beginning of the list.\n            renderedTail.sibling = workInProgress.child;\n            workInProgress.child = renderedTail;\n          } else {\n            var previousSibling = renderState.last;\n\n            if (previousSibling !== null) {\n              previousSibling.sibling = renderedTail;\n            } else {\n              workInProgress.child = renderedTail;\n            }\n\n            renderState.last = renderedTail;\n          }\n        }\n\n        if (renderState.tail !== null) {\n          // We still have tail rows to render.\n          // Pop a row.\n          var next = renderState.tail;\n          renderState.rendering = next;\n          renderState.tail = next.sibling;\n          renderState.renderingStartTime = now$1();\n          next.sibling = null; // Restore the context.\n          // TODO: We can probably just avoid popping it instead and only\n          // setting it the first time we go from not suspended to suspended.\n\n          var suspenseContext = suspenseStackCursor.current;\n\n          if (didSuspendAlready) {\n            suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n          } else {\n            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n          }\n\n          pushSuspenseContext(workInProgress, suspenseContext); // Do a pass over the next row.\n          // Don't bubble properties in this case.\n\n          return next;\n        }\n\n        bubbleProperties(workInProgress);\n        return null;\n      }\n\n    case ScopeComponent:\n      {\n\n        break;\n      }\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      {\n        popRenderLanes(workInProgress);\n        var _nextState = workInProgress.memoizedState;\n        var nextIsHidden = _nextState !== null;\n\n        if (current !== null) {\n          var _prevState2 = current.memoizedState;\n          var prevIsHidden = _prevState2 !== null;\n\n          if (prevIsHidden !== nextIsHidden && ( // LegacyHidden doesn't do any hiding  it only pre-renders.\n          !enableLegacyHidden )) {\n            workInProgress.flags |= Visibility;\n          }\n        }\n\n        if (!nextIsHidden || (workInProgress.mode & ConcurrentMode) === NoMode) {\n          bubbleProperties(workInProgress);\n        } else {\n          // Don't bubble properties for hidden children unless we're rendering\n          // at offscreen priority.\n          if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {\n            bubbleProperties(workInProgress);\n\n            if (supportsMutation) {\n              // Check if there was an insertion or update in the hidden subtree.\n              // If so, we need to hide those nodes in the commit phase, so\n              // schedule a visibility effect.\n              if ( workInProgress.subtreeFlags & (Placement | Update)) {\n                workInProgress.flags |= Visibility;\n              }\n            }\n          }\n        }\n\n        return null;\n      }\n\n    case CacheComponent:\n      {\n\n        return null;\n      }\n\n    case TracingMarkerComponent:\n      {\n\n        return null;\n      }\n  }\n\n  throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar didReceiveUpdate = false;\nvar didWarnAboutBadClass;\nvar didWarnAboutModulePatternComponent;\nvar didWarnAboutContextTypeOnFunctionComponent;\nvar didWarnAboutGetDerivedStateOnFunctionComponent;\nvar didWarnAboutFunctionRefs;\nvar didWarnAboutReassigningProps;\nvar didWarnAboutRevealOrder;\nvar didWarnAboutTailOptions;\n\n{\n  didWarnAboutBadClass = {};\n  didWarnAboutModulePatternComponent = {};\n  didWarnAboutContextTypeOnFunctionComponent = {};\n  didWarnAboutGetDerivedStateOnFunctionComponent = {};\n  didWarnAboutFunctionRefs = {};\n  didWarnAboutReassigningProps = false;\n  didWarnAboutRevealOrder = {};\n  didWarnAboutTailOptions = {};\n}\n\nfunction reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n  }\n}\n\nfunction forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {\n  // This function is fork of reconcileChildren. It's used in cases where we\n  // want to reconcile without matching against the existing set. This has the\n  // effect of all current children being unmounted; even if the type and key\n  // are the same, the old child is unmounted and a new child is created.\n  //\n  // To do this, we're going to go through the reconcile algorithm twice. In\n  // the first pass, we schedule a deletion for all the current children by\n  // passing null.\n  workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we\n  // pass null in place of where we usually pass the current child set. This has\n  // the effect of remounting all children regardless of whether their\n  // identities match.\n\n  workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n}\n\nfunction updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens after the first render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      var innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  }\n\n  var render = Component.render;\n  var ref = workInProgress.ref; // The rest is a fork of updateFunctionComponent\n\n  var nextChildren;\n  var hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n\n  {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  {\n    ReactCurrentOwner$1.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n    hasId = checkDidRenderIdHook();\n\n    if ( workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        nextChildren = renderWithHooks(current, workInProgress, render, nextProps, ref, renderLanes);\n        hasId = checkDidRenderIdHook();\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n\n    setIsRendering(false);\n  }\n\n  {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  if (current === null) {\n    var type = Component.type;\n\n    if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.\n    Component.defaultProps === undefined) {\n      var resolvedType = type;\n\n      {\n        resolvedType = resolveFunctionForHotReloading(type);\n      } // If this is a plain function component without default props,\n      // and with only the default shallow comparison, we upgrade it\n      // to a SimpleMemoComponent to allow fast path updates.\n\n\n      workInProgress.tag = SimpleMemoComponent;\n      workInProgress.type = resolvedType;\n\n      {\n        validateFunctionComponentInDev(workInProgress, type);\n      }\n\n      return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);\n    }\n\n    {\n      var innerPropTypes = type.propTypes;\n\n      if (innerPropTypes) {\n        // Inner memo component props aren't currently validated in createElement.\n        // We could move it there, but we'd still need this for lazy code path.\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(type));\n      }\n    }\n\n    var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n    child.ref = workInProgress.ref;\n    child.return = workInProgress;\n    workInProgress.child = child;\n    return child;\n  }\n\n  {\n    var _type = Component.type;\n    var _innerPropTypes = _type.propTypes;\n\n    if (_innerPropTypes) {\n      // Inner memo component props aren't currently validated in createElement.\n      // We could move it there, but we'd still need this for lazy code path.\n      checkPropTypes(_innerPropTypes, nextProps, // Resolved props\n      'prop', getComponentNameFromType(_type));\n    }\n  }\n\n  var currentChild = current.child; // This is always exactly one child\n\n  var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n\n  if (!hasScheduledUpdateOrContext) {\n    // This will be the props with resolved defaultProps,\n    // unlike current.memoizedProps which will be the unresolved ones.\n    var prevProps = currentChild.memoizedProps; // Default to shallow comparison\n\n    var compare = Component.compare;\n    compare = compare !== null ? compare : shallowEqual;\n\n    if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  var newChild = createWorkInProgress(currentChild, nextProps);\n  newChild.ref = workInProgress.ref;\n  newChild.return = workInProgress;\n  workInProgress.child = newChild;\n  return newChild;\n}\n\nfunction updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  // TODO: current can be non-null here even if the component\n  // hasn't yet mounted. This happens when the inner render suspends.\n  // We'll need to figure out if this is fine or can cause issues.\n  {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      var outerMemoType = workInProgress.elementType;\n\n      if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {\n        // We warn when you define propTypes on lazy()\n        // so let's just skip over it to find memo() outer wrapper.\n        // Inner props for memo are validated later.\n        var lazyComponent = outerMemoType;\n        var payload = lazyComponent._payload;\n        var init = lazyComponent._init;\n\n        try {\n          outerMemoType = init(payload);\n        } catch (x) {\n          outerMemoType = null;\n        } // Inner propTypes will be validated in the function component path.\n\n\n        var outerPropTypes = outerMemoType && outerMemoType.propTypes;\n\n        if (outerPropTypes) {\n          checkPropTypes(outerPropTypes, nextProps, // Resolved (SimpleMemoComponent has no defaultProps)\n          'prop', getComponentNameFromType(outerMemoType));\n        }\n      }\n    }\n  }\n\n  if (current !== null) {\n    var prevProps = current.memoizedProps;\n\n    if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && ( // Prevent bailout if the implementation changed due to hot reload.\n     workInProgress.type === current.type )) {\n      didReceiveUpdate = false;\n\n      if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n        // The pending lanes were cleared at the beginning of beginWork. We're\n        // about to bail out, but there might be other lanes that weren't\n        // included in the current render. Usually, the priority level of the\n        // remaining updates is accumulated during the evaluation of the\n        // component (i.e. when processing the update queue). But since since\n        // we're bailing out early *without* evaluating the component, we need\n        // to account for it here, too. Reset to the value of the current fiber.\n        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n        // because a MemoComponent fiber does not have hooks or an update queue;\n        // rather, it wraps around an inner component, which may or may not\n        // contains hooks.\n        // TODO: Move the reset at in beginWork out of the common path so that\n        // this is no longer necessary.\n        workInProgress.lanes = current.lanes;\n        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n      } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      }\n    }\n  }\n\n  return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n}\n\nfunction updateOffscreenComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps;\n  var nextChildren = nextProps.children;\n  var prevState = current !== null ? current.memoizedState : null;\n\n  if (nextProps.mode === 'hidden' || enableLegacyHidden ) {\n    // Rendering a hidden tree.\n    if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n      // In legacy sync mode, don't defer the subtree. Render it now.\n      var nextState = {\n        baseLanes: NoLanes,\n        cachePool: null\n      };\n      workInProgress.memoizedState = nextState;\n\n      pushRenderLanes(workInProgress, renderLanes);\n    } else if (!includesSomeLane(renderLanes, OffscreenLane)) {\n      var spawnedCachePool = null; // We're hidden, and we're not rendering at Offscreen. We will bail out\n      // and resume this tree later.\n\n      var nextBaseLanes;\n\n      if (prevState !== null) {\n        var prevBaseLanes = prevState.baseLanes;\n        nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes);\n      } else {\n        nextBaseLanes = renderLanes;\n      } // Schedule this fiber to re-render at offscreen priority. Then bailout.\n\n\n      workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane);\n      var _nextState = {\n        baseLanes: nextBaseLanes,\n        cachePool: spawnedCachePool\n      };\n      workInProgress.memoizedState = _nextState;\n      workInProgress.updateQueue = null;\n      // to avoid a push/pop misalignment.\n\n\n      pushRenderLanes(workInProgress, nextBaseLanes);\n\n      return null;\n    } else {\n      // This is the second render. The surrounding visible content has already\n      // committed. Now we resume rendering the hidden tree.\n      // Rendering at offscreen, so we can clear the base lanes.\n      var _nextState2 = {\n        baseLanes: NoLanes,\n        cachePool: null\n      };\n      workInProgress.memoizedState = _nextState2; // Push the lanes that were skipped when we bailed out.\n\n      var subtreeRenderLanes = prevState !== null ? prevState.baseLanes : renderLanes;\n\n      pushRenderLanes(workInProgress, subtreeRenderLanes);\n    }\n  } else {\n    // Rendering a visible tree.\n    var _subtreeRenderLanes;\n\n    if (prevState !== null) {\n      // We're going from hidden -> visible.\n      _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes);\n\n\n      workInProgress.memoizedState = null;\n    } else {\n      // We weren't previously hidden, and we still aren't, so there's nothing\n      // special to do. Need to push to the stack regardless, though, to avoid\n      // a push/pop misalignment.\n      _subtreeRenderLanes = renderLanes;\n    }\n\n    pushRenderLanes(workInProgress, _subtreeRenderLanes);\n  }\n\n  {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n    return workInProgress.child;\n  }\n}\n\nfunction updateFragment(current, workInProgress, renderLanes) {\n  var nextChildren = workInProgress.pendingProps;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateMode(current, workInProgress, renderLanes) {\n  var nextChildren = workInProgress.pendingProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateProfiler(current, workInProgress, renderLanes) {\n  {\n    workInProgress.flags |= Update;\n\n    {\n      // Reset effect durations for the next eventual effect phase.\n      // These are reset during render to allow the DevTools commit hook a chance to read them,\n      var stateNode = workInProgress.stateNode;\n      stateNode.effectDuration = 0;\n      stateNode.passiveEffectDuration = 0;\n    }\n  }\n\n  var nextProps = workInProgress.pendingProps;\n  var nextChildren = nextProps.children;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction markRef$1(current, workInProgress) {\n  var ref = workInProgress.ref;\n\n  if (current === null && ref !== null || current !== null && current.ref !== ref) {\n    // Schedule a Ref effect\n    workInProgress.flags |= Ref;\n\n    {\n      workInProgress.flags |= RefStatic;\n    }\n  }\n}\n\nfunction updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  {\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      var innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  }\n\n  var context;\n\n  {\n    var unmaskedContext = getUnmaskedContext(workInProgress, Component, true);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  var nextChildren;\n  var hasId;\n  prepareToReadContext(workInProgress, renderLanes);\n\n  {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  {\n    ReactCurrentOwner$1.current = workInProgress;\n    setIsRendering(true);\n    nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n\n    if ( workInProgress.mode & StrictLegacyMode) {\n      setIsStrictModeForDevtools(true);\n\n      try {\n        nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n        hasId = checkDidRenderIdHook();\n      } finally {\n        setIsStrictModeForDevtools(false);\n      }\n    }\n\n    setIsRendering(false);\n  }\n\n  {\n    markComponentRenderStopped();\n  }\n\n  if (current !== null && !didReceiveUpdate) {\n    bailoutHooks(current, workInProgress, renderLanes);\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  if (getIsHydrating() && hasId) {\n    pushMaterializedTreeId(workInProgress);\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n  {\n    // This is used by DevTools to force a boundary to error.\n    switch (shouldError(workInProgress)) {\n      case false:\n        {\n          var _instance = workInProgress.stateNode;\n          var ctor = workInProgress.type; // TODO This way of resetting the error boundary state is a hack.\n          // Is there a better way to do this?\n\n          var tempInstance = new ctor(workInProgress.memoizedProps, _instance.context);\n          var state = tempInstance.state;\n\n          _instance.updater.enqueueSetState(_instance, state, null);\n\n          break;\n        }\n\n      case true:\n        {\n          workInProgress.flags |= DidCapture;\n          workInProgress.flags |= ShouldCapture; // eslint-disable-next-line react-internal/prod-error-codes\n\n          var error$1 = new Error('Simulated error coming from DevTools');\n          var lane = pickArbitraryLane(renderLanes);\n          workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n\n          var update = createClassErrorUpdate(workInProgress, createCapturedValue(error$1, workInProgress), lane);\n          enqueueCapturedUpdate(workInProgress, update);\n          break;\n        }\n    }\n\n    if (workInProgress.type !== workInProgress.elementType) {\n      // Lazy component props can't be validated in createElement\n      // because they're only guaranteed to be resolved here.\n      var innerPropTypes = Component.propTypes;\n\n      if (innerPropTypes) {\n        checkPropTypes(innerPropTypes, nextProps, // Resolved props\n        'prop', getComponentNameFromType(Component));\n      }\n    }\n  } // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n\n  var hasContext;\n\n  if (isContextProvider(Component)) {\n    hasContext = true;\n    pushContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  var instance = workInProgress.stateNode;\n  var shouldUpdate;\n\n  if (instance === null) {\n    if (current !== null) {\n      // A class component without an instance only mounts if it suspended\n      // inside a non-concurrent tree, in an inconsistent state. We want to\n      // treat it like a new mount, even though an empty version of it already\n      // committed. Disconnect the alternate pointers.\n      current.alternate = null;\n      workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n      workInProgress.flags |= Placement;\n    } // In the initial pass we might need to construct the instance.\n\n\n    constructClassInstance(workInProgress, Component, nextProps);\n    mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n    shouldUpdate = true;\n  } else if (current === null) {\n    // In a resume, we'll already have an instance we can reuse.\n    shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);\n  } else {\n    shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);\n  }\n\n  var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);\n\n  {\n    var inst = workInProgress.stateNode;\n\n    if (shouldUpdate && inst.props !== nextProps) {\n      if (!didWarnAboutReassigningProps) {\n        error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentNameFromFiber(workInProgress) || 'a component');\n      }\n\n      didWarnAboutReassigningProps = true;\n    }\n  }\n\n  return nextUnitOfWork;\n}\n\nfunction finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {\n  // Refs should update even if shouldComponentUpdate returns false\n  markRef$1(current, workInProgress);\n  var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags;\n\n  if (!shouldUpdate && !didCaptureError) {\n    // Context providers should defer to sCU for rendering\n    if (hasContext) {\n      invalidateContextProvider(workInProgress, Component, false);\n    }\n\n    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n\n  var instance = workInProgress.stateNode; // Rerender\n\n  ReactCurrentOwner$1.current = workInProgress;\n  var nextChildren;\n\n  if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {\n    // If we captured an error, but getDerivedStateFromError is not defined,\n    // unmount all the children. componentDidCatch will schedule an update to\n    // re-render a fallback. This is temporary until we migrate everyone to\n    // the new API.\n    // TODO: Warn in a future release.\n    nextChildren = null;\n\n    {\n      stopProfilerTimerIfRunning();\n    }\n  } else {\n    {\n      markComponentRenderStarted(workInProgress);\n    }\n\n    {\n      setIsRendering(true);\n      nextChildren = instance.render();\n\n      if ( workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          instance.render();\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n\n      setIsRendering(false);\n    }\n\n    {\n      markComponentRenderStopped();\n    }\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n\n  if (current !== null && didCaptureError) {\n    // If we're recovering from an error, reconcile without reusing any of\n    // the existing children. Conceptually, the normal children and the children\n    // that are shown on error are two different sets, so we shouldn't reuse\n    // normal children even if their identities match.\n    forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  } // Memoize state using the values we just used to render.\n  // TODO: Restructure so we never read values from the instance.\n\n\n  workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n\n  if (hasContext) {\n    invalidateContextProvider(workInProgress, Component, true);\n  }\n\n  return workInProgress.child;\n}\n\nfunction pushHostRootContext(workInProgress) {\n  var root = workInProgress.stateNode;\n\n  if (root.pendingContext) {\n    pushTopLevelContextObject(workInProgress, root.pendingContext, root.pendingContext !== root.context);\n  } else if (root.context) {\n    // Should always be set\n    pushTopLevelContextObject(workInProgress, root.context, false);\n  }\n\n  pushHostContainer(workInProgress, root.containerInfo);\n}\n\nfunction updateHostRoot(current, workInProgress, renderLanes) {\n  pushHostRootContext(workInProgress);\n\n  if (current === null) {\n    throw new Error('Should have a current fiber. This is a bug in React.');\n  }\n\n  var nextProps = workInProgress.pendingProps;\n  var prevState = workInProgress.memoizedState;\n  var prevChildren = prevState.element;\n  cloneUpdateQueue(current, workInProgress);\n  processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n  var nextState = workInProgress.memoizedState;\n  var root = workInProgress.stateNode;\n  // being called \"element\".\n\n\n  var nextChildren = nextState.element;\n\n  if (supportsHydration && prevState.isDehydrated) {\n    // This is a hydration root whose shell has not yet hydrated. We should\n    // attempt to hydrate.\n    // Flip isDehydrated to false to indicate that when this render\n    // finishes, the root will no longer be dehydrated.\n    var overrideState = {\n      element: nextChildren,\n      isDehydrated: false,\n      cache: nextState.cache,\n      transitions: nextState.transitions\n    };\n    var updateQueue = workInProgress.updateQueue; // `baseState` can always be the last state because the root doesn't\n    // have reducer functions so it doesn't need rebasing.\n\n    updateQueue.baseState = overrideState;\n    workInProgress.memoizedState = overrideState;\n\n    if (workInProgress.flags & ForceClientRender) {\n      // Something errored during a previous attempt to hydrate the shell, so we\n      // forced a client render.\n      var recoverableError = new Error('There was an error while hydrating. Because the error happened outside ' + 'of a Suspense boundary, the entire root will switch to ' + 'client rendering.');\n      return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError);\n    } else if (nextChildren !== prevChildren) {\n      var _recoverableError = new Error('This root received an early update, before anything was able ' + 'hydrate. Switched the entire root to client rendering.');\n\n      return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, _recoverableError);\n    } else {\n      // The outermost shell has not hydrated yet. Start hydrating.\n      enterHydrationState(workInProgress);\n\n      var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n      workInProgress.child = child;\n      var node = child;\n\n      while (node) {\n        // Mark each child as hydrating. This is a fast path to know whether this\n        // tree is part of a hydrating tree. This is used to determine if a child\n        // node has fully mounted yet, and for scheduling event replaying.\n        // Conceptually this is similar to Placement in that a new subtree is\n        // inserted into the React tree here. It just happens to not need DOM\n        // mutations because it already exists.\n        node.flags = node.flags & ~Placement | Hydrating;\n        node = node.sibling;\n      }\n    }\n  } else {\n    // Root is not dehydrated. Either this is a client-only root, or it\n    // already hydrated.\n    resetHydrationState();\n\n    if (nextChildren === prevChildren) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n\n  return workInProgress.child;\n}\n\nfunction mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes, recoverableError) {\n  // Revert to client rendering.\n  resetHydrationState();\n  queueHydrationError(recoverableError);\n  workInProgress.flags |= ForceClientRender;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateHostComponent$1(current, workInProgress, renderLanes) {\n  pushHostContext(workInProgress);\n\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  }\n\n  var type = workInProgress.type;\n  var nextProps = workInProgress.pendingProps;\n  var prevProps = current !== null ? current.memoizedProps : null;\n  var nextChildren = nextProps.children;\n  var isDirectTextChild = shouldSetTextContent(type, nextProps);\n\n  if (isDirectTextChild) {\n    // We special case a direct text child of a host node. This is a common\n    // case. We won't handle it as a reified child. We will instead handle\n    // this in the host environment that also has access to this prop. That\n    // avoids allocating another HostText fiber and traversing it.\n    nextChildren = null;\n  } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n    // If we're switching from a direct text child to a normal child, or to\n    // empty, we need to schedule the text content to be reset.\n    workInProgress.flags |= ContentReset;\n  }\n\n  markRef$1(current, workInProgress);\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction updateHostText$1(current, workInProgress) {\n  if (current === null) {\n    tryToClaimNextHydratableInstance(workInProgress);\n  } // Nothing to do here. This is terminal. We'll do the completion step\n  // immediately after.\n\n\n  return null;\n}\n\nfunction mountLazyComponent(_current, workInProgress, elementType, renderLanes) {\n  if (_current !== null) {\n    // A lazy component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.flags |= Placement;\n  }\n\n  var props = workInProgress.pendingProps;\n  var lazyComponent = elementType;\n  var payload = lazyComponent._payload;\n  var init = lazyComponent._init;\n  var Component = init(payload); // Store the unwrapped component in the type.\n\n  workInProgress.type = Component;\n  var resolvedTag = workInProgress.tag = resolveLazyComponentTag(Component);\n  var resolvedProps = resolveDefaultProps(Component, props);\n  var child;\n\n  switch (resolvedTag) {\n    case FunctionComponent:\n      {\n        {\n          validateFunctionComponentInDev(workInProgress, Component);\n          workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n        }\n\n        child = updateFunctionComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case ClassComponent:\n      {\n        {\n          workInProgress.type = Component = resolveClassForHotReloading(Component);\n        }\n\n        child = updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case ForwardRef:\n      {\n        {\n          workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n        }\n\n        child = updateForwardRef(null, workInProgress, Component, resolvedProps, renderLanes);\n        return child;\n      }\n\n    case MemoComponent:\n      {\n        {\n          if (workInProgress.type !== workInProgress.elementType) {\n            var outerPropTypes = Component.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, resolvedProps, // Resolved for outer only\n              'prop', getComponentNameFromType(Component));\n            }\n          }\n        }\n\n        child = updateMemoComponent(null, workInProgress, Component, resolveDefaultProps(Component.type, resolvedProps), // The inner type can have defaults too\n        renderLanes);\n        return child;\n      }\n  }\n\n  var hint = '';\n\n  {\n    if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {\n      hint = ' Did you wrap a component in React.lazy() more than once?';\n    }\n  } // This message intentionally doesn't mention ForwardRef or MemoComponent\n  // because the fact that it's a separate type of work is an\n  // implementation detail.\n\n\n  throw new Error(\"Element type is invalid. Received a promise that resolves to: \" + Component + \". \" + (\"Lazy element type must resolve to a class or function.\" + hint));\n}\n\nfunction mountIncompleteClassComponent(_current, workInProgress, Component, nextProps, renderLanes) {\n  if (_current !== null) {\n    // An incomplete component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.flags |= Placement;\n  } // Promote the fiber to a class and try rendering again.\n\n\n  workInProgress.tag = ClassComponent; // The rest of this function is a fork of `updateClassComponent`\n  // Push context providers early to prevent context stack mismatches.\n  // During mounting we don't know the child context yet as the instance doesn't exist.\n  // We will invalidate the child context in finishClassComponent() right after rendering.\n\n  var hasContext;\n\n  if (isContextProvider(Component)) {\n    hasContext = true;\n    pushContextProvider(workInProgress);\n  } else {\n    hasContext = false;\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  constructClassInstance(workInProgress, Component, nextProps);\n  mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n  return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n}\n\nfunction mountIndeterminateComponent(_current, workInProgress, Component, renderLanes) {\n  if (_current !== null) {\n    // An indeterminate component only mounts if it suspended inside a non-\n    // concurrent tree, in an inconsistent state. We want to treat it like\n    // a new mount, even though an empty version of it already committed.\n    // Disconnect the alternate pointers.\n    _current.alternate = null;\n    workInProgress.alternate = null; // Since this is conceptually a new fiber, schedule a Placement effect\n\n    workInProgress.flags |= Placement;\n  }\n\n  var props = workInProgress.pendingProps;\n  var context;\n\n  {\n    var unmaskedContext = getUnmaskedContext(workInProgress, Component, false);\n    context = getMaskedContext(workInProgress, unmaskedContext);\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  var value;\n  var hasId;\n\n  {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  {\n    if (Component.prototype && typeof Component.prototype.render === 'function') {\n      var componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutBadClass[componentName]) {\n        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n\n        didWarnAboutBadClass[componentName] = true;\n      }\n    }\n\n    if (workInProgress.mode & StrictLegacyMode) {\n      ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n    }\n\n    setIsRendering(true);\n    ReactCurrentOwner$1.current = workInProgress;\n    value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n    hasId = checkDidRenderIdHook();\n    setIsRendering(false);\n  }\n\n  {\n    markComponentRenderStopped();\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n\n  {\n    // Support for module components is deprecated and is removed behind a flag.\n    // Whether or not it would crash later, we want to show a good message in DEV first.\n    if (typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n      var _componentName = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutModulePatternComponent[_componentName]) {\n        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', _componentName, _componentName, _componentName);\n\n        didWarnAboutModulePatternComponent[_componentName] = true;\n      }\n    }\n  }\n\n  if ( // Run these checks in production only if the flag is off.\n  // Eventually we'll delete this branch altogether.\n   typeof value === 'object' && value !== null && typeof value.render === 'function' && value.$$typeof === undefined) {\n    {\n      var _componentName2 = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutModulePatternComponent[_componentName2]) {\n        error('The <%s /> component appears to be a function component that returns a class instance. ' + 'Change %s to a class that extends React.Component instead. ' + \"If you can't use a class try assigning the prototype on the function as a workaround. \" + \"`%s.prototype = React.Component.prototype`. Don't use an arrow function since it \" + 'cannot be called with `new` by React.', _componentName2, _componentName2, _componentName2);\n\n        didWarnAboutModulePatternComponent[_componentName2] = true;\n      }\n    } // Proceed under the assumption that this is a class instance\n\n\n    workInProgress.tag = ClassComponent; // Throw out any hooks that were used.\n\n    workInProgress.memoizedState = null;\n    workInProgress.updateQueue = null; // Push context providers early to prevent context stack mismatches.\n    // During mounting we don't know the child context yet as the instance doesn't exist.\n    // We will invalidate the child context in finishClassComponent() right after rendering.\n\n    var hasContext = false;\n\n    if (isContextProvider(Component)) {\n      hasContext = true;\n      pushContextProvider(workInProgress);\n    } else {\n      hasContext = false;\n    }\n\n    workInProgress.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;\n    initializeUpdateQueue(workInProgress);\n    adoptClassInstance(workInProgress, value);\n    mountClassInstance(workInProgress, Component, props, renderLanes);\n    return finishClassComponent(null, workInProgress, Component, true, hasContext, renderLanes);\n  } else {\n    // Proceed under the assumption that this is a function component\n    workInProgress.tag = FunctionComponent;\n\n    {\n\n      if ( workInProgress.mode & StrictLegacyMode) {\n        setIsStrictModeForDevtools(true);\n\n        try {\n          value = renderWithHooks(null, workInProgress, Component, props, context, renderLanes);\n          hasId = checkDidRenderIdHook();\n        } finally {\n          setIsStrictModeForDevtools(false);\n        }\n      }\n    }\n\n    if (getIsHydrating() && hasId) {\n      pushMaterializedTreeId(workInProgress);\n    }\n\n    reconcileChildren(null, workInProgress, value, renderLanes);\n\n    {\n      validateFunctionComponentInDev(workInProgress, Component);\n    }\n\n    return workInProgress.child;\n  }\n}\n\nfunction validateFunctionComponentInDev(workInProgress, Component) {\n  {\n    if (Component) {\n      if (Component.childContextTypes) {\n        error('%s(...): childContextTypes cannot be defined on a function component.', Component.displayName || Component.name || 'Component');\n      }\n    }\n\n    if (workInProgress.ref !== null) {\n      var info = '';\n      var ownerName = getCurrentFiberOwnerNameInDevOrNull();\n\n      if (ownerName) {\n        info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n      }\n\n      var warningKey = ownerName || '';\n      var debugSource = workInProgress._debugSource;\n\n      if (debugSource) {\n        warningKey = debugSource.fileName + ':' + debugSource.lineNumber;\n      }\n\n      if (!didWarnAboutFunctionRefs[warningKey]) {\n        didWarnAboutFunctionRefs[warningKey] = true;\n\n        error('Function components cannot be given refs. ' + 'Attempts to access this ref will fail. ' + 'Did you mean to use React.forwardRef()?%s', info);\n      }\n    }\n\n    if (typeof Component.getDerivedStateFromProps === 'function') {\n      var _componentName3 = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {\n        error('%s: Function components do not support getDerivedStateFromProps.', _componentName3);\n\n        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;\n      }\n    }\n\n    if (typeof Component.contextType === 'object' && Component.contextType !== null) {\n      var _componentName4 = getComponentNameFromType(Component) || 'Unknown';\n\n      if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {\n        error('%s: Function components do not support contextType.', _componentName4);\n\n        didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;\n      }\n    }\n  }\n}\n\nvar SUSPENDED_MARKER = {\n  dehydrated: null,\n  treeContext: null,\n  retryLane: NoLane\n};\n\nfunction mountSuspenseOffscreenState(renderLanes) {\n  return {\n    baseLanes: renderLanes,\n    cachePool: getSuspendedCache()\n  };\n}\n\nfunction updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {\n  var cachePool = null;\n\n  return {\n    baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n    cachePool: cachePool\n  };\n} // TODO: Probably should inline this back\n\n\nfunction shouldRemainOnFallback(suspenseContext, current, workInProgress, renderLanes) {\n  // If we're already showing a fallback, there are cases where we need to\n  // remain on that fallback regardless of whether the content has resolved.\n  // For example, SuspenseList coordinates when nested content appears.\n  if (current !== null) {\n    var suspenseState = current.memoizedState;\n\n    if (suspenseState === null) {\n      // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n      // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n      // Note: This is a factoring smell. Can't remain on a fallback if there's\n      // no fallback to remain on.\n      return false;\n    }\n  } // Not currently showing content. Consult the Suspense context.\n\n\n  return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n}\n\nfunction getRemainingWorkInPrimaryTree(current, renderLanes) {\n  // TODO: Should not remove render lanes that were pinged during this render\n  return removeLanes(current.childLanes, renderLanes);\n}\n\nfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n\n  {\n    if (shouldSuspend(workInProgress)) {\n      workInProgress.flags |= DidCapture;\n    }\n  }\n\n  var suspenseContext = suspenseStackCursor.current;\n  var showFallback = false;\n  var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags;\n\n  if (didSuspend || shouldRemainOnFallback(suspenseContext, current)) {\n    // Something in this boundary's subtree already suspended. Switch to\n    // rendering the fallback children.\n    showFallback = true;\n    workInProgress.flags &= ~DidCapture;\n  } else {\n    // Attempting the main content\n    if (current === null || current.memoizedState !== null) {\n      // This is a new mount or this boundary is already showing a fallback state.\n      // Mark this subtree context as having at least one invisible parent that could\n      // handle the fallback state.\n      // Avoided boundaries are not considered since they cannot handle preferred fallback states.\n      {\n        suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);\n      }\n    }\n  }\n\n  suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  pushSuspenseContext(workInProgress, suspenseContext); // OK, the next part is confusing. We're about to reconcile the Suspense\n  // boundary's children. This involves some custom reconciliation logic. Two\n  // main reasons this is so complicated.\n  //\n  // First, Legacy Mode has different semantics for backwards compatibility. The\n  // primary tree will commit in an inconsistent state, so when we do the\n  // second pass to render the fallback, we do some exceedingly, uh, clever\n  // hacks to make that not totally break. Like transferring effects and\n  // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n  // because we bailout on the primary tree completely and leave it in its old\n  // state, no effects. Same as what we do for Offscreen (except that\n  // Offscreen doesn't have the first render pass).\n  //\n  // Second is hydration. During hydration, the Suspense fiber has a slightly\n  // different layout, where the child points to a dehydrated fragment, which\n  // contains the DOM rendered by the server.\n  //\n  // Third, even if you set all that aside, Suspense is like error boundaries in\n  // that we first we try to render one tree, and if that fails, we render again\n  // and switch to a different tree. Like a try/catch block. So we have to track\n  // which branch we're currently rendering. Ideally we would model this using\n  // a stack.\n\n  if (current === null) {\n    // Initial mount\n    // If we're currently hydrating, try to hydrate this boundary.\n    tryToClaimNextHydratableInstance(workInProgress); // This could've been a dehydrated suspense component.\n\n    {\n      var suspenseState = workInProgress.memoizedState;\n\n      if (suspenseState !== null) {\n        var dehydrated = suspenseState.dehydrated;\n\n        if (dehydrated !== null) {\n          return mountDehydratedSuspenseComponent(workInProgress, dehydrated);\n        }\n      }\n    }\n\n    var nextPrimaryChildren = nextProps.children;\n    var nextFallbackChildren = nextProps.fallback;\n\n    if (showFallback) {\n      var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n      var primaryChildFragment = workInProgress.child;\n      primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n      workInProgress.memoizedState = SUSPENDED_MARKER;\n      return fallbackFragment;\n    } else {\n      return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);\n    }\n  } else {\n    // This is an update.\n    // If the current fiber has a SuspenseState, that means it's already showing\n    // a fallback.\n    var prevState = current.memoizedState;\n\n    if (prevState !== null) {\n      // The current tree is already showing a fallback\n      // Special path for hydration\n      {\n        var _dehydrated = prevState.dehydrated;\n\n        if (_dehydrated !== null) {\n          if (!didSuspend) {\n            return updateDehydratedSuspenseComponent(current, workInProgress, _dehydrated, prevState, renderLanes);\n          } else if (workInProgress.flags & ForceClientRender) {\n            // Something errored during hydration. Try again without hydrating.\n            workInProgress.flags &= ~ForceClientRender;\n            return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, new Error('There was an error while hydrating this Suspense boundary. ' + 'Switched to client rendering.'));\n          } else if (workInProgress.memoizedState !== null) {\n            // Something suspended and we should still be in dehydrated mode.\n            // Leave the existing child in place.\n            workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n            // but the normal suspense pass doesn't.\n\n            workInProgress.flags |= DidCapture;\n            return null;\n          } else {\n            // Suspended but we should no longer be in dehydrated mode.\n            // Therefore we now have to render the fallback.\n            var _nextPrimaryChildren = nextProps.children;\n            var _nextFallbackChildren = nextProps.fallback;\n            var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, _nextPrimaryChildren, _nextFallbackChildren, renderLanes);\n            var _primaryChildFragment2 = workInProgress.child;\n            _primaryChildFragment2.memoizedState = mountSuspenseOffscreenState(renderLanes);\n            workInProgress.memoizedState = SUSPENDED_MARKER;\n            return fallbackChildFragment;\n          }\n        }\n      }\n\n      if (showFallback) {\n        var _nextFallbackChildren2 = nextProps.fallback;\n        var _nextPrimaryChildren2 = nextProps.children;\n\n        var _fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren2, _nextFallbackChildren2, renderLanes);\n\n        var _primaryChildFragment3 = workInProgress.child;\n        var prevOffscreenState = current.child.memoizedState;\n        _primaryChildFragment3.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n        _primaryChildFragment3.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes);\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        return _fallbackChildFragment;\n      } else {\n        var _nextPrimaryChildren3 = nextProps.children;\n\n        var _primaryChildFragment4 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren3, renderLanes);\n\n        workInProgress.memoizedState = null;\n        return _primaryChildFragment4;\n      }\n    } else {\n      // The current tree is not already showing a fallback.\n      if (showFallback) {\n        // Timed out.\n        var _nextFallbackChildren3 = nextProps.fallback;\n        var _nextPrimaryChildren4 = nextProps.children;\n\n        var _fallbackChildFragment2 = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren4, _nextFallbackChildren3, renderLanes);\n\n        var _primaryChildFragment5 = workInProgress.child;\n        var _prevOffscreenState = current.child.memoizedState;\n        _primaryChildFragment5.memoizedState = _prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(_prevOffscreenState, renderLanes);\n        _primaryChildFragment5.childLanes = getRemainingWorkInPrimaryTree(current, renderLanes); // Skip the primary children, and continue working on the\n        // fallback children.\n\n        workInProgress.memoizedState = SUSPENDED_MARKER;\n        return _fallbackChildFragment2;\n      } else {\n        // Still haven't timed out. Continue rendering the children, like we\n        // normally do.\n        var _nextPrimaryChildren5 = nextProps.children;\n\n        var _primaryChildFragment6 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren5, renderLanes);\n\n        workInProgress.memoizedState = null;\n        return _primaryChildFragment6;\n      }\n    }\n  }\n}\n\nfunction mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {\n  var mode = workInProgress.mode;\n  var primaryChildProps = {\n    mode: 'visible',\n    children: primaryChildren\n  };\n  var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n  primaryChildFragment.return = workInProgress;\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  var mode = workInProgress.mode;\n  var progressedPrimaryFragment = workInProgress.child;\n  var primaryChildProps = {\n    mode: 'hidden',\n    children: primaryChildren\n  };\n  var primaryChildFragment;\n  var fallbackChildFragment;\n\n  if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {\n    // In legacy mode, we commit the primary tree as if it successfully\n    // completed, even though it's in an inconsistent state.\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if ( workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration = 0;\n      primaryChildFragment.treeBaseDuration = 0;\n    }\n\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n  } else {\n    primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n  }\n\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n  return fallbackChildFragment;\n}\n\nfunction mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {\n  // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n  // this wrapper function to constrain it.\n  return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n}\n\nfunction updateWorkInProgressOffscreenFiber(current, offscreenProps) {\n  // The props argument to `createWorkInProgress` is `any` typed, so we use this\n  // wrapper function to constrain it.\n  return createWorkInProgress(current, offscreenProps);\n}\n\nfunction updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {\n  var currentPrimaryChildFragment = current.child;\n  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n  var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n    mode: 'visible',\n    children: primaryChildren\n  });\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    primaryChildFragment.lanes = renderLanes;\n  }\n\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = null;\n\n  if (currentFallbackChildFragment !== null) {\n    // Delete the fallback child fragment\n    var deletions = workInProgress.deletions;\n\n    if (deletions === null) {\n      workInProgress.deletions = [currentFallbackChildFragment];\n      workInProgress.flags |= ChildDeletion;\n    } else {\n      deletions.push(currentFallbackChildFragment);\n    }\n  }\n\n  workInProgress.child = primaryChildFragment;\n  return primaryChildFragment;\n}\n\nfunction updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  var mode = workInProgress.mode;\n  var currentPrimaryChildFragment = current.child;\n  var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n  var primaryChildProps = {\n    mode: 'hidden',\n    children: primaryChildren\n  };\n  var primaryChildFragment;\n\n  if ( // In legacy mode, we commit the primary tree as if it successfully\n  // completed, even though it's in an inconsistent state.\n  (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was\n  // already cloned. In legacy mode, the only case where this isn't true is\n  // when DevTools forces us to display a fallback; we skip the first render\n  // pass entirely and go straight to rendering the fallback. (In Concurrent\n  // Mode, SuspenseList can also trigger this scenario, but this is a legacy-\n  // only codepath.)\n  workInProgress.child !== currentPrimaryChildFragment) {\n    var progressedPrimaryFragment = workInProgress.child;\n    primaryChildFragment = progressedPrimaryFragment;\n    primaryChildFragment.childLanes = NoLanes;\n    primaryChildFragment.pendingProps = primaryChildProps;\n\n    if ( workInProgress.mode & ProfileMode) {\n      // Reset the durations from the first pass so they aren't included in the\n      // final amounts. This seems counterintuitive, since we're intentionally\n      // not measuring part of the render phase, but this makes it match what we\n      // do in Concurrent Mode.\n      primaryChildFragment.actualDuration = 0;\n      primaryChildFragment.actualStartTime = -1;\n      primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;\n      primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;\n    }\n    // However, since we're going to remain on the fallback, we no longer want\n    // to delete it.\n\n\n    workInProgress.deletions = null;\n  } else {\n    primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);\n    // (We don't do this in legacy mode, because in legacy mode we don't re-use\n    // the current tree; see previous branch.)\n\n\n    primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n  }\n\n  var fallbackChildFragment;\n\n  if (currentFallbackChildFragment !== null) {\n    fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n  } else {\n    fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already\n    // mounted but this is a new fiber.\n\n    fallbackChildFragment.flags |= Placement;\n  }\n\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n  return fallbackChildFragment;\n}\n\nfunction retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, recoverableError) {\n  // Falling back to client rendering. Because this has performance\n  // implications, it's considered a recoverable error, even though the user\n  // likely won't observe anything wrong with the UI.\n  //\n  // The error is passed in as an argument to enforce that every caller provide\n  // a custom message, or explicitly opt out (currently the only path that opts\n  // out is legacy mode; every concurrent path provides an error).\n  if (recoverableError !== null) {\n    queueHydrationError(recoverableError);\n  } // This will add the old fiber to the deletion list\n\n\n  reconcileChildFibers(workInProgress, current.child, null, renderLanes); // We're now not suspended nor dehydrated.\n\n  var nextProps = workInProgress.pendingProps;\n  var primaryChildren = nextProps.children;\n  var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Needs a placement effect because the parent (the Suspense boundary) already\n  // mounted but this is a new fiber.\n\n  primaryChildFragment.flags |= Placement;\n  workInProgress.memoizedState = null;\n  return primaryChildFragment;\n}\n\nfunction mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n  var fiberMode = workInProgress.mode;\n  var primaryChildProps = {\n    mode: 'visible',\n    children: primaryChildren\n  };\n  var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);\n  var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null); // Needs a placement effect because the parent (the Suspense\n  // boundary) already mounted but this is a new fiber.\n\n  fallbackChildFragment.flags |= Placement;\n  primaryChildFragment.return = workInProgress;\n  fallbackChildFragment.return = workInProgress;\n  primaryChildFragment.sibling = fallbackChildFragment;\n  workInProgress.child = primaryChildFragment;\n\n  if ((workInProgress.mode & ConcurrentMode) !== NoMode) {\n    // We will have dropped the effect list which contains the\n    // deletion. We need to reconcile to delete the current child.\n    reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n  }\n\n  return fallbackChildFragment;\n}\n\nfunction mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {\n  // During the first pass, we'll bail out and not drill into the children.\n  // Instead, we'll leave the content in place and try to hydrate it later.\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    {\n      error('Cannot hydrate Suspense in legacy mode. Switch from ' + 'ReactDOM.hydrate(element, container) to ' + 'ReactDOMClient.hydrateRoot(container, <App />)' + '.render(element) or remove the Suspense components from ' + 'the server rendered components.');\n    }\n\n    workInProgress.lanes = laneToLanes(SyncLane);\n  } else if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This is a client-only boundary. Since we won't get any content from the server\n    // for this, we need to schedule that at a higher priority based on when it would\n    // have timed out. In theory we could render it in this pass but it would have the\n    // wrong priority associated with it and will prevent hydration of parent path.\n    // Instead, we'll leave work left on it to render it in a separate commit.\n    // TODO This time should be the time at which the server rendered response that is\n    // a parent to this boundary was displayed. However, since we currently don't have\n    // a protocol to transfer that time, we'll just estimate it by using the current\n    // time. This will mean that Suspense timeouts are slightly shifted to later than\n    // they should be.\n    // Schedule a normal pri update to render this content.\n    workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n  } else {\n    // We'll continue hydrating the rest at offscreen priority since we'll already\n    // be showing the right content coming from the server, it is no rush.\n    workInProgress.lanes = laneToLanes(OffscreenLane);\n  }\n\n  return null;\n}\n\nfunction updateDehydratedSuspenseComponent(current, workInProgress, suspenseInstance, suspenseState, renderLanes) {\n  // We should never be hydrating at this point because it is the first pass,\n  // but after we've already committed once.\n  warnIfHydrating();\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, // TODO: When we delete legacy mode, we should make this error argument\n    // required  every concurrent mode path that causes hydration to\n    // de-opt to client rendering should have an error message.\n    null);\n  }\n\n  if (isSuspenseInstanceFallback(suspenseInstance)) {\n    // This boundary is in a permanent fallback state. In this case, we'll never\n    // get an update and we'll never be able to hydrate the final content. Let's just try the\n    // client side render instead.\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, // TODO: The server should serialize the error message so we can log it\n    // here on the client. Or, in production, a hash/id that corresponds to\n    // the error.\n    new Error('The server could not finish this Suspense boundary, likely ' + 'due to an error during server rendering. Switched to ' + 'client rendering.'));\n  }\n  // any context has changed, we need to treat is as if the input might have changed.\n\n\n  var hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n\n  if (didReceiveUpdate || hasContextChanged) {\n    // This boundary has changed since the first render. This means that we are now unable to\n    // hydrate it. We might still be able to hydrate it using a higher priority lane.\n    var root = getWorkInProgressRoot();\n\n    if (root !== null) {\n      var attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);\n\n      if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n        // Intentionally mutating since this render will get interrupted. This\n        // is one of the very rare times where we mutate the current tree\n        // during the render phase.\n        suspenseState.retryLane = attemptHydrationAtLane; // TODO: Ideally this would inherit the event time of the current render\n\n        var eventTime = NoTimestamp;\n        scheduleUpdateOnFiber(current, attemptHydrationAtLane, eventTime);\n      }\n    } // If we have scheduled higher pri work above, this will probably just abort the render\n    // since we now have higher priority work, but in case it doesn't, we need to prepare to\n    // render something, if we time out. Even if that requires us to delete everything and\n    // skip hydration.\n    // Delay having to do this as long as the suspense timeout allows us.\n\n\n    renderDidSuspendDelayIfPossible();\n    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes, new Error('This Suspense boundary received an update before it finished ' + 'hydrating. This caused the boundary to switch to client rendering. ' + 'The usual way to fix this is to wrap the original update ' + 'in startTransition.'));\n  } else if (isSuspenseInstancePending(suspenseInstance)) {\n    // This component is still pending more data from the server, so we can't hydrate its\n    // content. We treat it as if this component suspended itself. It might seem as if\n    // we could just try to render it client-side instead. However, this will perform a\n    // lot of unnecessary work and is unlikely to complete since it often will suspend\n    // on missing data anyway. Additionally, the server might be able to render more\n    // than we can on the client yet. In that case we'd end up with more fallback states\n    // on the client than if we just leave it alone. If the server times out or errors\n    // these should update this boundary to the permanent Fallback state instead.\n    // Mark it as having captured (i.e. suspended).\n    workInProgress.flags |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n\n    workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n\n    var retry = retryDehydratedSuspenseBoundary.bind(null, current);\n    registerSuspenseInstanceRetry(suspenseInstance, retry);\n    return null;\n  } else {\n    // This is the first attempt.\n    reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);\n    var nextProps = workInProgress.pendingProps;\n    var primaryChildren = nextProps.children;\n    var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Mark the children as hydrating. This is a fast path to know whether this\n    // tree is part of a hydrating tree. This is used to determine if a child\n    // node has fully mounted yet, and for scheduling event replaying.\n    // Conceptually this is similar to Placement in that a new subtree is\n    // inserted into the React tree here. It just happens to not need DOM\n    // mutations because it already exists.\n\n    primaryChildFragment.flags |= Hydrating;\n    return primaryChildFragment;\n  }\n}\n\nfunction scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n  fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n  var alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n  }\n\n  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n}\n\nfunction propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {\n  // Mark any Suspense boundaries with fallbacks as having work to do.\n  // If they were previously forced into fallbacks, they may now be able\n  // to unblock.\n  var node = firstChild;\n\n  while (node !== null) {\n    if (node.tag === SuspenseComponent) {\n      var state = node.memoizedState;\n\n      if (state !== null) {\n        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n      }\n    } else if (node.tag === SuspenseListComponent) {\n      // If the tail is hidden there might not be an Suspense boundaries\n      // to schedule work on. In this case we have to schedule it on the\n      // list itself.\n      // We don't have to traverse to the children of the list since\n      // the list will propagate the change when it rerenders.\n      scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n    } else if (node.child !== null) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === workInProgress) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === workInProgress) {\n        return;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction findLastContentRow(firstChild) {\n  // This is going to find the last row among these children that is already\n  // showing content on the screen, as opposed to being in fallback state or\n  // new. If a row has multiple Suspense boundaries, any of them being in the\n  // fallback state, counts as the whole row being in a fallback state.\n  // Note that the \"rows\" will be workInProgress, but any nested children\n  // will still be current since we haven't rendered them yet. The mounted\n  // order may not be the same as the new order. We use the new order.\n  var row = firstChild;\n  var lastContentRow = null;\n\n  while (row !== null) {\n    var currentRow = row.alternate; // New rows can't be content rows.\n\n    if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n      lastContentRow = row;\n    }\n\n    row = row.sibling;\n  }\n\n  return lastContentRow;\n}\n\nfunction validateRevealOrder(revealOrder) {\n  {\n    if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {\n      didWarnAboutRevealOrder[revealOrder] = true;\n\n      if (typeof revealOrder === 'string') {\n        switch (revealOrder.toLowerCase()) {\n          case 'together':\n          case 'forwards':\n          case 'backwards':\n            {\n              error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n\n              break;\n            }\n\n          case 'forward':\n          case 'backward':\n            {\n              error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n\n              break;\n            }\n\n          default:\n            error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n\n            break;\n        }\n      } else {\n        error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n      }\n    }\n  }\n}\n\nfunction validateTailOptions(tailMode, revealOrder) {\n  {\n    if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n      if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n        didWarnAboutTailOptions[tailMode] = true;\n\n        error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n      } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n        didWarnAboutTailOptions[tailMode] = true;\n\n        error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n      }\n    }\n  }\n}\n\nfunction validateSuspenseListNestedChild(childSlot, index) {\n  {\n    var isAnArray = isArray(childSlot);\n    var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === 'function';\n\n    if (isAnArray || isIterable) {\n      var type = isAnArray ? 'array' : 'iterable';\n\n      error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);\n\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction validateSuspenseListChildren(children, revealOrder) {\n  {\n    if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {\n      if (isArray(children)) {\n        for (var i = 0; i < children.length; i++) {\n          if (!validateSuspenseListNestedChild(children[i], i)) {\n            return;\n          }\n        }\n      } else {\n        var iteratorFn = getIteratorFn(children);\n\n        if (typeof iteratorFn === 'function') {\n          var childrenIterator = iteratorFn.call(children);\n\n          if (childrenIterator) {\n            var step = childrenIterator.next();\n            var _i = 0;\n\n            for (; !step.done; step = childrenIterator.next()) {\n              if (!validateSuspenseListNestedChild(step.value, _i)) {\n                return;\n              }\n\n              _i++;\n            }\n          }\n        } else {\n          error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);\n        }\n      }\n    }\n  }\n}\n\nfunction initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n  var renderState = workInProgress.memoizedState;\n\n  if (renderState === null) {\n    workInProgress.memoizedState = {\n      isBackwards: isBackwards,\n      rendering: null,\n      renderingStartTime: 0,\n      last: lastContentRow,\n      tail: tail,\n      tailMode: tailMode\n    };\n  } else {\n    // We can reuse the existing object from previous renders.\n    renderState.isBackwards = isBackwards;\n    renderState.rendering = null;\n    renderState.renderingStartTime = 0;\n    renderState.last = lastContentRow;\n    renderState.tail = tail;\n    renderState.tailMode = tailMode;\n  }\n} // This can end up rendering this component multiple passes.\n// The first pass splits the children fibers into two sets. A head and tail.\n// We first render the head. If anything is in fallback state, we do another\n// pass through beginWork to rerender all children (including the tail) with\n// the force suspend context. If the first render didn't have anything in\n// in fallback state. Then we render each row in the tail one-by-one.\n// That happens in the completeWork phase without going back to beginWork.\n\n\nfunction updateSuspenseListComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps;\n  var revealOrder = nextProps.revealOrder;\n  var tailMode = nextProps.tail;\n  var newChildren = nextProps.children;\n  validateRevealOrder(revealOrder);\n  validateTailOptions(tailMode, revealOrder);\n  validateSuspenseListChildren(newChildren, revealOrder);\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  var suspenseContext = suspenseStackCursor.current;\n  var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);\n\n  if (shouldForceFallback) {\n    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);\n    workInProgress.flags |= DidCapture;\n  } else {\n    var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags;\n\n    if (didSuspendBefore) {\n      // If we previously forced a fallback, we need to schedule work\n      // on any nested boundaries to let them know to try to render\n      // again. This is the same as context updating.\n      propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);\n    }\n\n    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);\n  }\n\n  pushSuspenseContext(workInProgress, suspenseContext);\n\n  if ((workInProgress.mode & ConcurrentMode) === NoMode) {\n    // In legacy mode, SuspenseList doesn't work so we just\n    // use make it a noop by treating it as the default revealOrder.\n    workInProgress.memoizedState = null;\n  } else {\n    switch (revealOrder) {\n      case 'forwards':\n        {\n          var lastContentRow = findLastContentRow(workInProgress.child);\n          var tail;\n\n          if (lastContentRow === null) {\n            // The whole list is part of the tail.\n            // TODO: We could fast path by just rendering the tail now.\n            tail = workInProgress.child;\n            workInProgress.child = null;\n          } else {\n            // Disconnect the tail rows after the content row.\n            // We're going to render them separately later.\n            tail = lastContentRow.sibling;\n            lastContentRow.sibling = null;\n          }\n\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          tail, lastContentRow, tailMode);\n          break;\n        }\n\n      case 'backwards':\n        {\n          // We're going to find the first row that has existing content.\n          // At the same time we're going to reverse the list of everything\n          // we pass in the meantime. That's going to be our tail in reverse\n          // order.\n          var _tail = null;\n          var row = workInProgress.child;\n          workInProgress.child = null;\n\n          while (row !== null) {\n            var currentRow = row.alternate; // New rows can't be content rows.\n\n            if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n              // This is the beginning of the main content.\n              workInProgress.child = row;\n              break;\n            }\n\n            var nextRow = row.sibling;\n            row.sibling = _tail;\n            _tail = row;\n            row = nextRow;\n          } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n\n\n          initSuspenseListRenderState(workInProgress, true, // isBackwards\n          _tail, null, // last\n          tailMode);\n          break;\n        }\n\n      case 'together':\n        {\n          initSuspenseListRenderState(workInProgress, false, // isBackwards\n          null, // tail\n          null, // last\n          undefined);\n          break;\n        }\n\n      default:\n        {\n          // The default reveal order is the same as not having\n          // a boundary.\n          workInProgress.memoizedState = null;\n        }\n    }\n  }\n\n  return workInProgress.child;\n}\n\nfunction updatePortalComponent(current, workInProgress, renderLanes) {\n  pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n  var nextChildren = workInProgress.pendingProps;\n\n  if (current === null) {\n    // Portals are special because we don't append the children during mount\n    // but at commit. Therefore we need to track insertions which the normal\n    // flow doesn't do during mount. This doesn't happen at the root because\n    // the root always starts with a \"current\" with a null child.\n    // TODO: Consider unifying this with how the root works.\n    workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n  } else {\n    reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  }\n\n  return workInProgress.child;\n}\n\nvar hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n\nfunction updateContextProvider(current, workInProgress, renderLanes) {\n  var providerType = workInProgress.type;\n  var context = providerType._context;\n  var newProps = workInProgress.pendingProps;\n  var oldProps = workInProgress.memoizedProps;\n  var newValue = newProps.value;\n\n  {\n    if (!('value' in newProps)) {\n      if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n\n        error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');\n      }\n    }\n\n    var providerPropTypes = workInProgress.type.propTypes;\n\n    if (providerPropTypes) {\n      checkPropTypes(providerPropTypes, newProps, 'prop', 'Context.Provider');\n    }\n  }\n\n  pushProvider(workInProgress, context, newValue);\n\n  {\n    if (oldProps !== null) {\n      var oldValue = oldProps.value;\n\n      if (objectIs(oldValue, newValue)) {\n        // No change. Bailout early if children are the same.\n        if (oldProps.children === newProps.children && !hasContextChanged()) {\n          return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n      } else {\n        // The context value changed. Search for matching consumers and schedule\n        // them to update.\n        propagateContextChange(workInProgress, context, renderLanes);\n      }\n    }\n  }\n\n  var newChildren = newProps.children;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nvar hasWarnedAboutUsingContextAsConsumer = false;\n\nfunction updateContextConsumer(current, workInProgress, renderLanes) {\n  var context = workInProgress.type; // The logic below for Context differs depending on PROD or DEV mode. In\n  // DEV mode, we create a separate object for Context.Consumer that acts\n  // like a proxy to Context. This proxy object adds unnecessary code in PROD\n  // so we use the old behaviour (Context.Consumer references Context) to\n  // reduce size and overhead. The separate object references context via\n  // a property called \"_context\", which also gives us the ability to check\n  // in DEV mode if this property exists or not and warn if it does not.\n\n  {\n    if (context._context === undefined) {\n      // This may be because it's a Context (rather than a Consumer).\n      // Or it may be because it's older React where they're the same thing.\n      // We only want to warn if we're sure it's a new React.\n      if (context !== context.Consumer) {\n        if (!hasWarnedAboutUsingContextAsConsumer) {\n          hasWarnedAboutUsingContextAsConsumer = true;\n\n          error('Rendering <Context> directly is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n        }\n      }\n    } else {\n      context = context._context;\n    }\n  }\n\n  var newProps = workInProgress.pendingProps;\n  var render = newProps.children;\n\n  {\n    if (typeof render !== 'function') {\n      error('A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');\n    }\n  }\n\n  prepareToReadContext(workInProgress, renderLanes);\n  var newValue = readContext(context);\n\n  {\n    markComponentRenderStarted(workInProgress);\n  }\n\n  var newChildren;\n\n  {\n    ReactCurrentOwner$1.current = workInProgress;\n    setIsRendering(true);\n    newChildren = render(newValue);\n    setIsRendering(false);\n  }\n\n  {\n    markComponentRenderStopped();\n  } // React DevTools reads this flag.\n\n\n  workInProgress.flags |= PerformedWork;\n  reconcileChildren(current, workInProgress, newChildren, renderLanes);\n  return workInProgress.child;\n}\n\nfunction markWorkInProgressReceivedUpdate() {\n  didReceiveUpdate = true;\n}\n\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n  if (current !== null) {\n    // Reuse previous dependencies\n    workInProgress.dependencies = current.dependencies;\n  }\n\n  {\n    // Don't update \"base\" render times for bailouts.\n    stopProfilerTimerIfRunning();\n  }\n\n  markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.\n\n  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n    // The children don't have any work either. We can skip them.\n    // TODO: Once we add back resuming, we should check if the children are\n    // a work-in-progress set. If so, we need to transfer their effects.\n    {\n      return null;\n    }\n  } // This fiber doesn't have work, but its subtree does. Clone the child\n  // fibers and continue.\n\n\n  cloneChildFibers(current, workInProgress);\n  return workInProgress.child;\n}\n\nfunction remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n  {\n    var returnFiber = oldWorkInProgress.return;\n\n    if (returnFiber === null) {\n      // eslint-disable-next-line react-internal/prod-error-codes\n      throw new Error('Cannot swap the root fiber.');\n    } // Disconnect from the old current.\n    // It will get deleted.\n\n\n    current.alternate = null;\n    oldWorkInProgress.alternate = null; // Connect to the new tree.\n\n    newWorkInProgress.index = oldWorkInProgress.index;\n    newWorkInProgress.sibling = oldWorkInProgress.sibling;\n    newWorkInProgress.return = oldWorkInProgress.return;\n    newWorkInProgress.ref = oldWorkInProgress.ref; // Replace the child/sibling pointers above it.\n\n    if (oldWorkInProgress === returnFiber.child) {\n      returnFiber.child = newWorkInProgress;\n    } else {\n      var prevSibling = returnFiber.child;\n\n      if (prevSibling === null) {\n        // eslint-disable-next-line react-internal/prod-error-codes\n        throw new Error('Expected parent to have a child.');\n      }\n\n      while (prevSibling.sibling !== oldWorkInProgress) {\n        prevSibling = prevSibling.sibling;\n\n        if (prevSibling === null) {\n          // eslint-disable-next-line react-internal/prod-error-codes\n          throw new Error('Expected to find the previous sibling.');\n        }\n      }\n\n      prevSibling.sibling = newWorkInProgress;\n    } // Delete the old fiber and place the new one.\n    // Since the old fiber is disconnected, we have to schedule it manually.\n\n\n    var deletions = returnFiber.deletions;\n\n    if (deletions === null) {\n      returnFiber.deletions = [current];\n      returnFiber.flags |= ChildDeletion;\n    } else {\n      deletions.push(current);\n    }\n\n    newWorkInProgress.flags |= Placement; // Restart work from the new fiber.\n\n    return newWorkInProgress;\n  }\n}\n\nfunction checkScheduledUpdateOrContext(current, renderLanes) {\n  // Before performing an early bailout, we must check if there are pending\n  // updates or context.\n  var updateLanes = current.lanes;\n\n  if (includesSomeLane(updateLanes, renderLanes)) {\n    return true;\n  } // No pending update, but because context is propagated lazily, we need\n\n  return false;\n}\n\nfunction attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n  // This fiber does not have any pending work. Bailout without entering\n  // the begin phase. There's still some bookkeeping we that needs to be done\n  // in this optimized path, mostly pushing stuff onto the stack.\n  switch (workInProgress.tag) {\n    case HostRoot:\n      pushHostRootContext(workInProgress);\n      var root = workInProgress.stateNode;\n\n      resetHydrationState();\n      break;\n\n    case HostComponent:\n      pushHostContext(workInProgress);\n      break;\n\n    case ClassComponent:\n      {\n        var Component = workInProgress.type;\n\n        if (isContextProvider(Component)) {\n          pushContextProvider(workInProgress);\n        }\n\n        break;\n      }\n\n    case HostPortal:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      break;\n\n    case ContextProvider:\n      {\n        var newValue = workInProgress.memoizedProps.value;\n        var context = workInProgress.type._context;\n        pushProvider(workInProgress, context, newValue);\n        break;\n      }\n\n    case Profiler:\n      {\n        // Profiler should only call onRender when one of its descendants actually rendered.\n        var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n\n        if (hasChildWork) {\n          workInProgress.flags |= Update;\n        }\n\n        {\n          // Reset effect durations for the next eventual effect phase.\n          // These are reset during render to allow the DevTools commit hook a chance to read them,\n          var stateNode = workInProgress.stateNode;\n          stateNode.effectDuration = 0;\n          stateNode.passiveEffectDuration = 0;\n        }\n      }\n\n      break;\n\n    case SuspenseComponent:\n      {\n        var state = workInProgress.memoizedState;\n\n        if (state !== null) {\n          {\n            if (state.dehydrated !== null) {\n              pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // We know that this component will suspend again because if it has\n              // been unsuspended it has committed as a resolved Suspense component.\n              // If it needs to be retried, it should have work scheduled on it.\n\n              workInProgress.flags |= DidCapture; // We should never render the children of a dehydrated boundary until we\n              // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n\n              return null;\n            }\n          } // If this boundary is currently timed out, we need to decide\n          // whether to retry the primary children, or to skip over it and\n          // go straight to the fallback. Check the priority of the primary\n          // child fragment.\n\n\n          var primaryChildFragment = workInProgress.child;\n          var primaryChildLanes = primaryChildFragment.childLanes;\n\n          if (includesSomeLane(renderLanes, primaryChildLanes)) {\n            // The primary children have pending work. Use the normal path\n            // to attempt to render the primary children again.\n            return updateSuspenseComponent(current, workInProgress, renderLanes);\n          } else {\n            // The primary child fragment does not have pending work marked\n            // on it\n            pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current)); // The primary children do not have pending work with sufficient\n            // priority. Bailout.\n\n            var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n\n            if (child !== null) {\n              // The fallback children have pending work. Skip over the\n              // primary children and work on the fallback.\n              return child.sibling;\n            } else {\n              // Note: We can return `null` here because we already checked\n              // whether there were nested context consumers, via the call to\n              // `bailoutOnAlreadyFinishedWork` above.\n              return null;\n            }\n          }\n        } else {\n          pushSuspenseContext(workInProgress, setDefaultShallowSuspenseContext(suspenseStackCursor.current));\n        }\n\n        break;\n      }\n\n    case SuspenseListComponent:\n      {\n        var didSuspendBefore = (current.flags & DidCapture) !== NoFlags;\n\n        var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n\n        if (didSuspendBefore) {\n          if (_hasChildWork) {\n            // If something was in fallback state last time, and we have all the\n            // same children then we're still in progressive loading state.\n            // Something might get unblocked by state updates or retries in the\n            // tree which will affect the tail. So we need to use the normal\n            // path to compute the correct tail.\n            return updateSuspenseListComponent(current, workInProgress, renderLanes);\n          } // If none of the children had any work, that means that none of\n          // them got retried so they'll still be blocked in the same way\n          // as before. We can fast bail out.\n\n\n          workInProgress.flags |= DidCapture;\n        } // If nothing suspended before and we're rendering the same children,\n        // then the tail doesn't matter. Anything new that suspends will work\n        // in the \"together\" mode, so we can continue from the state we had.\n\n\n        var renderState = workInProgress.memoizedState;\n\n        if (renderState !== null) {\n          // Reset to the \"together\" mode in case we've started a different\n          // update in the past but didn't complete it.\n          renderState.rendering = null;\n          renderState.tail = null;\n          renderState.lastEffect = null;\n        }\n\n        pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n\n        if (_hasChildWork) {\n          break;\n        } else {\n          // If none of the children had any work, that means that none of\n          // them got retried so they'll still be blocked in the same way\n          // as before. We can fast bail out.\n          return null;\n        }\n      }\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      {\n        // Need to check if the tree still needs to be deferred. This is\n        // almost identical to the logic used in the normal update path,\n        // so we'll just enter that. The only difference is we'll bail out\n        // at the next level instead of this one, because the child props\n        // have not changed. Which is fine.\n        // TODO: Probably should refactor `beginWork` to split the bailout\n        // path from the normal path. I'm tempted to do a labeled break here\n        // but I won't :)\n        workInProgress.lanes = NoLanes;\n        return updateOffscreenComponent(current, workInProgress, renderLanes);\n      }\n  }\n\n  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n}\n\nfunction beginWork(current, workInProgress, renderLanes) {\n  {\n    if (workInProgress._debugNeedsRemount && current !== null) {\n      // This will restart the begin phase with a new fiber.\n      return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));\n    }\n  }\n\n  if (current !== null) {\n    var oldProps = current.memoizedProps;\n    var newProps = workInProgress.pendingProps;\n\n    if (oldProps !== newProps || hasContextChanged() || ( // Force a re-render if the implementation changed due to hot reload:\n     workInProgress.type !== current.type )) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else {\n      // Neither props nor legacy context changes. Check if there's a pending\n      // update or context change.\n      var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n\n      if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n      // may not be work scheduled on `current`, so we check for this flag.\n      (workInProgress.flags & DidCapture) === NoFlags) {\n        // No pending updates or context. Bail out now.\n        didReceiveUpdate = false;\n        return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n      }\n\n      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      } else {\n        // An update was scheduled on this fiber, but there are no new props\n        // nor legacy context. Set this to false. If an update queue or context\n        // consumer produces a changed value, it will set this to true. Otherwise,\n        // the component will assume the children have not changed and bail out.\n        didReceiveUpdate = false;\n      }\n    }\n  } else {\n    didReceiveUpdate = false;\n\n    if (getIsHydrating() && isForkedChild(workInProgress)) {\n      // Check if this child belongs to a list of muliple children in\n      // its parent.\n      //\n      // In a true multi-threaded implementation, we would render children on\n      // parallel threads. This would represent the beginning of a new render\n      // thread for this subtree.\n      //\n      // We only use this for id generation during hydration, which is why the\n      // logic is located in this special branch.\n      var slotIndex = workInProgress.index;\n      var numberOfForks = getForksAtLevel();\n      pushTreeId(workInProgress, numberOfForks, slotIndex);\n    }\n  } // Before entering the begin phase, clear pending update priority.\n  // TODO: This assumes that we're about to evaluate the component and process\n  // the update queue. However, there's an exception: SimpleMemoComponent\n  // sometimes bails out later in the begin phase. This indicates that we should\n  // move this assignment out of the common path and into each branch.\n\n\n  workInProgress.lanes = NoLanes;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent:\n      {\n        return mountIndeterminateComponent(current, workInProgress, workInProgress.type, renderLanes);\n      }\n\n    case LazyComponent:\n      {\n        var elementType = workInProgress.elementType;\n        return mountLazyComponent(current, workInProgress, elementType, renderLanes);\n      }\n\n    case FunctionComponent:\n      {\n        var Component = workInProgress.type;\n        var unresolvedProps = workInProgress.pendingProps;\n        var resolvedProps = workInProgress.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);\n        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n      }\n\n    case ClassComponent:\n      {\n        var _Component = workInProgress.type;\n        var _unresolvedProps = workInProgress.pendingProps;\n\n        var _resolvedProps = workInProgress.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);\n\n        return updateClassComponent(current, workInProgress, _Component, _resolvedProps, renderLanes);\n      }\n\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderLanes);\n\n    case HostComponent:\n      return updateHostComponent$1(current, workInProgress, renderLanes);\n\n    case HostText:\n      return updateHostText$1(current, workInProgress);\n\n    case SuspenseComponent:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n\n    case HostPortal:\n      return updatePortalComponent(current, workInProgress, renderLanes);\n\n    case ForwardRef:\n      {\n        var type = workInProgress.type;\n        var _unresolvedProps2 = workInProgress.pendingProps;\n\n        var _resolvedProps2 = workInProgress.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);\n\n        return updateForwardRef(current, workInProgress, type, _resolvedProps2, renderLanes);\n      }\n\n    case Fragment:\n      return updateFragment(current, workInProgress, renderLanes);\n\n    case Mode:\n      return updateMode(current, workInProgress, renderLanes);\n\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderLanes);\n\n    case ContextProvider:\n      return updateContextProvider(current, workInProgress, renderLanes);\n\n    case ContextConsumer:\n      return updateContextConsumer(current, workInProgress, renderLanes);\n\n    case MemoComponent:\n      {\n        var _type2 = workInProgress.type;\n        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n\n        var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);\n\n        {\n          if (workInProgress.type !== workInProgress.elementType) {\n            var outerPropTypes = _type2.propTypes;\n\n            if (outerPropTypes) {\n              checkPropTypes(outerPropTypes, _resolvedProps3, // Resolved for outer only\n              'prop', getComponentNameFromType(_type2));\n            }\n          }\n        }\n\n        _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);\n        return updateMemoComponent(current, workInProgress, _type2, _resolvedProps3, renderLanes);\n      }\n\n    case SimpleMemoComponent:\n      {\n        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n      }\n\n    case IncompleteClassComponent:\n      {\n        var _Component2 = workInProgress.type;\n        var _unresolvedProps4 = workInProgress.pendingProps;\n\n        var _resolvedProps4 = workInProgress.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);\n\n        return mountIncompleteClassComponent(current, workInProgress, _Component2, _resolvedProps4, renderLanes);\n      }\n\n    case SuspenseListComponent:\n      {\n        return updateSuspenseListComponent(current, workInProgress, renderLanes);\n      }\n\n    case ScopeComponent:\n      {\n\n        break;\n      }\n\n    case OffscreenComponent:\n      {\n        return updateOffscreenComponent(current, workInProgress, renderLanes);\n      }\n  }\n\n  throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n}\n\nfunction unwindWork(current, workInProgress, renderLanes) {\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(workInProgress);\n\n  switch (workInProgress.tag) {\n    case ClassComponent:\n      {\n        var Component = workInProgress.type;\n\n        if (isContextProvider(Component)) {\n          popContext(workInProgress);\n        }\n\n        var flags = workInProgress.flags;\n\n        if (flags & ShouldCapture) {\n          workInProgress.flags = flags & ~ShouldCapture | DidCapture;\n\n          if ( (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          }\n\n          return workInProgress;\n        }\n\n        return null;\n      }\n\n    case HostRoot:\n      {\n\n        popHostContainer(workInProgress);\n        popTopLevelContextObject(workInProgress);\n        resetWorkInProgressVersions();\n        var _flags = workInProgress.flags;\n\n        if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {\n          // There was an error during render that wasn't captured by a suspense\n          // boundary. Do a second pass on the root to unmount the children.\n          workInProgress.flags = _flags & ~ShouldCapture | DidCapture;\n          return workInProgress;\n        } // We unwound to the root without completing it. Exit.\n\n\n        return null;\n      }\n\n    case HostComponent:\n      {\n        // TODO: popHydrationState\n        popHostContext(workInProgress);\n        return null;\n      }\n\n    case SuspenseComponent:\n      {\n        popSuspenseContext(workInProgress);\n\n        {\n          var suspenseState = workInProgress.memoizedState;\n\n          if (suspenseState !== null && suspenseState.dehydrated !== null) {\n            if (workInProgress.alternate === null) {\n              throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in ' + 'React. Please file an issue.');\n            }\n\n            resetHydrationState();\n          }\n        }\n\n        var _flags2 = workInProgress.flags;\n\n        if (_flags2 & ShouldCapture) {\n          workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n\n          if ( (workInProgress.mode & ProfileMode) !== NoMode) {\n            transferActualDuration(workInProgress);\n          }\n\n          return workInProgress;\n        }\n\n        return null;\n      }\n\n    case SuspenseListComponent:\n      {\n        popSuspenseContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been\n        // caught by a nested boundary. If not, it should bubble through.\n\n        return null;\n      }\n\n    case HostPortal:\n      popHostContainer(workInProgress);\n      return null;\n\n    case ContextProvider:\n      var context = workInProgress.type._context;\n      popProvider(context, workInProgress);\n      return null;\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      popRenderLanes(workInProgress);\n\n      return null;\n\n    case CacheComponent:\n\n      return null;\n\n    default:\n      return null;\n  }\n}\n\nfunction unwindInterruptedWork(current, interruptedWork, renderLanes) {\n  // Note: This intentionally doesn't check if we're hydrating because comparing\n  // to the current tree provider fiber is just as fast and less error-prone.\n  // Ideally we would have a special version of the work loop only\n  // for hydration.\n  popTreeContext(interruptedWork);\n\n  switch (interruptedWork.tag) {\n    case ClassComponent:\n      {\n        var childContextTypes = interruptedWork.type.childContextTypes;\n\n        if (childContextTypes !== null && childContextTypes !== undefined) {\n          popContext(interruptedWork);\n        }\n\n        break;\n      }\n\n    case HostRoot:\n      {\n\n        popHostContainer(interruptedWork);\n        popTopLevelContextObject(interruptedWork);\n        resetWorkInProgressVersions();\n        break;\n      }\n\n    case HostComponent:\n      {\n        popHostContext(interruptedWork);\n        break;\n      }\n\n    case HostPortal:\n      popHostContainer(interruptedWork);\n      break;\n\n    case SuspenseComponent:\n      popSuspenseContext(interruptedWork);\n      break;\n\n    case SuspenseListComponent:\n      popSuspenseContext(interruptedWork);\n      break;\n\n    case ContextProvider:\n      var context = interruptedWork.type._context;\n      popProvider(context, interruptedWork);\n      break;\n\n    case OffscreenComponent:\n    case LegacyHiddenComponent:\n      popRenderLanes(interruptedWork);\n\n      break;\n  }\n}\n\nfunction invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {\n  var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n  try {\n    func.apply(context, funcArgs);\n  } catch (error) {\n    this.onError(error);\n  }\n}\n\nvar invokeGuardedCallbackImpl = invokeGuardedCallbackProd;\n\n{\n  // In DEV mode, we swap out invokeGuardedCallback for a special version\n  // that plays more nicely with the browser's DevTools. The idea is to preserve\n  // \"Pause on exceptions\" behavior. Because React wraps all user-provided\n  // functions in invokeGuardedCallback, and the production version of\n  // invokeGuardedCallback uses a try-catch, all user exceptions are treated\n  // like caught exceptions, and the DevTools won't pause unless the developer\n  // takes the extra step of enabling pause on caught exceptions. This is\n  // unintuitive, though, because even though React has caught the error, from\n  // the developer's perspective, the error is uncaught.\n  //\n  // To preserve the expected \"Pause on exceptions\" behavior, we don't use a\n  // try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake\n  // DOM node, and call the user-provided callback from inside an event handler\n  // for that fake event. If the callback throws, the error is \"captured\" using\n  // a global event handler. But because the error happens in a different\n  // event loop context, it does not interrupt the normal program flow.\n  // Effectively, this gives us try-catch behavior without actually using\n  // try-catch. Neat!\n  // Check that the browser supports the APIs we need to implement our special\n  // DEV version of invokeGuardedCallback\n  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {\n    var fakeNode = document.createElement('react');\n\n    invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {\n      // If document doesn't exist we know for sure we will crash in this method\n      // when we call document.createEvent(). However this can cause confusing\n      // errors: https://github.com/facebook/create-react-app/issues/3482\n      // So we preemptively throw with a better message instead.\n      if (typeof document === 'undefined' || document === null) {\n        throw new Error('The `document` global was defined when React was initialized, but is not ' + 'defined anymore. This can happen in a test environment if a component ' + 'schedules an update from an asynchronous callback, but the test has already ' + 'finished running. To solve this, you can either unmount the component at ' + 'the end of your test (and ensure that any asynchronous operations get ' + 'canceled in `componentWillUnmount`), or you can change the test itself ' + 'to be asynchronous.');\n      }\n\n      var evt = document.createEvent('Event');\n      var didCall = false; // Keeps track of whether the user-provided callback threw an error. We\n      // set this to true at the beginning, then set it to false right after\n      // calling the function. If the function errors, `didError` will never be\n      // set to false. This strategy works even if the browser is flaky and\n      // fails to call our global error handler, because it doesn't rely on\n      // the error event at all.\n\n      var didError = true; // Keeps track of the value of window.event so that we can reset it\n      // during the callback to let user code access window.event in the\n      // browsers that support it.\n\n      var windowEvent = window.event; // Keeps track of the descriptor of window.event to restore it after event\n      // dispatching: https://github.com/facebook/react/issues/13688\n\n      var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, 'event');\n\n      function restoreAfterDispatch() {\n        // We immediately remove the callback from event listeners so that\n        // nested `invokeGuardedCallback` calls do not clash. Otherwise, a\n        // nested call would trigger the fake event handlers of any call higher\n        // in the stack.\n        fakeNode.removeEventListener(evtType, callCallback, false); // We check for window.hasOwnProperty('event') to prevent the\n        // window.event assignment in both IE <= 10 as they throw an error\n        // \"Member not found\" in strict mode, and in Firefox which does not\n        // support window.event.\n\n        if (typeof window.event !== 'undefined' && window.hasOwnProperty('event')) {\n          window.event = windowEvent;\n        }\n      } // Create an event handler for our fake event. We will synchronously\n      // dispatch our fake event using `dispatchEvent`. Inside the handler, we\n      // call the user-provided callback.\n\n\n      var funcArgs = Array.prototype.slice.call(arguments, 3);\n\n      function callCallback() {\n        didCall = true;\n        restoreAfterDispatch();\n        func.apply(context, funcArgs);\n        didError = false;\n      } // Create a global error event handler. We use this to capture the value\n      // that was thrown. It's possible that this error handler will fire more\n      // than once; for example, if non-React code also calls `dispatchEvent`\n      // and a handler for that event throws. We should be resilient to most of\n      // those cases. Even if our error event handler fires more than once, the\n      // last error event is always used. If the callback actually does error,\n      // we know that the last error event is the correct one, because it's not\n      // possible for anything else to have happened in between our callback\n      // erroring and the code that follows the `dispatchEvent` call below. If\n      // the callback doesn't error, but the error event was fired, we know to\n      // ignore it because `didError` will be false, as described above.\n\n\n      var error; // Use this to track whether the error event is ever called.\n\n      var didSetError = false;\n      var isCrossOriginError = false;\n\n      function handleWindowError(event) {\n        error = event.error;\n        didSetError = true;\n\n        if (error === null && event.colno === 0 && event.lineno === 0) {\n          isCrossOriginError = true;\n        }\n\n        if (event.defaultPrevented) {\n          // Some other error handler has prevented default.\n          // Browsers silence the error report if this happens.\n          // We'll remember this to later decide whether to log it or not.\n          if (error != null && typeof error === 'object') {\n            try {\n              error._suppressLogging = true;\n            } catch (inner) {// Ignore.\n            }\n          }\n        }\n      } // Create a fake event type.\n\n\n      var evtType = \"react-\" + (name ? name : 'invokeguardedcallback'); // Attach our event handlers\n\n      window.addEventListener('error', handleWindowError);\n      fakeNode.addEventListener(evtType, callCallback, false); // Synchronously dispatch our fake event. If the user-provided function\n      // errors, it will trigger our global error handler.\n\n      evt.initEvent(evtType, false, false);\n      fakeNode.dispatchEvent(evt);\n\n      if (windowEventDescriptor) {\n        Object.defineProperty(window, 'event', windowEventDescriptor);\n      }\n\n      if (didCall && didError) {\n        if (!didSetError) {\n          // The callback errored, but the error event never fired.\n          // eslint-disable-next-line react-internal/prod-error-codes\n          error = new Error('An error was thrown inside one of your components, but React ' + \"doesn't know what it was. This is likely due to browser \" + 'flakiness. React does its best to preserve the \"Pause on ' + 'exceptions\" behavior of the DevTools, which requires some ' + \"DEV-mode only tricks. It's possible that these don't work in \" + 'your browser. Try triggering the error in production mode, ' + 'or switching to a modern browser. If you suspect that this is ' + 'actually an issue with React, please file an issue.');\n        } else if (isCrossOriginError) {\n          // eslint-disable-next-line react-internal/prod-error-codes\n          error = new Error(\"A cross-origin error was thrown. React doesn't have access to \" + 'the actual error object in development. ' + 'See https://reactjs.org/link/crossorigin-error for more information.');\n        }\n\n        this.onError(error);\n      } // Remove our event listeners\n\n\n      window.removeEventListener('error', handleWindowError);\n\n      if (!didCall) {\n        // Something went really wrong, and our event was not dispatched.\n        // https://github.com/facebook/react/issues/16734\n        // https://github.com/facebook/react/issues/16585\n        // Fall back to the production implementation.\n        restoreAfterDispatch();\n        return invokeGuardedCallbackProd.apply(this, arguments);\n      }\n    };\n  }\n}\n\nvar invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;\n\nvar hasError = false;\nvar caughtError = null; // Used by event system to capture/rethrow the first error.\nvar reporter = {\n  onError: function (error) {\n    hasError = true;\n    caughtError = error;\n  }\n};\n/**\n * Call a function while guarding against errors that happens within it.\n * Returns an error if it throws, otherwise null.\n *\n * In production, this is implemented using a try-catch. The reason we don't\n * use a try-catch directly is so that we can swap out a different\n * implementation in DEV mode.\n *\n * @param {String} name of the guard to use for logging or debugging\n * @param {Function} func The function to invoke\n * @param {*} context The context to use when calling the function\n * @param {...*} args Arguments for function\n */\n\nfunction invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {\n  hasError = false;\n  caughtError = null;\n  invokeGuardedCallbackImpl$1.apply(reporter, arguments);\n}\nfunction hasCaughtError() {\n  return hasError;\n}\nfunction clearCaughtError() {\n  if (hasError) {\n    var error = caughtError;\n    hasError = false;\n    caughtError = null;\n    return error;\n  } else {\n    throw new Error('clearCaughtError was called but no error was captured. This error ' + 'is likely caused by a bug in React. Please file an issue.');\n  }\n}\n\nvar didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n\n{\n  didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n} // Used during the commit phase to track the state of the Offscreen component stack.\n// Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n// Only used when enableSuspenseLayoutEffectSemantics is enabled.\n\n\nvar offscreenSubtreeIsHidden = false;\nvar offscreenSubtreeWasHidden = false;\nvar PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\nvar nextEffect = null; // Used for Profiling builds to track updaters.\n\nvar inProgressLanes = null;\nvar inProgressRoot = null;\n\nfunction reportUncaughtErrorInDEV(error) {\n  // Wrapping each small part of the commit phase into a guarded\n  // callback is a bit too slow (https://github.com/facebook/react/pull/21666).\n  // But we rely on it to surface errors to DEV tools like overlays\n  // (https://github.com/facebook/react/issues/21712).\n  // As a compromise, rethrow only caught errors in a guard.\n  {\n    invokeGuardedCallback(null, function () {\n      throw error;\n    });\n    clearCaughtError();\n  }\n}\n\nvar callComponentWillUnmountWithTimer = function (current, instance) {\n  instance.props = current.memoizedProps;\n  instance.state = current.memoizedState;\n\n  if ( current.mode & ProfileMode) {\n    try {\n      startLayoutEffectTimer();\n      instance.componentWillUnmount();\n    } finally {\n      recordLayoutEffectDuration(current);\n    }\n  } else {\n    instance.componentWillUnmount();\n  }\n}; // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyCallCommitHookLayoutEffectListMount(current, nearestMountedAncestor) {\n  try {\n    commitHookEffectListMount(Layout, current);\n  } catch (error) {\n    reportUncaughtErrorInDEV(error);\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt unmounting.\n\n\nfunction safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n  try {\n    callComponentWillUnmountWithTimer(current, instance);\n  } catch (error) {\n    reportUncaughtErrorInDEV(error);\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyCallComponentDidMount(current, nearestMountedAncestor, instance) {\n  try {\n    instance.componentDidMount();\n  } catch (error) {\n    reportUncaughtErrorInDEV(error);\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n} // Capture errors so they don't interrupt mounting.\n\n\nfunction safelyAttachRef(current, nearestMountedAncestor) {\n  try {\n    commitAttachRef(current);\n  } catch (error) {\n    reportUncaughtErrorInDEV(error);\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nfunction safelyDetachRef(current, nearestMountedAncestor) {\n  var ref = current.ref;\n\n  if (ref !== null) {\n    if (typeof ref === 'function') {\n      var retVal;\n\n      try {\n        if (enableProfilerTimer && enableProfilerCommitHooks && current.mode & ProfileMode) {\n          try {\n            startLayoutEffectTimer();\n            retVal = ref(null);\n          } finally {\n            recordLayoutEffectDuration(current);\n          }\n        } else {\n          retVal = ref(null);\n        }\n      } catch (error) {\n        reportUncaughtErrorInDEV(error);\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\n      }\n\n      {\n        if (typeof retVal === 'function') {\n          error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(current));\n        }\n      }\n    } else {\n      ref.current = null;\n    }\n  }\n}\n\nfunction safelyCallDestroy(current, nearestMountedAncestor, destroy) {\n  try {\n    destroy();\n  } catch (error) {\n    reportUncaughtErrorInDEV(error);\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\n\nvar focusedInstanceHandle = null;\nvar shouldFireAfterActiveInstanceBlur = false;\nfunction commitBeforeMutationEffects(root, firstChild) {\n  focusedInstanceHandle = prepareForCommit(root.containerInfo);\n  nextEffect = firstChild;\n  commitBeforeMutationEffects_begin(); // We no longer need to track the active instance fiber\n\n  var shouldFire = shouldFireAfterActiveInstanceBlur;\n  shouldFireAfterActiveInstanceBlur = false;\n  focusedInstanceHandle = null;\n  return shouldFire;\n}\n\nfunction commitBeforeMutationEffects_begin() {\n  while (nextEffect !== null) {\n    var fiber = nextEffect; // This phase is only used for beforeActiveInstanceBlur.\n\n    var child = fiber.child;\n\n    if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {\n      ensureCorrectReturnPointer(child, fiber);\n      nextEffect = child;\n    } else {\n      commitBeforeMutationEffects_complete();\n    }\n  }\n}\n\nfunction commitBeforeMutationEffects_complete() {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    setCurrentFiber(fiber);\n\n    try {\n      commitBeforeMutationEffectsOnFiber(fiber);\n    } catch (error) {\n      reportUncaughtErrorInDEV(error);\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n\n    resetCurrentFiber();\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, fiber.return);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitBeforeMutationEffectsOnFiber(finishedWork) {\n  var current = finishedWork.alternate;\n  var flags = finishedWork.flags;\n\n  if ((flags & Snapshot) !== NoFlags) {\n    setCurrentFiber(finishedWork);\n\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          break;\n        }\n\n      case ClassComponent:\n        {\n          if (current !== null) {\n            var prevProps = current.memoizedProps;\n            var prevState = current.memoizedState;\n            var instance = finishedWork.stateNode; // We could update instance props and state here,\n            // but instead we rely on them being set during last render.\n            // TODO: revisit this when we implement resuming.\n\n            {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                if (instance.props !== finishedWork.memoizedProps) {\n                  error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n\n                if (instance.state !== finishedWork.memoizedState) {\n                  error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n              }\n            }\n\n            var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);\n\n            {\n              var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n\n              if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                didWarnSet.add(finishedWork.type);\n\n                error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentNameFromFiber(finishedWork));\n              }\n            }\n\n            instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n          }\n\n          break;\n        }\n\n      case HostRoot:\n        {\n          if (supportsMutation) {\n            var root = finishedWork.stateNode;\n            clearContainer(root.containerInfo);\n          }\n\n          break;\n        }\n\n      case HostComponent:\n      case HostText:\n      case HostPortal:\n      case IncompleteClassComponent:\n        // Nothing to do for these component types\n        break;\n\n      default:\n        {\n          throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n        }\n    }\n\n    resetCurrentFiber();\n  }\n}\n\nfunction commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n  var updateQueue = finishedWork.updateQueue;\n  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n  if (lastEffect !== null) {\n    var firstEffect = lastEffect.next;\n    var effect = firstEffect;\n\n    do {\n      if ((effect.tag & flags) === flags) {\n        // Unmount\n        var destroy = effect.destroy;\n        effect.destroy = undefined;\n\n        if (destroy !== undefined) {\n          {\n            if ((flags & Passive$1) !== NoFlags$1) {\n              markComponentPassiveEffectUnmountStarted(finishedWork);\n            } else if ((flags & Layout) !== NoFlags$1) {\n              markComponentLayoutEffectUnmountStarted(finishedWork);\n            }\n          }\n\n          safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n\n          {\n            if ((flags & Passive$1) !== NoFlags$1) {\n              markComponentPassiveEffectUnmountStopped();\n            } else if ((flags & Layout) !== NoFlags$1) {\n              markComponentLayoutEffectUnmountStopped();\n            }\n          }\n        }\n      }\n\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nfunction commitHookEffectListMount(flags, finishedWork) {\n  var updateQueue = finishedWork.updateQueue;\n  var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n\n  if (lastEffect !== null) {\n    var firstEffect = lastEffect.next;\n    var effect = firstEffect;\n\n    do {\n      if ((effect.tag & flags) === flags) {\n        {\n          if ((flags & Passive$1) !== NoFlags$1) {\n            markComponentPassiveEffectMountStarted(finishedWork);\n          } else if ((flags & Layout) !== NoFlags$1) {\n            markComponentLayoutEffectMountStarted(finishedWork);\n          }\n        } // Mount\n\n\n        var create = effect.create;\n        effect.destroy = create();\n\n        {\n          if ((flags & Passive$1) !== NoFlags$1) {\n            markComponentPassiveEffectMountStopped();\n          } else if ((flags & Layout) !== NoFlags$1) {\n            markComponentLayoutEffectMountStopped();\n          }\n        }\n\n        {\n          var destroy = effect.destroy;\n\n          if (destroy !== undefined && typeof destroy !== 'function') {\n            var hookName = void 0;\n\n            if ((effect.tag & Layout) !== NoFlags) {\n              hookName = 'useLayoutEffect';\n            } else if ((effect.tag & Insertion) !== NoFlags) {\n              hookName = 'useInsertionEffect';\n            } else {\n              hookName = 'useEffect';\n            }\n\n            var addendum = void 0;\n\n            if (destroy === null) {\n              addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';\n            } else if (typeof destroy.then === 'function') {\n              addendum = '\\n\\nIt looks like you wrote ' + hookName + '(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\\n\\n' + hookName + '(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + 'Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching';\n            } else {\n              addendum = ' You returned: ' + destroy;\n            }\n\n            error('%s must not return anything besides a function, ' + 'which is used for clean-up.%s', hookName, addendum);\n          }\n        }\n      }\n\n      effect = effect.next;\n    } while (effect !== firstEffect);\n  }\n}\n\nfunction commitPassiveEffectDurations(finishedRoot, finishedWork) {\n  {\n    // Only Profilers with work in their subtree will have an Update effect scheduled.\n    if ((finishedWork.flags & Update) !== NoFlags) {\n      switch (finishedWork.tag) {\n        case Profiler:\n          {\n            var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;\n            var _finishedWork$memoize = finishedWork.memoizedProps,\n                id = _finishedWork$memoize.id,\n                onPostCommit = _finishedWork$memoize.onPostCommit; // This value will still reflect the previous commit phase.\n            // It does not get reset until the start of the next commit phase.\n\n            var commitTime = getCommitTime();\n            var phase = finishedWork.alternate === null ? 'mount' : 'update';\n\n            {\n              if (isCurrentUpdateNested()) {\n                phase = 'nested-update';\n              }\n            }\n\n            if (typeof onPostCommit === 'function') {\n              onPostCommit(id, phase, passiveEffectDuration, commitTime);\n            } // Bubble times to the next nearest ancestor Profiler.\n            // After we process that Profiler, we'll bubble further up.\n\n\n            var parentFiber = finishedWork.return;\n\n            outer: while (parentFiber !== null) {\n              switch (parentFiber.tag) {\n                case HostRoot:\n                  var root = parentFiber.stateNode;\n                  root.passiveEffectDuration += passiveEffectDuration;\n                  break outer;\n\n                case Profiler:\n                  var parentStateNode = parentFiber.stateNode;\n                  parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                  break outer;\n              }\n\n              parentFiber = parentFiber.return;\n            }\n\n            break;\n          }\n      }\n    }\n  }\n}\n\nfunction commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {\n  if ((finishedWork.flags & LayoutMask) !== NoFlags) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          if ( !offscreenSubtreeWasHidden) {\n            // At this point layout effects have already been destroyed (during mutation phase).\n            // This is done to prevent sibling component effects from interfering with each other,\n            // e.g. a destroy function in one component should never override a ref set\n            // by a create function in another component during the same commit.\n            if ( finishedWork.mode & ProfileMode) {\n              try {\n                startLayoutEffectTimer();\n                commitHookEffectListMount(Layout | HasEffect, finishedWork);\n              } finally {\n                recordLayoutEffectDuration(finishedWork);\n              }\n            } else {\n              commitHookEffectListMount(Layout | HasEffect, finishedWork);\n            }\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          var instance = finishedWork.stateNode;\n\n          if (finishedWork.flags & Update) {\n            if (!offscreenSubtreeWasHidden) {\n              if (current === null) {\n                // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                {\n                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                    if (instance.props !== finishedWork.memoizedProps) {\n                      error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n\n                    if (instance.state !== finishedWork.memoizedState) {\n                      error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n                  }\n                }\n\n                if ( finishedWork.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    instance.componentDidMount();\n                  } finally {\n                    recordLayoutEffectDuration(finishedWork);\n                  }\n                } else {\n                  instance.componentDidMount();\n                }\n              } else {\n                var prevProps = finishedWork.elementType === finishedWork.type ? current.memoizedProps : resolveDefaultProps(finishedWork.type, current.memoizedProps);\n                var prevState = current.memoizedState; // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n\n                {\n                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                    if (instance.props !== finishedWork.memoizedProps) {\n                      error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n\n                    if (instance.state !== finishedWork.memoizedState) {\n                      error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                    }\n                  }\n                }\n\n                if ( finishedWork.mode & ProfileMode) {\n                  try {\n                    startLayoutEffectTimer();\n                    instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                  } finally {\n                    recordLayoutEffectDuration(finishedWork);\n                  }\n                } else {\n                  instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                }\n              }\n            }\n          } // TODO: I think this is now always non-null by the time it reaches the\n          // commit phase. Consider removing the type check.\n\n\n          var updateQueue = finishedWork.updateQueue;\n\n          if (updateQueue !== null) {\n            {\n              if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {\n                if (instance.props !== finishedWork.memoizedProps) {\n                  error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n\n                if (instance.state !== finishedWork.memoizedState) {\n                  error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                }\n              }\n            } // We could update instance props and state here,\n            // but instead we rely on them being set during last render.\n            // TODO: revisit this when we implement resuming.\n\n\n            commitUpdateQueue(finishedWork, updateQueue, instance);\n          }\n\n          break;\n        }\n\n      case HostRoot:\n        {\n          // TODO: I think this is now always non-null by the time it reaches the\n          // commit phase. Consider removing the type check.\n          var _updateQueue = finishedWork.updateQueue;\n\n          if (_updateQueue !== null) {\n            var _instance = null;\n\n            if (finishedWork.child !== null) {\n              switch (finishedWork.child.tag) {\n                case HostComponent:\n                  _instance = getPublicInstance(finishedWork.child.stateNode);\n                  break;\n\n                case ClassComponent:\n                  _instance = finishedWork.child.stateNode;\n                  break;\n              }\n            }\n\n            commitUpdateQueue(finishedWork, _updateQueue, _instance);\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          var _instance2 = finishedWork.stateNode; // Renderers may schedule work to be done after host components are mounted\n          // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n          // These effects should only be committed when components are first mounted,\n          // aka when there is no current/alternate.\n\n          if (current === null && finishedWork.flags & Update) {\n            var type = finishedWork.type;\n            var props = finishedWork.memoizedProps;\n            commitMount(_instance2, type, props, finishedWork);\n          }\n\n          break;\n        }\n\n      case HostText:\n        {\n          // We have no life-cycles associated with text.\n          break;\n        }\n\n      case HostPortal:\n        {\n          // We have no life-cycles associated with portals.\n          break;\n        }\n\n      case Profiler:\n        {\n          {\n            var _finishedWork$memoize2 = finishedWork.memoizedProps,\n                onCommit = _finishedWork$memoize2.onCommit,\n                onRender = _finishedWork$memoize2.onRender;\n            var effectDuration = finishedWork.stateNode.effectDuration;\n            var commitTime = getCommitTime();\n            var phase = current === null ? 'mount' : 'update';\n\n            {\n              if (isCurrentUpdateNested()) {\n                phase = 'nested-update';\n              }\n            }\n\n            if (typeof onRender === 'function') {\n              onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);\n            }\n\n            {\n              if (typeof onCommit === 'function') {\n                onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);\n              } // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n              // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n              // because the effect is also where times bubble to parent Profilers.\n\n\n              enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor.\n              // Do not reset these values until the next render so DevTools has a chance to read them first.\n\n              var parentFiber = finishedWork.return;\n\n              outer: while (parentFiber !== null) {\n                switch (parentFiber.tag) {\n                  case HostRoot:\n                    var root = parentFiber.stateNode;\n                    root.effectDuration += effectDuration;\n                    break outer;\n\n                  case Profiler:\n                    var parentStateNode = parentFiber.stateNode;\n                    parentStateNode.effectDuration += effectDuration;\n                    break outer;\n                }\n\n                parentFiber = parentFiber.return;\n              }\n            }\n          }\n\n          break;\n        }\n\n      case SuspenseComponent:\n        {\n          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n          break;\n        }\n\n      case SuspenseListComponent:\n      case IncompleteClassComponent:\n      case ScopeComponent:\n      case OffscreenComponent:\n      case LegacyHiddenComponent:\n        {\n          break;\n        }\n\n      default:\n        throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n    }\n  }\n\n  if ( !offscreenSubtreeWasHidden) {\n    {\n      if (finishedWork.flags & Ref) {\n        commitAttachRef(finishedWork);\n      }\n    }\n  }\n}\n\nfunction reappearLayoutEffectsOnFiber(node) {\n  // Turn on layout effects in a tree that previously disappeared.\n  // TODO (Offscreen) Check: flags & LayoutStatic\n  switch (node.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if ( node.mode & ProfileMode) {\n          try {\n            startLayoutEffectTimer();\n            safelyCallCommitHookLayoutEffectListMount(node, node.return);\n          } finally {\n            recordLayoutEffectDuration(node);\n          }\n        } else {\n          safelyCallCommitHookLayoutEffectListMount(node, node.return);\n        }\n\n        break;\n      }\n\n    case ClassComponent:\n      {\n        var instance = node.stateNode;\n\n        if (typeof instance.componentDidMount === 'function') {\n          safelyCallComponentDidMount(node, node.return, instance);\n        }\n\n        safelyAttachRef(node, node.return);\n        break;\n      }\n\n    case HostComponent:\n      {\n        safelyAttachRef(node, node.return);\n        break;\n      }\n  }\n}\n\nfunction hideOrUnhideAllChildren(finishedWork, isHidden) {\n  // Only hide or unhide the top-most host nodes.\n  var hostSubtreeRoot = null;\n\n  if (supportsMutation) {\n    // We only have the top Fiber that was inserted but we need to recurse down its\n    // children to find all the terminal nodes.\n    var node = finishedWork;\n\n    while (true) {\n      if (node.tag === HostComponent) {\n        if (hostSubtreeRoot === null) {\n          hostSubtreeRoot = node;\n          var instance = node.stateNode;\n\n          if (isHidden) {\n            hideInstance(instance);\n          } else {\n            unhideInstance(node.stateNode, node.memoizedProps);\n          }\n        }\n      } else if (node.tag === HostText) {\n        if (hostSubtreeRoot === null) {\n          var _instance3 = node.stateNode;\n\n          if (isHidden) {\n            hideTextInstance(_instance3);\n          } else {\n            unhideTextInstance(_instance3, node.memoizedProps);\n          }\n        }\n      } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ; else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === finishedWork) {\n        return;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === finishedWork) {\n          return;\n        }\n\n        if (hostSubtreeRoot === node) {\n          hostSubtreeRoot = null;\n        }\n\n        node = node.return;\n      }\n\n      if (hostSubtreeRoot === node) {\n        hostSubtreeRoot = null;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n}\n\nfunction commitAttachRef(finishedWork) {\n  var ref = finishedWork.ref;\n\n  if (ref !== null) {\n    var instance = finishedWork.stateNode;\n    var instanceToUse;\n\n    switch (finishedWork.tag) {\n      case HostComponent:\n        instanceToUse = getPublicInstance(instance);\n        break;\n\n      default:\n        instanceToUse = instance;\n    } // Moved outside to ensure DCE works with this flag\n\n    if (typeof ref === 'function') {\n      var retVal;\n\n      if ( finishedWork.mode & ProfileMode) {\n        try {\n          startLayoutEffectTimer();\n          retVal = ref(instanceToUse);\n        } finally {\n          recordLayoutEffectDuration(finishedWork);\n        }\n      } else {\n        retVal = ref(instanceToUse);\n      }\n\n      {\n        if (typeof retVal === 'function') {\n          error('Unexpected return value from a callback ref in %s. ' + 'A callback ref should not return a function.', getComponentNameFromFiber(finishedWork));\n        }\n      }\n    } else {\n      {\n        if (!ref.hasOwnProperty('current')) {\n          error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentNameFromFiber(finishedWork));\n        }\n      }\n\n      ref.current = instanceToUse;\n    }\n  }\n}\n\nfunction commitDetachRef(current) {\n  var currentRef = current.ref;\n\n  if (currentRef !== null) {\n    if (typeof currentRef === 'function') {\n      if ( current.mode & ProfileMode) {\n        try {\n          startLayoutEffectTimer();\n          currentRef(null);\n        } finally {\n          recordLayoutEffectDuration(current);\n        }\n      } else {\n        currentRef(null);\n      }\n    } else {\n      currentRef.current = null;\n    }\n  }\n} // User-originating errors (lifecycles and refs) should not interrupt\n// deletion, so don't let them throw. Host-originating errors should\n// interrupt deletion, so it's okay\n\n\nfunction commitUnmount(finishedRoot, current, nearestMountedAncestor) {\n  onCommitUnmount(current);\n\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      {\n        var updateQueue = current.updateQueue;\n\n        if (updateQueue !== null) {\n          var lastEffect = updateQueue.lastEffect;\n\n          if (lastEffect !== null) {\n            var firstEffect = lastEffect.next;\n            var effect = firstEffect;\n\n            do {\n              var _effect = effect,\n                  destroy = _effect.destroy,\n                  tag = _effect.tag;\n\n              if (destroy !== undefined) {\n                if ((tag & Insertion) !== NoFlags$1) {\n                  safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                } else if ((tag & Layout) !== NoFlags$1) {\n                  {\n                    markComponentLayoutEffectUnmountStarted(current);\n                  }\n\n                  if ( current.mode & ProfileMode) {\n                    startLayoutEffectTimer();\n                    safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                    recordLayoutEffectDuration(current);\n                  } else {\n                    safelyCallDestroy(current, nearestMountedAncestor, destroy);\n                  }\n\n                  {\n                    markComponentLayoutEffectUnmountStopped();\n                  }\n                }\n              }\n\n              effect = effect.next;\n            } while (effect !== firstEffect);\n          }\n        }\n\n        return;\n      }\n\n    case ClassComponent:\n      {\n        safelyDetachRef(current, nearestMountedAncestor);\n        var instance = current.stateNode;\n\n        if (typeof instance.componentWillUnmount === 'function') {\n          safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance);\n        }\n\n        return;\n      }\n\n    case HostComponent:\n      {\n        safelyDetachRef(current, nearestMountedAncestor);\n        return;\n      }\n\n    case HostPortal:\n      {\n        // TODO: this is recursive.\n        // We are also not using this parent because\n        // the portal will get pushed immediately.\n        if (supportsMutation) {\n          unmountHostComponents(finishedRoot, current, nearestMountedAncestor);\n        } else if (supportsPersistence) {\n          emptyPortalContainer(current);\n        }\n\n        return;\n      }\n\n    case DehydratedFragment:\n      {\n\n        return;\n      }\n\n    case ScopeComponent:\n      {\n\n        return;\n      }\n  }\n}\n\nfunction commitNestedUnmounts(finishedRoot, root, nearestMountedAncestor) {\n  // While we're inside a removed host node we don't want to call\n  // removeChild on the inner nodes because they're removed by the top\n  // call anyway. We also want to call componentWillUnmount on all\n  // composites before this host node is removed from the tree. Therefore\n  // we do an inner loop while we're still inside the host node.\n  var node = root;\n\n  while (true) {\n    commitUnmount(finishedRoot, node, nearestMountedAncestor); // Visit children because they may contain more composite or host nodes.\n    // Skip portals because commitUnmount() currently visits them recursively.\n\n    if (node.child !== null && ( // If we use mutation we drill down into portals using commitUnmount above.\n    // If we don't use mutation we drill down into portals here instead.\n    !supportsMutation || node.tag !== HostPortal)) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n\n    if (node === root) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === root) {\n        return;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction detachFiberMutation(fiber) {\n  // Cut off the return pointer to disconnect it from the tree.\n  // This enables us to detect and warn against state updates on an unmounted component.\n  // It also prevents events from bubbling from within disconnected components.\n  //\n  // Ideally, we should also clear the child pointer of the parent alternate to let this\n  // get GC:ed but we don't know which for sure which parent is the current\n  // one so we'll settle for GC:ing the subtree of this child.\n  // This child itself will be GC:ed when the parent updates the next time.\n  //\n  // Note that we can't clear child or sibling pointers yet.\n  // They're needed for passive effects and for findDOMNode.\n  // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n  //\n  // Don't reset the alternate yet, either. We need that so we can detach the\n  // alternate's fields in the passive phase. Clearing the return pointer is\n  // sufficient for findDOMNode semantics.\n  var alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    alternate.return = null;\n  }\n\n  fiber.return = null;\n}\n\nfunction detachFiberAfterEffects(fiber) {\n  var alternate = fiber.alternate;\n\n  if (alternate !== null) {\n    fiber.alternate = null;\n    detachFiberAfterEffects(alternate);\n  } // Note: Defensively using negation instead of < in case\n  // `deletedTreeCleanUpLevel` is undefined.\n\n\n  {\n    // Clear cyclical Fiber fields. This level alone is designed to roughly\n    // approximate the planned Fiber refactor. In that world, `setState` will be\n    // bound to a special \"instance\" object instead of a Fiber. The Instance\n    // object will not have any of these fields. It will only be connected to\n    // the fiber tree via a single link at the root. So if this level alone is\n    // sufficient to fix memory issues, that bodes well for our plans.\n    fiber.child = null;\n    fiber.deletions = null;\n    fiber.sibling = null; // The `stateNode` is cyclical because on host nodes it points to the host\n    // tree, which has its own pointers to children, parents, and siblings.\n    // The other host nodes also point back to fibers, so we should detach that\n    // one, too.\n\n    if (fiber.tag === HostComponent) {\n      var hostInstance = fiber.stateNode;\n\n      if (hostInstance !== null) {\n        detachDeletedInstance(hostInstance);\n      }\n    }\n\n    fiber.stateNode = null; // I'm intentionally not clearing the `return` field in this level. We\n    // already disconnect the `return` pointer at the root of the deleted\n    // subtree (in `detachFiberMutation`). Besides, `return` by itself is not\n    // cyclical  it's only cyclical when combined with `child`, `sibling`, and\n    // `alternate`. But we'll clear it in the next level anyway, just in case.\n\n    {\n      fiber._debugOwner = null;\n    }\n\n    {\n      // Theoretically, nothing in here should be necessary, because we already\n      // disconnected the fiber from the tree. So even if something leaks this\n      // particular fiber, it won't leak anything else\n      //\n      // The purpose of this branch is to be super aggressive so we can measure\n      // if there's any difference in memory impact. If there is, that could\n      // indicate a React leak we don't know about.\n      fiber.return = null;\n      fiber.dependencies = null;\n      fiber.memoizedProps = null;\n      fiber.memoizedState = null;\n      fiber.pendingProps = null;\n      fiber.stateNode = null; // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n\n      fiber.updateQueue = null;\n    }\n  }\n}\n\nfunction emptyPortalContainer(current) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  var portal = current.stateNode;\n  var containerInfo = portal.containerInfo;\n  var emptyChildSet = createContainerChildSet(containerInfo);\n  replaceContainerChildren(containerInfo, emptyChildSet);\n}\n\nfunction commitContainer(finishedWork) {\n  if (!supportsPersistence) {\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case ClassComponent:\n    case HostComponent:\n    case HostText:\n      {\n        return;\n      }\n\n    case HostRoot:\n    case HostPortal:\n      {\n        var portalOrRoot = finishedWork.stateNode;\n        var containerInfo = portalOrRoot.containerInfo,\n            pendingChildren = portalOrRoot.pendingChildren;\n        replaceContainerChildren(containerInfo, pendingChildren);\n        return;\n      }\n  }\n\n  throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n}\n\nfunction getHostParentFiber(fiber) {\n  var parent = fiber.return;\n\n  while (parent !== null) {\n    if (isHostParent(parent)) {\n      return parent;\n    }\n\n    parent = parent.return;\n  }\n\n  throw new Error('Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n}\n\nfunction isHostParent(fiber) {\n  return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;\n}\n\nfunction getHostSibling(fiber) {\n  // We're going to search forward into the tree until we find a sibling host\n  // node. Unfortunately, if multiple insertions are done in a row we have to\n  // search past them. This leads to exponential search for the next sibling.\n  // TODO: Find a more efficient way to do this.\n  var node = fiber;\n\n  siblings: while (true) {\n    // If we didn't find anything, let's try the next sibling.\n    while (node.sibling === null) {\n      if (node.return === null || isHostParent(node.return)) {\n        // If we pop out of the root or hit the parent the fiber we are the\n        // last sibling.\n        return null;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n\n    while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {\n      // If it is not host node and, we might have a host node inside it.\n      // Try to search down until we find one.\n      if (node.flags & Placement) {\n        // If we don't have a child, try the siblings instead.\n        continue siblings;\n      } // If we don't have a child, try the siblings instead.\n      // We also skip portals because they are not part of this host tree.\n\n\n      if (node.child === null || node.tag === HostPortal) {\n        continue siblings;\n      } else {\n        node.child.return = node;\n        node = node.child;\n      }\n    } // Check if this host node is stable or about to be placed.\n\n\n    if (!(node.flags & Placement)) {\n      // Found it!\n      return node.stateNode;\n    }\n  }\n}\n\nfunction commitPlacement(finishedWork) {\n  if (!supportsMutation) {\n    return;\n  } // Recursively insert all host nodes into the parent.\n\n\n  var parentFiber = getHostParentFiber(finishedWork); // Note: these two variables *must* always be updated together.\n\n  switch (parentFiber.tag) {\n    case HostComponent:\n      {\n        var parent = parentFiber.stateNode;\n\n        if (parentFiber.flags & ContentReset) {\n          // Reset the text content of the parent before doing any insertions\n          resetTextContent(parent); // Clear ContentReset from the effect tag\n\n          parentFiber.flags &= ~ContentReset;\n        }\n\n        var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n        // children to find all the terminal nodes.\n\n        insertOrAppendPlacementNode(finishedWork, before, parent);\n        break;\n      }\n\n    case HostRoot:\n    case HostPortal:\n      {\n        var _parent = parentFiber.stateNode.containerInfo;\n\n        var _before = getHostSibling(finishedWork);\n\n        insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);\n        break;\n      }\n    // eslint-disable-next-line-no-fallthrough\n\n    default:\n      throw new Error('Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n  }\n}\n\nfunction insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n  var tag = node.tag;\n  var isHost = tag === HostComponent || tag === HostText;\n\n  if (isHost) {\n    var stateNode = node.stateNode;\n\n    if (before) {\n      insertInContainerBefore(parent, stateNode, before);\n    } else {\n      appendChildToContainer(parent, stateNode);\n    }\n  } else if (tag === HostPortal) ; else {\n    var child = node.child;\n\n    if (child !== null) {\n      insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n      var sibling = child.sibling;\n\n      while (sibling !== null) {\n        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\nfunction insertOrAppendPlacementNode(node, before, parent) {\n  var tag = node.tag;\n  var isHost = tag === HostComponent || tag === HostText;\n\n  if (isHost) {\n    var stateNode = node.stateNode;\n\n    if (before) {\n      insertBefore(parent, stateNode, before);\n    } else {\n      appendChild(parent, stateNode);\n    }\n  } else if (tag === HostPortal) ; else {\n    var child = node.child;\n\n    if (child !== null) {\n      insertOrAppendPlacementNode(child, before, parent);\n      var sibling = child.sibling;\n\n      while (sibling !== null) {\n        insertOrAppendPlacementNode(sibling, before, parent);\n        sibling = sibling.sibling;\n      }\n    }\n  }\n}\n\nfunction unmountHostComponents(finishedRoot, current, nearestMountedAncestor) {\n  // We only have the top Fiber that was deleted but we need to recurse down its\n  // children to find all the terminal nodes.\n  var node = current; // Each iteration, currentParent is populated with node's host parent if not\n  // currentParentIsValid.\n\n  var currentParentIsValid = false; // Note: these two variables *must* always be updated together.\n\n  var currentParent;\n  var currentParentIsContainer;\n\n  while (true) {\n    if (!currentParentIsValid) {\n      var parent = node.return;\n\n      findParent: while (true) {\n        if (parent === null) {\n          throw new Error('Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n        }\n\n        var parentStateNode = parent.stateNode;\n\n        switch (parent.tag) {\n          case HostComponent:\n            currentParent = parentStateNode;\n            currentParentIsContainer = false;\n            break findParent;\n\n          case HostRoot:\n            currentParent = parentStateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n\n          case HostPortal:\n            currentParent = parentStateNode.containerInfo;\n            currentParentIsContainer = true;\n            break findParent;\n        }\n\n        parent = parent.return;\n      }\n\n      currentParentIsValid = true;\n    }\n\n    if (node.tag === HostComponent || node.tag === HostText) {\n      commitNestedUnmounts(finishedRoot, node, nearestMountedAncestor); // After all the children have unmounted, it is now safe to remove the\n      // node from the tree.\n\n      if (currentParentIsContainer) {\n        removeChildFromContainer(currentParent, node.stateNode);\n      } else {\n        removeChild(currentParent, node.stateNode);\n      } // Don't visit children because we already visited them.\n\n    } else if ( node.tag === DehydratedFragment) {\n\n\n      if (currentParentIsContainer) {\n        clearSuspenseBoundaryFromContainer(currentParent, node.stateNode);\n      } else {\n        clearSuspenseBoundary(currentParent, node.stateNode);\n      }\n    } else if (node.tag === HostPortal) {\n      if (node.child !== null) {\n        // When we go into a portal, it becomes the parent to remove from.\n        // We will reassign it back when we pop the portal on the way up.\n        currentParent = node.stateNode.containerInfo;\n        currentParentIsContainer = true; // Visit children because portals might contain host components.\n\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    } else {\n      commitUnmount(finishedRoot, node, nearestMountedAncestor); // Visit children because we may find more host components below.\n\n      if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n    }\n\n    if (node === current) {\n      return;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === current) {\n        return;\n      }\n\n      node = node.return;\n\n      if (node.tag === HostPortal) {\n        // When we go out of the portal, we need to restore the parent.\n        // Since we don't keep a stack of them, we will search for it.\n        currentParentIsValid = false;\n      }\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n}\n\nfunction commitDeletion(finishedRoot, current, nearestMountedAncestor) {\n  if (supportsMutation) {\n    // Recursively delete all host nodes from the parent.\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    unmountHostComponents(finishedRoot, current, nearestMountedAncestor);\n  } else {\n    // Detach refs and call componentWillUnmount() on the whole subtree.\n    commitNestedUnmounts(finishedRoot, current, nearestMountedAncestor);\n  }\n\n  detachFiberMutation(current);\n}\n\nfunction commitWork(current, finishedWork) {\n  if (!supportsMutation) {\n    switch (finishedWork.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent:\n        {\n          commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n          commitHookEffectListMount(Insertion | HasEffect, finishedWork); // Layout effects are destroyed during the mutation phase so that all\n          // destroy functions for all fibers are called before any create functions.\n          // This prevents sibling component effects from interfering with each other,\n          // e.g. a destroy function in one component should never override a ref set\n          // by a create function in another component during the same commit.\n          // TODO: Check if we're inside an Offscreen subtree that disappeared\n          // during this commit. If so, we would have already unmounted its\n          // layout hooks. (However, since we null out the `destroy` function\n          // right before calling it, the behavior is already correct, so this\n          // would mostly be for modeling purposes.)\n\n          if ( finishedWork.mode & ProfileMode) {\n            try {\n              startLayoutEffectTimer();\n              commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n            } finally {\n              recordLayoutEffectDuration(finishedWork);\n            }\n          } else {\n            commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n          }\n\n          return;\n        }\n\n      case Profiler:\n        {\n          return;\n        }\n\n      case SuspenseComponent:\n        {\n          commitSuspenseCallback(finishedWork);\n          attachSuspenseRetryListeners(finishedWork);\n          return;\n        }\n\n      case SuspenseListComponent:\n        {\n          attachSuspenseRetryListeners(finishedWork);\n          return;\n        }\n\n      case HostRoot:\n        {\n          if (supportsHydration) {\n            if (current !== null) {\n              var prevRootState = current.memoizedState;\n\n              if (prevRootState.isDehydrated) {\n                var root = finishedWork.stateNode;\n                commitHydratedContainer(root.containerInfo);\n              }\n            }\n          }\n\n          break;\n        }\n\n      case OffscreenComponent:\n      case LegacyHiddenComponent:\n        {\n          return;\n        }\n    }\n\n    commitContainer(finishedWork);\n    return;\n  }\n\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case MemoComponent:\n    case SimpleMemoComponent:\n      {\n        commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n        commitHookEffectListMount(Insertion | HasEffect, finishedWork); // Layout effects are destroyed during the mutation phase so that all\n        // destroy functions for all fibers are called before any create functions.\n        // This prevents sibling component effects from interfering with each other,\n        // e.g. a destroy function in one component should never override a ref set\n        // by a create function in another component during the same commit.\n\n        if ( finishedWork.mode & ProfileMode) {\n          try {\n            startLayoutEffectTimer();\n            commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n          } finally {\n            recordLayoutEffectDuration(finishedWork);\n          }\n        } else {\n          commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n        }\n\n        return;\n      }\n\n    case ClassComponent:\n      {\n        return;\n      }\n\n    case HostComponent:\n      {\n        var instance = finishedWork.stateNode;\n\n        if (instance != null) {\n          // Commit the work prepared earlier.\n          var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n          // as the newProps. The updatePayload will contain the real change in\n          // this case.\n\n          var oldProps = current !== null ? current.memoizedProps : newProps;\n          var type = finishedWork.type; // TODO: Type the updateQueue to be specific to host components.\n\n          var updatePayload = finishedWork.updateQueue;\n          finishedWork.updateQueue = null;\n\n          if (updatePayload !== null) {\n            commitUpdate(instance, updatePayload, type, oldProps, newProps, finishedWork);\n          }\n        }\n\n        return;\n      }\n\n    case HostText:\n      {\n        if (finishedWork.stateNode === null) {\n          throw new Error('This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n        }\n\n        var textInstance = finishedWork.stateNode;\n        var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n        // as the newProps. The updatePayload will contain the real change in\n        // this case.\n\n        var oldText = current !== null ? current.memoizedProps : newText;\n        commitTextUpdate(textInstance, oldText, newText);\n        return;\n      }\n\n    case HostRoot:\n      {\n        if (supportsHydration) {\n          if (current !== null) {\n            var _prevRootState = current.memoizedState;\n\n            if (_prevRootState.isDehydrated) {\n              var _root = finishedWork.stateNode;\n              commitHydratedContainer(_root.containerInfo);\n            }\n          }\n        }\n\n        return;\n      }\n\n    case Profiler:\n      {\n        return;\n      }\n\n    case SuspenseComponent:\n      {\n        commitSuspenseCallback(finishedWork);\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n\n    case SuspenseListComponent:\n      {\n        attachSuspenseRetryListeners(finishedWork);\n        return;\n      }\n\n    case IncompleteClassComponent:\n      {\n        return;\n      }\n  }\n\n  throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n}\n\nfunction commitSuspenseCallback(finishedWork) {\n  // TODO: Move this to passive phase\n  var newState = finishedWork.memoizedState;\n}\n\nfunction commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n  if (!supportsHydration) {\n    return;\n  }\n\n  var newState = finishedWork.memoizedState;\n\n  if (newState === null) {\n    var current = finishedWork.alternate;\n\n    if (current !== null) {\n      var prevState = current.memoizedState;\n\n      if (prevState !== null) {\n        var suspenseInstance = prevState.dehydrated;\n\n        if (suspenseInstance !== null) {\n          commitHydratedSuspenseInstance(suspenseInstance);\n        }\n      }\n    }\n  }\n}\n\nfunction attachSuspenseRetryListeners(finishedWork) {\n  // If this boundary just timed out, then it will have a set of wakeables.\n  // For each wakeable, attach a listener so that when it resolves, React\n  // attempts to re-render the boundary in the primary (pre-timeout) state.\n  var wakeables = finishedWork.updateQueue;\n\n  if (wakeables !== null) {\n    finishedWork.updateQueue = null;\n    var retryCache = finishedWork.stateNode;\n\n    if (retryCache === null) {\n      retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n    }\n\n    wakeables.forEach(function (wakeable) {\n      // Memoize using the boundary fiber to prevent redundant listeners.\n      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n\n      if (!retryCache.has(wakeable)) {\n        retryCache.add(wakeable);\n\n        {\n          if (isDevToolsPresent) {\n            if (inProgressLanes !== null && inProgressRoot !== null) {\n              // If we have pending work still, associate the original updaters with it.\n              restorePendingUpdaters(inProgressRoot, inProgressLanes);\n            } else {\n              throw Error('Expected finished root and lanes to be set. This is a bug in React.');\n            }\n          }\n        }\n\n        wakeable.then(retry, retry);\n      }\n    });\n  }\n} // This function detects when a Suspense boundary goes from visible to hidden.\n\nfunction commitResetTextContent(current) {\n  if (!supportsMutation) {\n    return;\n  }\n\n  resetTextContent(current.stateNode);\n}\n\nfunction commitMutationEffects(root, firstChild, committedLanes) {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n  nextEffect = firstChild;\n  commitMutationEffects_begin(root, committedLanes);\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction commitMutationEffects_begin(root, lanes) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect; // TODO: Should wrap this in flags check, too, as optimization\n\n    var deletions = fiber.deletions;\n\n    if (deletions !== null) {\n      for (var i = 0; i < deletions.length; i++) {\n        var childToDelete = deletions[i];\n\n        try {\n          commitDeletion(root, childToDelete, fiber);\n        } catch (error) {\n          reportUncaughtErrorInDEV(error);\n          captureCommitPhaseError(childToDelete, fiber, error);\n        }\n      }\n    }\n\n    var child = fiber.child;\n\n    if ((fiber.subtreeFlags & MutationMask) !== NoFlags && child !== null) {\n      ensureCorrectReturnPointer(child, fiber);\n      nextEffect = child;\n    } else {\n      commitMutationEffects_complete(root, lanes);\n    }\n  }\n}\n\nfunction commitMutationEffects_complete(root, lanes) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    setCurrentFiber(fiber);\n\n    try {\n      commitMutationEffectsOnFiber(fiber, root, lanes);\n    } catch (error) {\n      reportUncaughtErrorInDEV(error);\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n\n    resetCurrentFiber();\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, fiber.return);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitMutationEffectsOnFiber(finishedWork, root, lanes) {\n  // TODO: The factoring of this phase could probably be improved. Consider\n  // switching on the type of work before checking the flags. That's what\n  // we do in all the other phases. I think this one is only different\n  // because of the shared reconciliation logic below.\n  var flags = finishedWork.flags;\n\n  if (flags & ContentReset) {\n    commitResetTextContent(finishedWork);\n  }\n\n  if (flags & Ref) {\n    var current = finishedWork.alternate;\n\n    if (current !== null) {\n      commitDetachRef(current);\n    }\n  }\n\n  if (flags & Visibility) {\n    switch (finishedWork.tag) {\n      case SuspenseComponent:\n        {\n          var newState = finishedWork.memoizedState;\n          var isHidden = newState !== null;\n\n          if (isHidden) {\n            var _current = finishedWork.alternate;\n            var wasHidden = _current !== null && _current.memoizedState !== null;\n\n            if (!wasHidden) {\n              // TODO: Move to passive phase\n              markCommitTimeOfFallback();\n            }\n          }\n\n          break;\n        }\n\n      case OffscreenComponent:\n        {\n          var _newState = finishedWork.memoizedState;\n\n          var _isHidden = _newState !== null;\n\n          var _current2 = finishedWork.alternate;\n\n          var _wasHidden = _current2 !== null && _current2.memoizedState !== null;\n\n          var offscreenBoundary = finishedWork;\n\n          if (supportsMutation) {\n            // TODO: This needs to run whenever there's an insertion or update\n            // inside a hidden Offscreen tree.\n            hideOrUnhideAllChildren(offscreenBoundary, _isHidden);\n          }\n\n          {\n            if (_isHidden) {\n              if (!_wasHidden) {\n                if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {\n                  nextEffect = offscreenBoundary;\n                  var offscreenChild = offscreenBoundary.child;\n\n                  while (offscreenChild !== null) {\n                    nextEffect = offscreenChild;\n                    disappearLayoutEffects_begin(offscreenChild);\n                    offscreenChild = offscreenChild.sibling;\n                  }\n                }\n              }\n            }\n\n            break;\n          }\n        }\n    }\n  } // The following switch statement is only concerned about placement,\n  // updates, and deletions. To avoid needing to add a case for every possible\n  // bitmap value, we remove the secondary effects from the effect tag and\n  // switch on that value.\n\n\n  var primaryFlags = flags & (Placement | Update | Hydrating);\n\n   switch (primaryFlags) {\n    case Placement:\n      {\n        commitPlacement(finishedWork); // Clear the \"placement\" from effect tag so that we know that this is\n        // inserted, before any life-cycles like componentDidMount gets called.\n        // TODO: findDOMNode doesn't rely on this any more but isMounted does\n        // and isMounted is deprecated anyway so we should be able to kill this.\n\n        finishedWork.flags &= ~Placement;\n        break;\n      }\n\n    case PlacementAndUpdate:\n      {\n        // Placement\n        commitPlacement(finishedWork); // Clear the \"placement\" from effect tag so that we know that this is\n        // inserted, before any life-cycles like componentDidMount gets called.\n\n        finishedWork.flags &= ~Placement; // Update\n\n        var _current3 = finishedWork.alternate;\n        commitWork(_current3, finishedWork);\n        break;\n      }\n\n    case Hydrating:\n      {\n        finishedWork.flags &= ~Hydrating;\n        break;\n      }\n\n    case HydratingAndUpdate:\n      {\n        finishedWork.flags &= ~Hydrating; // Update\n\n        var _current4 = finishedWork.alternate;\n        commitWork(_current4, finishedWork);\n        break;\n      }\n\n    case Update:\n      {\n        var _current5 = finishedWork.alternate;\n        commitWork(_current5, finishedWork);\n        break;\n      }\n  }\n}\n\nfunction commitLayoutEffects(finishedWork, root, committedLanes) {\n  inProgressLanes = committedLanes;\n  inProgressRoot = root;\n  nextEffect = finishedWork;\n  commitLayoutEffects_begin(finishedWork, root, committedLanes);\n  inProgressLanes = null;\n  inProgressRoot = null;\n}\n\nfunction commitLayoutEffects_begin(subtreeRoot, root, committedLanes) {\n  // Suspense layout effects semantics don't change for legacy roots.\n  var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;\n\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var firstChild = fiber.child;\n\n    if ( fiber.tag === OffscreenComponent && isModernRoot) {\n      // Keep track of the current Offscreen stack's state.\n      var isHidden = fiber.memoizedState !== null;\n      var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n\n      if (newOffscreenSubtreeIsHidden) {\n        // The Offscreen tree is hidden. Skip over its layout effects.\n        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n        continue;\n      } else {\n        // TODO (Offscreen) Also check: subtreeFlags & LayoutMask\n        var current = fiber.alternate;\n        var wasHidden = current !== null && current.memoizedState !== null;\n        var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n        var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden; // Traverse the Offscreen subtree with the current Offscreen as the root.\n\n        offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n        offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n\n        if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n          // This is the root of a reappearing boundary. Turn its layout effects\n          // back on.\n          nextEffect = fiber;\n          reappearLayoutEffects_begin(fiber);\n        }\n\n        var child = firstChild;\n\n        while (child !== null) {\n          nextEffect = child;\n          commitLayoutEffects_begin(child, // New root; bubble back up to here and stop.\n          root, committedLanes);\n          child = child.sibling;\n        } // Restore Offscreen state and resume in our-progress traversal.\n\n\n        nextEffect = fiber;\n        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n        commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n        continue;\n      }\n    }\n\n    if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {\n      ensureCorrectReturnPointer(firstChild, fiber);\n      nextEffect = firstChild;\n    } else {\n      commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes);\n    }\n  }\n}\n\nfunction commitLayoutMountEffects_complete(subtreeRoot, root, committedLanes) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n\n    if ((fiber.flags & LayoutMask) !== NoFlags) {\n      var current = fiber.alternate;\n      setCurrentFiber(fiber);\n\n      try {\n        commitLayoutEffectOnFiber(root, current, fiber, committedLanes);\n      } catch (error) {\n        reportUncaughtErrorInDEV(error);\n        captureCommitPhaseError(fiber, fiber.return, error);\n      }\n\n      resetCurrentFiber();\n    }\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, fiber.return);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction disappearLayoutEffects_begin(subtreeRoot) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var firstChild = fiber.child; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case MemoComponent:\n      case SimpleMemoComponent:\n        {\n          if ( fiber.mode & ProfileMode) {\n            try {\n              startLayoutEffectTimer();\n              commitHookEffectListUnmount(Layout, fiber, fiber.return);\n            } finally {\n              recordLayoutEffectDuration(fiber);\n            }\n          } else {\n            commitHookEffectListUnmount(Layout, fiber, fiber.return);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          // TODO (Offscreen) Check: flags & RefStatic\n          safelyDetachRef(fiber, fiber.return);\n          var instance = fiber.stateNode;\n\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n          }\n\n          break;\n        }\n\n      case HostComponent:\n        {\n          safelyDetachRef(fiber, fiber.return);\n          break;\n        }\n\n      case OffscreenComponent:\n        {\n          // Check if this is a\n          var isHidden = fiber.memoizedState !== null;\n\n          if (isHidden) {\n            // Nested Offscreen tree is already hidden. Don't disappear\n            // its effects.\n            disappearLayoutEffects_complete(subtreeRoot);\n            continue;\n          }\n\n          break;\n        }\n    } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n\n\n    if (firstChild !== null) {\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      disappearLayoutEffects_complete(subtreeRoot);\n    }\n  }\n}\n\nfunction disappearLayoutEffects_complete(subtreeRoot) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction reappearLayoutEffects_begin(subtreeRoot) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var firstChild = fiber.child;\n\n    if (fiber.tag === OffscreenComponent) {\n      var isHidden = fiber.memoizedState !== null;\n\n      if (isHidden) {\n        // Nested Offscreen tree is still hidden. Don't re-appear its effects.\n        reappearLayoutEffects_complete(subtreeRoot);\n        continue;\n      }\n    } // TODO (Offscreen) Check: subtreeFlags & LayoutStatic\n\n\n    if (firstChild !== null) {\n      // This node may have been reused from a previous render, so we can't\n      // assume its return pointer is correct.\n      firstChild.return = fiber;\n      nextEffect = firstChild;\n    } else {\n      reappearLayoutEffects_complete(subtreeRoot);\n    }\n  }\n}\n\nfunction reappearLayoutEffects_complete(subtreeRoot) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect; // TODO (Offscreen) Check: flags & LayoutStatic\n\n    setCurrentFiber(fiber);\n\n    try {\n      reappearLayoutEffectsOnFiber(fiber);\n    } catch (error) {\n      reportUncaughtErrorInDEV(error);\n      captureCommitPhaseError(fiber, fiber.return, error);\n    }\n\n    resetCurrentFiber();\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      // This node may have been reused from a previous render, so we can't\n      // assume its return pointer is correct.\n      sibling.return = fiber.return;\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitPassiveMountEffects(root, finishedWork) {\n  nextEffect = finishedWork;\n  commitPassiveMountEffects_begin(finishedWork, root);\n}\n\nfunction commitPassiveMountEffects_begin(subtreeRoot, root) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var firstChild = fiber.child;\n\n    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {\n      ensureCorrectReturnPointer(firstChild, fiber);\n      nextEffect = firstChild;\n    } else {\n      commitPassiveMountEffects_complete(subtreeRoot, root);\n    }\n  }\n}\n\nfunction commitPassiveMountEffects_complete(subtreeRoot, root) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n\n    if ((fiber.flags & Passive) !== NoFlags) {\n      setCurrentFiber(fiber);\n\n      try {\n        commitPassiveMountOnFiber(root, fiber);\n      } catch (error) {\n        reportUncaughtErrorInDEV(error);\n        captureCommitPhaseError(fiber, fiber.return, error);\n      }\n\n      resetCurrentFiber();\n    }\n\n    if (fiber === subtreeRoot) {\n      nextEffect = null;\n      return;\n    }\n\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, fiber.return);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitPassiveMountOnFiber(finishedRoot, finishedWork) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if ( finishedWork.mode & ProfileMode) {\n          startPassiveEffectTimer();\n\n          try {\n            commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n          } finally {\n            recordPassiveEffectDuration(finishedWork);\n          }\n        } else {\n          commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);\n        }\n\n        break;\n      }\n  }\n}\n\nfunction commitPassiveUnmountEffects(firstChild) {\n  nextEffect = firstChild;\n  commitPassiveUnmountEffects_begin();\n}\n\nfunction commitPassiveUnmountEffects_begin() {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var child = fiber.child;\n\n    if ((nextEffect.flags & ChildDeletion) !== NoFlags) {\n      var deletions = fiber.deletions;\n\n      if (deletions !== null) {\n        for (var i = 0; i < deletions.length; i++) {\n          var fiberToDelete = deletions[i];\n          nextEffect = fiberToDelete;\n          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);\n        }\n\n        {\n          // A fiber was deleted from this parent fiber, but it's still part of\n          // the previous (alternate) parent fiber's list of children. Because\n          // children are a linked list, an earlier sibling that's still alive\n          // will be connected to the deleted fiber via its `alternate`:\n          //\n          //   live fiber\n          //   --alternate--> previous live fiber\n          //   --sibling--> deleted fiber\n          //\n          // We can't disconnect `alternate` on nodes that haven't been deleted\n          // yet, but we can disconnect the `sibling` and `child` pointers.\n          var previousFiber = fiber.alternate;\n\n          if (previousFiber !== null) {\n            var detachedChild = previousFiber.child;\n\n            if (detachedChild !== null) {\n              previousFiber.child = null;\n\n              do {\n                var detachedSibling = detachedChild.sibling;\n                detachedChild.sibling = null;\n                detachedChild = detachedSibling;\n              } while (detachedChild !== null);\n            }\n          }\n        }\n\n        nextEffect = fiber;\n      }\n    }\n\n    if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {\n      ensureCorrectReturnPointer(child, fiber);\n      nextEffect = child;\n    } else {\n      commitPassiveUnmountEffects_complete();\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffects_complete() {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n\n    if ((fiber.flags & Passive) !== NoFlags) {\n      setCurrentFiber(fiber);\n      commitPassiveUnmountOnFiber(fiber);\n      resetCurrentFiber();\n    }\n\n    var sibling = fiber.sibling;\n\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, fiber.return);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = fiber.return;\n  }\n}\n\nfunction commitPassiveUnmountOnFiber(finishedWork) {\n  switch (finishedWork.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if ( finishedWork.mode & ProfileMode) {\n          startPassiveEffectTimer();\n          commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n          recordPassiveEffectDuration(finishedWork);\n        } else {\n          commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);\n        }\n\n        break;\n      }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect; // Deletion effects fire in parent -> child order\n    // TODO: Check if fiber has a PassiveStatic flag\n\n    setCurrentFiber(fiber);\n    commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n    resetCurrentFiber();\n    var child = fiber.child; // TODO: Only traverse subtree if it has a PassiveStatic flag. (But, if we\n    // do this, still need to handle `deletedTreeCleanUpLevel` correctly.)\n\n    if (child !== null) {\n      ensureCorrectReturnPointer(child, fiber);\n      nextEffect = child;\n    } else {\n      commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n    }\n  }\n}\n\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n  while (nextEffect !== null) {\n    var fiber = nextEffect;\n    var sibling = fiber.sibling;\n    var returnFiber = fiber.return;\n\n    {\n      // Recursively traverse the entire deleted tree and clean up fiber fields.\n      // This is more aggressive than ideal, and the long term goal is to only\n      // have to detach the deleted tree at the root.\n      detachFiberAfterEffects(fiber);\n\n      if (fiber === deletedSubtreeRoot) {\n        nextEffect = null;\n        return;\n      }\n    }\n\n    if (sibling !== null) {\n      ensureCorrectReturnPointer(sibling, returnFiber);\n      nextEffect = sibling;\n      return;\n    }\n\n    nextEffect = returnFiber;\n  }\n}\n\nfunction commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {\n  switch (current.tag) {\n    case FunctionComponent:\n    case ForwardRef:\n    case SimpleMemoComponent:\n      {\n        if ( current.mode & ProfileMode) {\n          startPassiveEffectTimer();\n          commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);\n          recordPassiveEffectDuration(current);\n        } else {\n          commitHookEffectListUnmount(Passive$1, current, nearestMountedAncestor);\n        }\n\n        break;\n      }\n  }\n}\n\nvar didWarnWrongReturnPointer = false;\n\nfunction ensureCorrectReturnPointer(fiber, expectedReturnFiber) {\n  {\n    if (!didWarnWrongReturnPointer && fiber.return !== expectedReturnFiber) {\n      didWarnWrongReturnPointer = true;\n\n      error('Internal React error: Return pointer is inconsistent ' + 'with parent.');\n    }\n  } // TODO: Remove this assignment once we're confident that it won't break\n  // anything, by checking the warning logs for the above invariant\n\n\n  fiber.return = expectedReturnFiber;\n} // TODO: Reuse reappearLayoutEffects traversal here?\n\n\nfunction invokeLayoutEffectMountInDEV(fiber) {\n  {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListMount(Layout | HasEffect, fiber);\n          } catch (error) {\n            reportUncaughtErrorInDEV(error);\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          var instance = fiber.stateNode;\n\n          try {\n            instance.componentDidMount();\n          } catch (error) {\n            reportUncaughtErrorInDEV(error);\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokePassiveEffectMountInDEV(fiber) {\n  {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListMount(Passive$1 | HasEffect, fiber);\n          } catch (error) {\n            reportUncaughtErrorInDEV(error);\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokeLayoutEffectUnmountInDEV(fiber) {\n  {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);\n          } catch (error) {\n            reportUncaughtErrorInDEV(error);\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n\n          break;\n        }\n\n      case ClassComponent:\n        {\n          var instance = fiber.stateNode;\n\n          if (typeof instance.componentWillUnmount === 'function') {\n            safelyCallComponentWillUnmount(fiber, fiber.return, instance);\n          }\n\n          break;\n        }\n    }\n  }\n}\n\nfunction invokePassiveEffectUnmountInDEV(fiber) {\n  {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    switch (fiber.tag) {\n      case FunctionComponent:\n      case ForwardRef:\n      case SimpleMemoComponent:\n        {\n          try {\n            commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);\n          } catch (error) {\n            reportUncaughtErrorInDEV(error);\n            captureCommitPhaseError(fiber, fiber.return, error);\n          }\n        }\n    }\n  }\n}\n\nvar COMPONENT_TYPE = 0;\nvar HAS_PSEUDO_CLASS_TYPE = 1;\nvar ROLE_TYPE = 2;\nvar TEST_NAME_TYPE = 3;\nvar TEXT_TYPE = 4;\n\nif (typeof Symbol === 'function' && Symbol.for) {\n  var symbolFor = Symbol.for;\n  COMPONENT_TYPE = symbolFor('selector.component');\n  HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class');\n  ROLE_TYPE = symbolFor('selector.role');\n  TEST_NAME_TYPE = symbolFor('selector.test_id');\n  TEXT_TYPE = symbolFor('selector.text');\n}\n\nfunction createComponentSelector(component) {\n  return {\n    $$typeof: COMPONENT_TYPE,\n    value: component\n  };\n}\nfunction createHasPseudoClassSelector(selectors) {\n  return {\n    $$typeof: HAS_PSEUDO_CLASS_TYPE,\n    value: selectors\n  };\n}\nfunction createRoleSelector(role) {\n  return {\n    $$typeof: ROLE_TYPE,\n    value: role\n  };\n}\nfunction createTextSelector(text) {\n  return {\n    $$typeof: TEXT_TYPE,\n    value: text\n  };\n}\nfunction createTestNameSelector(id) {\n  return {\n    $$typeof: TEST_NAME_TYPE,\n    value: id\n  };\n}\n\nfunction findFiberRootForHostRoot(hostRoot) {\n  var maybeFiber = getInstanceFromNode(hostRoot);\n\n  if (maybeFiber != null) {\n    if (typeof maybeFiber.memoizedProps['data-testname'] !== 'string') {\n      throw new Error('Invalid host root specified. Should be either a React container or a node with a testname attribute.');\n    }\n\n    return maybeFiber;\n  } else {\n    var fiberRoot = findFiberRoot(hostRoot);\n\n    if (fiberRoot === null) {\n      throw new Error('Could not find React container within specified host subtree.');\n    } // The Flow type for FiberRoot is a little funky.\n    // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.\n\n\n    return fiberRoot.stateNode.current;\n  }\n}\n\nfunction matchSelector(fiber, selector) {\n  switch (selector.$$typeof) {\n    case COMPONENT_TYPE:\n      if (fiber.type === selector.value) {\n        return true;\n      }\n\n      break;\n\n    case HAS_PSEUDO_CLASS_TYPE:\n      return hasMatchingPaths(fiber, selector.value);\n\n    case ROLE_TYPE:\n      if (fiber.tag === HostComponent) {\n        var node = fiber.stateNode;\n\n        if (matchAccessibilityRole(node, selector.value)) {\n          return true;\n        }\n      }\n\n      break;\n\n    case TEXT_TYPE:\n      if (fiber.tag === HostComponent || fiber.tag === HostText) {\n        var textContent = getTextContent(fiber);\n\n        if (textContent !== null && textContent.indexOf(selector.value) >= 0) {\n          return true;\n        }\n      }\n\n      break;\n\n    case TEST_NAME_TYPE:\n      if (fiber.tag === HostComponent) {\n        var dataTestID = fiber.memoizedProps['data-testname'];\n\n        if (typeof dataTestID === 'string' && dataTestID.toLowerCase() === selector.value.toLowerCase()) {\n          return true;\n        }\n      }\n\n      break;\n\n    default:\n      throw new Error('Invalid selector type specified.');\n  }\n\n  return false;\n}\n\nfunction selectorToString(selector) {\n  switch (selector.$$typeof) {\n    case COMPONENT_TYPE:\n      var displayName = getComponentNameFromType(selector.value) || 'Unknown';\n      return \"<\" + displayName + \">\";\n\n    case HAS_PSEUDO_CLASS_TYPE:\n      return \":has(\" + (selectorToString(selector) || '') + \")\";\n\n    case ROLE_TYPE:\n      return \"[role=\\\"\" + selector.value + \"\\\"]\";\n\n    case TEXT_TYPE:\n      return \"\\\"\" + selector.value + \"\\\"\";\n\n    case TEST_NAME_TYPE:\n      return \"[data-testname=\\\"\" + selector.value + \"\\\"]\";\n\n    default:\n      throw new Error('Invalid selector type specified.');\n  }\n}\n\nfunction findPaths(root, selectors) {\n  var matchingFibers = [];\n  var stack = [root, 0];\n  var index = 0;\n\n  while (index < stack.length) {\n    var fiber = stack[index++];\n    var selectorIndex = stack[index++];\n    var selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else {\n      while (selector != null && matchSelector(fiber, selector)) {\n        selectorIndex++;\n        selector = selectors[selectorIndex];\n      }\n    }\n\n    if (selectorIndex === selectors.length) {\n      matchingFibers.push(fiber);\n    } else {\n      var child = fiber.child;\n\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return matchingFibers;\n} // Same as findPaths but with eager bailout on first match\n\n\nfunction hasMatchingPaths(root, selectors) {\n  var stack = [root, 0];\n  var index = 0;\n\n  while (index < stack.length) {\n    var fiber = stack[index++];\n    var selectorIndex = stack[index++];\n    var selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else {\n      while (selector != null && matchSelector(fiber, selector)) {\n        selectorIndex++;\n        selector = selectors[selectorIndex];\n      }\n    }\n\n    if (selectorIndex === selectors.length) {\n      return true;\n    } else {\n      var child = fiber.child;\n\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction findAllNodes(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  var root = findFiberRootForHostRoot(hostRoot);\n  var matchingFibers = findPaths(root, selectors);\n  var instanceRoots = [];\n  var stack = Array.from(matchingFibers);\n  var index = 0;\n\n  while (index < stack.length) {\n    var node = stack[index++];\n\n    if (node.tag === HostComponent) {\n      if (isHiddenSubtree(node)) {\n        continue;\n      }\n\n      instanceRoots.push(node.stateNode);\n    } else {\n      var child = node.child;\n\n      while (child !== null) {\n        stack.push(child);\n        child = child.sibling;\n      }\n    }\n  }\n\n  return instanceRoots;\n}\nfunction getFindAllNodesFailureDescription(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  var root = findFiberRootForHostRoot(hostRoot);\n  var maxSelectorIndex = 0;\n  var matchedNames = []; // The logic of this loop should be kept in sync with findPaths()\n\n  var stack = [root, 0];\n  var index = 0;\n\n  while (index < stack.length) {\n    var fiber = stack[index++];\n    var selectorIndex = stack[index++];\n    var selector = selectors[selectorIndex];\n\n    if (fiber.tag === HostComponent && isHiddenSubtree(fiber)) {\n      continue;\n    } else if (matchSelector(fiber, selector)) {\n      matchedNames.push(selectorToString(selector));\n      selectorIndex++;\n\n      if (selectorIndex > maxSelectorIndex) {\n        maxSelectorIndex = selectorIndex;\n      }\n    }\n\n    if (selectorIndex < selectors.length) {\n      var child = fiber.child;\n\n      while (child !== null) {\n        stack.push(child, selectorIndex);\n        child = child.sibling;\n      }\n    }\n  }\n\n  if (maxSelectorIndex < selectors.length) {\n    var unmatchedNames = [];\n\n    for (var i = maxSelectorIndex; i < selectors.length; i++) {\n      unmatchedNames.push(selectorToString(selectors[i]));\n    }\n\n    return 'findAllNodes was able to match part of the selector:\\n' + (\"  \" + matchedNames.join(' > ') + \"\\n\\n\") + 'No matching component was found for:\\n' + (\"  \" + unmatchedNames.join(' > '));\n  }\n\n  return null;\n}\nfunction findBoundingRects(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  var instanceRoots = findAllNodes(hostRoot, selectors);\n  var boundingRects = [];\n\n  for (var i = 0; i < instanceRoots.length; i++) {\n    boundingRects.push(getBoundingRect(instanceRoots[i]));\n  }\n\n  for (var _i = boundingRects.length - 1; _i > 0; _i--) {\n    var targetRect = boundingRects[_i];\n    var targetLeft = targetRect.x;\n    var targetRight = targetLeft + targetRect.width;\n    var targetTop = targetRect.y;\n    var targetBottom = targetTop + targetRect.height;\n\n    for (var j = _i - 1; j >= 0; j--) {\n      if (_i !== j) {\n        var otherRect = boundingRects[j];\n        var otherLeft = otherRect.x;\n        var otherRight = otherLeft + otherRect.width;\n        var otherTop = otherRect.y;\n        var otherBottom = otherTop + otherRect.height; // Merging all rects to the minimums set would be complicated,\n        // but we can handle the most common cases:\n        // 1. completely overlapping rects\n        // 2. adjacent rects that are the same width or height (e.g. items in a list)\n        //\n        // Even given the above constraints,\n        // we still won't end up with the fewest possible rects without doing multiple passes,\n        // but it's good enough for this purpose.\n\n        if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n          // Complete overlapping rects; remove the inner one.\n          boundingRects.splice(_i, 1);\n          break;\n        } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {\n          // Adjacent vertical rects; merge them.\n          if (otherTop > targetTop) {\n            otherRect.height += otherTop - targetTop;\n            otherRect.y = targetTop;\n          }\n\n          if (otherBottom < targetBottom) {\n            otherRect.height = targetBottom - otherTop;\n          }\n\n          boundingRects.splice(_i, 1);\n          break;\n        } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {\n          // Adjacent horizontal rects; merge them.\n          if (otherLeft > targetLeft) {\n            otherRect.width += otherLeft - targetLeft;\n            otherRect.x = targetLeft;\n          }\n\n          if (otherRight < targetRight) {\n            otherRect.width = targetRight - otherLeft;\n          }\n\n          boundingRects.splice(_i, 1);\n          break;\n        }\n      }\n    }\n  }\n\n  return boundingRects;\n}\nfunction focusWithin(hostRoot, selectors) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  var root = findFiberRootForHostRoot(hostRoot);\n  var matchingFibers = findPaths(root, selectors);\n  var stack = Array.from(matchingFibers);\n  var index = 0;\n\n  while (index < stack.length) {\n    var fiber = stack[index++];\n\n    if (isHiddenSubtree(fiber)) {\n      continue;\n    }\n\n    if (fiber.tag === HostComponent) {\n      var node = fiber.stateNode;\n\n      if (setFocusIfFocusable(node)) {\n        return true;\n      }\n    }\n\n    var child = fiber.child;\n\n    while (child !== null) {\n      stack.push(child);\n      child = child.sibling;\n    }\n  }\n\n  return false;\n}\nvar commitHooks = [];\nfunction onCommitRoot$1() {\n  if (supportsTestSelectors) {\n    commitHooks.forEach(function (commitHook) {\n      return commitHook();\n    });\n  }\n}\nfunction observeVisibleRects(hostRoot, selectors, callback, options) {\n  if (!supportsTestSelectors) {\n    throw new Error('Test selector API is not supported by this renderer.');\n  }\n\n  var instanceRoots = findAllNodes(hostRoot, selectors);\n\n  var _setupIntersectionObs = setupIntersectionObserver(instanceRoots, callback, options),\n      disconnect = _setupIntersectionObs.disconnect,\n      observe = _setupIntersectionObs.observe,\n      unobserve = _setupIntersectionObs.unobserve; // When React mutates the host environment, we may need to change what we're listening to.\n\n\n  var commitHook = function () {\n    var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n    instanceRoots.forEach(function (target) {\n      if (nextInstanceRoots.indexOf(target) < 0) {\n        unobserve(target);\n      }\n    });\n    nextInstanceRoots.forEach(function (target) {\n      if (instanceRoots.indexOf(target) < 0) {\n        observe(target);\n      }\n    });\n  };\n\n  commitHooks.push(commitHook);\n  return {\n    disconnect: function () {\n      // Stop listening for React mutations:\n      var index = commitHooks.indexOf(commitHook);\n\n      if (index >= 0) {\n        commitHooks.splice(index, 1);\n      } // Disconnect the host observer:\n\n\n      disconnect();\n    }\n  };\n}\n\nvar ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;\nfunction isLegacyActEnvironment(fiber) {\n  {\n    // Legacy mode. We preserve the behavior of React 17's act. It assumes an\n    // act environment whenever `jest` is defined, but you can still turn off\n    // spurious warnings by setting IS_REACT_ACT_ENVIRONMENT explicitly\n    // to false.\n    var isReactActEnvironmentGlobal = // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\n    typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined; // $FlowExpectedError - Flow doesn't know about jest\n\n    var jestIsDefined = typeof jest !== 'undefined';\n    return warnsIfNotActing && jestIsDefined && isReactActEnvironmentGlobal !== false;\n  }\n}\nfunction isConcurrentActEnvironment() {\n  {\n    var isReactActEnvironmentGlobal = // $FlowExpectedError  Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global\n    typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined;\n\n    if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {\n      // TODO: Include link to relevant documentation page.\n      error('The current testing environment is not configured to support ' + 'act(...)');\n    }\n\n    return isReactActEnvironmentGlobal;\n  }\n}\n\nvar ceil = Math.ceil;\nvar ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher,\n    ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,\n    ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig,\n    ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;\nvar NoContext =\n/*             */\n0;\nvar BatchedContext =\n/*               */\n1;\nvar RenderContext =\n/*                */\n2;\nvar CommitContext =\n/*                */\n4;\nvar RootInProgress = 0;\nvar RootFatalErrored = 1;\nvar RootErrored = 2;\nvar RootSuspended = 3;\nvar RootSuspendedWithDelay = 4;\nvar RootCompleted = 5;\nvar RootDidNotComplete = 6; // Describes where we are in the React execution stack\n\nvar executionContext = NoContext; // The root we're working on\n\nvar workInProgressRoot = null; // The fiber we're working on\n\nvar workInProgress = null; // The lanes we're rendering\n\nvar workInProgressRootRenderLanes = NoLanes; // Stack that allows components to change the render lanes for its subtree\n// This is a superset of the lanes we started working on at the root. The only\n// case where it's different from `workInProgressRootRenderLanes` is when we\n// enter a subtree that is hidden and needs to be unhidden: Suspense and\n// Offscreen component.\n//\n// Most things in the work loop should deal with workInProgressRootRenderLanes.\n// Most things in begin/complete phases should deal with subtreeRenderLanes.\n\nvar subtreeRenderLanes = NoLanes;\nvar subtreeRenderLanesCursor = createCursor(NoLanes); // Whether to root completed, errored, suspended, etc.\n\nvar workInProgressRootExitStatus = RootInProgress; // A fatal error, if one is thrown\n\nvar workInProgressRootFatalError = null; // \"Included\" lanes refer to lanes that were worked on during this render. It's\n// slightly different than `renderLanes` because `renderLanes` can change as you\n// enter and exit an Offscreen tree. This value is the combination of all render\n// lanes for the entire render phase.\n\nvar workInProgressRootIncludedLanes = NoLanes; // The work left over by components that were visited during this render. Only\n// includes unprocessed updates, not work in bailed out children.\n\nvar workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.\n\nvar workInProgressRootInterleavedUpdatedLanes = NoLanes; // Lanes that were updated during the render phase (*not* an interleaved event).\n\nvar workInProgressRootPingedLanes = NoLanes; // Errors that are thrown during the render phase.\n\nvar workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.\n// We will log them once the tree commits.\n\nvar workInProgressRootRecoverableErrors = null; // The most recent time we committed a fallback. This lets us ensure a train\n// model where we don't commit new loading states in too quick succession.\n\nvar globalMostRecentFallbackTime = 0;\nvar FALLBACK_THROTTLE_MS = 500; // The absolute time for when we should start giving up on rendering\n// more and prefer CPU suspense heuristics instead.\n\nvar workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU\n// suspense heuristics and opt out of rendering more content.\n\nvar RENDER_TIMEOUT_MS = 500;\n\nfunction resetRenderTimer() {\n  workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n}\n\nfunction getRenderTargetTime() {\n  return workInProgressRootRenderTargetTime;\n}\nvar hasUncaughtError = false;\nvar firstUncaughtError = null;\nvar legacyErrorBoundariesThatAlreadyFailed = null; // Only used when enableProfilerNestedUpdateScheduledHook is true;\nvar rootDoesHavePassiveEffects = false;\nvar rootWithPendingPassiveEffects = null;\nvar pendingPassiveEffectsLanes = NoLanes;\nvar pendingPassiveProfilerEffects = [];\n\nvar NESTED_UPDATE_LIMIT = 50;\nvar nestedUpdateCount = 0;\nvar rootWithNestedUpdates = null;\nvar NESTED_PASSIVE_UPDATE_LIMIT = 50;\nvar nestedPassiveUpdateCount = 0; // If two updates are scheduled within the same event, we should treat their\n// event times as simultaneous, even if the actual clock time has advanced\n// between the first and second call.\n\nvar currentEventTime = NoTimestamp;\nvar currentEventTransitionLane = NoLanes;\nfunction getWorkInProgressRoot() {\n  return workInProgressRoot;\n}\nfunction requestEventTime() {\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    // We're inside React, so it's fine to read the actual time.\n    return now$1();\n  } // We're not inside React, so we may be in the middle of a browser event.\n\n\n  if (currentEventTime !== NoTimestamp) {\n    // Use the same start time for all updates until we enter React again.\n    return currentEventTime;\n  } // This is the first update since React yielded. Compute a new start time.\n\n\n  currentEventTime = now$1();\n  return currentEventTime;\n}\nfunction requestUpdateLane(fiber) {\n  // Special cases\n  var mode = fiber.mode;\n\n  if ((mode & ConcurrentMode) === NoMode) {\n    return SyncLane;\n  } else if ( (executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n    // This is a render phase update. These are not officially supported. The\n    // old behavior is to give this the same \"thread\" (lanes) as\n    // whatever is currently rendering. So if you call `setState` on a component\n    // that happens later in the same render, it will flush. Ideally, we want to\n    // remove the special case and treat them as if they came from an\n    // interleaved event. Regardless, this pattern is not officially supported.\n    // This behavior is only a fallback. The flag only exists until we can roll\n    // out the setState warning, since existing code might accidentally rely on\n    // the current behavior.\n    return pickArbitraryLane(workInProgressRootRenderLanes);\n  }\n\n  var isTransition = requestCurrentTransition() !== NoTransition;\n\n  if (isTransition) {\n    if ( ReactCurrentBatchConfig$2.transition !== null) {\n      var transition = ReactCurrentBatchConfig$2.transition;\n\n      if (!transition._updatedFibers) {\n        transition._updatedFibers = new Set();\n      }\n\n      transition._updatedFibers.add(fiber);\n    } // The algorithm for assigning an update to a lane should be stable for all\n    // updates at the same priority within the same event. To do this, the\n    // inputs to the algorithm must be the same.\n    //\n    // The trick we use is to cache the first of each of these inputs within an\n    // event. Then reset the cached values once we can be sure the event is\n    // over. Our heuristic for that is whenever we enter a concurrent work loop.\n\n\n    if (currentEventTransitionLane === NoLane) {\n      // All transitions within the same event are assigned the same lane.\n      currentEventTransitionLane = claimNextTransitionLane();\n    }\n\n    return currentEventTransitionLane;\n  } // Updates originating inside certain React methods, like flushSync, have\n  // their priority set by tracking it with a context variable.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n\n\n  var updateLane = getCurrentUpdatePriority();\n\n  if (updateLane !== NoLane) {\n    return updateLane;\n  } // This update originated outside React. Ask the host environment for an\n  // appropriate priority, based on the type of event.\n  //\n  // The opaque type returned by the host config is internally a lane, so we can\n  // use that directly.\n  // TODO: Move this type conversion to the event priority module.\n\n\n  var eventLane = getCurrentEventPriority();\n  return eventLane;\n}\n\nfunction requestRetryLane(fiber) {\n  // This is a fork of `requestUpdateLane` designed specifically for Suspense\n  // \"retries\"  a special update that attempts to flip a Suspense boundary\n  // from its placeholder state to its primary/resolved state.\n  // Special cases\n  var mode = fiber.mode;\n\n  if ((mode & ConcurrentMode) === NoMode) {\n    return SyncLane;\n  }\n\n  return claimNextRetryLane();\n}\n\nfunction scheduleUpdateOnFiber(fiber, lane, eventTime) {\n  checkForNestedUpdates();\n  var root = markUpdateLaneFromFiberToRoot(fiber, lane);\n\n  if (root === null) {\n    return null;\n  } // Mark that the root has a pending update.\n\n\n  markRootUpdated(root, lane, eventTime);\n\n  if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {\n    // This update was dispatched during the render phase. This is a mistake\n    // if the update originates from user space (with the exception of local\n    // hook updates, which are handled differently and don't reach this\n    // function), but there are some internal React features that use this as\n    // an implementation detail, like selective hydration.\n    warnAboutRenderPhaseUpdatesInDEV(fiber); // Track lanes that were updated during the render phase\n  } else {\n    // This is a normal update, scheduled from outside the render phase. For\n    // example, during an input event.\n    {\n      if (isDevToolsPresent) {\n        addFiberToLanesMap(root, fiber, lane);\n      }\n    }\n\n    warnIfUpdatesNotWrappedWithActDEV(fiber);\n\n    if (root === workInProgressRoot) {\n      // TODO: Consolidate with `isInterleavedUpdate` check\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that there was an interleaved update work on this root. Unless the\n      // `deferRenderPhaseUpdateToNextBatch` flag is off and this is a render\n      // phase update. In that case, we don't treat render phase updates as if\n      // they were interleaved, for backwards compat reasons.\n      if ( (executionContext & RenderContext) === NoContext) {\n        workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n      }\n\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: Make sure this doesn't override pings that happen while we've\n        // already started rendering.\n        markRootSuspended$1(root, workInProgressRootRenderLanes);\n      }\n    }\n\n    ensureRootIsScheduled(root, eventTime);\n\n    if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n    !( ReactCurrentActQueue$1.isBatchingLegacy)) {\n      // Flush the synchronous work now, unless we're already working or inside\n      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n      // scheduleCallbackForFiber to preserve the ability to schedule a callback\n      // without immediately flushing it. We only do this for user-initiated\n      // updates, to preserve historical behavior of legacy mode.\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n\n  return root;\n}\nfunction scheduleInitialHydrationOnRoot(root, lane, eventTime) {\n  // This is a special fork of scheduleUpdateOnFiber that is only used to\n  // schedule the initial hydration of a root that has just been created. Most\n  // of the stuff in scheduleUpdateOnFiber can be skipped.\n  //\n  // The main reason for this separate path, though, is to distinguish the\n  // initial children from subsequent updates. In fully client-rendered roots\n  // (createRoot instead of hydrateRoot), all top-level renders are modeled as\n  // updates, but hydration roots are special because the initial render must\n  // match what was rendered on the server.\n  var current = root.current;\n  current.lanes = lane;\n  markRootUpdated(root, lane, eventTime);\n  ensureRootIsScheduled(root, eventTime);\n} // This is split into a separate function so we can mark a fiber with pending\n// work without treating it as a typical update that originates from an event;\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n// on a fiber.\n\nfunction markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n  // Update the source fiber's lanes\n  sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n  var alternate = sourceFiber.alternate;\n\n  if (alternate !== null) {\n    alternate.lanes = mergeLanes(alternate.lanes, lane);\n  }\n\n  {\n    if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {\n      warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n    }\n  } // Walk the parent path to the root and update the child lanes.\n\n\n  var node = sourceFiber;\n  var parent = sourceFiber.return;\n\n  while (parent !== null) {\n    parent.childLanes = mergeLanes(parent.childLanes, lane);\n    alternate = parent.alternate;\n\n    if (alternate !== null) {\n      alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n    } else {\n      {\n        if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {\n          warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n        }\n      }\n    }\n\n    node = parent;\n    parent = parent.return;\n  }\n\n  if (node.tag === HostRoot) {\n    var root = node.stateNode;\n    return root;\n  } else {\n    return null;\n  }\n}\n\nfunction isInterleavedUpdate(fiber, lane) {\n  return (// TODO: Optimize slightly by comparing to root that fiber belongs to.\n    // Requires some refactoring. Not a big deal though since it's rare for\n    // concurrent apps to have more than a single root.\n    workInProgressRoot !== null && (fiber.mode & ConcurrentMode) !== NoMode && ( // If this is a render phase update (i.e. UNSAFE_componentWillReceiveProps),\n    // then don't treat this as an interleaved update. This pattern is\n    // accompanied by a warning but we haven't fully deprecated it yet. We can\n    // remove once the deferRenderPhaseUpdateToNextBatch flag is enabled.\n     (executionContext & RenderContext) === NoContext)\n  );\n} // Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\n\nfunction ensureRootIsScheduled(root, currentTime) {\n  var existingCallbackNode = root.callbackNode; // Check if any lanes are being starved by other work. If so, mark them as\n  // expired so we know to work on those next.\n\n  markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.\n\n  var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n\n  if (nextLanes === NoLanes) {\n    // Special case: There's nothing to work on.\n    if (existingCallbackNode !== null) {\n      cancelCallback$1(existingCallbackNode);\n    }\n\n    root.callbackNode = null;\n    root.callbackPriority = NoLane;\n    return;\n  } // We use the highest priority lane to represent the priority of the callback.\n\n\n  var newCallbackPriority = getHighestPriorityLane(nextLanes); // Check if there's an existing task. We may be able to reuse it.\n\n  var existingCallbackPriority = root.callbackPriority;\n\n  if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n  // Scheduler task, rather than an `act` task, cancel it and re-scheduled\n  // on the `act` queue.\n  !( ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {\n    {\n      // If we're going to re-use an existing task, it needs to exist.\n      // Assume that discrete update microtasks are non-cancellable and null.\n      // TODO: Temporary until we confirm this warning is not fired.\n      if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {\n        error('Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.');\n      }\n    } // The priority hasn't changed. We can reuse the existing task. Exit.\n\n\n    return;\n  }\n\n  if (existingCallbackNode != null) {\n    // Cancel the existing callback. We'll schedule a new one below.\n    cancelCallback$1(existingCallbackNode);\n  } // Schedule a new callback.\n\n\n  var newCallbackNode;\n\n  if (newCallbackPriority === SyncLane) {\n    // Special case: Sync React callbacks are scheduled on a special\n    // internal queue\n    if (root.tag === LegacyRoot) {\n      if ( ReactCurrentActQueue$1.isBatchingLegacy !== null) {\n        ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;\n      }\n\n      scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root));\n    } else {\n      scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root));\n    }\n\n    if (supportsMicrotasks) {\n      // Flush the queue in a microtask.\n      if ( ReactCurrentActQueue$1.current !== null) {\n        // Inside `act`, use our internal `act` queue so that these get flushed\n        // at the end of the current scope even when using the sync version\n        // of `act`.\n        ReactCurrentActQueue$1.current.push(flushSyncCallbacks);\n      } else {\n        scheduleMicrotask(function () {\n          // In Safari, appending an iframe forces microtasks to run.\n          // https://github.com/facebook/react/issues/22459\n          // We don't support running callbacks in the middle of render\n          // or commit so we need to check against that.\n          if (executionContext === NoContext) {\n            // It's only safe to do this conditionally because we always\n            // check for pending work before we exit the task.\n            flushSyncCallbacks();\n          }\n        });\n      }\n    } else {\n      // Flush the queue in an Immediate task.\n      scheduleCallback$1(ImmediatePriority, flushSyncCallbacks);\n    }\n\n    newCallbackNode = null;\n  } else {\n    var schedulerPriorityLevel;\n\n    switch (lanesToEventPriority(nextLanes)) {\n      case DiscreteEventPriority:\n        schedulerPriorityLevel = ImmediatePriority;\n        break;\n\n      case ContinuousEventPriority:\n        schedulerPriorityLevel = UserBlockingPriority;\n        break;\n\n      case DefaultEventPriority:\n        schedulerPriorityLevel = NormalPriority;\n        break;\n\n      case IdleEventPriority:\n        schedulerPriorityLevel = IdlePriority;\n        break;\n\n      default:\n        schedulerPriorityLevel = NormalPriority;\n        break;\n    }\n\n    newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n  }\n\n  root.callbackPriority = newCallbackPriority;\n  root.callbackNode = newCallbackNode;\n} // This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\n\n\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  {\n    resetNestedUpdateFlag();\n  } // Since we know we're in a React event, we can clear the current\n  // event time. The next update will compute a new event time.\n\n\n  currentEventTime = NoTimestamp;\n  currentEventTransitionLane = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  } // Flush any pending passive effects before deciding which lanes to work on,\n  // in case they schedule additional work.\n\n\n  var originalCallbackNode = root.callbackNode;\n  var didFlushPassiveEffects = flushPassiveEffects();\n\n  if (didFlushPassiveEffects) {\n    // Something in the passive effect phase may have canceled the current task.\n    // Check if the task node for this root was changed.\n    if (root.callbackNode !== originalCallbackNode) {\n      // The current task was canceled. Exit. We don't need to call\n      // `ensureRootIsScheduled` because the check above implies either that\n      // there's a new task, or that there's no remaining work on this root.\n      return null;\n    }\n  } // Determine the next lanes to work on, using the fields stored\n  // on the root.\n\n\n  var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n\n  if (lanes === NoLanes) {\n    // Defensive coding. This is never expected to happen.\n    return null;\n  } // We disable time-slicing in some cases: if the work has been CPU-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n  // bug we're still investigating. Once the bug in Scheduler is fixed,\n  // we can remove this, since we track expiration ourselves.\n\n\n  var shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && ( !didTimeout);\n  var exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);\n\n  if (exitStatus !== RootInProgress) {\n    if (exitStatus === RootErrored) {\n      // If something threw an error, try rendering one more time. We'll\n      // render synchronously to block concurrent data mutations, and we'll\n      // includes all pending updates are included. If it still fails after\n      // the second attempt, we'll give up and commit the resulting tree.\n      var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n      if (errorRetryLanes !== NoLanes) {\n        lanes = errorRetryLanes;\n        exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n      }\n    }\n\n    if (exitStatus === RootFatalErrored) {\n      var fatalError = workInProgressRootFatalError;\n      prepareFreshStack(root, NoLanes);\n      markRootSuspended$1(root, lanes);\n      ensureRootIsScheduled(root, now$1());\n      throw fatalError;\n    }\n\n    if (exitStatus === RootDidNotComplete) {\n      // The render unwound without completing the tree. This happens in special\n      // cases where need to exit the current render without producing a\n      // consistent tree or committing.\n      //\n      // This should only happen during a concurrent render, not a discrete or\n      // synchronous update. We should have already checked for this when we\n      // unwound the stack.\n      markRootSuspended$1(root, lanes);\n    } else {\n      // The render completed.\n      // Check if this render may have yielded to a concurrent event, and if so,\n      // confirm that any newly rendered stores are consistent.\n      // TODO: It's possible that even a concurrent render may never have yielded\n      // to the main thread, if it was fast enough, or if it expired. We could\n      // skip the consistency check in that case, too.\n      var renderWasConcurrent = !includesBlockingLane(root, lanes);\n      var finishedWork = root.current.alternate;\n\n      if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n        // A store was mutated in an interleaved event. Render again,\n        // synchronously, to block further mutations.\n        exitStatus = renderRootSync(root, lanes); // We need to check again if something threw\n\n        if (exitStatus === RootErrored) {\n          var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n          if (_errorRetryLanes !== NoLanes) {\n            lanes = _errorRetryLanes;\n            exitStatus = recoverFromConcurrentError(root, _errorRetryLanes); // We assume the tree is now consistent because we didn't yield to any\n            // concurrent events.\n          }\n        }\n\n        if (exitStatus === RootFatalErrored) {\n          var _fatalError = workInProgressRootFatalError;\n          prepareFreshStack(root, NoLanes);\n          markRootSuspended$1(root, lanes);\n          ensureRootIsScheduled(root, now$1());\n          throw _fatalError;\n        }\n      } // We now have a consistent tree. The next step is either to commit it,\n      // or, if something suspended, wait to commit it after a timeout.\n\n\n      root.finishedWork = finishedWork;\n      root.finishedLanes = lanes;\n      finishConcurrentRender(root, exitStatus, lanes);\n    }\n  }\n\n  ensureRootIsScheduled(root, now$1());\n\n  if (root.callbackNode === originalCallbackNode) {\n    // The task node scheduled for this root is the same one that's\n    // currently executed. Need to return a continuation.\n    return performConcurrentWorkOnRoot.bind(null, root);\n  }\n\n  return null;\n}\n\nfunction recoverFromConcurrentError(root, errorRetryLanes) {\n  // If an error occurred during hydration, discard server response and fall\n  // back to client side render.\n  // Before rendering again, save the errors from the previous attempt.\n  var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n\n  if (isRootDehydrated(root)) {\n    // The shell failed to hydrate. Set a flag to force a client rendering\n    // during the next attempt. To do this, we call prepareFreshStack now\n    // to create the root work-in-progress fiber. This is a bit weird in terms\n    // of factoring, because it relies on renderRootSync not calling\n    // prepareFreshStack again in the call below, which happens because the\n    // root and lanes haven't changed.\n    //\n    // TODO: I think what we should do is set ForceClientRender inside\n    // throwException, like we do for nested Suspense boundaries. The reason\n    // it's here instead is so we can switch to the synchronous work loop, too.\n    // Something to consider for a future refactor.\n    var rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);\n    rootWorkInProgress.flags |= ForceClientRender;\n\n    {\n      errorHydratingContainer(root.containerInfo);\n    }\n  }\n\n  var exitStatus = renderRootSync(root, errorRetryLanes);\n\n  if (exitStatus !== RootErrored) {\n    // Successfully finished rendering on retry\n    // The errors from the failed first attempt have been recovered. Add\n    // them to the collection of recoverable errors. We'll log them in the\n    // commit phase.\n    var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n    workInProgressRootRecoverableErrors = errorsFromFirstAttempt; // The errors from the second attempt should be queued after the errors\n    // from the first attempt, to preserve the causal sequence.\n\n    if (errorsFromSecondAttempt !== null) {\n      queueRecoverableErrors(errorsFromSecondAttempt);\n    }\n  }\n\n  return exitStatus;\n}\n\nfunction queueRecoverableErrors(errors) {\n  if (workInProgressRootRecoverableErrors === null) {\n    workInProgressRootRecoverableErrors = errors;\n  } else {\n    workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n  }\n}\n\nfunction finishConcurrentRender(root, exitStatus, lanes) {\n  switch (exitStatus) {\n    case RootInProgress:\n    case RootFatalErrored:\n      {\n        throw new Error('Root did not complete. This is a bug in React.');\n      }\n    // Flow knows about invariant, so it complains if I add a break\n    // statement, but eslint doesn't know about invariant, so it complains\n    // if I do. eslint-disable-next-line no-fallthrough\n\n    case RootErrored:\n      {\n        // We should have already attempted to retry this tree. If we reached\n        // this point, it errored again. Commit it.\n        commitRoot(root, workInProgressRootRecoverableErrors);\n        break;\n      }\n\n    case RootSuspended:\n      {\n        markRootSuspended$1(root, lanes); // We have an acceptable loading state. We need to figure out if we\n        // should immediately commit it or wait a bit.\n\n        if (includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope\n        !shouldForceFlushFallbacksInDEV()) {\n          // This render only included retries, no updates. Throttle committing\n          // retries so that we don't show too many loading states too quickly.\n          var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(); // Don't bother with a very short suspense time.\n\n          if (msUntilTimeout > 10) {\n            var nextLanes = getNextLanes(root, NoLanes);\n\n            if (nextLanes !== NoLanes) {\n              // There's additional work on this root.\n              break;\n            }\n\n            var suspendedLanes = root.suspendedLanes;\n\n            if (!isSubsetOfLanes(suspendedLanes, lanes)) {\n              // We should prefer to render the fallback of at the last\n              // suspended level. Ping the last suspended level to try\n              // rendering it again.\n              // FIXME: What if the suspended lanes are Idle? Should not restart.\n              var eventTime = requestEventTime();\n              markRootPinged(root, suspendedLanes);\n              break;\n            } // The render is suspended, it hasn't timed out, and there's no\n            // lower priority work to do. Instead of committing the fallback\n            // immediately, wait for more data to arrive.\n\n\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors), msUntilTimeout);\n            break;\n          }\n        } // The work expired. Commit immediately.\n\n\n        commitRoot(root, workInProgressRootRecoverableErrors);\n        break;\n      }\n\n    case RootSuspendedWithDelay:\n      {\n        markRootSuspended$1(root, lanes);\n\n        if (includesOnlyTransitions(lanes)) {\n          // This is a transition, so we should exit without committing a\n          // placeholder and without scheduling a timeout. Delay indefinitely\n          // until we receive more data.\n          break;\n        }\n\n        if (!shouldForceFlushFallbacksInDEV()) {\n          // This is not a transition, but we did trigger an avoided state.\n          // Schedule a placeholder to display after a short delay, using the Just\n          // Noticeable Difference.\n          // TODO: Is the JND optimization worth the added complexity? If this is\n          // the only reason we track the event time, then probably not.\n          // Consider removing.\n          var mostRecentEventTime = getMostRecentEventTime(root, lanes);\n          var eventTimeMs = mostRecentEventTime;\n          var timeElapsedMs = now$1() - eventTimeMs;\n\n          var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs; // Don't bother with a very short suspense time.\n\n\n          if (_msUntilTimeout > 10) {\n            // Instead of committing the fallback immediately, wait for more data\n            // to arrive.\n            root.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root, workInProgressRootRecoverableErrors), _msUntilTimeout);\n            break;\n          }\n        } // Commit the placeholder.\n\n\n        commitRoot(root, workInProgressRootRecoverableErrors);\n        break;\n      }\n\n    case RootCompleted:\n      {\n        // The work completed. Ready to commit.\n        commitRoot(root, workInProgressRootRecoverableErrors);\n        break;\n      }\n\n    default:\n      {\n        throw new Error('Unknown root exit status.');\n      }\n  }\n}\n\nfunction isRenderConsistentWithExternalStores(finishedWork) {\n  // Search the rendered tree for external store reads, and check whether the\n  // stores were mutated in a concurrent event. Intentionally using an iterative\n  // loop instead of recursion so we can exit early.\n  var node = finishedWork;\n\n  while (true) {\n    if (node.flags & StoreConsistency) {\n      var updateQueue = node.updateQueue;\n\n      if (updateQueue !== null) {\n        var checks = updateQueue.stores;\n\n        if (checks !== null) {\n          for (var i = 0; i < checks.length; i++) {\n            var check = checks[i];\n            var getSnapshot = check.getSnapshot;\n            var renderedValue = check.value;\n\n            try {\n              if (!objectIs(getSnapshot(), renderedValue)) {\n                // Found an inconsistent store.\n                return false;\n              }\n            } catch (error) {\n              // If `getSnapshot` throws, return `false`. This will schedule\n              // a re-render, and the error will be rethrown during render.\n              return false;\n            }\n          }\n        }\n      }\n    }\n\n    var child = node.child;\n\n    if (node.subtreeFlags & StoreConsistency && child !== null) {\n      child.return = node;\n      node = child;\n      continue;\n    }\n\n    if (node === finishedWork) {\n      return true;\n    }\n\n    while (node.sibling === null) {\n      if (node.return === null || node.return === finishedWork) {\n        return true;\n      }\n\n      node = node.return;\n    }\n\n    node.sibling.return = node.return;\n    node = node.sibling;\n  } // Flow doesn't know this is unreachable, but eslint does\n  // eslint-disable-next-line no-unreachable\n\n\n  return true;\n}\n\nfunction markRootSuspended$1(root, suspendedLanes) {\n  // When suspending, we should always exclude lanes that were pinged or (more\n  // rarely, since we try to avoid it) updated during the render phase.\n  // TODO: Lol maybe there's a better way to factor this besides this\n  // obnoxiously named function :)\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n  suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n  markRootSuspended(root, suspendedLanes);\n} // This is the entry point for synchronous tasks that don't go\n// through Scheduler\n\n\nfunction performSyncWorkOnRoot(root) {\n  {\n    syncNestedUpdateFlag();\n  }\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  flushPassiveEffects();\n  var lanes = getNextLanes(root, NoLanes);\n\n  if (!includesSomeLane(lanes, SyncLane)) {\n    // There's no remaining sync work left.\n    ensureRootIsScheduled(root, now$1());\n    return null;\n  }\n\n  var exitStatus = renderRootSync(root, lanes);\n\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\n    // If something threw an error, try rendering one more time. We'll render\n    // synchronously to block concurrent data mutations, and we'll includes\n    // all pending updates are included. If it still fails after the second\n    // attempt, we'll give up and commit the resulting tree.\n    var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root);\n\n    if (errorRetryLanes !== NoLanes) {\n      lanes = errorRetryLanes;\n      exitStatus = recoverFromConcurrentError(root, errorRetryLanes);\n    }\n  }\n\n  if (exitStatus === RootFatalErrored) {\n    var fatalError = workInProgressRootFatalError;\n    prepareFreshStack(root, NoLanes);\n    markRootSuspended$1(root, lanes);\n    ensureRootIsScheduled(root, now$1());\n    throw fatalError;\n  }\n\n  if (exitStatus === RootDidNotComplete) {\n    throw new Error('Root did not complete. This is a bug in React.');\n  } // We now have a consistent tree. Because this is a sync render, we\n  // will commit it even if something suspended.\n\n\n  var finishedWork = root.current.alternate;\n  root.finishedWork = finishedWork;\n  root.finishedLanes = lanes;\n  commitRoot(root, workInProgressRootRecoverableErrors); // Before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n\n  ensureRootIsScheduled(root, now$1());\n  return null;\n}\n\nfunction flushRoot(root, lanes) {\n  if (lanes !== NoLanes) {\n    markRootEntangled(root, mergeLanes(lanes, SyncLane));\n    ensureRootIsScheduled(root, now$1());\n\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n}\nfunction deferredUpdates(fn) {\n  var previousPriority = getCurrentUpdatePriority();\n  var prevTransition = ReactCurrentBatchConfig$2.transition;\n\n  try {\n    ReactCurrentBatchConfig$2.transition = null;\n    setCurrentUpdatePriority(DefaultEventPriority);\n    return fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n  }\n}\nfunction batchedUpdates(fn, a) {\n  var prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n\n  try {\n    return fn(a);\n  } finally {\n    executionContext = prevExecutionContext; // If there were legacy sync updates, flush them at the end of the outer\n    // most batchedUpdates-like method.\n\n    if (executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.\n    !( ReactCurrentActQueue$1.isBatchingLegacy)) {\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n}\nfunction discreteUpdates(fn, a, b, c, d) {\n  var previousPriority = getCurrentUpdatePriority();\n  var prevTransition = ReactCurrentBatchConfig$2.transition;\n\n  try {\n    ReactCurrentBatchConfig$2.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    return fn(a, b, c, d);\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n\n    if (executionContext === NoContext) {\n      resetRenderTimer();\n    }\n  }\n} // Overload the definition to the two valid signatures.\n// Warning, this opts-out of checking the function body.\n\n// eslint-disable-next-line no-redeclare\nfunction flushSync(fn) {\n  // In legacy mode, we flush pending passive effects at the beginning of the\n  // next event, not at the end of the previous one.\n  if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n    flushPassiveEffects();\n  }\n\n  var prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  var prevTransition = ReactCurrentBatchConfig$2.transition;\n  var previousPriority = getCurrentUpdatePriority();\n\n  try {\n    ReactCurrentBatchConfig$2.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n\n    if (fn) {\n      return fn();\n    } else {\n      return undefined;\n    }\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n    executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n    // Note that this will happen even if batchedUpdates is higher up\n    // the stack.\n\n    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n      flushSyncCallbacks();\n    }\n  }\n}\nfunction isAlreadyRendering() {\n  // Used by the renderer to print a warning if certain APIs are called from\n  // the wrong context.\n  return  (executionContext & (RenderContext | CommitContext)) !== NoContext;\n}\nfunction flushControlled(fn) {\n  var prevExecutionContext = executionContext;\n  executionContext |= BatchedContext;\n  var prevTransition = ReactCurrentBatchConfig$2.transition;\n  var previousPriority = getCurrentUpdatePriority();\n\n  try {\n    ReactCurrentBatchConfig$2.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    fn();\n  } finally {\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n    executionContext = prevExecutionContext;\n\n    if (executionContext === NoContext) {\n      // Flush the immediate callbacks that were scheduled during this batch\n      resetRenderTimer();\n      flushSyncCallbacks();\n    }\n  }\n}\nfunction pushRenderLanes(fiber, lanes) {\n  push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);\n  subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);\n  workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);\n}\nfunction popRenderLanes(fiber) {\n  subtreeRenderLanes = subtreeRenderLanesCursor.current;\n  pop(subtreeRenderLanesCursor, fiber);\n}\n\nfunction prepareFreshStack(root, lanes) {\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n  var timeoutHandle = root.timeoutHandle;\n\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout; // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n\n    cancelTimeout(timeoutHandle);\n  }\n\n  if (workInProgress !== null) {\n    var interruptedWork = workInProgress.return;\n\n    while (interruptedWork !== null) {\n      var current = interruptedWork.alternate;\n      unwindInterruptedWork(current, interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n\n  workInProgressRoot = root;\n  var rootWorkInProgress = createWorkInProgress(root.current, null);\n  workInProgress = rootWorkInProgress;\n  workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;\n  workInProgressRootExitStatus = RootInProgress;\n  workInProgressRootFatalError = null;\n  workInProgressRootSkippedLanes = NoLanes;\n  workInProgressRootInterleavedUpdatedLanes = NoLanes;\n  workInProgressRootPingedLanes = NoLanes;\n  workInProgressRootConcurrentErrors = null;\n  workInProgressRootRecoverableErrors = null;\n  enqueueInterleavedUpdates();\n\n  {\n    ReactStrictModeWarnings.discardPendingWarnings();\n  }\n\n  return rootWorkInProgress;\n}\n\nfunction handleError(root, thrownValue) {\n  do {\n    var erroredWork = workInProgress;\n\n    try {\n      // Reset module-level state that was set during the render phase.\n      resetContextDependencies();\n      resetHooksAfterThrow();\n      resetCurrentFiber(); // TODO: I found and added this missing line while investigating a\n      // separate issue. Write a regression test using string refs.\n\n      ReactCurrentOwner$2.current = null;\n\n      if (erroredWork === null || erroredWork.return === null) {\n        // Expected to be working on a non-root fiber. This is a fatal error\n        // because there's no ancestor that can handle it; the root is\n        // supposed to capture all errors that weren't caught by an error\n        // boundary.\n        workInProgressRootExitStatus = RootFatalErrored;\n        workInProgressRootFatalError = thrownValue; // Set `workInProgress` to null. This represents advancing to the next\n        // sibling, or the parent if there are no siblings. But since the root\n        // has no siblings nor a parent, we set it to null. Usually this is\n        // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n        // intentionally not calling those, we need set it here.\n        // TODO: Consider calling `unwindWork` to pop the contexts.\n\n        workInProgress = null;\n        return;\n      }\n\n      if (enableProfilerTimer && erroredWork.mode & ProfileMode) {\n        // Record the time spent rendering before an error was thrown. This\n        // avoids inaccurate Profiler durations in the case of a\n        // suspended render.\n        stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n      }\n\n      if (enableSchedulingProfiler) {\n        markComponentRenderStopped();\n\n        if (thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function') {\n          var wakeable = thrownValue;\n          markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n        } else {\n          markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n        }\n      }\n\n      throwException(root, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);\n      completeUnitOfWork(erroredWork);\n    } catch (yetAnotherThrownValue) {\n      // Something in the return path also threw.\n      thrownValue = yetAnotherThrownValue;\n\n      if (workInProgress === erroredWork && erroredWork !== null) {\n        // If this boundary has already errored, then we had trouble processing\n        // the error. Bubble it to the next boundary.\n        erroredWork = erroredWork.return;\n        workInProgress = erroredWork;\n      } else {\n        erroredWork = workInProgress;\n      }\n\n      continue;\n    } // Return to the normal work loop.\n\n\n    return;\n  } while (true);\n}\n\nfunction pushDispatcher() {\n  var prevDispatcher = ReactCurrentDispatcher$2.current;\n  ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;\n\n  if (prevDispatcher === null) {\n    // The React isomorphic package does not include a default dispatcher.\n    // Instead the first renderer will lazily attach one, in order to give\n    // nicer error messages.\n    return ContextOnlyDispatcher;\n  } else {\n    return prevDispatcher;\n  }\n}\n\nfunction popDispatcher(prevDispatcher) {\n  ReactCurrentDispatcher$2.current = prevDispatcher;\n}\n\nfunction markCommitTimeOfFallback() {\n  globalMostRecentFallbackTime = now$1();\n}\nfunction markSkippedUpdateLanes(lane) {\n  workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n}\nfunction renderDidSuspend() {\n  if (workInProgressRootExitStatus === RootInProgress) {\n    workInProgressRootExitStatus = RootSuspended;\n  }\n}\nfunction renderDidSuspendDelayIfPossible() {\n  if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {\n    workInProgressRootExitStatus = RootSuspendedWithDelay;\n  } // Check if there are updates that we skipped tree that might have unblocked\n  // this render.\n\n\n  if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {\n    // Mark the current render as suspended so that we switch to working on\n    // the updates that were skipped. Usually we only suspend at the end of\n    // the render phase.\n    // TODO: We should probably always mark the root as suspended immediately\n    // (inside this function), since by suspending at the end of the render\n    // phase introduces a potential mistake where we suspend lanes that were\n    // pinged or updated while we were rendering.\n    markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);\n  }\n}\nfunction renderDidError(error) {\n  if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n    workInProgressRootExitStatus = RootErrored;\n  }\n\n  if (workInProgressRootConcurrentErrors === null) {\n    workInProgressRootConcurrentErrors = [error];\n  } else {\n    workInProgressRootConcurrentErrors.push(error);\n  }\n} // Called during render to determine if anything has suspended.\n// Returns false if we're not sure.\n\nfunction renderHasNotSuspendedYet() {\n  // If something errored or completed, we can't really be sure,\n  // so those are false.\n  return workInProgressRootExitStatus === RootInProgress;\n}\n\nfunction renderRootSync(root, lanes) {\n  var prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    {\n      if (isDevToolsPresent) {\n        var memoizedUpdaters = root.memoizedUpdaters;\n\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n\n\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n    prepareFreshStack(root, lanes);\n  }\n\n  {\n    markRenderStarted(lanes);\n  }\n\n  do {\n    try {\n      workLoopSync();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n\n  resetContextDependencies();\n  executionContext = prevExecutionContext;\n  popDispatcher(prevDispatcher);\n\n  if (workInProgress !== null) {\n    // This is a sync render, so we should have finished the whole tree.\n    throw new Error('Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');\n  }\n\n  {\n    markRenderStopped();\n  } // Set this to null to indicate there's no in-progress render.\n\n\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = NoLanes;\n  return workInProgressRootExitStatus;\n} // The work loop is an extremely hot path. Tell Closure not to inline it.\n\n/** @noinline */\n\n\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction renderRootConcurrent(root, lanes) {\n  var prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  var prevDispatcher = pushDispatcher(); // If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n    {\n      if (isDevToolsPresent) {\n        var memoizedUpdaters = root.memoizedUpdaters;\n\n        if (memoizedUpdaters.size > 0) {\n          restorePendingUpdaters(root, workInProgressRootRenderLanes);\n          memoizedUpdaters.clear();\n        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n        // If we bailout on this work, we'll move them back (like above).\n        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n        // That way we can keep the current update and future updates separate.\n\n\n        movePendingFibersToMemoized(root, lanes);\n      }\n    }\n    resetRenderTimer();\n    prepareFreshStack(root, lanes);\n  }\n\n  {\n    markRenderStarted(lanes);\n  }\n\n  do {\n    try {\n      workLoopConcurrent();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n\n  resetContextDependencies();\n  popDispatcher(prevDispatcher);\n  executionContext = prevExecutionContext;\n\n\n  if (workInProgress !== null) {\n    // Still work remaining.\n    {\n      markRenderYielded();\n    }\n\n    return RootInProgress;\n  } else {\n    // Completed the tree.\n    {\n      markRenderStopped();\n    } // Set this to null to indicate there's no in-progress render.\n\n\n    workInProgressRoot = null;\n    workInProgressRootRenderLanes = NoLanes; // Return the final exit status.\n\n    return workInProgressRootExitStatus;\n  }\n}\n/** @noinline */\n\n\nfunction workLoopConcurrent() {\n  // Perform work until Scheduler asks us to yield\n  while (workInProgress !== null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork) {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  var current = unitOfWork.alternate;\n  setCurrentFiber(unitOfWork);\n  var next;\n\n  if ( (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);\n  }\n\n  resetCurrentFiber();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner$2.current = null;\n}\n\nfunction completeUnitOfWork(unitOfWork) {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  var completedWork = unitOfWork;\n\n  do {\n    // The current, flushed, state of this fiber is the alternate. Ideally\n    // nothing should rely on this, but relying on it here means that we don't\n    // need an additional field on the work in progress.\n    var current = completedWork.alternate;\n    var returnFiber = completedWork.return; // Check if the work completed or if something threw.\n\n    if ((completedWork.flags & Incomplete) === NoFlags) {\n      setCurrentFiber(completedWork);\n      var next = void 0;\n\n      if ( (completedWork.mode & ProfileMode) === NoMode) {\n        next = completeWork(current, completedWork, subtreeRenderLanes);\n      } else {\n        startProfilerTimer(completedWork);\n        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.\n\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n      }\n\n      resetCurrentFiber();\n\n      if (next !== null) {\n        // Completing this fiber spawned new work. Work on that next.\n        workInProgress = next;\n        return;\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      var _next = unwindWork(current, completedWork); // Because this fiber did not complete, don't reset its lanes.\n\n\n      if (_next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        _next.flags &= HostEffectMask;\n        workInProgress = _next;\n        return;\n      }\n\n      if ( (completedWork.mode & ProfileMode) !== NoMode) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.\n\n        var actualDuration = completedWork.actualDuration;\n        var child = completedWork.child;\n\n        while (child !== null) {\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n\n        completedWork.actualDuration = actualDuration;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its subtree flags.\n        returnFiber.flags |= Incomplete;\n        returnFiber.subtreeFlags = NoFlags;\n        returnFiber.deletions = null;\n      } else {\n        // We've unwound all the way to the root.\n        workInProgressRootExitStatus = RootDidNotComplete;\n        workInProgress = null;\n        return;\n      }\n    }\n\n    var siblingFiber = completedWork.sibling;\n\n    if (siblingFiber !== null) {\n      // If there is more work to do in this returnFiber, do that next.\n      workInProgress = siblingFiber;\n      return;\n    } // Otherwise, return to the parent\n\n\n    completedWork = returnFiber; // Update the next thing we're working on in case something throws.\n\n    workInProgress = completedWork;\n  } while (completedWork !== null); // We've reached the root.\n\n\n  if (workInProgressRootExitStatus === RootInProgress) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n}\n\nfunction commitRoot(root, recoverableErrors) {\n  // TODO: This no longer makes any sense. We already wrap the mutation and\n  // layout phases. Should be able to remove.\n  var previousUpdateLanePriority = getCurrentUpdatePriority();\n  var prevTransition = ReactCurrentBatchConfig$2.transition;\n\n  try {\n    ReactCurrentBatchConfig$2.transition = null;\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    commitRootImpl(root, recoverableErrors, previousUpdateLanePriority);\n  } finally {\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n    setCurrentUpdatePriority(previousUpdateLanePriority);\n  }\n\n  return null;\n}\n\nfunction commitRootImpl(root, recoverableErrors, renderPriorityLevel) {\n  do {\n    // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n    // means `flushPassiveEffects` will sometimes result in additional\n    // passive effects. So we need to keep flushing in a loop until there are\n    // no more pending effects.\n    // TODO: Might be better if `flushPassiveEffects` did not automatically\n    // flush synchronous work at the end, to avoid factoring hazards like this.\n    flushPassiveEffects();\n  } while (rootWithPendingPassiveEffects !== null);\n\n  flushRenderPhaseStrictModeWarningsInDEV();\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Should not already be working.');\n  }\n\n  var finishedWork = root.finishedWork;\n  var lanes = root.finishedLanes;\n\n  {\n    markCommitStarted(lanes);\n  }\n\n  if (finishedWork === null) {\n\n    {\n      markCommitStopped();\n    }\n\n    return null;\n  } else {\n    {\n      if (lanes === NoLanes) {\n        error('root.finishedLanes should not be empty during a commit. This is a ' + 'bug in React.');\n      }\n    }\n  }\n\n  root.finishedWork = null;\n  root.finishedLanes = NoLanes;\n\n  if (finishedWork === root.current) {\n    throw new Error('Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n  } // commitRoot never returns a continuation; it always finishes synchronously.\n  // So we can clear these now to allow a new callback to be scheduled.\n\n\n  root.callbackNode = null;\n  root.callbackPriority = NoLane; // Update the first and last pending times on this root. The new first\n  // pending time is whatever is left on the root fiber.\n\n  var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);\n  markRootFinished(root, remainingLanes);\n\n  if (root === workInProgressRoot) {\n    // We can reset these now that they are finished.\n    workInProgressRoot = null;\n    workInProgress = null;\n    workInProgressRootRenderLanes = NoLanes;\n  } // If there are pending passive effects, schedule a callback to process them.\n  // Do this as early as possible, so it is queued before anything else that\n  // might get scheduled in the commit phase. (See #16714.)\n  // TODO: Delete all other places that schedule the passive effect callback\n  // They're redundant.\n\n\n  if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      scheduleCallback$1(NormalPriority, function () {\n        flushPassiveEffects(); // This render triggered passive effects: release the root cache pool\n        // *after* passive effects fire to avoid freeing a cache pool that may\n        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n\n        return null;\n      });\n    }\n  } // Check if there are any effects in the whole tree.\n  // TODO: This is left over from the effect list implementation, where we had\n  // to check for the existence of `firstEffect` to satisfy Flow. I think the\n  // only other reason this optimization exists is because it affects profiling.\n  // Reconsider whether this is necessary.\n\n\n  var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n  var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;\n\n  if (subtreeHasEffects || rootHasEffect) {\n    var prevTransition = ReactCurrentBatchConfig$2.transition;\n    ReactCurrentBatchConfig$2.transition = null;\n    var previousPriority = getCurrentUpdatePriority();\n    setCurrentUpdatePriority(DiscreteEventPriority);\n    var prevExecutionContext = executionContext;\n    executionContext |= CommitContext; // Reset this to null before calling lifecycles\n\n    ReactCurrentOwner$2.current = null; // The commit phase is broken into several sub-phases. We do a separate pass\n    // of the effect list for each phase: all mutation effects come before all\n    // layout effects, and so on.\n    // The first phase a \"before mutation\" phase. We use this phase to read the\n    // state of the host tree right before we mutate it. This is where\n    // getSnapshotBeforeUpdate is called.\n\n    var shouldFireAfterActiveInstanceBlur = commitBeforeMutationEffects(root, finishedWork);\n\n    {\n      // Mark the current commit time to be shared by all Profilers in this\n      // batch. This enables them to be grouped later.\n      recordCommitTime();\n    }\n\n\n    commitMutationEffects(root, finishedWork, lanes);\n\n    resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n    // the mutation phase, so that the previous tree is still current during\n    // componentWillUnmount, but before the layout phase, so that the finished\n    // work is current during componentDidMount/Update.\n\n    root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n\n    {\n      markLayoutEffectsStarted(lanes);\n    }\n\n    commitLayoutEffects(finishedWork, root, lanes);\n\n    {\n      markLayoutEffectsStopped();\n    }\n    // opportunity to paint.\n\n\n    requestPaint();\n    executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.\n\n    setCurrentUpdatePriority(previousPriority);\n    ReactCurrentBatchConfig$2.transition = prevTransition;\n  } else {\n    // No effects.\n    root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n    // no effects.\n    // TODO: Maybe there's a better way to report this.\n\n    {\n      recordCommitTime();\n    }\n  }\n\n  var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n\n  if (rootDoesHavePassiveEffects) {\n    // This commit has passive effects. Stash a reference to them. But don't\n    // schedule a callback until after flushing layout work.\n    rootDoesHavePassiveEffects = false;\n    rootWithPendingPassiveEffects = root;\n    pendingPassiveEffectsLanes = lanes;\n  } // Read this again, since an effect might have updated it\n\n\n  remainingLanes = root.pendingLanes; // Check if there's remaining work on this root\n  // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n  // is to detect whether something might have called setState inside\n  // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n  // inside `componentDidCatch` is itself flawed  that's why we recommend\n  // `getDerivedStateFromError` instead. However, it could be improved by\n  // checking if remainingLanes includes Sync work, instead of whether there's\n  // any work remaining at all (which would also include stuff like Suspense\n  // retries or transitions). It's been like this for a while, though, so fixing\n  // it probably isn't that urgent.\n\n  if (remainingLanes === NoLanes) {\n    // If there's no remaining work, we can clear the set of already failed\n    // error boundaries.\n    legacyErrorBoundariesThatAlreadyFailed = null;\n  }\n\n  {\n    if (!rootDidHavePassiveEffects) {\n      commitDoubleInvokeEffectsInDEV(root.current, false);\n    }\n  }\n\n  onCommitRoot(finishedWork.stateNode, renderPriorityLevel);\n\n  {\n    if (isDevToolsPresent) {\n      root.memoizedUpdaters.clear();\n    }\n  }\n\n  {\n    onCommitRoot$1();\n  } // Always call this before exiting `commitRoot`, to ensure that any\n  // additional work on this root is scheduled.\n\n\n  ensureRootIsScheduled(root, now$1());\n\n  if (recoverableErrors !== null) {\n    // There were errors during this render, but recovered from them without\n    // needing to surface it to the UI. We log them here.\n    var onRecoverableError = root.onRecoverableError;\n\n    for (var i = 0; i < recoverableErrors.length; i++) {\n      var recoverableError = recoverableErrors[i];\n      onRecoverableError(recoverableError);\n    }\n  }\n\n  if (hasUncaughtError) {\n    hasUncaughtError = false;\n    var error$1 = firstUncaughtError;\n    firstUncaughtError = null;\n    throw error$1;\n  } // If the passive effects are the result of a discrete render, flush them\n  // synchronously at the end of the current task so that the result is\n  // immediately observable. Otherwise, we assume that they are not\n  // order-dependent and do not need to be observed by external systems, so we\n  // can wait until after paint.\n  // TODO: We can optimize this by not scheduling the callback earlier. Since we\n  // currently schedule the callback in multiple places, will wait until those\n  // are consolidated.\n\n\n  if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root.tag !== LegacyRoot) {\n    flushPassiveEffects();\n  } // Read this again, since a passive effect might have updated it\n\n\n  remainingLanes = root.pendingLanes;\n\n  if (includesSomeLane(remainingLanes, SyncLane)) {\n    {\n      markNestedUpdateScheduled();\n    } // Count the number of times the root synchronously re-renders without\n    // finishing. If there are too many, it indicates an infinite update loop.\n\n\n    if (root === rootWithNestedUpdates) {\n      nestedUpdateCount++;\n    } else {\n      nestedUpdateCount = 0;\n      rootWithNestedUpdates = root;\n    }\n  } else {\n    nestedUpdateCount = 0;\n  } // If layout work was scheduled, flush it now.\n\n\n  flushSyncCallbacks();\n\n  {\n    markCommitStopped();\n  }\n\n  return null;\n}\n\nfunction flushPassiveEffects() {\n  // Returns whether passive effects were flushed.\n  // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n  // probably just combine the two functions. I believe they were only separate\n  // in the first place because we used to wrap it with\n  // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n  // priority within React itself, so we can mutate the variable directly.\n  if (rootWithPendingPassiveEffects !== null) {\n    var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n    var priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n    var prevTransition = ReactCurrentBatchConfig$2.transition;\n    var previousPriority = getCurrentUpdatePriority();\n\n    try {\n      ReactCurrentBatchConfig$2.transition = null;\n      setCurrentUpdatePriority(priority);\n      return flushPassiveEffectsImpl();\n    } finally {\n      setCurrentUpdatePriority(previousPriority);\n      ReactCurrentBatchConfig$2.transition = prevTransition; // Once passive effects have run for the tree - giving components a\n    }\n  }\n\n  return false;\n}\nfunction enqueuePendingPassiveProfilerEffect(fiber) {\n  {\n    pendingPassiveProfilerEffects.push(fiber);\n\n    if (!rootDoesHavePassiveEffects) {\n      rootDoesHavePassiveEffects = true;\n      scheduleCallback$1(NormalPriority, function () {\n        flushPassiveEffects();\n        return null;\n      });\n    }\n  }\n}\n\nfunction flushPassiveEffectsImpl() {\n  if (rootWithPendingPassiveEffects === null) {\n    return false;\n  }\n\n  var root = rootWithPendingPassiveEffects;\n  var lanes = pendingPassiveEffectsLanes;\n  rootWithPendingPassiveEffects = null; // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n  // Figure out why and fix it. It's not causing any known issues (probably\n  // because it's only used for profiling), but it's a refactor hazard.\n\n  pendingPassiveEffectsLanes = NoLanes;\n\n  if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n    throw new Error('Cannot flush passive effects while already rendering.');\n  }\n\n  {\n    markPassiveEffectsStarted(lanes);\n  }\n\n  var prevExecutionContext = executionContext;\n  executionContext |= CommitContext;\n  commitPassiveUnmountEffects(root.current);\n  commitPassiveMountEffects(root, root.current); // TODO: Move to commitPassiveMountEffects\n\n  {\n    var profilerEffects = pendingPassiveProfilerEffects;\n    pendingPassiveProfilerEffects = [];\n\n    for (var i = 0; i < profilerEffects.length; i++) {\n      var _fiber = profilerEffects[i];\n      commitPassiveEffectDurations(root, _fiber);\n    }\n  }\n\n  {\n    markPassiveEffectsStopped();\n  }\n\n  {\n    commitDoubleInvokeEffectsInDEV(root.current, true);\n  }\n\n  executionContext = prevExecutionContext;\n  flushSyncCallbacks(); // If additional passive effects were scheduled, increment a counter. If this\n  // exceeds the limit, we'll fire a warning.\n\n  nestedPassiveUpdateCount = rootWithPendingPassiveEffects === null ? 0 : nestedPassiveUpdateCount + 1; // TODO: Move to commitPassiveMountEffects\n\n  onPostCommitRoot(root);\n\n  {\n    var stateNode = root.current.stateNode;\n    stateNode.effectDuration = 0;\n    stateNode.passiveEffectDuration = 0;\n  }\n\n  return true;\n}\n\nfunction isAlreadyFailedLegacyErrorBoundary(instance) {\n  return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n}\nfunction markLegacyErrorBoundaryAsFailed(instance) {\n  if (legacyErrorBoundariesThatAlreadyFailed === null) {\n    legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);\n  } else {\n    legacyErrorBoundariesThatAlreadyFailed.add(instance);\n  }\n}\n\nfunction prepareToThrowUncaughtError(error) {\n  if (!hasUncaughtError) {\n    hasUncaughtError = true;\n    firstUncaughtError = error;\n  }\n}\n\nvar onUncaughtError = prepareToThrowUncaughtError;\n\nfunction captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n  var errorInfo = createCapturedValue(error, sourceFiber);\n  var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);\n  enqueueUpdate(rootFiber, update);\n  var eventTime = requestEventTime();\n  var root = markUpdateLaneFromFiberToRoot(rootFiber, SyncLane);\n\n  if (root !== null) {\n    markRootUpdated(root, SyncLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nfunction captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {\n  if (sourceFiber.tag === HostRoot) {\n    // Error was thrown at the root. There is no parent, so the root\n    // itself should capture it.\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);\n    return;\n  }\n\n  var fiber = null;\n\n  {\n    fiber = nearestMountedAncestor;\n  }\n\n  while (fiber !== null) {\n    if (fiber.tag === HostRoot) {\n      captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);\n      return;\n    } else if (fiber.tag === ClassComponent) {\n      var ctor = fiber.type;\n      var instance = fiber.stateNode;\n\n      if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n        var errorInfo = createCapturedValue(error$1, sourceFiber);\n        var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);\n        enqueueUpdate(fiber, update);\n        var eventTime = requestEventTime();\n        var root = markUpdateLaneFromFiberToRoot(fiber, SyncLane);\n\n        if (root !== null) {\n          markRootUpdated(root, SyncLane, eventTime);\n          ensureRootIsScheduled(root, eventTime);\n        }\n\n        return;\n      }\n    }\n\n    fiber = fiber.return;\n  }\n\n  {\n    // TODO: Until we re-land skipUnmountedBoundaries (see #20147), this warning\n    // will fire for errors that are thrown by destroy functions inside deleted\n    // trees. What it should instead do is propagate the error to the parent of\n    // the deleted tree. In the meantime, do not add this warning to the\n    // allowlist; this is only for our internal use.\n    error('Internal React error: Attempted to capture a commit phase error ' + 'inside a detached tree. This indicates a bug in React. Likely ' + 'causes include deleting the same fiber more than once, committing an ' + 'already-finished tree, or an inconsistent return pointer.\\n\\n' + 'Error message:\\n\\n%s', error$1);\n  }\n}\nfunction pingSuspendedRoot(root, wakeable, pingedLanes) {\n  var pingCache = root.pingCache;\n\n  if (pingCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    pingCache.delete(wakeable);\n  }\n\n  var eventTime = requestEventTime();\n  markRootPinged(root, pingedLanes);\n  warnIfSuspenseResolutionNotWrappedWithActDEV(root);\n\n  if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n    // Received a ping at the same priority level at which we're currently\n    // rendering. We might want to restart this render. This should mirror\n    // the logic of whether or not a root suspends once it completes.\n    // TODO: If we're rendering sync either due to Sync, Batched or expired,\n    // we should probably never restart.\n    // If we're suspended with delay, or if it's a retry, we'll always suspend\n    // so we can always restart.\n    if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n      // Restart from the root.\n      prepareFreshStack(root, NoLanes);\n    } else {\n      // Even though we can't restart right now, we might get an\n      // opportunity later. So we mark this render as having a ping.\n      workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n    }\n  }\n\n  ensureRootIsScheduled(root, eventTime);\n}\n\nfunction retryTimedOutBoundary(boundaryFiber, retryLane) {\n  // The boundary fiber (a Suspense component or SuspenseList component)\n  // previously was rendered in its fallback state. One of the promises that\n  // suspended it has resolved, which means at least part of the tree was\n  // likely unblocked. Try rendering again, at a new lanes.\n  if (retryLane === NoLane) {\n    // TODO: Assign this to `suspenseState.retryLane`? to avoid\n    // unnecessary entanglement?\n    retryLane = requestRetryLane(boundaryFiber);\n  } // TODO: Special case idle priority?\n\n\n  var eventTime = requestEventTime();\n  var root = markUpdateLaneFromFiberToRoot(boundaryFiber, retryLane);\n\n  if (root !== null) {\n    markRootUpdated(root, retryLane, eventTime);\n    ensureRootIsScheduled(root, eventTime);\n  }\n}\n\nfunction retryDehydratedSuspenseBoundary(boundaryFiber) {\n  var suspenseState = boundaryFiber.memoizedState;\n  var retryLane = NoLane;\n\n  if (suspenseState !== null) {\n    retryLane = suspenseState.retryLane;\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\nfunction resolveRetryWakeable(boundaryFiber, wakeable) {\n  var retryLane = NoLane; // Default\n\n  var retryCache;\n\n  {\n    switch (boundaryFiber.tag) {\n      case SuspenseComponent:\n        retryCache = boundaryFiber.stateNode;\n        var suspenseState = boundaryFiber.memoizedState;\n\n        if (suspenseState !== null) {\n          retryLane = suspenseState.retryLane;\n        }\n\n        break;\n\n      case SuspenseListComponent:\n        retryCache = boundaryFiber.stateNode;\n        break;\n\n      default:\n        throw new Error('Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');\n    }\n  }\n\n  if (retryCache !== null) {\n    // The wakeable resolved, so we no longer need to memoize, because it will\n    // never be thrown again.\n    retryCache.delete(wakeable);\n  }\n\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n} // Computes the next Just Noticeable Difference (JND) boundary.\n// The theory is that a person can't tell the difference between small differences in time.\n// Therefore, if we wait a bit longer than necessary that won't translate to a noticeable\n// difference in the experience. However, waiting for longer might mean that we can avoid\n// showing an intermediate loading state. The longer we have already waited, the harder it\n// is to tell small differences in time. Therefore, the longer we've already waited,\n// the longer we can wait additionally. At some point we have to give up though.\n// We pick a train model where the next boundary commits at a consistent schedule.\n// These particular numbers are vague estimates. We expect to adjust them based on research.\n\nfunction jnd(timeElapsed) {\n  return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;\n}\n\nfunction checkForNestedUpdates() {\n  if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n    nestedUpdateCount = 0;\n    rootWithNestedUpdates = null;\n    throw new Error('Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');\n  }\n\n  {\n    if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n      nestedPassiveUpdateCount = 0;\n\n      error('Maximum update depth exceeded. This can happen when a component ' + \"calls setState inside useEffect, but useEffect either doesn't \" + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');\n    }\n  }\n}\n\nfunction flushRenderPhaseStrictModeWarningsInDEV() {\n  {\n    ReactStrictModeWarnings.flushLegacyContextWarning();\n\n    {\n      ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n    }\n  }\n}\n\nfunction commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {\n  {\n    // TODO (StrictEffects) Should we set a marker on the root if it contains strict effects\n    // so we don't traverse unnecessarily? similar to subtreeFlags but just at the root level.\n    // Maybe not a big deal since this is DEV only behavior.\n    setCurrentFiber(fiber);\n    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);\n\n    if (hasPassiveEffects) {\n      invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);\n    }\n\n    invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);\n\n    if (hasPassiveEffects) {\n      invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);\n    }\n\n    resetCurrentFiber();\n  }\n}\n\nfunction invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {\n  {\n    // We don't need to re-check StrictEffectsMode here.\n    // This function is only called if that check has already passed.\n    var current = firstChild;\n    var subtreeRoot = null;\n\n    while (current !== null) {\n      var primarySubtreeFlag = current.subtreeFlags & fiberFlags;\n\n      if (current !== subtreeRoot && current.child !== null && primarySubtreeFlag !== NoFlags) {\n        current = current.child;\n      } else {\n        if ((current.flags & fiberFlags) !== NoFlags) {\n          invokeEffectFn(current);\n        }\n\n        if (current.sibling !== null) {\n          current = current.sibling;\n        } else {\n          current = subtreeRoot = current.return;\n        }\n      }\n    }\n  }\n}\n\nvar didWarnStateUpdateForNotYetMountedComponent = null;\n\nfunction warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n  {\n    if ((executionContext & RenderContext) !== NoContext) {\n      // We let the other warning about render phase updates deal with this one.\n      return;\n    }\n\n    if (!(fiber.mode & ConcurrentMode)) {\n      return;\n    }\n\n    var tag = fiber.tag;\n\n    if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n      // Only warn for user-defined components, not internal ones like Suspense.\n      return;\n    } // We show the whole stack but dedupe on the top component's name because\n    // the problematic code almost always lies inside that component.\n\n\n    var componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';\n\n    if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n      if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n        return;\n      }\n\n      didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n    } else {\n      didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);\n    }\n\n    var previousFiber = current;\n\n    try {\n      setCurrentFiber(fiber);\n\n      error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');\n    } finally {\n      if (previousFiber) {\n        setCurrentFiber(fiber);\n      } else {\n        resetCurrentFiber();\n      }\n    }\n  }\n}\n\nvar beginWork$1;\n\n{\n  var dummyFiber = null;\n\n  beginWork$1 = function (current, unitOfWork, lanes) {\n    // If a component throws an error, we replay it again in a synchronously\n    // dispatched event, so that the debugger will treat it as an uncaught\n    // error See ReactErrorUtils for more information.\n    // Before entering the begin phase, copy the work-in-progress onto a dummy\n    // fiber. If beginWork throws, we'll use this to reset the state.\n    var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);\n\n    try {\n      return beginWork(current, unitOfWork, lanes);\n    } catch (originalError) {\n      if (originalError !== null && typeof originalError === 'object' && typeof originalError.then === 'function') {\n        // Don't replay promises. Treat everything else like an error.\n        throw originalError;\n      } // Keep this code in sync with handleError; any changes here must have\n      // corresponding changes there.\n\n\n      resetContextDependencies();\n      resetHooksAfterThrow(); // Don't reset current debug fiber, since we're about to work on the\n      // same fiber again.\n      // Unwind the failed stack frame\n\n      unwindInterruptedWork(current, unitOfWork); // Restore the original properties of the fiber.\n\n      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);\n\n      if ( unitOfWork.mode & ProfileMode) {\n        // Reset the profiler timer.\n        startProfilerTimer(unitOfWork);\n      } // Run beginWork again.\n\n\n      invokeGuardedCallback(null, beginWork, null, current, unitOfWork, lanes);\n\n      if (hasCaughtError()) {\n        var replayError = clearCaughtError();\n\n        if (typeof replayError === 'object' && replayError !== null && replayError._suppressLogging && typeof originalError === 'object' && originalError !== null && !originalError._suppressLogging) {\n          // If suppressed, let the flag carry over to the original error which is the one we'll rethrow.\n          originalError._suppressLogging = true;\n        }\n      } // We always throw the original error in case the second render pass is not idempotent.\n      // This can happen if a memoized function or CommonJS module doesn't throw after first invocation.\n\n\n      throw originalError;\n    }\n  };\n}\n\nvar didWarnAboutUpdateInRender = false;\nvar didWarnAboutUpdateInRenderForAnotherComponent;\n\n{\n  didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n}\n\nfunction warnAboutRenderPhaseUpdatesInDEV(fiber) {\n  {\n    if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {\n      switch (fiber.tag) {\n        case FunctionComponent:\n        case ForwardRef:\n        case SimpleMemoComponent:\n          {\n            var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.\n\n            var dedupeKey = renderingComponentName;\n\n            if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n              didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n              var setStateComponentName = getComponentNameFromFiber(fiber) || 'Unknown';\n\n              error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://reactjs.org/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);\n            }\n\n            break;\n          }\n\n        case ClassComponent:\n          {\n            if (!didWarnAboutUpdateInRender) {\n              error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');\n\n              didWarnAboutUpdateInRender = true;\n            }\n\n            break;\n          }\n      }\n    }\n  }\n}\n\nfunction restorePendingUpdaters(root, lanes) {\n  {\n    if (isDevToolsPresent) {\n      var memoizedUpdaters = root.memoizedUpdaters;\n      memoizedUpdaters.forEach(function (schedulingFiber) {\n        addFiberToLanesMap(root, schedulingFiber, lanes);\n      }); // This function intentionally does not clear memoized updaters.\n      // Those may still be relevant to the current commit\n      // and a future one (e.g. Suspense).\n    }\n  }\n}\nvar fakeActCallbackNode = {};\n\nfunction scheduleCallback$1(priorityLevel, callback) {\n  {\n    // If we're currently inside an `act` scope, bypass Scheduler and push to\n    // the `act` queue instead.\n    var actQueue = ReactCurrentActQueue$1.current;\n\n    if (actQueue !== null) {\n      actQueue.push(callback);\n      return fakeActCallbackNode;\n    } else {\n      return scheduleCallback(priorityLevel, callback);\n    }\n  }\n}\n\nfunction cancelCallback$1(callbackNode) {\n  if ( callbackNode === fakeActCallbackNode) {\n    return;\n  } // In production, always call Scheduler. This function will be stripped out.\n\n\n  return cancelCallback(callbackNode);\n}\n\nfunction shouldForceFlushFallbacksInDEV() {\n  // Never force flush in production. This function should get stripped out.\n  return  ReactCurrentActQueue$1.current !== null;\n}\n\nfunction warnIfUpdatesNotWrappedWithActDEV(fiber) {\n  {\n    if (fiber.mode & ConcurrentMode) {\n      if (!isConcurrentActEnvironment()) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n    } else {\n      // Legacy mode has additional cases where we suppress a warning.\n      if (!isLegacyActEnvironment()) {\n        // Not in an act environment. No need to warn.\n        return;\n      }\n\n      if (executionContext !== NoContext) {\n        // Legacy mode doesn't warn if the update is batched, i.e.\n        // batchedUpdates or flushSync.\n        return;\n      }\n\n      if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {\n        // For backwards compatibility with pre-hooks code, legacy mode only\n        // warns for updates that originate from a hook.\n        return;\n      }\n    }\n\n    if (ReactCurrentActQueue$1.current === null) {\n      var previousFiber = current;\n\n      try {\n        setCurrentFiber(fiber);\n\n        error('An update to %s inside a test was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act', getComponentNameFromFiber(fiber));\n      } finally {\n        if (previousFiber) {\n          setCurrentFiber(fiber);\n        } else {\n          resetCurrentFiber();\n        }\n      }\n    }\n  }\n}\n\nfunction warnIfSuspenseResolutionNotWrappedWithActDEV(root) {\n  {\n    if (root.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {\n      error('A suspended resource finished loading inside a test, but the event ' + 'was not wrapped in act(...).\\n\\n' + 'When testing, code that resolves suspended data should be wrapped ' + 'into act(...):\\n\\n' + 'act(() => {\\n' + '  /* finish loading suspended data */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://reactjs.org/link/wrap-tests-with-act');\n    }\n  }\n}\n\n/* eslint-disable react-internal/prod-error-codes */\nvar resolveFamily = null; // $FlowFixMe Flow gets confused by a WeakSet feature check below.\n\nvar failedBoundaries = null;\nvar setRefreshHandler = function (handler) {\n  {\n    resolveFamily = handler;\n  }\n};\nfunction resolveFunctionForHotReloading(type) {\n  {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return type;\n    }\n\n    var family = resolveFamily(type);\n\n    if (family === undefined) {\n      return type;\n    } // Use the latest known implementation.\n\n\n    return family.current;\n  }\n}\nfunction resolveClassForHotReloading(type) {\n  // No implementation differences.\n  return resolveFunctionForHotReloading(type);\n}\nfunction resolveForwardRefForHotReloading(type) {\n  {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return type;\n    }\n\n    var family = resolveFamily(type);\n\n    if (family === undefined) {\n      // Check if we're dealing with a real forwardRef. Don't want to crash early.\n      if (type !== null && type !== undefined && typeof type.render === 'function') {\n        // ForwardRef is special because its resolved .type is an object,\n        // but it's possible that we only have its inner render function in the map.\n        // If that inner render function is different, we'll build a new forwardRef type.\n        var currentRender = resolveFunctionForHotReloading(type.render);\n\n        if (type.render !== currentRender) {\n          var syntheticType = {\n            $$typeof: REACT_FORWARD_REF_TYPE,\n            render: currentRender\n          };\n\n          if (type.displayName !== undefined) {\n            syntheticType.displayName = type.displayName;\n          }\n\n          return syntheticType;\n        }\n      }\n\n      return type;\n    } // Use the latest known implementation.\n\n\n    return family.current;\n  }\n}\nfunction isCompatibleFamilyForHotReloading(fiber, element) {\n  {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return false;\n    }\n\n    var prevType = fiber.elementType;\n    var nextType = element.type; // If we got here, we know types aren't === equal.\n\n    var needsCompareFamilies = false;\n    var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;\n\n    switch (fiber.tag) {\n      case ClassComponent:\n        {\n          if (typeof nextType === 'function') {\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      case FunctionComponent:\n        {\n          if (typeof nextType === 'function') {\n            needsCompareFamilies = true;\n          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n            // We don't know the inner type yet.\n            // We're going to assume that the lazy inner type is stable,\n            // and so it is sufficient to avoid reconciling it away.\n            // We're not going to unwrap or actually use the new lazy type.\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      case ForwardRef:\n        {\n          if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n            needsCompareFamilies = true;\n          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      case MemoComponent:\n      case SimpleMemoComponent:\n        {\n          if ($$typeofNextType === REACT_MEMO_TYPE) {\n            // TODO: if it was but can no longer be simple,\n            // we shouldn't set this.\n            needsCompareFamilies = true;\n          } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n            needsCompareFamilies = true;\n          }\n\n          break;\n        }\n\n      default:\n        return false;\n    } // Check if both types have a family and it's the same one.\n\n\n    if (needsCompareFamilies) {\n      // Note: memo() and forwardRef() we'll compare outer rather than inner type.\n      // This means both of them need to be registered to preserve state.\n      // If we unwrapped and compared the inner types for wrappers instead,\n      // then we would risk falsely saying two separate memo(Foo)\n      // calls are equivalent because they wrap the same Foo function.\n      var prevFamily = resolveFamily(prevType);\n\n      if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\nfunction markFailedErrorBoundaryForHotReloading(fiber) {\n  {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return;\n    }\n\n    if (typeof WeakSet !== 'function') {\n      return;\n    }\n\n    if (failedBoundaries === null) {\n      failedBoundaries = new WeakSet();\n    }\n\n    failedBoundaries.add(fiber);\n  }\n}\nvar scheduleRefresh = function (root, update) {\n  {\n    if (resolveFamily === null) {\n      // Hot reloading is disabled.\n      return;\n    }\n\n    var staleFamilies = update.staleFamilies,\n        updatedFamilies = update.updatedFamilies;\n    flushPassiveEffects();\n    flushSync(function () {\n      scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);\n    });\n  }\n};\nvar scheduleRoot = function (root, element) {\n  {\n    if (root.context !== emptyContextObject) {\n      // Super edge case: root has a legacy _renderSubtree context\n      // but we don't know the parentComponent so we can't pass it.\n      // Just ignore. We'll delete this with _renderSubtree code path later.\n      return;\n    }\n\n    flushPassiveEffects();\n    flushSync(function () {\n      updateContainer(element, root, null, null);\n    });\n  }\n};\n\nfunction scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n  {\n    var alternate = fiber.alternate,\n        child = fiber.child,\n        sibling = fiber.sibling,\n        tag = fiber.tag,\n        type = fiber.type;\n    var candidateType = null;\n\n    switch (tag) {\n      case FunctionComponent:\n      case SimpleMemoComponent:\n      case ClassComponent:\n        candidateType = type;\n        break;\n\n      case ForwardRef:\n        candidateType = type.render;\n        break;\n    }\n\n    if (resolveFamily === null) {\n      throw new Error('Expected resolveFamily to be set during hot reload.');\n    }\n\n    var needsRender = false;\n    var needsRemount = false;\n\n    if (candidateType !== null) {\n      var family = resolveFamily(candidateType);\n\n      if (family !== undefined) {\n        if (staleFamilies.has(family)) {\n          needsRemount = true;\n        } else if (updatedFamilies.has(family)) {\n          if (tag === ClassComponent) {\n            needsRemount = true;\n          } else {\n            needsRender = true;\n          }\n        }\n      }\n    }\n\n    if (failedBoundaries !== null) {\n      if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {\n        needsRemount = true;\n      }\n    }\n\n    if (needsRemount) {\n      fiber._debugNeedsRemount = true;\n    }\n\n    if (needsRemount || needsRender) {\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n    }\n\n    if (child !== null && !needsRemount) {\n      scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n    }\n\n    if (sibling !== null) {\n      scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n    }\n  }\n}\n\nvar findHostInstancesForRefresh = function (root, families) {\n  {\n    var hostInstances = new Set();\n    var types = new Set(families.map(function (family) {\n      return family.current;\n    }));\n    findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);\n    return hostInstances;\n  }\n};\n\nfunction findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n  {\n    var child = fiber.child,\n        sibling = fiber.sibling,\n        tag = fiber.tag,\n        type = fiber.type;\n    var candidateType = null;\n\n    switch (tag) {\n      case FunctionComponent:\n      case SimpleMemoComponent:\n      case ClassComponent:\n        candidateType = type;\n        break;\n\n      case ForwardRef:\n        candidateType = type.render;\n        break;\n    }\n\n    var didMatch = false;\n\n    if (candidateType !== null) {\n      if (types.has(candidateType)) {\n        didMatch = true;\n      }\n    }\n\n    if (didMatch) {\n      // We have a match. This only drills down to the closest host components.\n      // There's no need to search deeper because for the purpose of giving\n      // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\n      findHostInstancesForFiberShallowly(fiber, hostInstances);\n    } else {\n      // If there's no match, maybe there will be one further down in the child tree.\n      if (child !== null) {\n        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n      }\n    }\n\n    if (sibling !== null) {\n      findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n    }\n  }\n}\n\nfunction findHostInstancesForFiberShallowly(fiber, hostInstances) {\n  {\n    var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n\n    if (foundHostInstances) {\n      return;\n    } // If we didn't find any host children, fallback to closest host parent.\n\n\n    var node = fiber;\n\n    while (true) {\n      switch (node.tag) {\n        case HostComponent:\n          hostInstances.add(node.stateNode);\n          return;\n\n        case HostPortal:\n          hostInstances.add(node.stateNode.containerInfo);\n          return;\n\n        case HostRoot:\n          hostInstances.add(node.stateNode.containerInfo);\n          return;\n      }\n\n      if (node.return === null) {\n        throw new Error('Expected to reach root first.');\n      }\n\n      node = node.return;\n    }\n  }\n}\n\nfunction findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n  {\n    var node = fiber;\n    var foundHostInstances = false;\n\n    while (true) {\n      if (node.tag === HostComponent) {\n        // We got a match.\n        foundHostInstances = true;\n        hostInstances.add(node.stateNode); // There may still be more, so keep searching.\n      } else if (node.child !== null) {\n        node.child.return = node;\n        node = node.child;\n        continue;\n      }\n\n      if (node === fiber) {\n        return foundHostInstances;\n      }\n\n      while (node.sibling === null) {\n        if (node.return === null || node.return === fiber) {\n          return foundHostInstances;\n        }\n\n        node = node.return;\n      }\n\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n\n  return false;\n}\n\nvar hasBadMapPolyfill;\n\n{\n  hasBadMapPolyfill = false;\n\n  try {\n    var nonExtensibleObject = Object.preventExtensions({});\n    /* eslint-disable no-new */\n\n    new Map([[nonExtensibleObject, null]]);\n    new Set([nonExtensibleObject]);\n    /* eslint-enable no-new */\n  } catch (e) {\n    // TODO: Consider warning about bad polyfills\n    hasBadMapPolyfill = true;\n  }\n}\n\nfunction FiberNode(tag, pendingProps, key, mode) {\n  // Instance\n  this.tag = tag;\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null; // Fiber\n\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n  this.ref = null;\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n  this.mode = mode; // Effects\n\n  this.flags = NoFlags;\n  this.subtreeFlags = NoFlags;\n  this.deletions = null;\n  this.lanes = NoLanes;\n  this.childLanes = NoLanes;\n  this.alternate = null;\n\n  {\n    // Note: The following is done to avoid a v8 performance cliff.\n    //\n    // Initializing the fields below to smis and later updating them with\n    // double values will cause Fibers to end up having separate shapes.\n    // This behavior/bug has something to do with Object.preventExtension().\n    // Fortunately this only impacts DEV builds.\n    // Unfortunately it makes React unusably slow for some applications.\n    // To work around this, initialize the fields below with doubles.\n    //\n    // Learn more about this here:\n    // https://github.com/facebook/react/issues/14365\n    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n    this.actualDuration = Number.NaN;\n    this.actualStartTime = Number.NaN;\n    this.selfBaseDuration = Number.NaN;\n    this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.\n    // This won't trigger the performance cliff mentioned above,\n    // and it simplifies other profiler code (including DevTools).\n\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n\n  {\n    // This isn't directly used but is handy for debugging internals:\n    this._debugSource = null;\n    this._debugOwner = null;\n    this._debugNeedsRemount = false;\n    this._debugHookTypes = null;\n\n    if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n      Object.preventExtensions(this);\n    }\n  }\n} // This is a constructor function, rather than a POJO constructor, still\n// please ensure we do the following:\n// 1) Nobody should add any instance methods on this. Instance methods can be\n//    more difficult to predict when they get optimized and they are almost\n//    never inlined properly in static compilers.\n// 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n//    always know when it is a fiber.\n// 3) We might want to experiment with using numeric keys since they are easier\n//    to optimize in a non-JIT environment.\n// 4) We can easily go from a constructor to a createFiber object literal if that\n//    is faster.\n// 5) It should be easy to port this to a C struct and keep a C implementation\n//    compatible.\n\n\nvar createFiber = function (tag, pendingProps, key, mode) {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};\n\nfunction shouldConstruct$1(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction isSimpleFunctionComponent(type) {\n  return typeof type === 'function' && !shouldConstruct$1(type) && type.defaultProps === undefined;\n}\nfunction resolveLazyComponentTag(Component) {\n  if (typeof Component === 'function') {\n    return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;\n  } else if (Component !== undefined && Component !== null) {\n    var $$typeof = Component.$$typeof;\n\n    if ($$typeof === REACT_FORWARD_REF_TYPE) {\n      return ForwardRef;\n    }\n\n    if ($$typeof === REACT_MEMO_TYPE) {\n      return MemoComponent;\n    }\n  }\n\n  return IndeterminateComponent;\n} // This is used to create an alternate fiber to do work on.\n\nfunction createWorkInProgress(current, pendingProps) {\n  var workInProgress = current.alternate;\n\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n    workInProgress.elementType = current.elementType;\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    {\n      // DEV-only fields\n      workInProgress._debugSource = current._debugSource;\n      workInProgress._debugOwner = current._debugOwner;\n      workInProgress._debugHookTypes = current._debugHookTypes;\n    }\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.\n\n    workInProgress.type = current.type; // We already have an alternate.\n    // Reset the effect tag.\n\n    workInProgress.flags = NoFlags; // The effects are no longer valid.\n\n    workInProgress.subtreeFlags = NoFlags;\n    workInProgress.deletions = null;\n\n    {\n      // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n      // This prevents time from endlessly accumulating in new commits.\n      // This has the downside of resetting values for different priority renders,\n      // But works for yielding (the common case) and should support resuming.\n      workInProgress.actualDuration = 0;\n      workInProgress.actualStartTime = -1;\n    }\n  } // Reset all effects except static ones.\n  // Static effects are not specific to a render.\n\n\n  workInProgress.flags = current.flags & StaticMask;\n  workInProgress.childLanes = current.childLanes;\n  workInProgress.lanes = current.lanes;\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so\n  // it cannot be shared with the current fiber.\n\n  var currentDependencies = current.dependencies;\n  workInProgress.dependencies = currentDependencies === null ? null : {\n    lanes: currentDependencies.lanes,\n    firstContext: currentDependencies.firstContext\n  }; // These will be overridden during the parent's reconciliation\n\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  {\n    workInProgress.selfBaseDuration = current.selfBaseDuration;\n    workInProgress.treeBaseDuration = current.treeBaseDuration;\n  }\n\n  {\n    workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n\n    switch (workInProgress.tag) {\n      case IndeterminateComponent:\n      case FunctionComponent:\n      case SimpleMemoComponent:\n        workInProgress.type = resolveFunctionForHotReloading(current.type);\n        break;\n\n      case ClassComponent:\n        workInProgress.type = resolveClassForHotReloading(current.type);\n        break;\n\n      case ForwardRef:\n        workInProgress.type = resolveForwardRefForHotReloading(current.type);\n        break;\n    }\n  }\n\n  return workInProgress;\n} // Used to reuse a Fiber for a second pass.\n\nfunction resetWorkInProgress(workInProgress, renderLanes) {\n  // This resets the Fiber to what createFiber or createWorkInProgress would\n  // have set the values to before during the first pass. Ideally this wouldn't\n  // be necessary but unfortunately many code paths reads from the workInProgress\n  // when they should be reading from current and writing to workInProgress.\n  // We assume pendingProps, index, key, ref, return are still untouched to\n  // avoid doing another reconciliation.\n  // Reset the effect flags but keep any Placement tags, since that's something\n  // that child fiber is setting, not the reconciliation.\n  workInProgress.flags &= StaticMask | Placement; // The effects are no longer valid.\n\n  var current = workInProgress.alternate;\n\n  if (current === null) {\n    // Reset to createFiber's initial values.\n    workInProgress.childLanes = NoLanes;\n    workInProgress.lanes = renderLanes;\n    workInProgress.child = null;\n    workInProgress.subtreeFlags = NoFlags;\n    workInProgress.memoizedProps = null;\n    workInProgress.memoizedState = null;\n    workInProgress.updateQueue = null;\n    workInProgress.dependencies = null;\n    workInProgress.stateNode = null;\n\n    {\n      // Note: We don't reset the actualTime counts. It's useful to accumulate\n      // actual time across multiple render passes.\n      workInProgress.selfBaseDuration = 0;\n      workInProgress.treeBaseDuration = 0;\n    }\n  } else {\n    // Reset to the cloned values that createWorkInProgress would've.\n    workInProgress.childLanes = current.childLanes;\n    workInProgress.lanes = current.lanes;\n    workInProgress.child = current.child;\n    workInProgress.subtreeFlags = NoFlags;\n    workInProgress.deletions = null;\n    workInProgress.memoizedProps = current.memoizedProps;\n    workInProgress.memoizedState = current.memoizedState;\n    workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.\n\n    workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so\n    // it cannot be shared with the current fiber.\n\n    var currentDependencies = current.dependencies;\n    workInProgress.dependencies = currentDependencies === null ? null : {\n      lanes: currentDependencies.lanes,\n      firstContext: currentDependencies.firstContext\n    };\n\n    {\n      // Note: We don't reset the actualTime counts. It's useful to accumulate\n      // actual time across multiple render passes.\n      workInProgress.selfBaseDuration = current.selfBaseDuration;\n      workInProgress.treeBaseDuration = current.treeBaseDuration;\n    }\n  }\n\n  return workInProgress;\n}\nfunction createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {\n  var mode;\n\n  if (tag === ConcurrentRoot) {\n    mode = ConcurrentMode;\n\n    if (isStrictMode === true) {\n      mode |= StrictLegacyMode;\n\n      {\n        mode |= StrictEffectsMode;\n      }\n    }\n  } else {\n    mode = NoMode;\n  }\n\n  if ( isDevToolsPresent) {\n    // Always collect profile timings when DevTools are present.\n    // This enables DevTools to start capturing timing at any point\n    // Without some nodes in the tree having empty base times.\n    mode |= ProfileMode;\n  }\n\n  return createFiber(HostRoot, null, null, mode);\n}\nfunction createFiberFromTypeAndProps(type, // React$ElementType\nkey, pendingProps, owner, mode, lanes) {\n  var fiberTag = IndeterminateComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.\n\n  var resolvedType = type;\n\n  if (typeof type === 'function') {\n    if (shouldConstruct$1(type)) {\n      fiberTag = ClassComponent;\n\n      {\n        resolvedType = resolveClassForHotReloading(resolvedType);\n      }\n    } else {\n      {\n        resolvedType = resolveFunctionForHotReloading(resolvedType);\n      }\n    }\n  } else if (typeof type === 'string') {\n    fiberTag = HostComponent;\n  } else {\n    getTag: switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= StrictLegacyMode;\n\n        if ( (mode & ConcurrentMode) !== NoMode) {\n          // Strict effects should never run on legacy roots\n          mode |= StrictEffectsMode;\n        }\n\n        break;\n\n      case REACT_PROFILER_TYPE:\n        return createFiberFromProfiler(pendingProps, mode, lanes, key);\n\n      case REACT_SUSPENSE_TYPE:\n        return createFiberFromSuspense(pendingProps, mode, lanes, key);\n\n      case REACT_SUSPENSE_LIST_TYPE:\n        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\n\n      case REACT_OFFSCREEN_TYPE:\n        return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n\n      case REACT_LEGACY_HIDDEN_TYPE:\n\n      // eslint-disable-next-line no-fallthrough\n\n      case REACT_SCOPE_TYPE:\n\n      // eslint-disable-next-line no-fallthrough\n\n      case REACT_CACHE_TYPE:\n\n      // eslint-disable-next-line no-fallthrough\n\n      case REACT_TRACING_MARKER_TYPE:\n\n      // eslint-disable-next-line no-fallthrough\n\n      case REACT_DEBUG_TRACING_MODE_TYPE:\n\n      // eslint-disable-next-line no-fallthrough\n\n      default:\n        {\n          if (typeof type === 'object' && type !== null) {\n            switch (type.$$typeof) {\n              case REACT_PROVIDER_TYPE:\n                fiberTag = ContextProvider;\n                break getTag;\n\n              case REACT_CONTEXT_TYPE:\n                // This is a consumer\n                fiberTag = ContextConsumer;\n                break getTag;\n\n              case REACT_FORWARD_REF_TYPE:\n                fiberTag = ForwardRef;\n\n                {\n                  resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                }\n\n                break getTag;\n\n              case REACT_MEMO_TYPE:\n                fiberTag = MemoComponent;\n                break getTag;\n\n              case REACT_LAZY_TYPE:\n                fiberTag = LazyComponent;\n                resolvedType = null;\n                break getTag;\n            }\n          }\n\n          var info = '';\n\n          {\n            if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n              info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and \" + 'named imports.';\n            }\n\n            var ownerName = owner ? getComponentNameFromFiber(owner) : null;\n\n            if (ownerName) {\n              info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n            }\n          }\n\n          throw new Error('Element type is invalid: expected a string (for built-in ' + 'components) or a class/function (for composite components) ' + (\"but got: \" + (type == null ? type : typeof type) + \".\" + info));\n        }\n    }\n  }\n\n  var fiber = createFiber(fiberTag, pendingProps, key, mode);\n  fiber.elementType = type;\n  fiber.type = resolvedType;\n  fiber.lanes = lanes;\n\n  {\n    fiber._debugOwner = owner;\n  }\n\n  return fiber;\n}\nfunction createFiberFromElement(element, mode, lanes) {\n  var owner = null;\n\n  {\n    owner = element._owner;\n  }\n\n  var type = element.type;\n  var key = element.key;\n  var pendingProps = element.props;\n  var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n\n  {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n\n  return fiber;\n}\nfunction createFiberFromFragment(elements, mode, lanes, key) {\n  var fiber = createFiber(Fragment, elements, key, mode);\n  fiber.lanes = lanes;\n  return fiber;\n}\n\nfunction createFiberFromProfiler(pendingProps, mode, lanes, key) {\n  {\n    if (typeof pendingProps.id !== 'string') {\n      error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);\n    }\n  }\n\n  var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n  fiber.elementType = REACT_PROFILER_TYPE;\n  fiber.lanes = lanes;\n\n  {\n    fiber.stateNode = {\n      effectDuration: 0,\n      passiveEffectDuration: 0\n    };\n  }\n\n  return fiber;\n}\n\nfunction createFiberFromSuspense(pendingProps, mode, lanes, key) {\n  var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\n  fiber.elementType = REACT_SUSPENSE_TYPE;\n  fiber.lanes = lanes;\n  return fiber;\n}\nfunction createFiberFromSuspenseList(pendingProps, mode, lanes, key) {\n  var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);\n  fiber.elementType = REACT_SUSPENSE_LIST_TYPE;\n  fiber.lanes = lanes;\n  return fiber;\n}\nfunction createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n  var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);\n  fiber.elementType = REACT_OFFSCREEN_TYPE;\n  fiber.lanes = lanes;\n  var primaryChildInstance = {};\n  fiber.stateNode = primaryChildInstance;\n  return fiber;\n}\nfunction createFiberFromText(content, mode, lanes) {\n  var fiber = createFiber(HostText, content, null, mode);\n  fiber.lanes = lanes;\n  return fiber;\n}\nfunction createFiberFromHostInstanceForDeletion() {\n  var fiber = createFiber(HostComponent, null, null, NoMode);\n  fiber.elementType = 'DELETED';\n  return fiber;\n}\nfunction createFiberFromDehydratedFragment(dehydratedNode) {\n  var fiber = createFiber(DehydratedFragment, null, null, NoMode);\n  fiber.stateNode = dehydratedNode;\n  return fiber;\n}\nfunction createFiberFromPortal(portal, mode, lanes) {\n  var pendingProps = portal.children !== null ? portal.children : [];\n  var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n  fiber.lanes = lanes;\n  fiber.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null,\n    // Used by persistent updates\n    implementation: portal.implementation\n  };\n  return fiber;\n} // Used for stashing WIP properties to replay failed work in DEV.\n\nfunction assignFiberPropertiesInDEV(target, source) {\n  if (target === null) {\n    // This Fiber's initial properties will always be overwritten.\n    // We only use a Fiber to ensure the same hidden class so DEV isn't slow.\n    target = createFiber(IndeterminateComponent, null, null, NoMode);\n  } // This is intentionally written as a list of all properties.\n  // We tried to use Object.assign() instead but this is called in\n  // the hottest path, and Object.assign() was too slow:\n  // https://github.com/facebook/react/issues/12502\n  // This code is DEV-only so size is not a concern.\n\n\n  target.tag = source.tag;\n  target.key = source.key;\n  target.elementType = source.elementType;\n  target.type = source.type;\n  target.stateNode = source.stateNode;\n  target.return = source.return;\n  target.child = source.child;\n  target.sibling = source.sibling;\n  target.index = source.index;\n  target.ref = source.ref;\n  target.pendingProps = source.pendingProps;\n  target.memoizedProps = source.memoizedProps;\n  target.updateQueue = source.updateQueue;\n  target.memoizedState = source.memoizedState;\n  target.dependencies = source.dependencies;\n  target.mode = source.mode;\n  target.flags = source.flags;\n  target.subtreeFlags = source.subtreeFlags;\n  target.deletions = source.deletions;\n  target.lanes = source.lanes;\n  target.childLanes = source.childLanes;\n  target.alternate = source.alternate;\n\n  {\n    target.actualDuration = source.actualDuration;\n    target.actualStartTime = source.actualStartTime;\n    target.selfBaseDuration = source.selfBaseDuration;\n    target.treeBaseDuration = source.treeBaseDuration;\n  }\n\n  target._debugSource = source._debugSource;\n  target._debugOwner = source._debugOwner;\n  target._debugNeedsRemount = source._debugNeedsRemount;\n  target._debugHookTypes = source._debugHookTypes;\n  return target;\n}\n\nfunction FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError) {\n  this.tag = tag;\n  this.containerInfo = containerInfo;\n  this.pendingChildren = null;\n  this.current = null;\n  this.pingCache = null;\n  this.finishedWork = null;\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.callbackNode = null;\n  this.callbackPriority = NoLane;\n  this.eventTimes = createLaneMap(NoLanes);\n  this.expirationTimes = createLaneMap(NoTimestamp);\n  this.pendingLanes = NoLanes;\n  this.suspendedLanes = NoLanes;\n  this.pingedLanes = NoLanes;\n  this.expiredLanes = NoLanes;\n  this.mutableReadLanes = NoLanes;\n  this.finishedLanes = NoLanes;\n  this.entangledLanes = NoLanes;\n  this.entanglements = createLaneMap(NoLanes);\n  this.identifierPrefix = identifierPrefix;\n  this.onRecoverableError = onRecoverableError;\n\n  if (supportsHydration) {\n    this.mutableSourceEagerHydrationData = null;\n  }\n\n  {\n    this.effectDuration = 0;\n    this.passiveEffectDuration = 0;\n  }\n\n  {\n    this.memoizedUpdaters = new Set();\n    var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n\n    for (var _i = 0; _i < TotalLanes; _i++) {\n      pendingUpdatersLaneMap.push(new Set());\n    }\n  }\n\n  {\n    switch (tag) {\n      case ConcurrentRoot:\n        this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';\n        break;\n\n      case LegacyRoot:\n        this._debugRootType = hydrate ? 'hydrate()' : 'render()';\n        break;\n    }\n  }\n}\n\nfunction createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, // TODO: We have several of these arguments that are conceptually part of the\n// host config, but because they are passed in at runtime, we have to thread\n// them through the root constructor. Perhaps we should put them all into a\n// single type, like a DynamicHostConfig that is defined by the renderer.\nidentifierPrefix, onRecoverableError, transitionCallbacks) {\n  var root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onRecoverableError);\n  // stateNode is any.\n\n\n  var uninitializedFiber = createHostRootFiber(tag, isStrictMode);\n  root.current = uninitializedFiber;\n  uninitializedFiber.stateNode = root;\n\n  {\n    var _initialState = {\n      element: initialChildren,\n      isDehydrated: hydrate,\n      cache: null,\n      // not enabled yet\n      transitions: null\n    };\n    uninitializedFiber.memoizedState = _initialState;\n  }\n\n  initializeUpdateQueue(uninitializedFiber);\n  return root;\n}\n\nvar ReactVersion = '18.0.0-fc46dba67-20220329';\n\nfunction createPortal(children, containerInfo, // TODO: figure out the API for cross-renderer implementation.\nimplementation) {\n  var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  {\n    checkKeyStringCoercion(key);\n  }\n\n  return {\n    // This tag allow us to uniquely identify this as a React Portal\n    $$typeof: REACT_PORTAL_TYPE,\n    key: key == null ? null : '' + key,\n    children: children,\n    containerInfo: containerInfo,\n    implementation: implementation\n  };\n}\n\nvar didWarnAboutNestedUpdates;\nvar didWarnAboutFindNodeInStrictMode;\n\n{\n  didWarnAboutNestedUpdates = false;\n  didWarnAboutFindNodeInStrictMode = {};\n}\n\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) {\n    return emptyContextObject;\n  }\n\n  var fiber = get(parentComponent);\n  var parentContext = findCurrentUnmaskedContext(fiber);\n\n  if (fiber.tag === ClassComponent) {\n    var Component = fiber.type;\n\n    if (isContextProvider(Component)) {\n      return processChildContext(fiber, Component, parentContext);\n    }\n  }\n\n  return parentContext;\n}\n\nfunction findHostInstance(component) {\n  var fiber = get(component);\n\n  if (fiber === undefined) {\n    if (typeof component.render === 'function') {\n      throw new Error('Unable to find node on an unmounted component.');\n    } else {\n      var keys = Object.keys(component).join(',');\n      throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n    }\n  }\n\n  var hostFiber = findCurrentHostFiber(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nfunction findHostInstanceWithWarning(component, methodName) {\n  {\n    var fiber = get(component);\n\n    if (fiber === undefined) {\n      if (typeof component.render === 'function') {\n        throw new Error('Unable to find node on an unmounted component.');\n      } else {\n        var keys = Object.keys(component).join(',');\n        throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n      }\n    }\n\n    var hostFiber = findCurrentHostFiber(fiber);\n\n    if (hostFiber === null) {\n      return null;\n    }\n\n    if (hostFiber.mode & StrictLegacyMode) {\n      var componentName = getComponentNameFromFiber(fiber) || 'Component';\n\n      if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n        didWarnAboutFindNodeInStrictMode[componentName] = true;\n        var previousFiber = current;\n\n        try {\n          setCurrentFiber(hostFiber);\n\n          if (fiber.mode & StrictLegacyMode) {\n            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\n          } else {\n            error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-find-node', methodName, methodName, componentName);\n          }\n        } finally {\n          // Ideally this should reset to previous but this shouldn't be called in\n          // render and there's another warning for that anyway.\n          if (previousFiber) {\n            setCurrentFiber(previousFiber);\n          } else {\n            resetCurrentFiber();\n          }\n        }\n      }\n    }\n\n    return hostFiber.stateNode;\n  }\n}\n\nfunction createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n  var hydrate = false;\n  var initialChildren = null;\n  return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);\n}\nfunction createHydrationContainer(initialChildren, // TODO: Remove `callback` when we delete legacy mode.\ncallback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {\n  var hydrate = true;\n  var root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError); // TODO: Move this to FiberRoot constructor\n\n  root.context = getContextForSubtree(null); // Schedule the initial render. In a hydration root, this is different from\n  // a regular update because the initial render must match was was rendered\n  // on the server.\n  // NOTE: This update intentionally doesn't have a payload. We're only using\n  // the update to schedule work on the root fiber (and, for legacy roots, to\n  // enqueue the callback if one is provided).\n\n  var current = root.current;\n  var eventTime = requestEventTime();\n  var lane = requestUpdateLane(current);\n  var update = createUpdate(eventTime, lane);\n  update.callback = callback !== undefined && callback !== null ? callback : null;\n  enqueueUpdate(current, update);\n  scheduleInitialHydrationOnRoot(root, lane, eventTime);\n  return root;\n}\nfunction updateContainer(element, container, parentComponent, callback) {\n  {\n    onScheduleRoot(container, element);\n  }\n\n  var current$1 = container.current;\n  var eventTime = requestEventTime();\n  var lane = requestUpdateLane(current$1);\n\n  {\n    markRenderScheduled(lane);\n  }\n\n  var context = getContextForSubtree(parentComponent);\n\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  {\n    if (isRendering && current !== null && !didWarnAboutNestedUpdates) {\n      didWarnAboutNestedUpdates = true;\n\n      error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentNameFromFiber(current) || 'Unknown');\n    }\n  }\n\n  var update = createUpdate(eventTime, lane); // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n\n  update.payload = {\n    element: element\n  };\n  callback = callback === undefined ? null : callback;\n\n  if (callback !== null) {\n    {\n      if (typeof callback !== 'function') {\n        error('render(...): Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n      }\n    }\n\n    update.callback = callback;\n  }\n\n  enqueueUpdate(current$1, update);\n  var root = scheduleUpdateOnFiber(current$1, lane, eventTime);\n\n  if (root !== null) {\n    entangleTransitions(root, current$1, lane);\n  }\n\n  return lane;\n}\nfunction getPublicRootInstance(container) {\n  var containerFiber = container.current;\n\n  if (!containerFiber.child) {\n    return null;\n  }\n\n  switch (containerFiber.child.tag) {\n    case HostComponent:\n      return getPublicInstance(containerFiber.child.stateNode);\n\n    default:\n      return containerFiber.child.stateNode;\n  }\n}\nfunction attemptSynchronousHydration(fiber) {\n  switch (fiber.tag) {\n    case HostRoot:\n      var root = fiber.stateNode;\n\n      if (isRootDehydrated(root)) {\n        // Flush the first scheduled \"update\".\n        var lanes = getHighestPriorityPendingLanes(root);\n        flushRoot(root, lanes);\n      }\n\n      break;\n\n    case SuspenseComponent:\n      var eventTime = requestEventTime();\n      flushSync(function () {\n        return scheduleUpdateOnFiber(fiber, SyncLane, eventTime);\n      }); // If we're still blocked after this, we need to increase\n      // the priority of any promises resolving within this\n      // boundary so that they next attempt also has higher pri.\n\n      var retryLane = SyncLane;\n      markRetryLaneIfNotHydrated(fiber, retryLane);\n      break;\n  }\n}\n\nfunction markRetryLaneImpl(fiber, retryLane) {\n  var suspenseState = fiber.memoizedState;\n\n  if (suspenseState !== null && suspenseState.dehydrated !== null) {\n    suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n  }\n} // Increases the priority of thenables when they resolve within this boundary.\n\n\nfunction markRetryLaneIfNotHydrated(fiber, retryLane) {\n  markRetryLaneImpl(fiber, retryLane);\n  var alternate = fiber.alternate;\n\n  if (alternate) {\n    markRetryLaneImpl(alternate, retryLane);\n  }\n}\n\nfunction attemptContinuousHydration(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority and they should not suspend on I/O,\n    // since you have to wrap anything that might suspend in\n    // Suspense.\n    return;\n  }\n\n  var eventTime = requestEventTime();\n  var lane = SelectiveHydrationLane;\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nfunction attemptHydrationAtCurrentPriority(fiber) {\n  if (fiber.tag !== SuspenseComponent) {\n    // We ignore HostRoots here because we can't increase\n    // their priority other than synchronously flush it.\n    return;\n  }\n\n  var eventTime = requestEventTime();\n  var lane = requestUpdateLane(fiber);\n  scheduleUpdateOnFiber(fiber, lane, eventTime);\n  markRetryLaneIfNotHydrated(fiber, lane);\n}\nfunction findHostInstanceWithNoPortals(fiber) {\n  var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nvar shouldErrorImpl = function (fiber) {\n  return null;\n};\n\nfunction shouldError(fiber) {\n  return shouldErrorImpl(fiber);\n}\n\nvar shouldSuspendImpl = function (fiber) {\n  return false;\n};\n\nfunction shouldSuspend(fiber) {\n  return shouldSuspendImpl(fiber);\n}\nvar overrideHookState = null;\nvar overrideHookStateDeletePath = null;\nvar overrideHookStateRenamePath = null;\nvar overrideProps = null;\nvar overridePropsDeletePath = null;\nvar overridePropsRenamePath = null;\nvar scheduleUpdate = null;\nvar setErrorHandler = null;\nvar setSuspenseHandler = null;\n\n{\n  var copyWithDeleteImpl = function (obj, path, index) {\n    var key = path[index];\n    var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n\n    if (index + 1 === path.length) {\n      if (isArray(updated)) {\n        updated.splice(key, 1);\n      } else {\n        delete updated[key];\n      }\n\n      return updated;\n    } // $FlowFixMe number or string is fine here\n\n\n    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n    return updated;\n  };\n\n  var copyWithDelete = function (obj, path) {\n    return copyWithDeleteImpl(obj, path, 0);\n  };\n\n  var copyWithRenameImpl = function (obj, oldPath, newPath, index) {\n    var oldKey = oldPath[index];\n    var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n\n    if (index + 1 === oldPath.length) {\n      var newKey = newPath[index]; // $FlowFixMe number or string is fine here\n\n      updated[newKey] = updated[oldKey];\n\n      if (isArray(updated)) {\n        updated.splice(oldKey, 1);\n      } else {\n        delete updated[oldKey];\n      }\n    } else {\n      // $FlowFixMe number or string is fine here\n      updated[oldKey] = copyWithRenameImpl( // $FlowFixMe number or string is fine here\n      obj[oldKey], oldPath, newPath, index + 1);\n    }\n\n    return updated;\n  };\n\n  var copyWithRename = function (obj, oldPath, newPath) {\n    if (oldPath.length !== newPath.length) {\n      warn('copyWithRename() expects paths of the same length');\n\n      return;\n    } else {\n      for (var i = 0; i < newPath.length - 1; i++) {\n        if (oldPath[i] !== newPath[i]) {\n          warn('copyWithRename() expects paths to be the same except for the deepest key');\n\n          return;\n        }\n      }\n    }\n\n    return copyWithRenameImpl(obj, oldPath, newPath, 0);\n  };\n\n  var copyWithSetImpl = function (obj, path, index, value) {\n    if (index >= path.length) {\n      return value;\n    }\n\n    var key = path[index];\n    var updated = isArray(obj) ? obj.slice() : assign({}, obj); // $FlowFixMe number or string is fine here\n\n    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n    return updated;\n  };\n\n  var copyWithSet = function (obj, path, value) {\n    return copyWithSetImpl(obj, path, 0, value);\n  };\n\n  var findHook = function (fiber, id) {\n    // For now, the \"id\" of stateful hooks is just the stateful hook index.\n    // This may change in the future with e.g. nested hooks.\n    var currentHook = fiber.memoizedState;\n\n    while (currentHook !== null && id > 0) {\n      currentHook = currentHook.next;\n      id--;\n    }\n\n    return currentHook;\n  }; // Support DevTools editable values for useState and useReducer.\n\n\n  overrideHookState = function (fiber, id, path, value) {\n    var hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      var newState = copyWithSet(hook.memoizedState, path, value);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = assign({}, fiber.memoizedProps);\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  overrideHookStateDeletePath = function (fiber, id, path) {\n    var hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      var newState = copyWithDelete(hook.memoizedState, path);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = assign({}, fiber.memoizedProps);\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n    }\n  };\n\n  overrideHookStateRenamePath = function (fiber, id, oldPath, newPath) {\n    var hook = findHook(fiber, id);\n\n    if (hook !== null) {\n      var newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n      hook.memoizedState = newState;\n      hook.baseState = newState; // We aren't actually adding an update to the queue,\n      // because there is no update we can add for useReducer hooks that won't trigger an error.\n      // (There's no appropriate action type for DevTools overrides.)\n      // As a result though, React will see the scheduled update as a noop and bailout.\n      // Shallow cloning props works as a workaround for now to bypass the bailout check.\n\n      fiber.memoizedProps = assign({}, fiber.memoizedProps);\n      scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n    }\n  }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n\n\n  overrideProps = function (fiber, path, value) {\n    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n\n  overridePropsDeletePath = function (fiber, path) {\n    fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n\n  overridePropsRenamePath = function (fiber, oldPath, newPath) {\n    fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n\n    if (fiber.alternate) {\n      fiber.alternate.pendingProps = fiber.pendingProps;\n    }\n\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n\n  scheduleUpdate = function (fiber) {\n    scheduleUpdateOnFiber(fiber, SyncLane, NoTimestamp);\n  };\n\n  setErrorHandler = function (newShouldErrorImpl) {\n    shouldErrorImpl = newShouldErrorImpl;\n  };\n\n  setSuspenseHandler = function (newShouldSuspendImpl) {\n    shouldSuspendImpl = newShouldSuspendImpl;\n  };\n}\n\nfunction findHostInstanceByFiber(fiber) {\n  var hostFiber = findCurrentHostFiber(fiber);\n\n  if (hostFiber === null) {\n    return null;\n  }\n\n  return hostFiber.stateNode;\n}\n\nfunction emptyFindFiberByHostInstance(instance) {\n  return null;\n}\n\nfunction getCurrentFiberForDevTools() {\n  return current;\n}\n\nfunction injectIntoDevTools(devToolsConfig) {\n  var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n  var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n  return injectInternals({\n    bundleType: devToolsConfig.bundleType,\n    version: devToolsConfig.version,\n    rendererPackageName: devToolsConfig.rendererPackageName,\n    rendererConfig: devToolsConfig.rendererConfig,\n    overrideHookState: overrideHookState,\n    overrideHookStateDeletePath: overrideHookStateDeletePath,\n    overrideHookStateRenamePath: overrideHookStateRenamePath,\n    overrideProps: overrideProps,\n    overridePropsDeletePath: overridePropsDeletePath,\n    overridePropsRenamePath: overridePropsRenamePath,\n    setErrorHandler: setErrorHandler,\n    setSuspenseHandler: setSuspenseHandler,\n    scheduleUpdate: scheduleUpdate,\n    currentDispatcherRef: ReactCurrentDispatcher,\n    findHostInstanceByFiber: findHostInstanceByFiber,\n    findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n    // React Refresh\n    findHostInstancesForRefresh:  findHostInstancesForRefresh ,\n    scheduleRefresh:  scheduleRefresh ,\n    scheduleRoot:  scheduleRoot ,\n    setRefreshHandler:  setRefreshHandler ,\n    // Enables DevTools to append owner stacks to error messages in DEV mode.\n    getCurrentFiber:  getCurrentFiberForDevTools ,\n    // Enables DevTools to detect reconciler version rather than renderer version\n    // which may not match for third party renderers.\n    reconcilerVersion: ReactVersion\n  });\n}\n\nexports.attemptContinuousHydration = attemptContinuousHydration;\nexports.attemptHydrationAtCurrentPriority = attemptHydrationAtCurrentPriority;\nexports.attemptSynchronousHydration = attemptSynchronousHydration;\nexports.batchedUpdates = batchedUpdates;\nexports.createComponentSelector = createComponentSelector;\nexports.createContainer = createContainer;\nexports.createHasPseudoClassSelector = createHasPseudoClassSelector;\nexports.createHydrationContainer = createHydrationContainer;\nexports.createPortal = createPortal;\nexports.createRoleSelector = createRoleSelector;\nexports.createTestNameSelector = createTestNameSelector;\nexports.createTextSelector = createTextSelector;\nexports.deferredUpdates = deferredUpdates;\nexports.discreteUpdates = discreteUpdates;\nexports.findAllNodes = findAllNodes;\nexports.findBoundingRects = findBoundingRects;\nexports.findHostInstance = findHostInstance;\nexports.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals;\nexports.findHostInstanceWithWarning = findHostInstanceWithWarning;\nexports.flushControlled = flushControlled;\nexports.flushPassiveEffects = flushPassiveEffects;\nexports.flushSync = flushSync;\nexports.focusWithin = focusWithin;\nexports.getCurrentUpdatePriority = getCurrentUpdatePriority;\nexports.getFindAllNodesFailureDescription = getFindAllNodesFailureDescription;\nexports.getPublicRootInstance = getPublicRootInstance;\nexports.injectIntoDevTools = injectIntoDevTools;\nexports.isAlreadyRendering = isAlreadyRendering;\nexports.observeVisibleRects = observeVisibleRects;\nexports.registerMutableSourceForHydration = registerMutableSourceForHydration;\nexports.runWithPriority = runWithPriority;\nexports.shouldError = shouldError;\nexports.shouldSuspend = shouldSuspend;\nexports.updateContainer = updateContainer;\n    return exports;\n  };\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-reconciler.production.min.js');\n} else {\n  module.exports = require('./cjs/react-reconciler.development.js');\n}\n"],"names":["SyncLane","InputContinuousLane","DefaultLane","IdleLane","DiscreteEventPriority","ContinuousEventPriority","DefaultEventPriority","IdleEventPriority","LegacyRoot","ConcurrentRoot","reactReconcilerConstants_development","constantsModule","require$$0","reactReconciler_developmentModule","$$$hostConfig","exports","React","Scheduler","require$$1","ReactSharedInternals","suppressWarning","setSuppressWarning","newSuppressWarning","warn","format","_len","args","_key","printWarning","error","_len2","_key2","level","ReactDebugCurrentFrame","stack","argsWithFormat","item","assign","get","key","set","value","enablePersistentOffscreenHostContainer","enableNewReconciler","enableLazyContextPropagation","enableLegacyHidden","enableSuspenseAvoidThisFallback","warnAboutStringRefs","enableSchedulingProfiler","enableProfilerTimer","enableProfilerCommitHooks","FunctionComponent","ClassComponent","IndeterminateComponent","HostRoot","HostPortal","HostComponent","HostText","Fragment","Mode","ContextConsumer","ContextProvider","ForwardRef","Profiler","SuspenseComponent","MemoComponent","SimpleMemoComponent","LazyComponent","IncompleteClassComponent","DehydratedFragment","SuspenseListComponent","ScopeComponent","OffscreenComponent","LegacyHiddenComponent","CacheComponent","TracingMarkerComponent","REACT_ELEMENT_TYPE","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_PROVIDER_TYPE","REACT_CONTEXT_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","REACT_SCOPE_TYPE","REACT_DEBUG_TRACING_MODE_TYPE","REACT_OFFSCREEN_TYPE","REACT_LEGACY_HIDDEN_TYPE","REACT_CACHE_TYPE","REACT_TRACING_MARKER_TYPE","MAYBE_ITERATOR_SYMBOL","FAUX_ITERATOR_SYMBOL","getIteratorFn","maybeIterable","maybeIterator","getWrappedName","outerType","innerType","wrapperName","displayName","functionName","getContextName","type","getComponentNameFromType","context","provider","outerName","lazyComponent","payload","init","getWrappedName$1","getContextName$1","getComponentNameFromFiber","fiber","tag","NoFlags","PerformedWork","Placement","Update","PlacementAndUpdate","ChildDeletion","ContentReset","Callback","DidCapture","ForceClientRender","Ref","Snapshot","Passive","Hydrating","HydratingAndUpdate","Visibility","StoreConsistency","LifecycleEffectMask","HostEffectMask","Incomplete","ShouldCapture","ForceUpdateForLegacySuspense","Forked","RefStatic","LayoutStatic","PassiveStatic","MountLayoutDev","MountPassiveDev","BeforeMutationMask","MutationMask","LayoutMask","PassiveMask","StaticMask","ReactCurrentOwner","getNearestMountedFiber","node","nearestMounted","nextNode","isFiberMounted","isMounted","component","owner","ownerFiber","instance","assertIsMounted","findCurrentFiberUsingSlowPath","alternate","b","parentA","parentB","nextParent","child","didFindChild","_child","findCurrentHostFiber","parent","currentParent","findCurrentHostFiberImpl","match","findCurrentHostFiberWithNoPortals","findCurrentHostFiberWithNoPortalsImpl","isArrayImpl","isArray","a","getPublicInstance","getRootHostContext","getChildHostContext","prepareForCommit","resetAfterCommit","createInstance","appendInitialChild","finalizeInitialChildren","prepareUpdate","shouldSetTextContent","createTextInstance","scheduleTimeout","cancelTimeout","noTimeout","isPrimaryRenderer","warnsIfNotActing","supportsMutation","supportsPersistence","supportsHydration","getInstanceFromNode","preparePortalMount","getCurrentEventPriority","detachDeletedInstance","supportsMicrotasks","scheduleMicrotask","supportsTestSelectors","findFiberRoot","getBoundingRect","getTextContent","isHiddenSubtree","matchAccessibilityRole","setFocusIfFocusable","setupIntersectionObserver","appendChild","appendChildToContainer","commitTextUpdate","commitMount","commitUpdate","insertBefore","insertInContainerBefore","removeChild","removeChildFromContainer","resetTextContent","hideInstance","hideTextInstance","unhideInstance","unhideTextInstance","clearContainer","cloneInstance","createContainerChildSet","appendChildToContainerChildSet","finalizeContainerChildren","replaceContainerChildren","getOffscreenContainerProps","cloneHiddenInstance","cloneHiddenTextInstance","canHydrateInstance","canHydrateTextInstance","canHydrateSuspenseInstance","isSuspenseInstancePending","isSuspenseInstanceFallback","registerSuspenseInstanceRetry","getNextHydratableSibling","getFirstHydratableChild","getFirstHydratableChildWithinContainer","getFirstHydratableChildWithinSuspenseInstance","hydrateInstance","hydrateTextInstance","hydrateSuspenseInstance","getNextHydratableInstanceAfterSuspenseInstance","commitHydratedContainer","commitHydratedSuspenseInstance","clearSuspenseBoundary","clearSuspenseBoundaryFromContainer","shouldDeleteUnhydratedTailInstances","didNotMatchHydratedContainerTextInstance","didNotMatchHydratedTextInstance","didNotHydrateInstanceWithinContainer","didNotHydrateInstanceWithinSuspenseInstance","didNotHydrateInstance","didNotFindHydratableInstanceWithinContainer","didNotFindHydratableTextInstanceWithinContainer","didNotFindHydratableSuspenseInstanceWithinContainer","didNotFindHydratableInstanceWithinSuspenseInstance","didNotFindHydratableTextInstanceWithinSuspenseInstance","didNotFindHydratableSuspenseInstanceWithinSuspenseInstance","didNotFindHydratableInstance","didNotFindHydratableTextInstance","didNotFindHydratableSuspenseInstance","errorHydratingContainer","disabledDepth","prevLog","prevInfo","prevWarn","prevError","prevGroup","prevGroupCollapsed","prevGroupEnd","disabledLog","disableLogs","props","reenableLogs","ReactCurrentDispatcher","prefix","describeBuiltInComponentFrame","name","source","ownerFn","x","reentry","componentFrameCache","PossiblyWeakMap","describeNativeComponentFrame","fn","construct","frame","control","previousPrepareStackTrace","previousDispatcher","Fake","sample","sampleLines","controlLines","s","c","_frame","syntheticFrame","describeClassComponentFrame","ctor","describeFunctionComponentFrame","shouldConstruct","Component","prototype","describeUnknownElementTypeFrameInDEV","hasOwnProperty","loggedTypeFailures","setCurrentlyValidatingElement","element","checkPropTypes","typeSpecs","values","location","componentName","has","typeSpecName","error$1","err","ex","valueStack","fiberStack","index","createCursor","defaultValue","pop","cursor","push","warnedAboutMissingGetChildContext","emptyContextObject","contextStackCursor","didPerformWorkStackCursor","previousContext","getUnmaskedContext","workInProgress","didPushOwnContextIfProvider","isContextProvider","cacheContext","unmaskedContext","maskedContext","getMaskedContext","contextTypes","hasContextChanged","childContextTypes","popContext","popTopLevelContextObject","pushTopLevelContextObject","didChange","processChildContext","parentContext","childContext","contextKey","pushContextProvider","memoizedMergedChildContext","invalidateContextProvider","mergedContext","findCurrentUnmaskedContext","NoMode","ConcurrentMode","ProfileMode","StrictLegacyMode","StrictEffectsMode","clz32","clz32Fallback","log","LN2","asUint","TotalLanes","NoLanes","NoLane","InputContinuousHydrationLane","DefaultHydrationLane","TransitionHydrationLane","TransitionLanes","TransitionLane1","TransitionLane2","TransitionLane3","TransitionLane4","TransitionLane5","TransitionLane6","TransitionLane7","TransitionLane8","TransitionLane9","TransitionLane10","TransitionLane11","TransitionLane12","TransitionLane13","TransitionLane14","TransitionLane15","TransitionLane16","RetryLanes","RetryLane1","RetryLane2","RetryLane3","RetryLane4","RetryLane5","SomeRetryLane","SelectiveHydrationLane","NonIdleLanes","IdleHydrationLane","OffscreenLane","getLabelForLane","lane","NoTimestamp","nextTransitionLane","nextRetryLane","getHighestPriorityLanes","lanes","getHighestPriorityLane","getNextLanes","root","wipLanes","pendingLanes","nextLanes","suspendedLanes","pingedLanes","nonIdlePendingLanes","nonIdleUnblockedLanes","nonIdlePingedLanes","unblockedLanes","nextLane","wipLane","entangledLanes","entanglements","pickArbitraryLaneIndex","getMostRecentEventTime","eventTimes","mostRecentEventTime","eventTime","computeExpirationTime","currentTime","markStarvedLanesAsExpired","expirationTimes","expirationTime","getHighestPriorityPendingLanes","getLanesToRetrySynchronouslyOnError","everythingButOffscreen","includesSyncLane","includesNonIdleWork","includesOnlyRetries","includesOnlyTransitions","includesBlockingLane","SyncDefaultLanes","includesExpiredLane","isTransitionLane","claimNextTransitionLane","claimNextRetryLane","pickArbitraryLane","laneToIndex","includesSomeLane","isSubsetOfLanes","subset","mergeLanes","removeLanes","intersectLanes","laneToLanes","higherPriorityLane","createLaneMap","initial","laneMap","i","markRootUpdated","updateLane","markRootSuspended","markRootPinged","markRootFinished","remainingLanes","noLongerPendingLanes","markRootEntangled","rootEntangledLanes","getBumpedLaneForHydration","renderLanes","renderLane","addFiberToLanesMap","isDevToolsPresent","pendingUpdatersLaneMap","updaters","movePendingFibersToMemoized","memoizedUpdaters","currentUpdatePriority","getCurrentUpdatePriority","setCurrentUpdatePriority","newPriority","runWithPriority","priority","previousPriority","higherEventPriority","lowerEventPriority","isHigherEventPriority","lanesToEventPriority","scheduleCallback","cancelCallback","shouldYield","requestPaint","now$1","ImmediatePriority","UserBlockingPriority","NormalPriority","IdlePriority","unstable_yieldValue","unstable_setDisableYieldValue","rendererID","injectedHook","injectedProfilingHooks","hasLoggedError","injectInternals","internals","hook","getLaneLabelMap","injectProfilingHooks","onScheduleRoot","children","onCommitRoot","eventPriority","didError","schedulerPriority","onPostCommitRoot","onCommitUnmount","setIsStrictModeForDevtools","newIsStrictMode","profilingHooks","map","label","markCommitStarted","markCommitStopped","markComponentRenderStarted","markComponentRenderStopped","markComponentPassiveEffectMountStarted","markComponentPassiveEffectMountStopped","markComponentPassiveEffectUnmountStarted","markComponentPassiveEffectUnmountStopped","markComponentLayoutEffectMountStarted","markComponentLayoutEffectMountStopped","markComponentLayoutEffectUnmountStarted","markComponentLayoutEffectUnmountStopped","markComponentErrored","thrownValue","markComponentSuspended","wakeable","markLayoutEffectsStarted","markLayoutEffectsStopped","markPassiveEffectsStarted","markPassiveEffectsStopped","markRenderStarted","markRenderYielded","markRenderStopped","markRenderScheduled","markForceUpdateScheduled","markStateUpdateScheduled","is","y","objectIs","syncQueue","includesLegacySyncCallbacks","isFlushingSyncQueue","scheduleSyncCallback","callback","scheduleLegacySyncCallback","flushSyncCallbacksOnlyInLegacyMode","flushSyncCallbacks","previousUpdatePriority","isSync","queue","isRootDehydrated","currentState","ReactCurrentBatchConfig","NoTransition","requestCurrentTransition","shallowEqual","objA","objB","keysA","keysB","currentKey","describeFiber","getStackByFiberInDevAndProd","info","ReactDebugCurrentFrame$1","current","isRendering","getCurrentFiberOwnerNameInDevOrNull","getCurrentFiberStackInDev","resetCurrentFiber","setCurrentFiber","setIsRendering","rendering","ReactStrictModeWarnings","findStrictRoot","maybeStrictRoot","setToSortedString","array","pendingComponentWillMountWarnings","pendingUNSAFE_ComponentWillMountWarnings","pendingComponentWillReceivePropsWarnings","pendingUNSAFE_ComponentWillReceivePropsWarnings","pendingComponentWillUpdateWarnings","pendingUNSAFE_ComponentWillUpdateWarnings","didWarnAboutUnsafeLifecycles","componentWillMountUniqueNames","UNSAFE_componentWillMountUniqueNames","componentWillReceivePropsUniqueNames","UNSAFE_componentWillReceivePropsUniqueNames","componentWillUpdateUniqueNames","UNSAFE_componentWillUpdateUniqueNames","sortedNames","_sortedNames","_sortedNames2","_sortedNames3","_sortedNames4","_sortedNames5","pendingLegacyContextWarning","didWarnAboutLegacyContext","strictRoot","warningsForRoot","fiberArray","firstFiber","uniqueNames","typeName","hasToStringTag","willCoercionThrow","testStringCoercion","checkKeyStringCoercion","checkPropStringCoercion","propName","resolveDefaultProps","baseProps","defaultProps","valueCursor","rendererSigil","currentlyRenderingFiber","lastContextDependency","lastFullyObservedContext","isDisallowedContextReadInDEV","resetContextDependencies","enterDisallowedContextReadInDEV","exitDisallowedContextReadInDEV","pushProvider","providerFiber","nextValue","popProvider","currentValue","scheduleContextWorkOnParentPath","propagationRoot","propagateContextChange","propagateContextChange_eager","nextFiber","list","dependency","update","createUpdate","ForceUpdate","updateQueue","sharedQueue","pending","parentSuspense","_alternate","sibling","prepareToReadContext","dependencies","firstContext","markWorkInProgressReceivedUpdate","readContext","contextItem","interleavedQueues","pushInterleavedQueue","enqueueInterleavedUpdates","lastInterleavedUpdate","firstInterleavedUpdate","lastPendingUpdate","firstPendingUpdate","UpdateState","ReplaceState","CaptureUpdate","hasForceUpdate","didWarnUpdateInsideUpdate","currentlyProcessingQueue","initializeUpdateQueue","cloneUpdateQueue","currentQueue","clone","enqueueUpdate","isInterleavedUpdate","interleaved","entangleTransitions","queueLanes","newQueueLanes","enqueueCapturedUpdate","capturedUpdate","newFirst","newLast","firstBaseUpdate","lastBaseUpdate","getStateFromUpdate","prevState","nextProps","nextState","_payload","partialState","processUpdateQueue","pendingQueue","currentLastBaseUpdate","newState","newLanes","newBaseState","newFirstBaseUpdate","newLastBaseUpdate","updateEventTime","_clone","effects","_lastPendingUpdate","_firstPendingUpdate","lastInterleaved","markSkippedUpdateLanes","callCallback","resetHasForceUpdateBeforeProcessing","checkHasForceUpdateAfterProcessing","commitUpdateQueue","finishedWork","finishedQueue","effect","fakeInternalInstance","emptyRefsObject","didWarnAboutStateAssignmentForComponent","didWarnAboutUninitializedState","didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate","didWarnAboutLegacyLifecyclesAndDerivedState","didWarnAboutUndefinedDerivedState","warnOnUndefinedDerivedState","warnOnInvalidCallback","didWarnAboutDirectlyAssigningPropsToState","didWarnAboutContextTypeAndContextTypes","didWarnAboutInvalidateContextType","didWarnOnInvalidCallback","callerName","applyDerivedStateFromProps","getDerivedStateFromProps","memoizedState","classComponentUpdater","inst","requestEventTime","requestUpdateLane","scheduleUpdateOnFiber","checkShouldComponentUpdate","oldProps","newProps","oldState","nextContext","shouldUpdate","checkClassInstance","renderPresent","hasMutatedProps","_state","adoptClassInstance","constructClassInstance","isLegacyContextConsumer","contextType","isValid","addendum","state","foundWillMountName","foundWillReceivePropsName","foundWillUpdateName","_componentName","newApiName","callComponentWillMount","callComponentWillReceiveProps","mountClassInstance","fiberFlags","resumeMountClassInstance","oldContext","nextLegacyUnmaskedContext","hasNewLifecycles","_fiberFlags","_fiberFlags2","updateClassInstance","unresolvedOldProps","unresolvedNewProps","nextUnmaskedContext","forkStack","forkStackIndex","treeForkProvider","treeForkCount","idStack","idStackIndex","treeContextProvider","treeContextId","treeContextOverflow","isForkedChild","warnIfNotHydrating","getForksAtLevel","getTreeId","overflow","idWithLeadingBit","id","getLeadingBit","pushTreeFork","totalChildren","pushTreeId","baseIdWithLeadingBit","baseOverflow","baseLength","getBitLength","baseId","slot","length","numberOfOverflowBits","newOverflowBits","newOverflow","restOfBaseId","restOfBaseLength","restOfLength","restOfNewBits","newBits","_id","_overflow","pushMaterializedTreeId","returnFiber","numberOfForks","slotIndex","number","popTreeContext","getSuspendedTreeContext","restoreSuspendedTreeContext","suspendedContext","getIsHydrating","hydrationParentFiber","nextHydratableInstance","isHydrating","didSuspend","hydrationErrors","warnIfHydrating","markDidSuspendWhileHydratingDEV","enterHydrationState","parentInstance","reenterHydrationStateFromDehydratedSuspenseInstance","suspenseInstance","treeContext","warnUnhydratedInstance","suspenseState","deleteHydratableInstance","childToDelete","createFiberFromHostInstanceForDeletion","deletions","warnNonhydratedInstance","parentContainer","text","parentType","parentProps","_type","_props","_text","_parentInstance","_type2","_props2","_text2","insertNonHydratedInstance","tryHydrate","nextInstance","textInstance","dehydratedFragment","createFiberFromDehydratedFragment","shouldClientRenderOnMismatch","throwOnHydrationMismatch","tryToClaimNextHydratableInstance","firstAttemptedInstance","prevHydrationParentFiber","prepareToHydrateHostInstance","rootContainerInstance","hostContext","shouldWarnIfMismatchDev","updatePayload","prepareToHydrateHostTextInstance","textContent","isConcurrentMode","prepareToHydrateHostSuspenseInstance","skipPastDehydratedSuspenseInstance","popToNextHostParent","popHydrationState","warnIfUnhydratedTailNodes","hasUnhydratedTailNodes","resetHydrationState","upgradeHydrationErrorsToRecoverable","queueRecoverableErrors","queueHydrationError","didWarnAboutMaps","didWarnAboutGenerators","didWarnAboutStringRefs","ownerHasKeyUseWarning","ownerHasFunctionTypeWarning","warnForMissingKey","coerceRef","mixedRef","resolvedInst","stringRef","ref","refs","throwOnInvalidObjectType","newChild","childString","warnOnFunctionType","resolveLazy","lazyType","ChildReconciler","shouldTrackSideEffects","deleteChild","deleteRemainingChildren","currentFirstChild","mapRemainingChildren","existingChildren","existingChild","useFiber","pendingProps","createWorkInProgress","placeChild","newFiber","lastPlacedIndex","newIndex","oldIndex","placeSingleChild","updateTextNode","created","createFiberFromText","existing","updateElement","elementType","updateFragment","isCompatibleFamilyForHotReloading","createFiberFromElement","updatePortal","portal","createFiberFromPortal","fragment","createFiberFromFragment","createChild","_created","_created2","_created3","updateSlot","oldFiber","updateFromMap","newIdx","matchedFiber","_matchedFiber","_matchedFiber2","_matchedFiber3","warnOnInvalidKey","knownKeys","reconcileChildrenArray","newChildren","resultingFirstChild","previousNewFiber","nextOldFiber","_newFiber","_numberOfForks","_newFiber2","_numberOfForks2","reconcileChildrenIterator","newChildrenIterable","iteratorFn","_newChildren","_step","step","_newFiber3","_numberOfForks3","_newFiber4","_numberOfForks4","reconcileSingleTextNode","reconcileSingleElement","_existing","_created4","reconcileSinglePortal","reconcileChildFibers","isUnkeyedTopLevelFragment","mountChildFibers","cloneChildFibers","currentChild","resetChildFibers","resetWorkInProgress","NO_CONTEXT","contextStackCursor$1","contextFiberStackCursor","rootInstanceStackCursor","requiredContext","getRootHostContainer","rootInstance","pushHostContainer","nextRootInstance","nextRootContext","popHostContainer","getHostContext","pushHostContext","popHostContext","DefaultSuspenseContext","SubtreeSuspenseContextMask","InvisibleParentSuspenseContext","ForceSuspenseFallback","suspenseStackCursor","hasSuspenseContext","flag","setDefaultShallowSuspenseContext","setShallowSuspenseContext","shallowContext","addSubtreeSuspenseContext","subtreeContext","pushSuspenseContext","newContext","popSuspenseContext","shouldCaptureSuspense","hasInvisibleParent","findFirstSuspended","row","dehydrated","NoFlags$1","HasEffect","Insertion","Layout","Passive$1","workInProgressSources","resetWorkInProgressVersions","mutableSource","registerMutableSourceForHydration","getVersion","version","ReactCurrentDispatcher$1","ReactCurrentBatchConfig$1","didWarnAboutMismatchedHooksForComponent","didWarnUncachedGetSnapshot","currentlyRenderingFiber$1","currentHook","workInProgressHook","didScheduleRenderPhaseUpdate","didScheduleRenderPhaseUpdateDuringThisPass","localIdCounter","globalClientIdCounter","RE_RENDER_LIMIT","currentHookNameInDev","hookTypesDev","hookTypesUpdateIndexDev","ignorePreviousDependencies","mountHookTypesDev","hookName","updateHookTypesDev","warnOnHookMismatchInDev","checkDepsAreArrayDev","deps","currentHookName","table","secondColumnStart","oldHookName","newHookName","throwInvalidHookError","areHookInputsEqual","nextDeps","prevDeps","renderWithHooks","secondArg","nextRenderLanes","HooksDispatcherOnUpdateInDEV","HooksDispatcherOnMountWithHookTypesInDEV","HooksDispatcherOnMountInDEV","numberOfReRenders","HooksDispatcherOnRerenderInDEV","ContextOnlyDispatcher","didRenderTooFewHooks","checkDidRenderIdHook","didRenderIdHook","bailoutHooks","resetHooksAfterThrow","isUpdatingOpaqueValueInRenderPhase","mountWorkInProgressHook","updateWorkInProgressHook","nextCurrentHook","nextWorkInProgressHook","newHook","createFunctionComponentUpdateQueue","basicStateReducer","action","mountReducer","reducer","initialArg","initialState","dispatch","dispatchReducerAction","updateReducer","baseQueue","baseFirst","pendingFirst","first","newBaseQueueFirst","newBaseQueueLast","interleavedLane","rerenderReducer","lastRenderPhaseUpdate","firstRenderPhaseUpdate","mountMutableSource","getSnapshot","subscribe","updateMutableSource","mountSyncExternalStore","getServerSnapshot","nextSnapshot","cachedSnapshot","getWorkInProgressRoot","pushStoreConsistencyCheck","mountEffect","subscribeToStore","pushEffect","updateStoreInstance","updateSyncExternalStore","prevSnapshot","snapshotChanged","updateEffect","renderedSnapshot","check","componentUpdateQueue","stores","checkIfSnapshotChanged","forceStoreRerender","handleStoreChange","latestGetSnapshot","prevValue","mountState","dispatchSetState","updateState","rerenderState","create","destroy","lastEffect","firstEffect","mountRef","initialValue","_ref2","updateRef","mountEffectImpl","hookFlags","updateEffectImpl","prevEffect","mountInsertionEffect","updateInsertionEffect","mountLayoutEffect","updateLayoutEffect","imperativeHandleEffect","refCallback","_inst","refObject","_inst2","mountImperativeHandle","effectDeps","updateImperativeHandle","mountDebugValue","formatterFn","updateDebugValue","mountCallback","updateCallback","mountMemo","nextCreate","updateMemo","mountDeferredValue","_mountState","setValue","prevTransition","updateDeferredValue","_updateState","rerenderDeferredValue","_rerenderState","startTransition","setPending","options","currentTransition","updatedFibersCount","mountTransition","_mountState2","isPending","start","updateTransition","_updateState2","rerenderTransition","_rerenderState2","getIsUpdatingOpaqueValueInRenderPhaseInDEV","mountId","identifierPrefix","treeId","localId","globalClientId","updateId","isRenderPhaseUpdate","enqueueRenderPhaseUpdate","enqueueUpdate$1","entangleTransitionUpdate","markUpdateInDevTools","lastRenderedReducer","prevDispatcher","InvalidNestedHooksDispatcherOnUpdateInDEV","eagerState","InvalidNestedHooksDispatcherOnMountInDEV","InvalidNestedHooksDispatcherOnRerenderInDEV","warnInvalidContextAccess","warnInvalidHookAccess","now$2","commitTime","layoutEffectStartTime","profilerStartTime","passiveEffectStartTime","currentUpdateIsNested","nestedUpdateScheduled","isCurrentUpdateNested","markNestedUpdateScheduled","resetNestedUpdateFlag","syncNestedUpdateFlag","getCommitTime","recordCommitTime","startProfilerTimer","stopProfilerTimerIfRunning","stopProfilerTimerIfRunningAndRecordDelta","overrideBaseTime","elapsedTime","recordLayoutEffectDuration","parentFiber","parentStateNode","recordPassiveEffectDuration","startLayoutEffectTimer","startPassiveEffectTimer","transferActualDuration","createCapturedValue","showErrorDialog","boundary","errorInfo","logCapturedError","logError","componentStack","componentNameMessage","errorBoundaryMessage","errorBoundaryName","combinedMessage","e","PossiblyWeakMap$1","createRootErrorUpdate","onUncaughtError","createClassErrorUpdate","getDerivedStateFromError","markFailedErrorBoundaryForHotReloading","markLegacyErrorBoundaryAsFailed","attachPingListener","pingCache","threadIDs","ping","pingSuspendedRoot","restorePendingUpdaters","attachRetryListener","suspenseBoundary","wakeables","resetSuspendedComponent","sourceFiber","rootRenderLanes","currentSource","getNearestSuspenseBoundaryToCapture","markSuspenseBoundaryShouldCapture","currentSuspenseBoundary","offscreenFiber","offscreenContainer","containerProps","currentSourceFiber","throwException","renderDidSuspendDelayIfPossible","uncaughtSuspenseError","_suspenseBoundary","renderDidError","_errorInfo","isAlreadyFailedLegacyErrorBoundary","_lane","_update","getSuspendedCache","markUpdate","markRef","hadNoMutationsEffects","completedWork","didBailout","appendAllChildren","updateHostContainer","updateHostComponent","updateHostText","needsVisibilityToggle","isHidden","currentHostContext","oldText","newText","_instance","appendAllChildrenToContainer","containerChildSet","_instance2","portalOrRoot","childrenUnchanged","container","newChildSet","currentInstance","recyclableInstance","newInstance","cutOffTailIfNeeded","renderState","hasRenderedATailFallback","tailNode","lastTailNode","_tailNode","_lastTailNode","bubbleProperties","newChildLanes","subtreeFlags","_treeBaseDuration","_child2","_child3","actualDuration","treeBaseDuration","completeWork","fiberRoot","wasHydrated","_wasHydrated","_rootContainerInstance","_currentHostContext","_wasHydrated2","_wasHydrated3","isTimedOutSuspense","primaryChildFragment","_isTimedOutSuspense","_primaryChildFragment","nextDidTimeout","prevDidTimeout","_prevState","_offscreenFiber","hasInvisibleChildContext","renderDidSuspend","_primaryChildFragment2","_Component","didSuspendAlready","renderedTail","cannotBeSuspended","renderHasNotSuspendedYet","suspended","newThenables","getRenderTargetTime","_suspended","_newThenables","previousSibling","next","suspenseContext","popRenderLanes","_nextState","nextIsHidden","_prevState2","prevIsHidden","subtreeRenderLanes","ReactCurrentOwner$1","didReceiveUpdate","didWarnAboutBadClass","didWarnAboutModulePatternComponent","didWarnAboutContextTypeOnFunctionComponent","didWarnAboutGetDerivedStateOnFunctionComponent","didWarnAboutFunctionRefs","didWarnAboutReassigningProps","didWarnAboutRevealOrder","didWarnAboutTailOptions","reconcileChildren","nextChildren","forceUnmountCurrentAndReconcile","updateForwardRef","innerPropTypes","render","hasId","bailoutOnAlreadyFinishedWork","updateMemoComponent","isSimpleFunctionComponent","resolvedType","resolveFunctionForHotReloading","validateFunctionComponentInDev","updateSimpleMemoComponent","createFiberFromTypeAndProps","_innerPropTypes","hasScheduledUpdateOrContext","checkScheduledUpdateOrContext","prevProps","compare","outerMemoType","outerPropTypes","updateFunctionComponent","updateOffscreenComponent","pushRenderLanes","_nextState2","spawnedCachePool","nextBaseLanes","prevBaseLanes","_subtreeRenderLanes","updateMode","updateProfiler","stateNode","markRef$1","updateClassComponent","shouldError","tempInstance","hasContext","nextUnitOfWork","finishClassComponent","didCaptureError","pushHostRootContext","updateHostRoot","prevChildren","overrideState","recoverableError","mountHostRootWithoutHydrating","_recoverableError","updateHostComponent$1","isDirectTextChild","updateHostText$1","mountLazyComponent","_current","resolvedTag","resolveLazyComponentTag","resolvedProps","resolveClassForHotReloading","resolveForwardRefForHotReloading","hint","mountIncompleteClassComponent","mountIndeterminateComponent","_componentName2","ownerName","warningKey","debugSource","_componentName3","_componentName4","SUSPENDED_MARKER","mountSuspenseOffscreenState","updateSuspenseOffscreenState","prevOffscreenState","cachePool","shouldRemainOnFallback","getRemainingWorkInPrimaryTree","updateSuspenseComponent","shouldSuspend","showFallback","mountDehydratedSuspenseComponent","nextPrimaryChildren","nextFallbackChildren","fallbackFragment","mountSuspenseFallbackChildren","mountSuspensePrimaryChildren","_dehydrated","retrySuspenseComponentWithoutHydrating","_nextPrimaryChildren","_nextFallbackChildren","fallbackChildFragment","mountSuspenseFallbackAfterRetryWithoutHydrating","updateDehydratedSuspenseComponent","_nextFallbackChildren2","_nextPrimaryChildren2","_fallbackChildFragment","updateSuspenseFallbackChildren","_primaryChildFragment3","_nextPrimaryChildren3","_primaryChildFragment4","updateSuspensePrimaryChildren","_nextFallbackChildren3","_nextPrimaryChildren4","_fallbackChildFragment2","_primaryChildFragment5","_prevOffscreenState","_nextPrimaryChildren5","_primaryChildFragment6","primaryChildren","mode","primaryChildProps","mountWorkInProgressOffscreenFiber","fallbackChildren","progressedPrimaryFragment","offscreenProps","createFiberFromOffscreen","updateWorkInProgressOffscreenFiber","currentPrimaryChildFragment","currentFallbackChildFragment","fiberMode","attemptHydrationAtLane","retry","retryDehydratedSuspenseBoundary","scheduleSuspenseWorkOnFiber","propagateSuspenseContextChange","firstChild","findLastContentRow","lastContentRow","currentRow","validateRevealOrder","revealOrder","validateTailOptions","tailMode","validateSuspenseListNestedChild","childSlot","isAnArray","isIterable","validateSuspenseListChildren","childrenIterator","_i","initSuspenseListRenderState","isBackwards","tail","updateSuspenseListComponent","shouldForceFallback","didSuspendBefore","_tail","nextRow","updatePortalComponent","hasWarnedAboutUsingNoValuePropOnContextProvider","updateContextProvider","providerType","newValue","providerPropTypes","oldValue","hasWarnedAboutUsingContextAsConsumer","updateContextConsumer","remountFiber","oldWorkInProgress","newWorkInProgress","prevSibling","updateLanes","attemptEarlyBailoutIfNoScheduledUpdate","hasChildWork","primaryChildLanes","_hasChildWork","beginWork","unresolvedProps","_unresolvedProps","_resolvedProps","_unresolvedProps2","_resolvedProps2","_unresolvedProps3","_resolvedProps3","_Component2","_unresolvedProps4","_resolvedProps4","unwindWork","flags","_flags","_flags2","unwindInterruptedWork","interruptedWork","invokeGuardedCallbackProd","func","d","f","funcArgs","invokeGuardedCallbackImpl","fakeNode","evt","didCall","windowEvent","windowEventDescriptor","restoreAfterDispatch","evtType","didSetError","isCrossOriginError","handleWindowError","event","invokeGuardedCallbackImpl$1","hasError","caughtError","reporter","invokeGuardedCallback","hasCaughtError","clearCaughtError","didWarnAboutUndefinedSnapshotBeforeUpdate","offscreenSubtreeIsHidden","offscreenSubtreeWasHidden","PossiblyWeakSet","nextEffect","inProgressLanes","inProgressRoot","reportUncaughtErrorInDEV","callComponentWillUnmountWithTimer","safelyCallCommitHookLayoutEffectListMount","nearestMountedAncestor","commitHookEffectListMount","captureCommitPhaseError","safelyCallComponentWillUnmount","safelyCallComponentDidMount","safelyAttachRef","commitAttachRef","safelyDetachRef","retVal","safelyCallDestroy","shouldFireAfterActiveInstanceBlur","commitBeforeMutationEffects","commitBeforeMutationEffects_begin","shouldFire","ensureCorrectReturnPointer","commitBeforeMutationEffects_complete","commitBeforeMutationEffectsOnFiber","snapshot","didWarnSet","commitHookEffectListUnmount","commitPassiveEffectDurations","finishedRoot","passiveEffectDuration","_finishedWork$memoize","onPostCommit","phase","outer","commitLayoutEffectOnFiber","committedLanes","_updateQueue","_finishedWork$memoize2","onCommit","onRender","effectDuration","enqueuePendingPassiveProfilerEffect","commitSuspenseHydrationCallbacks","reappearLayoutEffectsOnFiber","hideOrUnhideAllChildren","hostSubtreeRoot","_instance3","instanceToUse","commitDetachRef","currentRef","commitUnmount","_effect","unmountHostComponents","emptyPortalContainer","commitNestedUnmounts","detachFiberMutation","detachFiberAfterEffects","hostInstance","containerInfo","emptyChildSet","commitContainer","pendingChildren","getHostParentFiber","isHostParent","getHostSibling","siblings","commitPlacement","before","insertOrAppendPlacementNode","_parent","_before","insertOrAppendPlacementNodeIntoContainer","isHost","currentParentIsValid","currentParentIsContainer","findParent","commitDeletion","commitWork","commitSuspenseCallback","attachSuspenseRetryListeners","prevRootState","_prevRootState","_root","retryCache","resolveRetryWakeable","commitResetTextContent","commitMutationEffects","commitMutationEffects_begin","commitMutationEffects_complete","commitMutationEffectsOnFiber","wasHidden","markCommitTimeOfFallback","_newState","_isHidden","_current2","_wasHidden","offscreenBoundary","offscreenChild","disappearLayoutEffects_begin","primaryFlags","_current3","_current4","_current5","commitLayoutEffects","commitLayoutEffects_begin","subtreeRoot","isModernRoot","newOffscreenSubtreeIsHidden","commitLayoutMountEffects_complete","newOffscreenSubtreeWasHidden","prevOffscreenSubtreeIsHidden","prevOffscreenSubtreeWasHidden","reappearLayoutEffects_begin","disappearLayoutEffects_complete","reappearLayoutEffects_complete","commitPassiveMountEffects","commitPassiveMountEffects_begin","commitPassiveMountEffects_complete","commitPassiveMountOnFiber","commitPassiveUnmountEffects","commitPassiveUnmountEffects_begin","fiberToDelete","commitPassiveUnmountEffectsInsideOfDeletedTree_begin","previousFiber","detachedChild","detachedSibling","commitPassiveUnmountEffects_complete","commitPassiveUnmountOnFiber","deletedSubtreeRoot","commitPassiveUnmountInsideDeletedTreeOnFiber","commitPassiveUnmountEffectsInsideOfDeletedTree_complete","didWarnWrongReturnPointer","expectedReturnFiber","invokeLayoutEffectMountInDEV","invokePassiveEffectMountInDEV","invokeLayoutEffectUnmountInDEV","invokePassiveEffectUnmountInDEV","COMPONENT_TYPE","HAS_PSEUDO_CLASS_TYPE","ROLE_TYPE","TEST_NAME_TYPE","TEXT_TYPE","symbolFor","createComponentSelector","createHasPseudoClassSelector","selectors","createRoleSelector","role","createTextSelector","createTestNameSelector","findFiberRootForHostRoot","hostRoot","maybeFiber","matchSelector","selector","hasMatchingPaths","dataTestID","selectorToString","findPaths","matchingFibers","selectorIndex","findAllNodes","instanceRoots","getFindAllNodesFailureDescription","maxSelectorIndex","matchedNames","unmatchedNames","findBoundingRects","boundingRects","targetRect","targetLeft","targetRight","targetTop","targetBottom","j","otherRect","otherLeft","otherRight","otherTop","otherBottom","focusWithin","commitHooks","onCommitRoot$1","commitHook","observeVisibleRects","_setupIntersectionObs","disconnect","observe","unobserve","nextInstanceRoots","target","ReactCurrentActQueue","isLegacyActEnvironment","isReactActEnvironmentGlobal","jestIsDefined","isConcurrentActEnvironment","ceil","ReactCurrentDispatcher$2","ReactCurrentOwner$2","ReactCurrentBatchConfig$2","ReactCurrentActQueue$1","NoContext","BatchedContext","RenderContext","CommitContext","RootInProgress","RootFatalErrored","RootErrored","RootSuspended","RootSuspendedWithDelay","RootCompleted","RootDidNotComplete","executionContext","workInProgressRoot","workInProgressRootRenderLanes","subtreeRenderLanesCursor","workInProgressRootExitStatus","workInProgressRootFatalError","workInProgressRootSkippedLanes","workInProgressRootInterleavedUpdatedLanes","workInProgressRootPingedLanes","workInProgressRootConcurrentErrors","workInProgressRootRecoverableErrors","globalMostRecentFallbackTime","FALLBACK_THROTTLE_MS","workInProgressRootRenderTargetTime","RENDER_TIMEOUT_MS","resetRenderTimer","hasUncaughtError","firstUncaughtError","legacyErrorBoundariesThatAlreadyFailed","rootDoesHavePassiveEffects","rootWithPendingPassiveEffects","pendingPassiveEffectsLanes","pendingPassiveProfilerEffects","NESTED_UPDATE_LIMIT","nestedUpdateCount","rootWithNestedUpdates","NESTED_PASSIVE_UPDATE_LIMIT","nestedPassiveUpdateCount","currentEventTime","currentEventTransitionLane","isTransition","transition","eventLane","requestRetryLane","checkForNestedUpdates","markUpdateLaneFromFiberToRoot","warnAboutRenderPhaseUpdatesInDEV","warnIfUpdatesNotWrappedWithActDEV","markRootSuspended$1","ensureRootIsScheduled","scheduleInitialHydrationOnRoot","warnAboutUpdateOnNotYetMountedFiberInDEV","existingCallbackNode","cancelCallback$1","newCallbackPriority","existingCallbackPriority","fakeActCallbackNode","newCallbackNode","performSyncWorkOnRoot","scheduleCallback$1","schedulerPriorityLevel","performConcurrentWorkOnRoot","didTimeout","originalCallbackNode","didFlushPassiveEffects","flushPassiveEffects","shouldTimeSlice","exitStatus","renderRootConcurrent","renderRootSync","errorRetryLanes","recoverFromConcurrentError","fatalError","prepareFreshStack","renderWasConcurrent","isRenderConsistentWithExternalStores","_errorRetryLanes","_fatalError","finishConcurrentRender","errorsFromFirstAttempt","rootWorkInProgress","errorsFromSecondAttempt","errors","commitRoot","shouldForceFlushFallbacksInDEV","msUntilTimeout","eventTimeMs","timeElapsedMs","_msUntilTimeout","jnd","checks","renderedValue","flushRoot","deferredUpdates","batchedUpdates","prevExecutionContext","discreteUpdates","flushSync","isAlreadyRendering","flushControlled","timeoutHandle","handleError","erroredWork","completeUnitOfWork","yetAnotherThrownValue","pushDispatcher","popDispatcher","workLoopSync","performUnitOfWork","workLoopConcurrent","unitOfWork","beginWork$1","_next","siblingFiber","recoverableErrors","previousUpdateLanePriority","commitRootImpl","renderPriorityLevel","flushRenderPhaseStrictModeWarningsInDEV","subtreeHasEffects","rootHasEffect","rootDidHavePassiveEffects","commitDoubleInvokeEffectsInDEV","onRecoverableError","renderPriority","flushPassiveEffectsImpl","profilerEffects","_fiber","prepareToThrowUncaughtError","captureCommitPhaseErrorOnRoot","rootFiber","warnIfSuspenseResolutionNotWrappedWithActDEV","retryTimedOutBoundary","boundaryFiber","retryLane","timeElapsed","hasPassiveEffects","invokeEffectsInDev","invokeEffectFn","primarySubtreeFlag","didWarnStateUpdateForNotYetMountedComponent","dummyFiber","originalWorkInProgressCopy","assignFiberPropertiesInDEV","originalError","replayError","didWarnAboutUpdateInRender","didWarnAboutUpdateInRenderForAnotherComponent","renderingComponentName","dedupeKey","setStateComponentName","schedulingFiber","priorityLevel","actQueue","callbackNode","resolveFamily","failedBoundaries","setRefreshHandler","handler","family","currentRender","syntheticType","prevType","nextType","needsCompareFamilies","$$typeofNextType","prevFamily","scheduleRefresh","staleFamilies","updatedFamilies","scheduleFibersWithFamiliesRecursively","scheduleRoot","updateContainer","candidateType","needsRender","needsRemount","findHostInstancesForRefresh","families","hostInstances","types","findHostInstancesForMatchingFibersRecursively","didMatch","findHostInstancesForFiberShallowly","foundHostInstances","findChildHostInstancesForFiberShallowly","hasBadMapPolyfill","nonExtensibleObject","FiberNode","createFiber","shouldConstruct$1","$$typeof","currentDependencies","createHostRootFiber","isStrictMode","concurrentUpdatesByDefaultOverride","fiberTag","getTag","createFiberFromProfiler","createFiberFromSuspense","createFiberFromSuspenseList","elements","primaryChildInstance","content","dehydratedNode","FiberRootNode","hydrate","createFiberRoot","initialChildren","hydrationCallbacks","transitionCallbacks","uninitializedFiber","_initialState","ReactVersion","createPortal","implementation","didWarnAboutNestedUpdates","didWarnAboutFindNodeInStrictMode","getContextForSubtree","parentComponent","findHostInstance","keys","hostFiber","findHostInstanceWithWarning","methodName","createContainer","createHydrationContainer","current$1","getPublicRootInstance","containerFiber","attemptSynchronousHydration","markRetryLaneIfNotHydrated","markRetryLaneImpl","attemptContinuousHydration","attemptHydrationAtCurrentPriority","findHostInstanceWithNoPortals","shouldErrorImpl","shouldSuspendImpl","overrideHookState","overrideHookStateDeletePath","overrideHookStateRenamePath","overrideProps","overridePropsDeletePath","overridePropsRenamePath","scheduleUpdate","setErrorHandler","setSuspenseHandler","copyWithDeleteImpl","obj","path","updated","copyWithDelete","copyWithRenameImpl","oldPath","newPath","oldKey","newKey","copyWithRename","copyWithSetImpl","copyWithSet","findHook","newShouldErrorImpl","newShouldSuspendImpl","findHostInstanceByFiber","emptyFindFiberByHostInstance","getCurrentFiberForDevTools","injectIntoDevTools","devToolsConfig","findFiberByHostInstance","reactReconcilerModule"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}