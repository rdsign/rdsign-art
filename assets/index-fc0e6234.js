(function(){const relList=document.createElement("link").relList;if(relList&&relList.supports&&relList.supports("modulepreload"))return;for(const link of document.querySelectorAll('link[rel="modulepreload"]'))processPreload(link);new MutationObserver(mutations=>{for(const mutation of mutations)if(mutation.type==="childList")for(const node of mutation.addedNodes)node.tagName==="LINK"&&node.rel==="modulepreload"&&processPreload(node)}).observe(document,{childList:!0,subtree:!0});function getFetchOpts(link){const fetchOpts={};return link.integrity&&(fetchOpts.integrity=link.integrity),link.referrerPolicy&&(fetchOpts.referrerPolicy=link.referrerPolicy),link.crossOrigin==="use-credentials"?fetchOpts.credentials="include":link.crossOrigin==="anonymous"?fetchOpts.credentials="omit":fetchOpts.credentials="same-origin",fetchOpts}function processPreload(link){if(link.ep)return;link.ep=!0;const fetchOpts=getFetchOpts(link);fetch(link.href,fetchOpts)}})();function getDefaultExportFromCjs(x2){return x2&&x2.__esModule&&Object.prototype.hasOwnProperty.call(x2,"default")?x2.default:x2}var jsxDevRuntime={exports:{}},reactJsxDevRuntime_development={},react={exports:{}},react_development={exports:{}};/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */react_development.exports;(function(module,exports){(function(){typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart=="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);var ReactVersion="18.2.0",REACT_ELEMENT_TYPE=Symbol.for("react.element"),REACT_PORTAL_TYPE=Symbol.for("react.portal"),REACT_FRAGMENT_TYPE=Symbol.for("react.fragment"),REACT_STRICT_MODE_TYPE=Symbol.for("react.strict_mode"),REACT_PROFILER_TYPE=Symbol.for("react.profiler"),REACT_PROVIDER_TYPE=Symbol.for("react.provider"),REACT_CONTEXT_TYPE=Symbol.for("react.context"),REACT_FORWARD_REF_TYPE=Symbol.for("react.forward_ref"),REACT_SUSPENSE_TYPE=Symbol.for("react.suspense"),REACT_SUSPENSE_LIST_TYPE=Symbol.for("react.suspense_list"),REACT_MEMO_TYPE=Symbol.for("react.memo"),REACT_LAZY_TYPE=Symbol.for("react.lazy"),REACT_OFFSCREEN_TYPE=Symbol.for("react.offscreen"),MAYBE_ITERATOR_SYMBOL=Symbol.iterator,FAUX_ITERATOR_SYMBOL="@@iterator";function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable!="object")return null;var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];return typeof maybeIterator=="function"?maybeIterator:null}var ReactCurrentDispatcher2={current:null},ReactCurrentBatchConfig={transition:null},ReactCurrentActQueue={current:null,isBatchingLegacy:!1,didScheduleLegacyUpdate:!1},ReactCurrentOwner2={current:null},ReactDebugCurrentFrame={},currentExtraStackFrame=null;function setExtraStackFrame(stack){currentExtraStackFrame=stack}ReactDebugCurrentFrame.setExtraStackFrame=function(stack){currentExtraStackFrame=stack},ReactDebugCurrentFrame.getCurrentStack=null,ReactDebugCurrentFrame.getStackAddendum=function(){var stack="";currentExtraStackFrame&&(stack+=currentExtraStackFrame);var impl=ReactDebugCurrentFrame.getCurrentStack;return impl&&(stack+=impl()||""),stack};var enableScopeAPI=!1,enableCacheElement=!1,enableTransitionTracing=!1,enableLegacyHidden=!1,enableDebugTracing=!1,ReactSharedInternals={ReactCurrentDispatcher:ReactCurrentDispatcher2,ReactCurrentBatchConfig,ReactCurrentOwner:ReactCurrentOwner2};ReactSharedInternals.ReactDebugCurrentFrame=ReactDebugCurrentFrame,ReactSharedInternals.ReactCurrentActQueue=ReactCurrentActQueue;function warn(format){{for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];printWarning("warn",format,args)}}function error(format){{for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++)args[_key2-1]=arguments[_key2];printWarning("error",format,args)}}function printWarning(level,format,args){{var ReactDebugCurrentFrame2=ReactSharedInternals.ReactDebugCurrentFrame,stack=ReactDebugCurrentFrame2.getStackAddendum();stack!==""&&(format+="%s",args=args.concat([stack]));var argsWithFormat=args.map(function(item){return String(item)});argsWithFormat.unshift("Warning: "+format),Function.prototype.apply.call(console[level],console,argsWithFormat)}}var didWarnStateUpdateForUnmountedComponent={};function warnNoop(publicInstance,callerName){{var _constructor=publicInstance.constructor,componentName=_constructor&&(_constructor.displayName||_constructor.name)||"ReactClass",warningKey=componentName+"."+callerName;if(didWarnStateUpdateForUnmountedComponent[warningKey])return;error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",callerName,componentName),didWarnStateUpdateForUnmountedComponent[warningKey]=!0}}var ReactNoopUpdateQueue={isMounted:function(publicInstance){return!1},enqueueForceUpdate:function(publicInstance,callback,callerName){warnNoop(publicInstance,"forceUpdate")},enqueueReplaceState:function(publicInstance,completeState,callback,callerName){warnNoop(publicInstance,"replaceState")},enqueueSetState:function(publicInstance,partialState,callback,callerName){warnNoop(publicInstance,"setState")}},assign=Object.assign,emptyObject={};Object.freeze(emptyObject);function Component(props,context2,updater){this.props=props,this.context=context2,this.refs=emptyObject,this.updater=updater||ReactNoopUpdateQueue}Component.prototype.isReactComponent={},Component.prototype.setState=function(partialState,callback){if(typeof partialState!="object"&&typeof partialState!="function"&&partialState!=null)throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,partialState,callback,"setState")},Component.prototype.forceUpdate=function(callback){this.updater.enqueueForceUpdate(this,callback,"forceUpdate")};{var deprecatedAPIs={isMounted:["isMounted","Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],replaceState:["replaceState","Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]},defineDeprecationWarning=function(methodName,info){Object.defineProperty(Component.prototype,methodName,{get:function(){warn("%s(...) is deprecated in plain JavaScript React classes. %s",info[0],info[1])}})};for(var fnName in deprecatedAPIs)deprecatedAPIs.hasOwnProperty(fnName)&&defineDeprecationWarning(fnName,deprecatedAPIs[fnName])}function ComponentDummy(){}ComponentDummy.prototype=Component.prototype;function PureComponent(props,context2,updater){this.props=props,this.context=context2,this.refs=emptyObject,this.updater=updater||ReactNoopUpdateQueue}var pureComponentPrototype=PureComponent.prototype=new ComponentDummy;pureComponentPrototype.constructor=PureComponent,assign(pureComponentPrototype,Component.prototype),pureComponentPrototype.isPureReactComponent=!0;function createRef(){var refObject={current:null};return Object.seal(refObject),refObject}var isArrayImpl=Array.isArray;function isArray(a2){return isArrayImpl(a2)}function typeName(value){{var hasToStringTag=typeof Symbol=="function"&&Symbol.toStringTag,type=hasToStringTag&&value[Symbol.toStringTag]||value.constructor.name||"Object";return type}}function willCoercionThrow(value){try{return testStringCoercion(value),!1}catch{return!0}}function testStringCoercion(value){return""+value}function checkKeyStringCoercion(value){if(willCoercionThrow(value))return error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.",typeName(value)),testStringCoercion(value)}function getWrappedName(outerType,innerType,wrapperName){var displayName=outerType.displayName;if(displayName)return displayName;var functionName=innerType.displayName||innerType.name||"";return functionName!==""?wrapperName+"("+functionName+")":wrapperName}function getContextName(type){return type.displayName||"Context"}function getComponentNameFromType(type){if(type==null)return null;if(typeof type.tag=="number"&&error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."),typeof type=="function")return type.displayName||type.name||null;if(typeof type=="string")return type;switch(type){case REACT_FRAGMENT_TYPE:return"Fragment";case REACT_PORTAL_TYPE:return"Portal";case REACT_PROFILER_TYPE:return"Profiler";case REACT_STRICT_MODE_TYPE:return"StrictMode";case REACT_SUSPENSE_TYPE:return"Suspense";case REACT_SUSPENSE_LIST_TYPE:return"SuspenseList"}if(typeof type=="object")switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context2=type;return getContextName(context2)+".Consumer";case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+".Provider";case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,"ForwardRef");case REACT_MEMO_TYPE:var outerName=type.displayName||null;return outerName!==null?outerName:getComponentNameFromType(type.type)||"Memo";case REACT_LAZY_TYPE:{var lazyComponent=type,payload=lazyComponent._payload,init=lazyComponent._init;try{return getComponentNameFromType(init(payload))}catch{return null}}}return null}var hasOwnProperty=Object.prototype.hasOwnProperty,RESERVED_PROPS={key:!0,ref:!0,__self:!0,__source:!0},specialPropKeyWarningShown,specialPropRefWarningShown,didWarnAboutStringRefs;didWarnAboutStringRefs={};function hasValidRef(config){if(hasOwnProperty.call(config,"ref")){var getter=Object.getOwnPropertyDescriptor(config,"ref").get;if(getter&&getter.isReactWarning)return!1}return config.ref!==void 0}function hasValidKey(config){if(hasOwnProperty.call(config,"key")){var getter=Object.getOwnPropertyDescriptor(config,"key").get;if(getter&&getter.isReactWarning)return!1}return config.key!==void 0}function defineKeyPropWarningGetter(props,displayName){var warnAboutAccessingKey=function(){specialPropKeyWarningShown||(specialPropKeyWarningShown=!0,error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)",displayName))};warnAboutAccessingKey.isReactWarning=!0,Object.defineProperty(props,"key",{get:warnAboutAccessingKey,configurable:!0})}function defineRefPropWarningGetter(props,displayName){var warnAboutAccessingRef=function(){specialPropRefWarningShown||(specialPropRefWarningShown=!0,error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)",displayName))};warnAboutAccessingRef.isReactWarning=!0,Object.defineProperty(props,"ref",{get:warnAboutAccessingRef,configurable:!0})}function warnIfStringRefCannotBeAutoConverted(config){if(typeof config.ref=="string"&&ReactCurrentOwner2.current&&config.__self&&ReactCurrentOwner2.current.stateNode!==config.__self){var componentName=getComponentNameFromType(ReactCurrentOwner2.current.type);didWarnAboutStringRefs[componentName]||(error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',componentName,config.ref),didWarnAboutStringRefs[componentName]=!0)}}var ReactElement=function(type,key,ref,self2,source,owner,props){var element={$$typeof:REACT_ELEMENT_TYPE,type,key,ref,props,_owner:owner};return element._store={},Object.defineProperty(element._store,"validated",{configurable:!1,enumerable:!1,writable:!0,value:!1}),Object.defineProperty(element,"_self",{configurable:!1,enumerable:!1,writable:!1,value:self2}),Object.defineProperty(element,"_source",{configurable:!1,enumerable:!1,writable:!1,value:source}),Object.freeze&&(Object.freeze(element.props),Object.freeze(element)),element};function createElement(type,config,children){var propName,props={},key=null,ref=null,self2=null,source=null;if(config!=null){hasValidRef(config)&&(ref=config.ref,warnIfStringRefCannotBeAutoConverted(config)),hasValidKey(config)&&(checkKeyStringCoercion(config.key),key=""+config.key),self2=config.__self===void 0?null:config.__self,source=config.__source===void 0?null:config.__source;for(propName in config)hasOwnProperty.call(config,propName)&&!RESERVED_PROPS.hasOwnProperty(propName)&&(props[propName]=config[propName])}var childrenLength=arguments.length-2;if(childrenLength===1)props.children=children;else if(childrenLength>1){for(var childArray=Array(childrenLength),i2=0;i2<childrenLength;i2++)childArray[i2]=arguments[i2+2];Object.freeze&&Object.freeze(childArray),props.children=childArray}if(type&&type.defaultProps){var defaultProps=type.defaultProps;for(propName in defaultProps)props[propName]===void 0&&(props[propName]=defaultProps[propName])}if(key||ref){var displayName=typeof type=="function"?type.displayName||type.name||"Unknown":type;key&&defineKeyPropWarningGetter(props,displayName),ref&&defineRefPropWarningGetter(props,displayName)}return ReactElement(type,key,ref,self2,source,ReactCurrentOwner2.current,props)}function cloneAndReplaceKey(oldElement,newKey){var newElement=ReactElement(oldElement.type,newKey,oldElement.ref,oldElement._self,oldElement._source,oldElement._owner,oldElement.props);return newElement}function cloneElement(element,config,children){if(element==null)throw new Error("React.cloneElement(...): The argument must be a React element, but you passed "+element+".");var propName,props=assign({},element.props),key=element.key,ref=element.ref,self2=element._self,source=element._source,owner=element._owner;if(config!=null){hasValidRef(config)&&(ref=config.ref,owner=ReactCurrentOwner2.current),hasValidKey(config)&&(checkKeyStringCoercion(config.key),key=""+config.key);var defaultProps;element.type&&element.type.defaultProps&&(defaultProps=element.type.defaultProps);for(propName in config)hasOwnProperty.call(config,propName)&&!RESERVED_PROPS.hasOwnProperty(propName)&&(config[propName]===void 0&&defaultProps!==void 0?props[propName]=defaultProps[propName]:props[propName]=config[propName])}var childrenLength=arguments.length-2;if(childrenLength===1)props.children=children;else if(childrenLength>1){for(var childArray=Array(childrenLength),i2=0;i2<childrenLength;i2++)childArray[i2]=arguments[i2+2];props.children=childArray}return ReactElement(element.type,key,ref,self2,source,owner,props)}function isValidElement(object){return typeof object=="object"&&object!==null&&object.$$typeof===REACT_ELEMENT_TYPE}var SEPARATOR=".",SUBSEPARATOR=":";function escape2(key){var escapeRegex=/[=:]/g,escaperLookup={"=":"=0",":":"=2"},escapedString=key.replace(escapeRegex,function(match){return escaperLookup[match]});return"$"+escapedString}var didWarnAboutMaps=!1,userProvidedKeyEscapeRegex=/\/+/g;function escapeUserProvidedKey(text){return text.replace(userProvidedKeyEscapeRegex,"$&/")}function getElementKey(element,index){return typeof element=="object"&&element!==null&&element.key!=null?(checkKeyStringCoercion(element.key),escape2(""+element.key)):index.toString(36)}function mapIntoArray(children,array,escapedPrefix,nameSoFar,callback){var type=typeof children;(type==="undefined"||type==="boolean")&&(children=null);var invokeCallback=!1;if(children===null)invokeCallback=!0;else switch(type){case"string":case"number":invokeCallback=!0;break;case"object":switch(children.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:invokeCallback=!0}}if(invokeCallback){var _child=children,mappedChild=callback(_child),childKey=nameSoFar===""?SEPARATOR+getElementKey(_child,0):nameSoFar;if(isArray(mappedChild)){var escapedChildKey="";childKey!=null&&(escapedChildKey=escapeUserProvidedKey(childKey)+"/"),mapIntoArray(mappedChild,array,escapedChildKey,"",function(c2){return c2})}else mappedChild!=null&&(isValidElement(mappedChild)&&(mappedChild.key&&(!_child||_child.key!==mappedChild.key)&&checkKeyStringCoercion(mappedChild.key),mappedChild=cloneAndReplaceKey(mappedChild,escapedPrefix+(mappedChild.key&&(!_child||_child.key!==mappedChild.key)?escapeUserProvidedKey(""+mappedChild.key)+"/":"")+childKey)),array.push(mappedChild));return 1}var child,nextName,subtreeCount=0,nextNamePrefix=nameSoFar===""?SEPARATOR:nameSoFar+SUBSEPARATOR;if(isArray(children))for(var i2=0;i2<children.length;i2++)child=children[i2],nextName=nextNamePrefix+getElementKey(child,i2),subtreeCount+=mapIntoArray(child,array,escapedPrefix,nextName,callback);else{var iteratorFn=getIteratorFn(children);if(typeof iteratorFn=="function"){var iterableChildren=children;iteratorFn===iterableChildren.entries&&(didWarnAboutMaps||warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."),didWarnAboutMaps=!0);for(var iterator=iteratorFn.call(iterableChildren),step,ii=0;!(step=iterator.next()).done;)child=step.value,nextName=nextNamePrefix+getElementKey(child,ii++),subtreeCount+=mapIntoArray(child,array,escapedPrefix,nextName,callback)}else if(type==="object"){var childrenString=String(children);throw new Error("Objects are not valid as a React child (found: "+(childrenString==="[object Object]"?"object with keys {"+Object.keys(children).join(", ")+"}":childrenString)+"). If you meant to render a collection of children, use an array instead.")}}return subtreeCount}function mapChildren(children,func,context2){if(children==null)return children;var result=[],count=0;return mapIntoArray(children,result,"","",function(child){return func.call(context2,child,count++)}),result}function countChildren(children){var n=0;return mapChildren(children,function(){n++}),n}function forEachChildren(children,forEachFunc,forEachContext){mapChildren(children,function(){forEachFunc.apply(this,arguments)},forEachContext)}function toArray(children){return mapChildren(children,function(child){return child})||[]}function onlyChild(children){if(!isValidElement(children))throw new Error("React.Children.only expected to receive a single React element child.");return children}function createContext(defaultValue){var context2={$$typeof:REACT_CONTEXT_TYPE,_currentValue:defaultValue,_currentValue2:defaultValue,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};context2.Provider={$$typeof:REACT_PROVIDER_TYPE,_context:context2};var hasWarnedAboutUsingNestedContextConsumers=!1,hasWarnedAboutUsingConsumerProvider=!1,hasWarnedAboutDisplayNameOnConsumer=!1;{var Consumer={$$typeof:REACT_CONTEXT_TYPE,_context:context2};Object.defineProperties(Consumer,{Provider:{get:function(){return hasWarnedAboutUsingConsumerProvider||(hasWarnedAboutUsingConsumerProvider=!0,error("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")),context2.Provider},set:function(_Provider){context2.Provider=_Provider}},_currentValue:{get:function(){return context2._currentValue},set:function(_currentValue){context2._currentValue=_currentValue}},_currentValue2:{get:function(){return context2._currentValue2},set:function(_currentValue2){context2._currentValue2=_currentValue2}},_threadCount:{get:function(){return context2._threadCount},set:function(_threadCount){context2._threadCount=_threadCount}},Consumer:{get:function(){return hasWarnedAboutUsingNestedContextConsumers||(hasWarnedAboutUsingNestedContextConsumers=!0,error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")),context2.Consumer}},displayName:{get:function(){return context2.displayName},set:function(displayName){hasWarnedAboutDisplayNameOnConsumer||(warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.",displayName),hasWarnedAboutDisplayNameOnConsumer=!0)}}}),context2.Consumer=Consumer}return context2._currentRenderer=null,context2._currentRenderer2=null,context2}var Uninitialized=-1,Pending=0,Resolved=1,Rejected=2;function lazyInitializer(payload){if(payload._status===Uninitialized){var ctor=payload._result,thenable=ctor();if(thenable.then(function(moduleObject2){if(payload._status===Pending||payload._status===Uninitialized){var resolved=payload;resolved._status=Resolved,resolved._result=moduleObject2}},function(error2){if(payload._status===Pending||payload._status===Uninitialized){var rejected=payload;rejected._status=Rejected,rejected._result=error2}}),payload._status===Uninitialized){var pending=payload;pending._status=Pending,pending._result=thenable}}if(payload._status===Resolved){var moduleObject=payload._result;return moduleObject===void 0&&error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`,moduleObject),"default"in moduleObject||error(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`,moduleObject),moduleObject.default}else throw payload._result}function lazy(ctor){var payload={_status:Uninitialized,_result:ctor},lazyType={$$typeof:REACT_LAZY_TYPE,_payload:payload,_init:lazyInitializer};{var defaultProps,propTypes;Object.defineProperties(lazyType,{defaultProps:{configurable:!0,get:function(){return defaultProps},set:function(newDefaultProps){error("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."),defaultProps=newDefaultProps,Object.defineProperty(lazyType,"defaultProps",{enumerable:!0})}},propTypes:{configurable:!0,get:function(){return propTypes},set:function(newPropTypes){error("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."),propTypes=newPropTypes,Object.defineProperty(lazyType,"propTypes",{enumerable:!0})}}})}return lazyType}function forwardRef(render){render!=null&&render.$$typeof===REACT_MEMO_TYPE?error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."):typeof render!="function"?error("forwardRef requires a render function but was given %s.",render===null?"null":typeof render):render.length!==0&&render.length!==2&&error("forwardRef render functions accept exactly two parameters: props and ref. %s",render.length===1?"Did you forget to use the ref parameter?":"Any additional parameter will be undefined."),render!=null&&(render.defaultProps!=null||render.propTypes!=null)&&error("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");var elementType={$$typeof:REACT_FORWARD_REF_TYPE,render};{var ownName;Object.defineProperty(elementType,"displayName",{enumerable:!1,configurable:!0,get:function(){return ownName},set:function(name){ownName=name,!render.name&&!render.displayName&&(render.displayName=name)}})}return elementType}var REACT_MODULE_REFERENCE;REACT_MODULE_REFERENCE=Symbol.for("react.module.reference");function isValidElementType(type){return!!(typeof type=="string"||typeof type=="function"||type===REACT_FRAGMENT_TYPE||type===REACT_PROFILER_TYPE||enableDebugTracing||type===REACT_STRICT_MODE_TYPE||type===REACT_SUSPENSE_TYPE||type===REACT_SUSPENSE_LIST_TYPE||enableLegacyHidden||type===REACT_OFFSCREEN_TYPE||enableScopeAPI||enableCacheElement||enableTransitionTracing||typeof type=="object"&&type!==null&&(type.$$typeof===REACT_LAZY_TYPE||type.$$typeof===REACT_MEMO_TYPE||type.$$typeof===REACT_PROVIDER_TYPE||type.$$typeof===REACT_CONTEXT_TYPE||type.$$typeof===REACT_FORWARD_REF_TYPE||type.$$typeof===REACT_MODULE_REFERENCE||type.getModuleId!==void 0))}function memo2(type,compare){isValidElementType(type)||error("memo: The first argument must be a component. Instead received: %s",type===null?"null":typeof type);var elementType={$$typeof:REACT_MEMO_TYPE,type,compare:compare===void 0?null:compare};{var ownName;Object.defineProperty(elementType,"displayName",{enumerable:!1,configurable:!0,get:function(){return ownName},set:function(name){ownName=name,!type.name&&!type.displayName&&(type.displayName=name)}})}return elementType}function resolveDispatcher(){var dispatcher=ReactCurrentDispatcher2.current;return dispatcher===null&&error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`),dispatcher}function useContext(Context){var dispatcher=resolveDispatcher();if(Context._context!==void 0){var realContext=Context._context;realContext.Consumer===Context?error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?"):realContext.Provider===Context&&error("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?")}return dispatcher.useContext(Context)}function useState(initialState){var dispatcher=resolveDispatcher();return dispatcher.useState(initialState)}function useReducer(reducer,initialArg,init){var dispatcher=resolveDispatcher();return dispatcher.useReducer(reducer,initialArg,init)}function useRef(initialValue){var dispatcher=resolveDispatcher();return dispatcher.useRef(initialValue)}function useEffect(create2,deps){var dispatcher=resolveDispatcher();return dispatcher.useEffect(create2,deps)}function useInsertionEffect(create2,deps){var dispatcher=resolveDispatcher();return dispatcher.useInsertionEffect(create2,deps)}function useLayoutEffect(create2,deps){var dispatcher=resolveDispatcher();return dispatcher.useLayoutEffect(create2,deps)}function useCallback(callback,deps){var dispatcher=resolveDispatcher();return dispatcher.useCallback(callback,deps)}function useMemo(create2,deps){var dispatcher=resolveDispatcher();return dispatcher.useMemo(create2,deps)}function useImperativeHandle(ref,create2,deps){var dispatcher=resolveDispatcher();return dispatcher.useImperativeHandle(ref,create2,deps)}function useDebugValue(value,formatterFn){{var dispatcher=resolveDispatcher();return dispatcher.useDebugValue(value,formatterFn)}}function useTransition(){var dispatcher=resolveDispatcher();return dispatcher.useTransition()}function useDeferredValue(value){var dispatcher=resolveDispatcher();return dispatcher.useDeferredValue(value)}function useId(){var dispatcher=resolveDispatcher();return dispatcher.useId()}function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var dispatcher=resolveDispatcher();return dispatcher.useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot)}var disabledDepth=0,prevLog,prevInfo,prevWarn,prevError,prevGroup,prevGroupCollapsed,prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=!0;function disableLogs(){{if(disabledDepth===0){prevLog=console.log,prevInfo=console.info,prevWarn=console.warn,prevError=console.error,prevGroup=console.group,prevGroupCollapsed=console.groupCollapsed,prevGroupEnd=console.groupEnd;var props={configurable:!0,enumerable:!0,value:disabledLog,writable:!0};Object.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props})}disabledDepth++}}function reenableLogs(){{if(disabledDepth--,disabledDepth===0){var props={configurable:!0,enumerable:!0,writable:!0};Object.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})})}disabledDepth<0&&error("disabledDepth fell below zero. This is a bug in React. Please file an issue.")}}var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===void 0)try{throw Error()}catch(x2){var match=x2.stack.trim().match(/\n( *(at )?)/);prefix=match&&match[1]||""}return`
`+prefix+name}}var reentry=!1,componentFrameCache;{var PossiblyWeakMap=typeof WeakMap=="function"?WeakMap:Map;componentFrameCache=new PossiblyWeakMap}function describeNativeComponentFrame(fn,construct){if(!fn||reentry)return"";{var frame2=componentFrameCache.get(fn);if(frame2!==void 0)return frame2}var control;reentry=!0;var previousPrepareStackTrace=Error.prepareStackTrace;Error.prepareStackTrace=void 0;var previousDispatcher;previousDispatcher=ReactCurrentDispatcher$1.current,ReactCurrentDispatcher$1.current=null,disableLogs();try{if(construct){var Fake=function(){throw Error()};if(Object.defineProperty(Fake.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Fake,[])}catch(x2){control=x2}Reflect.construct(fn,[],Fake)}else{try{Fake.call()}catch(x2){control=x2}fn.call(Fake.prototype)}}else{try{throw Error()}catch(x2){control=x2}fn()}}catch(sample){if(sample&&control&&typeof sample.stack=="string"){for(var sampleLines=sample.stack.split(`
`),controlLines=control.stack.split(`
`),s2=sampleLines.length-1,c2=controlLines.length-1;s2>=1&&c2>=0&&sampleLines[s2]!==controlLines[c2];)c2--;for(;s2>=1&&c2>=0;s2--,c2--)if(sampleLines[s2]!==controlLines[c2]){if(s2!==1||c2!==1)do if(s2--,c2--,c2<0||sampleLines[s2]!==controlLines[c2]){var _frame=`
`+sampleLines[s2].replace(" at new "," at ");return fn.displayName&&_frame.includes("<anonymous>")&&(_frame=_frame.replace("<anonymous>",fn.displayName)),typeof fn=="function"&&componentFrameCache.set(fn,_frame),_frame}while(s2>=1&&c2>=0);break}}}finally{reentry=!1,ReactCurrentDispatcher$1.current=previousDispatcher,reenableLogs(),Error.prepareStackTrace=previousPrepareStackTrace}var name=fn?fn.displayName||fn.name:"",syntheticFrame=name?describeBuiltInComponentFrame(name):"";return typeof fn=="function"&&componentFrameCache.set(fn,syntheticFrame),syntheticFrame}function describeFunctionComponentFrame(fn,source,ownerFn){return describeNativeComponentFrame(fn,!1)}function shouldConstruct(Component2){var prototype=Component2.prototype;return!!(prototype&&prototype.isReactComponent)}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null)return"";if(typeof type=="function")return describeNativeComponentFrame(type,shouldConstruct(type));if(typeof type=="string")return describeBuiltInComponentFrame(type);switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame("Suspense");case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame("SuspenseList")}if(typeof type=="object")switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:return describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:{var lazyComponent=type,payload=lazyComponent._payload,init=lazyComponent._init;try{return describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn)}catch{}}}return""}var loggedTypeFailures={},ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){if(element){var owner=element._owner,stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame$1.setExtraStackFrame(stack)}else ReactDebugCurrentFrame$1.setExtraStackFrame(null)}function checkPropTypes(typeSpecs,values,location,componentName,element){{var has=Function.call.bind(hasOwnProperty);for(var typeSpecName in typeSpecs)if(has(typeSpecs,typeSpecName)){var error$1=void 0;try{if(typeof typeSpecs[typeSpecName]!="function"){var err=Error((componentName||"React class")+": "+location+" type `"+typeSpecName+"` is invalid; it must be a function, usually from the `prop-types` package, but received `"+typeof typeSpecs[typeSpecName]+"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");throw err.name="Invariant Violation",err}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(ex){error$1=ex}error$1&&!(error$1 instanceof Error)&&(setCurrentlyValidatingElement(element),error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).",componentName||"React class",location,typeSpecName,typeof error$1),setCurrentlyValidatingElement(null)),error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)&&(loggedTypeFailures[error$1.message]=!0,setCurrentlyValidatingElement(element),error("Failed %s type: %s",location,error$1.message),setCurrentlyValidatingElement(null))}}}function setCurrentlyValidatingElement$1(element){if(element){var owner=element._owner,stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);setExtraStackFrame(stack)}else setExtraStackFrame(null)}var propTypesMisspellWarningShown;propTypesMisspellWarningShown=!1;function getDeclarationErrorAddendum(){if(ReactCurrentOwner2.current){var name=getComponentNameFromType(ReactCurrentOwner2.current.type);if(name)return`

Check the render method of \``+name+"`."}return""}function getSourceInfoErrorAddendum(source){if(source!==void 0){var fileName=source.fileName.replace(/^.*[\\\/]/,""),lineNumber=source.lineNumber;return`

Check your code at `+fileName+":"+lineNumber+"."}return""}function getSourceInfoErrorAddendumForProps(elementProps){return elementProps!=null?getSourceInfoErrorAddendum(elementProps.__source):""}var ownerHasKeyUseWarning={};function getCurrentComponentErrorInfo(parentType){var info=getDeclarationErrorAddendum();if(!info){var parentName=typeof parentType=="string"?parentType:parentType.displayName||parentType.name;parentName&&(info=`

Check the top-level render call using <`+parentName+">.")}return info}function validateExplicitKey(element,parentType){if(!(!element._store||element._store.validated||element.key!=null)){element._store.validated=!0;var currentComponentErrorInfo=getCurrentComponentErrorInfo(parentType);if(!ownerHasKeyUseWarning[currentComponentErrorInfo]){ownerHasKeyUseWarning[currentComponentErrorInfo]=!0;var childOwner="";element&&element._owner&&element._owner!==ReactCurrentOwner2.current&&(childOwner=" It was passed a child from "+getComponentNameFromType(element._owner.type)+"."),setCurrentlyValidatingElement$1(element),error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',currentComponentErrorInfo,childOwner),setCurrentlyValidatingElement$1(null)}}}function validateChildKeys(node,parentType){if(typeof node=="object"){if(isArray(node))for(var i2=0;i2<node.length;i2++){var child=node[i2];isValidElement(child)&&validateExplicitKey(child,parentType)}else if(isValidElement(node))node._store&&(node._store.validated=!0);else if(node){var iteratorFn=getIteratorFn(node);if(typeof iteratorFn=="function"&&iteratorFn!==node.entries)for(var iterator=iteratorFn.call(node),step;!(step=iterator.next()).done;)isValidElement(step.value)&&validateExplicitKey(step.value,parentType)}}}function validatePropTypes(element){{var type=element.type;if(type==null||typeof type=="string")return;var propTypes;if(typeof type=="function")propTypes=type.propTypes;else if(typeof type=="object"&&(type.$$typeof===REACT_FORWARD_REF_TYPE||type.$$typeof===REACT_MEMO_TYPE))propTypes=type.propTypes;else return;if(propTypes){var name=getComponentNameFromType(type);checkPropTypes(propTypes,element.props,"prop",name,element)}else if(type.PropTypes!==void 0&&!propTypesMisspellWarningShown){propTypesMisspellWarningShown=!0;var _name=getComponentNameFromType(type);error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?",_name||"Unknown")}typeof type.getDefaultProps=="function"&&!type.getDefaultProps.isReactClassApproved&&error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.")}}function validateFragmentProps(fragment2){{for(var keys2=Object.keys(fragment2.props),i2=0;i2<keys2.length;i2++){var key=keys2[i2];if(key!=="children"&&key!=="key"){setCurrentlyValidatingElement$1(fragment2),error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",key),setCurrentlyValidatingElement$1(null);break}}fragment2.ref!==null&&(setCurrentlyValidatingElement$1(fragment2),error("Invalid attribute `ref` supplied to `React.Fragment`."),setCurrentlyValidatingElement$1(null))}}function createElementWithValidation(type,props,children){var validType=isValidElementType(type);if(!validType){var info="";(type===void 0||typeof type=="object"&&type!==null&&Object.keys(type).length===0)&&(info+=" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");var sourceInfo=getSourceInfoErrorAddendumForProps(props);sourceInfo?info+=sourceInfo:info+=getDeclarationErrorAddendum();var typeString;type===null?typeString="null":isArray(type)?typeString="array":type!==void 0&&type.$$typeof===REACT_ELEMENT_TYPE?(typeString="<"+(getComponentNameFromType(type.type)||"Unknown")+" />",info=" Did you accidentally export a JSX literal instead of a component?"):typeString=typeof type,error("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",typeString,info)}var element=createElement.apply(this,arguments);if(element==null)return element;if(validType)for(var i2=2;i2<arguments.length;i2++)validateChildKeys(arguments[i2],type);return type===REACT_FRAGMENT_TYPE?validateFragmentProps(element):validatePropTypes(element),element}var didWarnAboutDeprecatedCreateFactory=!1;function createFactoryWithValidation(type){var validatedFactory=createElementWithValidation.bind(null,type);return validatedFactory.type=type,didWarnAboutDeprecatedCreateFactory||(didWarnAboutDeprecatedCreateFactory=!0,warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")),Object.defineProperty(validatedFactory,"type",{enumerable:!1,get:function(){return warn("Factory.type is deprecated. Access the class directly before passing it to createFactory."),Object.defineProperty(this,"type",{value:type}),type}}),validatedFactory}function cloneElementWithValidation(element,props,children){for(var newElement=cloneElement.apply(this,arguments),i2=2;i2<arguments.length;i2++)validateChildKeys(arguments[i2],newElement.type);return validatePropTypes(newElement),newElement}function startTransition(scope,options){var prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition={};var currentTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition._updatedFibers=new Set;try{scope()}finally{if(ReactCurrentBatchConfig.transition=prevTransition,prevTransition===null&&currentTransition._updatedFibers){var updatedFibersCount=currentTransition._updatedFibers.size;updatedFibersCount>10&&warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."),currentTransition._updatedFibers.clear()}}}var didWarnAboutMessageChannel=!1,enqueueTaskImpl=null;function enqueueTask(task){if(enqueueTaskImpl===null)try{var requireString=("require"+Math.random()).slice(0,7),nodeRequire=module&&module[requireString];enqueueTaskImpl=nodeRequire.call(module,"timers").setImmediate}catch{enqueueTaskImpl=function(callback){didWarnAboutMessageChannel===!1&&(didWarnAboutMessageChannel=!0,typeof MessageChannel>"u"&&error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));var channel=new MessageChannel;channel.port1.onmessage=callback,channel.port2.postMessage(void 0)}}return enqueueTaskImpl(task)}var actScopeDepth=0,didWarnNoAwaitAct=!1;function act(callback){{var prevActScopeDepth=actScopeDepth;actScopeDepth++,ReactCurrentActQueue.current===null&&(ReactCurrentActQueue.current=[]);var prevIsBatchingLegacy=ReactCurrentActQueue.isBatchingLegacy,result;try{if(ReactCurrentActQueue.isBatchingLegacy=!0,result=callback(),!prevIsBatchingLegacy&&ReactCurrentActQueue.didScheduleLegacyUpdate){var queue=ReactCurrentActQueue.current;queue!==null&&(ReactCurrentActQueue.didScheduleLegacyUpdate=!1,flushActQueue(queue))}}catch(error2){throw popActScope(prevActScopeDepth),error2}finally{ReactCurrentActQueue.isBatchingLegacy=prevIsBatchingLegacy}if(result!==null&&typeof result=="object"&&typeof result.then=="function"){var thenableResult=result,wasAwaited=!1,thenable={then:function(resolve2,reject){wasAwaited=!0,thenableResult.then(function(returnValue2){popActScope(prevActScopeDepth),actScopeDepth===0?recursivelyFlushAsyncActWork(returnValue2,resolve2,reject):resolve2(returnValue2)},function(error2){popActScope(prevActScopeDepth),reject(error2)})}};return!didWarnNoAwaitAct&&typeof Promise<"u"&&Promise.resolve().then(function(){}).then(function(){wasAwaited||(didWarnNoAwaitAct=!0,error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"))}),thenable}else{var returnValue=result;if(popActScope(prevActScopeDepth),actScopeDepth===0){var _queue=ReactCurrentActQueue.current;_queue!==null&&(flushActQueue(_queue),ReactCurrentActQueue.current=null);var _thenable={then:function(resolve2,reject){ReactCurrentActQueue.current===null?(ReactCurrentActQueue.current=[],recursivelyFlushAsyncActWork(returnValue,resolve2,reject)):resolve2(returnValue)}};return _thenable}else{var _thenable2={then:function(resolve2,reject){resolve2(returnValue)}};return _thenable2}}}}function popActScope(prevActScopeDepth){prevActScopeDepth!==actScopeDepth-1&&error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "),actScopeDepth=prevActScopeDepth}function recursivelyFlushAsyncActWork(returnValue,resolve2,reject){{var queue=ReactCurrentActQueue.current;if(queue!==null)try{flushActQueue(queue),enqueueTask(function(){queue.length===0?(ReactCurrentActQueue.current=null,resolve2(returnValue)):recursivelyFlushAsyncActWork(returnValue,resolve2,reject)})}catch(error2){reject(error2)}else resolve2(returnValue)}}var isFlushing=!1;function flushActQueue(queue){if(!isFlushing){isFlushing=!0;var i2=0;try{for(;i2<queue.length;i2++){var callback=queue[i2];do callback=callback(!0);while(callback!==null)}queue.length=0}catch(error2){throw queue=queue.slice(i2+1),error2}finally{isFlushing=!1}}}var createElement$1=createElementWithValidation,cloneElement$1=cloneElementWithValidation,createFactory=createFactoryWithValidation,Children={map:mapChildren,forEach:forEachChildren,count:countChildren,toArray,only:onlyChild};exports.Children=Children,exports.Component=Component,exports.Fragment=REACT_FRAGMENT_TYPE,exports.Profiler=REACT_PROFILER_TYPE,exports.PureComponent=PureComponent,exports.StrictMode=REACT_STRICT_MODE_TYPE,exports.Suspense=REACT_SUSPENSE_TYPE,exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ReactSharedInternals,exports.cloneElement=cloneElement$1,exports.createContext=createContext,exports.createElement=createElement$1,exports.createFactory=createFactory,exports.createRef=createRef,exports.forwardRef=forwardRef,exports.isValidElement=isValidElement,exports.lazy=lazy,exports.memo=memo2,exports.startTransition=startTransition,exports.unstable_act=act,exports.useCallback=useCallback,exports.useContext=useContext,exports.useDebugValue=useDebugValue,exports.useDeferredValue=useDeferredValue,exports.useEffect=useEffect,exports.useId=useId,exports.useImperativeHandle=useImperativeHandle,exports.useInsertionEffect=useInsertionEffect,exports.useLayoutEffect=useLayoutEffect,exports.useMemo=useMemo,exports.useReducer=useReducer,exports.useRef=useRef,exports.useState=useState,exports.useSyncExternalStore=useSyncExternalStore,exports.useTransition=useTransition,exports.version=ReactVersion,typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop=="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error)})()})(react_development,react_development.exports);var react_developmentExports=react_development.exports;react.exports=react_developmentExports;var reactExports=react.exports;const u$1=getDefaultExportFromCjs(reactExports);/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(){var React=reactExports,REACT_ELEMENT_TYPE=Symbol.for("react.element"),REACT_PORTAL_TYPE=Symbol.for("react.portal"),REACT_FRAGMENT_TYPE=Symbol.for("react.fragment"),REACT_STRICT_MODE_TYPE=Symbol.for("react.strict_mode"),REACT_PROFILER_TYPE=Symbol.for("react.profiler"),REACT_PROVIDER_TYPE=Symbol.for("react.provider"),REACT_CONTEXT_TYPE=Symbol.for("react.context"),REACT_FORWARD_REF_TYPE=Symbol.for("react.forward_ref"),REACT_SUSPENSE_TYPE=Symbol.for("react.suspense"),REACT_SUSPENSE_LIST_TYPE=Symbol.for("react.suspense_list"),REACT_MEMO_TYPE=Symbol.for("react.memo"),REACT_LAZY_TYPE=Symbol.for("react.lazy"),REACT_OFFSCREEN_TYPE=Symbol.for("react.offscreen"),MAYBE_ITERATOR_SYMBOL=Symbol.iterator,FAUX_ITERATOR_SYMBOL="@@iterator";function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable!="object")return null;var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];return typeof maybeIterator=="function"?maybeIterator:null}var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;function error(format){{for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++)args[_key2-1]=arguments[_key2];printWarning("error",format,args)}}function printWarning(level,format,args){{var ReactDebugCurrentFrame2=ReactSharedInternals.ReactDebugCurrentFrame,stack=ReactDebugCurrentFrame2.getStackAddendum();stack!==""&&(format+="%s",args=args.concat([stack]));var argsWithFormat=args.map(function(item){return String(item)});argsWithFormat.unshift("Warning: "+format),Function.prototype.apply.call(console[level],console,argsWithFormat)}}var enableScopeAPI=!1,enableCacheElement=!1,enableTransitionTracing=!1,enableLegacyHidden=!1,enableDebugTracing=!1,REACT_MODULE_REFERENCE;REACT_MODULE_REFERENCE=Symbol.for("react.module.reference");function isValidElementType(type){return!!(typeof type=="string"||typeof type=="function"||type===REACT_FRAGMENT_TYPE||type===REACT_PROFILER_TYPE||enableDebugTracing||type===REACT_STRICT_MODE_TYPE||type===REACT_SUSPENSE_TYPE||type===REACT_SUSPENSE_LIST_TYPE||enableLegacyHidden||type===REACT_OFFSCREEN_TYPE||enableScopeAPI||enableCacheElement||enableTransitionTracing||typeof type=="object"&&type!==null&&(type.$$typeof===REACT_LAZY_TYPE||type.$$typeof===REACT_MEMO_TYPE||type.$$typeof===REACT_PROVIDER_TYPE||type.$$typeof===REACT_CONTEXT_TYPE||type.$$typeof===REACT_FORWARD_REF_TYPE||type.$$typeof===REACT_MODULE_REFERENCE||type.getModuleId!==void 0))}function getWrappedName(outerType,innerType,wrapperName){var displayName=outerType.displayName;if(displayName)return displayName;var functionName=innerType.displayName||innerType.name||"";return functionName!==""?wrapperName+"("+functionName+")":wrapperName}function getContextName(type){return type.displayName||"Context"}function getComponentNameFromType(type){if(type==null)return null;if(typeof type.tag=="number"&&error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."),typeof type=="function")return type.displayName||type.name||null;if(typeof type=="string")return type;switch(type){case REACT_FRAGMENT_TYPE:return"Fragment";case REACT_PORTAL_TYPE:return"Portal";case REACT_PROFILER_TYPE:return"Profiler";case REACT_STRICT_MODE_TYPE:return"StrictMode";case REACT_SUSPENSE_TYPE:return"Suspense";case REACT_SUSPENSE_LIST_TYPE:return"SuspenseList"}if(typeof type=="object")switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context2=type;return getContextName(context2)+".Consumer";case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+".Provider";case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,"ForwardRef");case REACT_MEMO_TYPE:var outerName=type.displayName||null;return outerName!==null?outerName:getComponentNameFromType(type.type)||"Memo";case REACT_LAZY_TYPE:{var lazyComponent=type,payload=lazyComponent._payload,init=lazyComponent._init;try{return getComponentNameFromType(init(payload))}catch{return null}}}return null}var assign=Object.assign,disabledDepth=0,prevLog,prevInfo,prevWarn,prevError,prevGroup,prevGroupCollapsed,prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=!0;function disableLogs(){{if(disabledDepth===0){prevLog=console.log,prevInfo=console.info,prevWarn=console.warn,prevError=console.error,prevGroup=console.group,prevGroupCollapsed=console.groupCollapsed,prevGroupEnd=console.groupEnd;var props={configurable:!0,enumerable:!0,value:disabledLog,writable:!0};Object.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props})}disabledDepth++}}function reenableLogs(){{if(disabledDepth--,disabledDepth===0){var props={configurable:!0,enumerable:!0,writable:!0};Object.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})})}disabledDepth<0&&error("disabledDepth fell below zero. This is a bug in React. Please file an issue.")}}var ReactCurrentDispatcher2=ReactSharedInternals.ReactCurrentDispatcher,prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===void 0)try{throw Error()}catch(x2){var match=x2.stack.trim().match(/\n( *(at )?)/);prefix=match&&match[1]||""}return`
`+prefix+name}}var reentry=!1,componentFrameCache;{var PossiblyWeakMap=typeof WeakMap=="function"?WeakMap:Map;componentFrameCache=new PossiblyWeakMap}function describeNativeComponentFrame(fn,construct){if(!fn||reentry)return"";{var frame2=componentFrameCache.get(fn);if(frame2!==void 0)return frame2}var control;reentry=!0;var previousPrepareStackTrace=Error.prepareStackTrace;Error.prepareStackTrace=void 0;var previousDispatcher;previousDispatcher=ReactCurrentDispatcher2.current,ReactCurrentDispatcher2.current=null,disableLogs();try{if(construct){var Fake=function(){throw Error()};if(Object.defineProperty(Fake.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Fake,[])}catch(x2){control=x2}Reflect.construct(fn,[],Fake)}else{try{Fake.call()}catch(x2){control=x2}fn.call(Fake.prototype)}}else{try{throw Error()}catch(x2){control=x2}fn()}}catch(sample){if(sample&&control&&typeof sample.stack=="string"){for(var sampleLines=sample.stack.split(`
`),controlLines=control.stack.split(`
`),s2=sampleLines.length-1,c2=controlLines.length-1;s2>=1&&c2>=0&&sampleLines[s2]!==controlLines[c2];)c2--;for(;s2>=1&&c2>=0;s2--,c2--)if(sampleLines[s2]!==controlLines[c2]){if(s2!==1||c2!==1)do if(s2--,c2--,c2<0||sampleLines[s2]!==controlLines[c2]){var _frame=`
`+sampleLines[s2].replace(" at new "," at ");return fn.displayName&&_frame.includes("<anonymous>")&&(_frame=_frame.replace("<anonymous>",fn.displayName)),typeof fn=="function"&&componentFrameCache.set(fn,_frame),_frame}while(s2>=1&&c2>=0);break}}}finally{reentry=!1,ReactCurrentDispatcher2.current=previousDispatcher,reenableLogs(),Error.prepareStackTrace=previousPrepareStackTrace}var name=fn?fn.displayName||fn.name:"",syntheticFrame=name?describeBuiltInComponentFrame(name):"";return typeof fn=="function"&&componentFrameCache.set(fn,syntheticFrame),syntheticFrame}function describeFunctionComponentFrame(fn,source,ownerFn){return describeNativeComponentFrame(fn,!1)}function shouldConstruct(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent)}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null)return"";if(typeof type=="function")return describeNativeComponentFrame(type,shouldConstruct(type));if(typeof type=="string")return describeBuiltInComponentFrame(type);switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame("Suspense");case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame("SuspenseList")}if(typeof type=="object")switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:return describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:{var lazyComponent=type,payload=lazyComponent._payload,init=lazyComponent._init;try{return describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn)}catch{}}}return""}var hasOwnProperty=Object.prototype.hasOwnProperty,loggedTypeFailures={},ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){if(element){var owner=element._owner,stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame.setExtraStackFrame(stack)}else ReactDebugCurrentFrame.setExtraStackFrame(null)}function checkPropTypes(typeSpecs,values,location,componentName,element){{var has=Function.call.bind(hasOwnProperty);for(var typeSpecName in typeSpecs)if(has(typeSpecs,typeSpecName)){var error$1=void 0;try{if(typeof typeSpecs[typeSpecName]!="function"){var err=Error((componentName||"React class")+": "+location+" type `"+typeSpecName+"` is invalid; it must be a function, usually from the `prop-types` package, but received `"+typeof typeSpecs[typeSpecName]+"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");throw err.name="Invariant Violation",err}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(ex){error$1=ex}error$1&&!(error$1 instanceof Error)&&(setCurrentlyValidatingElement(element),error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).",componentName||"React class",location,typeSpecName,typeof error$1),setCurrentlyValidatingElement(null)),error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)&&(loggedTypeFailures[error$1.message]=!0,setCurrentlyValidatingElement(element),error("Failed %s type: %s",location,error$1.message),setCurrentlyValidatingElement(null))}}}var isArrayImpl=Array.isArray;function isArray(a2){return isArrayImpl(a2)}function typeName(value){{var hasToStringTag=typeof Symbol=="function"&&Symbol.toStringTag,type=hasToStringTag&&value[Symbol.toStringTag]||value.constructor.name||"Object";return type}}function willCoercionThrow(value){try{return testStringCoercion(value),!1}catch{return!0}}function testStringCoercion(value){return""+value}function checkKeyStringCoercion(value){if(willCoercionThrow(value))return error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.",typeName(value)),testStringCoercion(value)}var ReactCurrentOwner2=ReactSharedInternals.ReactCurrentOwner,RESERVED_PROPS={key:!0,ref:!0,__self:!0,__source:!0},specialPropKeyWarningShown,specialPropRefWarningShown,didWarnAboutStringRefs;didWarnAboutStringRefs={};function hasValidRef(config){if(hasOwnProperty.call(config,"ref")){var getter=Object.getOwnPropertyDescriptor(config,"ref").get;if(getter&&getter.isReactWarning)return!1}return config.ref!==void 0}function hasValidKey(config){if(hasOwnProperty.call(config,"key")){var getter=Object.getOwnPropertyDescriptor(config,"key").get;if(getter&&getter.isReactWarning)return!1}return config.key!==void 0}function warnIfStringRefCannotBeAutoConverted(config,self2){if(typeof config.ref=="string"&&ReactCurrentOwner2.current&&self2&&ReactCurrentOwner2.current.stateNode!==self2){var componentName=getComponentNameFromType(ReactCurrentOwner2.current.type);didWarnAboutStringRefs[componentName]||(error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',getComponentNameFromType(ReactCurrentOwner2.current.type),config.ref),didWarnAboutStringRefs[componentName]=!0)}}function defineKeyPropWarningGetter(props,displayName){{var warnAboutAccessingKey=function(){specialPropKeyWarningShown||(specialPropKeyWarningShown=!0,error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)",displayName))};warnAboutAccessingKey.isReactWarning=!0,Object.defineProperty(props,"key",{get:warnAboutAccessingKey,configurable:!0})}}function defineRefPropWarningGetter(props,displayName){{var warnAboutAccessingRef=function(){specialPropRefWarningShown||(specialPropRefWarningShown=!0,error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)",displayName))};warnAboutAccessingRef.isReactWarning=!0,Object.defineProperty(props,"ref",{get:warnAboutAccessingRef,configurable:!0})}}var ReactElement=function(type,key,ref,self2,source,owner,props){var element={$$typeof:REACT_ELEMENT_TYPE,type,key,ref,props,_owner:owner};return element._store={},Object.defineProperty(element._store,"validated",{configurable:!1,enumerable:!1,writable:!0,value:!1}),Object.defineProperty(element,"_self",{configurable:!1,enumerable:!1,writable:!1,value:self2}),Object.defineProperty(element,"_source",{configurable:!1,enumerable:!1,writable:!1,value:source}),Object.freeze&&(Object.freeze(element.props),Object.freeze(element)),element};function jsxDEV(type,config,maybeKey,source,self2){{var propName,props={},key=null,ref=null;maybeKey!==void 0&&(checkKeyStringCoercion(maybeKey),key=""+maybeKey),hasValidKey(config)&&(checkKeyStringCoercion(config.key),key=""+config.key),hasValidRef(config)&&(ref=config.ref,warnIfStringRefCannotBeAutoConverted(config,self2));for(propName in config)hasOwnProperty.call(config,propName)&&!RESERVED_PROPS.hasOwnProperty(propName)&&(props[propName]=config[propName]);if(type&&type.defaultProps){var defaultProps=type.defaultProps;for(propName in defaultProps)props[propName]===void 0&&(props[propName]=defaultProps[propName])}if(key||ref){var displayName=typeof type=="function"?type.displayName||type.name||"Unknown":type;key&&defineKeyPropWarningGetter(props,displayName),ref&&defineRefPropWarningGetter(props,displayName)}return ReactElement(type,key,ref,self2,source,ReactCurrentOwner2.current,props)}}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner,ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement$1(element){if(element){var owner=element._owner,stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame$1.setExtraStackFrame(stack)}else ReactDebugCurrentFrame$1.setExtraStackFrame(null)}var propTypesMisspellWarningShown;propTypesMisspellWarningShown=!1;function isValidElement(object){return typeof object=="object"&&object!==null&&object.$$typeof===REACT_ELEMENT_TYPE}function getDeclarationErrorAddendum(){{if(ReactCurrentOwner$1.current){var name=getComponentNameFromType(ReactCurrentOwner$1.current.type);if(name)return`

Check the render method of \``+name+"`."}return""}}function getSourceInfoErrorAddendum(source){{if(source!==void 0){var fileName=source.fileName.replace(/^.*[\\\/]/,""),lineNumber=source.lineNumber;return`

Check your code at `+fileName+":"+lineNumber+"."}return""}}var ownerHasKeyUseWarning={};function getCurrentComponentErrorInfo(parentType){{var info=getDeclarationErrorAddendum();if(!info){var parentName=typeof parentType=="string"?parentType:parentType.displayName||parentType.name;parentName&&(info=`

Check the top-level render call using <`+parentName+">.")}return info}}function validateExplicitKey(element,parentType){{if(!element._store||element._store.validated||element.key!=null)return;element._store.validated=!0;var currentComponentErrorInfo=getCurrentComponentErrorInfo(parentType);if(ownerHasKeyUseWarning[currentComponentErrorInfo])return;ownerHasKeyUseWarning[currentComponentErrorInfo]=!0;var childOwner="";element&&element._owner&&element._owner!==ReactCurrentOwner$1.current&&(childOwner=" It was passed a child from "+getComponentNameFromType(element._owner.type)+"."),setCurrentlyValidatingElement$1(element),error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',currentComponentErrorInfo,childOwner),setCurrentlyValidatingElement$1(null)}}function validateChildKeys(node,parentType){{if(typeof node!="object")return;if(isArray(node))for(var i2=0;i2<node.length;i2++){var child=node[i2];isValidElement(child)&&validateExplicitKey(child,parentType)}else if(isValidElement(node))node._store&&(node._store.validated=!0);else if(node){var iteratorFn=getIteratorFn(node);if(typeof iteratorFn=="function"&&iteratorFn!==node.entries)for(var iterator=iteratorFn.call(node),step;!(step=iterator.next()).done;)isValidElement(step.value)&&validateExplicitKey(step.value,parentType)}}}function validatePropTypes(element){{var type=element.type;if(type==null||typeof type=="string")return;var propTypes;if(typeof type=="function")propTypes=type.propTypes;else if(typeof type=="object"&&(type.$$typeof===REACT_FORWARD_REF_TYPE||type.$$typeof===REACT_MEMO_TYPE))propTypes=type.propTypes;else return;if(propTypes){var name=getComponentNameFromType(type);checkPropTypes(propTypes,element.props,"prop",name,element)}else if(type.PropTypes!==void 0&&!propTypesMisspellWarningShown){propTypesMisspellWarningShown=!0;var _name=getComponentNameFromType(type);error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?",_name||"Unknown")}typeof type.getDefaultProps=="function"&&!type.getDefaultProps.isReactClassApproved&&error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.")}}function validateFragmentProps(fragment2){{for(var keys2=Object.keys(fragment2.props),i2=0;i2<keys2.length;i2++){var key=keys2[i2];if(key!=="children"&&key!=="key"){setCurrentlyValidatingElement$1(fragment2),error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",key),setCurrentlyValidatingElement$1(null);break}}fragment2.ref!==null&&(setCurrentlyValidatingElement$1(fragment2),error("Invalid attribute `ref` supplied to `React.Fragment`."),setCurrentlyValidatingElement$1(null))}}function jsxWithValidation(type,props,key,isStaticChildren,source,self2){{var validType=isValidElementType(type);if(!validType){var info="";(type===void 0||typeof type=="object"&&type!==null&&Object.keys(type).length===0)&&(info+=" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");var sourceInfo=getSourceInfoErrorAddendum(source);sourceInfo?info+=sourceInfo:info+=getDeclarationErrorAddendum();var typeString;type===null?typeString="null":isArray(type)?typeString="array":type!==void 0&&type.$$typeof===REACT_ELEMENT_TYPE?(typeString="<"+(getComponentNameFromType(type.type)||"Unknown")+" />",info=" Did you accidentally export a JSX literal instead of a component?"):typeString=typeof type,error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",typeString,info)}var element=jsxDEV(type,props,key,source,self2);if(element==null)return element;if(validType){var children=props.children;if(children!==void 0)if(isStaticChildren)if(isArray(children)){for(var i2=0;i2<children.length;i2++)validateChildKeys(children[i2],type);Object.freeze&&Object.freeze(children)}else error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");else validateChildKeys(children,type)}return type===REACT_FRAGMENT_TYPE?validateFragmentProps(element):validatePropTypes(element),element}}var jsxDEV$1=jsxWithValidation;reactJsxDevRuntime_development.Fragment=REACT_FRAGMENT_TYPE,reactJsxDevRuntime_development.jsxDEV=jsxDEV$1})();jsxDevRuntime.exports=reactJsxDevRuntime_development;var jsxDevRuntimeExports=jsxDevRuntime.exports;const s=getDefaultExportFromCjs(jsxDevRuntimeExports);var reactDom={exports:{}},reactDom_development={},scheduler$1={exports:{}},scheduler_development$1={};/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(exports){(function(){typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart=="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);var enableSchedulerDebugging=!1,enableProfiling=!1,frameYieldMs=5;function push(heap,node){var index=heap.length;heap.push(node),siftUp(heap,node,index)}function peek(heap){return heap.length===0?null:heap[0]}function pop(heap){if(heap.length===0)return null;var first=heap[0],last=heap.pop();return last!==first&&(heap[0]=last,siftDown(heap,last,0)),first}function siftUp(heap,node,i2){for(var index=i2;index>0;){var parentIndex=index-1>>>1,parent=heap[parentIndex];if(compare(parent,node)>0)heap[parentIndex]=node,heap[index]=parent,index=parentIndex;else return}}function siftDown(heap,node,i2){for(var index=i2,length=heap.length,halfLength=length>>>1;index<halfLength;){var leftIndex=(index+1)*2-1,left=heap[leftIndex],rightIndex=leftIndex+1,right=heap[rightIndex];if(compare(left,node)<0)rightIndex<length&&compare(right,left)<0?(heap[index]=right,heap[rightIndex]=node,index=rightIndex):(heap[index]=left,heap[leftIndex]=node,index=leftIndex);else if(rightIndex<length&&compare(right,node)<0)heap[index]=right,heap[rightIndex]=node,index=rightIndex;else return}}function compare(a2,b2){var diff=a2.sortIndex-b2.sortIndex;return diff!==0?diff:a2.id-b2.id}var ImmediatePriority=1,UserBlockingPriority=2,NormalPriority=3,LowPriority=4,IdlePriority=5;function markTaskErrored(task,ms){}var hasPerformanceNow=typeof performance=="object"&&typeof performance.now=="function";if(hasPerformanceNow){var localPerformance=performance;exports.unstable_now=function(){return localPerformance.now()}}else{var localDate=Date,initialTime=localDate.now();exports.unstable_now=function(){return localDate.now()-initialTime}}var maxSigned31BitInt=1073741823,IMMEDIATE_PRIORITY_TIMEOUT=-1,USER_BLOCKING_PRIORITY_TIMEOUT=250,NORMAL_PRIORITY_TIMEOUT=5e3,LOW_PRIORITY_TIMEOUT=1e4,IDLE_PRIORITY_TIMEOUT=maxSigned31BitInt,taskQueue=[],timerQueue=[],taskIdCounter=1,currentTask=null,currentPriorityLevel=NormalPriority,isPerformingWork=!1,isHostCallbackScheduled=!1,isHostTimeoutScheduled=!1,localSetTimeout=typeof setTimeout=="function"?setTimeout:null,localClearTimeout=typeof clearTimeout=="function"?clearTimeout:null,localSetImmediate=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function advanceTimers(currentTime){for(var timer=peek(timerQueue);timer!==null;){if(timer.callback===null)pop(timerQueue);else if(timer.startTime<=currentTime)pop(timerQueue),timer.sortIndex=timer.expirationTime,push(taskQueue,timer);else return;timer=peek(timerQueue)}}function handleTimeout(currentTime){if(isHostTimeoutScheduled=!1,advanceTimers(currentTime),!isHostCallbackScheduled)if(peek(taskQueue)!==null)isHostCallbackScheduled=!0,requestHostCallback(flushWork);else{var firstTimer=peek(timerQueue);firstTimer!==null&&requestHostTimeout(handleTimeout,firstTimer.startTime-currentTime)}}function flushWork(hasTimeRemaining,initialTime2){isHostCallbackScheduled=!1,isHostTimeoutScheduled&&(isHostTimeoutScheduled=!1,cancelHostTimeout()),isPerformingWork=!0;var previousPriorityLevel=currentPriorityLevel;try{var currentTime;if(!enableProfiling)return workLoop(hasTimeRemaining,initialTime2)}finally{currentTask=null,currentPriorityLevel=previousPriorityLevel,isPerformingWork=!1}}function workLoop(hasTimeRemaining,initialTime2){var currentTime=initialTime2;for(advanceTimers(currentTime),currentTask=peek(taskQueue);currentTask!==null&&!enableSchedulerDebugging&&!(currentTask.expirationTime>currentTime&&(!hasTimeRemaining||shouldYieldToHost()));){var callback=currentTask.callback;if(typeof callback=="function"){currentTask.callback=null,currentPriorityLevel=currentTask.priorityLevel;var didUserCallbackTimeout=currentTask.expirationTime<=currentTime,continuationCallback=callback(didUserCallbackTimeout);currentTime=exports.unstable_now(),typeof continuationCallback=="function"?currentTask.callback=continuationCallback:currentTask===peek(taskQueue)&&pop(taskQueue),advanceTimers(currentTime)}else pop(taskQueue);currentTask=peek(taskQueue)}if(currentTask!==null)return!0;var firstTimer=peek(timerQueue);return firstTimer!==null&&requestHostTimeout(handleTimeout,firstTimer.startTime-currentTime),!1}function unstable_runWithPriority(priorityLevel,eventHandler){switch(priorityLevel){case ImmediatePriority:case UserBlockingPriority:case NormalPriority:case LowPriority:case IdlePriority:break;default:priorityLevel=NormalPriority}var previousPriorityLevel=currentPriorityLevel;currentPriorityLevel=priorityLevel;try{return eventHandler()}finally{currentPriorityLevel=previousPriorityLevel}}function unstable_next(eventHandler){var priorityLevel;switch(currentPriorityLevel){case ImmediatePriority:case UserBlockingPriority:case NormalPriority:priorityLevel=NormalPriority;break;default:priorityLevel=currentPriorityLevel;break}var previousPriorityLevel=currentPriorityLevel;currentPriorityLevel=priorityLevel;try{return eventHandler()}finally{currentPriorityLevel=previousPriorityLevel}}function unstable_wrapCallback(callback){var parentPriorityLevel=currentPriorityLevel;return function(){var previousPriorityLevel=currentPriorityLevel;currentPriorityLevel=parentPriorityLevel;try{return callback.apply(this,arguments)}finally{currentPriorityLevel=previousPriorityLevel}}}function unstable_scheduleCallback(priorityLevel,callback,options){var currentTime=exports.unstable_now(),startTime2;if(typeof options=="object"&&options!==null){var delay2=options.delay;typeof delay2=="number"&&delay2>0?startTime2=currentTime+delay2:startTime2=currentTime}else startTime2=currentTime;var timeout;switch(priorityLevel){case ImmediatePriority:timeout=IMMEDIATE_PRIORITY_TIMEOUT;break;case UserBlockingPriority:timeout=USER_BLOCKING_PRIORITY_TIMEOUT;break;case IdlePriority:timeout=IDLE_PRIORITY_TIMEOUT;break;case LowPriority:timeout=LOW_PRIORITY_TIMEOUT;break;case NormalPriority:default:timeout=NORMAL_PRIORITY_TIMEOUT;break}var expirationTime=startTime2+timeout,newTask={id:taskIdCounter++,callback,priorityLevel,startTime:startTime2,expirationTime,sortIndex:-1};return startTime2>currentTime?(newTask.sortIndex=startTime2,push(timerQueue,newTask),peek(taskQueue)===null&&newTask===peek(timerQueue)&&(isHostTimeoutScheduled?cancelHostTimeout():isHostTimeoutScheduled=!0,requestHostTimeout(handleTimeout,startTime2-currentTime))):(newTask.sortIndex=expirationTime,push(taskQueue,newTask),!isHostCallbackScheduled&&!isPerformingWork&&(isHostCallbackScheduled=!0,requestHostCallback(flushWork))),newTask}function unstable_pauseExecution(){}function unstable_continueExecution(){!isHostCallbackScheduled&&!isPerformingWork&&(isHostCallbackScheduled=!0,requestHostCallback(flushWork))}function unstable_getFirstCallbackNode(){return peek(taskQueue)}function unstable_cancelCallback(task){task.callback=null}function unstable_getCurrentPriorityLevel(){return currentPriorityLevel}var isMessageLoopRunning=!1,scheduledHostCallback=null,taskTimeoutID=-1,frameInterval=frameYieldMs,startTime=-1;function shouldYieldToHost(){var timeElapsed=exports.unstable_now()-startTime;return!(timeElapsed<frameInterval)}function requestPaint(){}function forceFrameRate(fps){if(fps<0||fps>125){console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");return}fps>0?frameInterval=Math.floor(1e3/fps):frameInterval=frameYieldMs}var performWorkUntilDeadline=function(){if(scheduledHostCallback!==null){var currentTime=exports.unstable_now();startTime=currentTime;var hasTimeRemaining=!0,hasMoreWork=!0;try{hasMoreWork=scheduledHostCallback(hasTimeRemaining,currentTime)}finally{hasMoreWork?schedulePerformWorkUntilDeadline():(isMessageLoopRunning=!1,scheduledHostCallback=null)}}else isMessageLoopRunning=!1},schedulePerformWorkUntilDeadline;if(typeof localSetImmediate=="function")schedulePerformWorkUntilDeadline=function(){localSetImmediate(performWorkUntilDeadline)};else if(typeof MessageChannel<"u"){var channel=new MessageChannel,port=channel.port2;channel.port1.onmessage=performWorkUntilDeadline,schedulePerformWorkUntilDeadline=function(){port.postMessage(null)}}else schedulePerformWorkUntilDeadline=function(){localSetTimeout(performWorkUntilDeadline,0)};function requestHostCallback(callback){scheduledHostCallback=callback,isMessageLoopRunning||(isMessageLoopRunning=!0,schedulePerformWorkUntilDeadline())}function requestHostTimeout(callback,ms){taskTimeoutID=localSetTimeout(function(){callback(exports.unstable_now())},ms)}function cancelHostTimeout(){localClearTimeout(taskTimeoutID),taskTimeoutID=-1}var unstable_requestPaint=requestPaint,unstable_Profiling=null;exports.unstable_IdlePriority=IdlePriority,exports.unstable_ImmediatePriority=ImmediatePriority,exports.unstable_LowPriority=LowPriority,exports.unstable_NormalPriority=NormalPriority,exports.unstable_Profiling=unstable_Profiling,exports.unstable_UserBlockingPriority=UserBlockingPriority,exports.unstable_cancelCallback=unstable_cancelCallback,exports.unstable_continueExecution=unstable_continueExecution,exports.unstable_forceFrameRate=forceFrameRate,exports.unstable_getCurrentPriorityLevel=unstable_getCurrentPriorityLevel,exports.unstable_getFirstCallbackNode=unstable_getFirstCallbackNode,exports.unstable_next=unstable_next,exports.unstable_pauseExecution=unstable_pauseExecution,exports.unstable_requestPaint=unstable_requestPaint,exports.unstable_runWithPriority=unstable_runWithPriority,exports.unstable_scheduleCallback=unstable_scheduleCallback,exports.unstable_shouldYield=shouldYieldToHost,exports.unstable_wrapCallback=unstable_wrapCallback,typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop=="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error)})()})(scheduler_development$1);scheduler$1.exports=scheduler_development$1;var schedulerExports$1=scheduler$1.exports;/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(){typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart=="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);var React=reactExports,Scheduler=schedulerExports$1,ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,suppressWarning=!1;function setSuppressWarning(newSuppressWarning){suppressWarning=newSuppressWarning}function warn(format){if(!suppressWarning){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];printWarning("warn",format,args)}}function error(format){if(!suppressWarning){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++)args[_key2-1]=arguments[_key2];printWarning("error",format,args)}}function printWarning(level,format,args){{var ReactDebugCurrentFrame2=ReactSharedInternals.ReactDebugCurrentFrame,stack=ReactDebugCurrentFrame2.getStackAddendum();stack!==""&&(format+="%s",args=args.concat([stack]));var argsWithFormat=args.map(function(item){return String(item)});argsWithFormat.unshift("Warning: "+format),Function.prototype.apply.call(console[level],console,argsWithFormat)}}var FunctionComponent=0,ClassComponent=1,IndeterminateComponent=2,HostRoot=3,HostPortal=4,HostComponent=5,HostText=6,Fragment=7,Mode=8,ContextConsumer=9,ContextProvider=10,ForwardRef=11,Profiler=12,SuspenseComponent=13,MemoComponent=14,SimpleMemoComponent=15,LazyComponent=16,IncompleteClassComponent=17,DehydratedFragment=18,SuspenseListComponent=19,ScopeComponent=21,OffscreenComponent=22,LegacyHiddenComponent=23,CacheComponent=24,TracingMarkerComponent=25,enableClientRenderFallbackOnTextMismatch=!0,enableNewReconciler=!1,enableLazyContextPropagation=!1,enableLegacyHidden=!1,enableSuspenseAvoidThisFallback=!1,disableCommentsAsDOMContainers=!0,enableCustomElementPropertySupport=!1,warnAboutStringRefs=!1,enableSchedulingProfiler=!0,enableProfilerTimer=!0,enableProfilerCommitHooks=!0,allNativeEvents=new Set,registrationNameDependencies={},possibleRegistrationNames={};function registerTwoPhaseEvent(registrationName,dependencies){registerDirectEvent(registrationName,dependencies),registerDirectEvent(registrationName+"Capture",dependencies)}function registerDirectEvent(registrationName,dependencies){registrationNameDependencies[registrationName]&&error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",registrationName),registrationNameDependencies[registrationName]=dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName,registrationName==="onDoubleClick"&&(possibleRegistrationNames.ondblclick=registrationName)}for(var i2=0;i2<dependencies.length;i2++)allNativeEvents.add(dependencies[i2])}var canUseDOM=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u",hasOwnProperty=Object.prototype.hasOwnProperty;function typeName(value){{var hasToStringTag=typeof Symbol=="function"&&Symbol.toStringTag,type=hasToStringTag&&value[Symbol.toStringTag]||value.constructor.name||"Object";return type}}function willCoercionThrow(value){try{return testStringCoercion(value),!1}catch{return!0}}function testStringCoercion(value){return""+value}function checkAttributeStringCoercion(value,attributeName){if(willCoercionThrow(value))return error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.",attributeName,typeName(value)),testStringCoercion(value)}function checkKeyStringCoercion(value){if(willCoercionThrow(value))return error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.",typeName(value)),testStringCoercion(value)}function checkPropStringCoercion(value,propName){if(willCoercionThrow(value))return error("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.",propName,typeName(value)),testStringCoercion(value)}function checkCSSPropertyStringCoercion(value,propName){if(willCoercionThrow(value))return error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.",propName,typeName(value)),testStringCoercion(value)}function checkHtmlStringCoercion(value){if(willCoercionThrow(value))return error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.",typeName(value)),testStringCoercion(value)}function checkFormFieldValueStringCoercion(value){if(willCoercionThrow(value))return error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.",typeName(value)),testStringCoercion(value)}var RESERVED=0,STRING=1,BOOLEANISH_STRING=2,BOOLEAN=3,OVERLOADED_BOOLEAN=4,NUMERIC=5,POSITIVE_NUMERIC=6,ATTRIBUTE_NAME_START_CHAR=":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD",ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+"\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040",VALID_ATTRIBUTE_NAME_REGEX=new RegExp("^["+ATTRIBUTE_NAME_START_CHAR+"]["+ATTRIBUTE_NAME_CHAR+"]*$"),illegalAttributeNameCache={},validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){return hasOwnProperty.call(validatedAttributeNameCache,attributeName)?!0:hasOwnProperty.call(illegalAttributeNameCache,attributeName)?!1:VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)?(validatedAttributeNameCache[attributeName]=!0,!0):(illegalAttributeNameCache[attributeName]=!0,error("Invalid attribute name: `%s`",attributeName),!1)}function shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag){return propertyInfo!==null?propertyInfo.type===RESERVED:isCustomComponentTag?!1:name.length>2&&(name[0]==="o"||name[0]==="O")&&(name[1]==="n"||name[1]==="N")}function shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag){if(propertyInfo!==null&&propertyInfo.type===RESERVED)return!1;switch(typeof value){case"function":case"symbol":return!0;case"boolean":{if(isCustomComponentTag)return!1;if(propertyInfo!==null)return!propertyInfo.acceptsBooleans;var prefix2=name.toLowerCase().slice(0,5);return prefix2!=="data-"&&prefix2!=="aria-"}default:return!1}}function shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag){if(value===null||typeof value>"u"||shouldRemoveAttributeWithWarning(name,value,propertyInfo,isCustomComponentTag))return!0;if(isCustomComponentTag)return!1;if(propertyInfo!==null)switch(propertyInfo.type){case BOOLEAN:return!value;case OVERLOADED_BOOLEAN:return value===!1;case NUMERIC:return isNaN(value);case POSITIVE_NUMERIC:return isNaN(value)||value<1}return!1}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null}function PropertyInfoRecord(name,type,mustUseProperty,attributeName,attributeNamespace,sanitizeURL2,removeEmptyString){this.acceptsBooleans=type===BOOLEANISH_STRING||type===BOOLEAN||type===OVERLOADED_BOOLEAN,this.attributeName=attributeName,this.attributeNamespace=attributeNamespace,this.mustUseProperty=mustUseProperty,this.propertyName=name,this.type=type,this.sanitizeURL=sanitizeURL2,this.removeEmptyString=removeEmptyString}var properties={},reservedProps=["children","dangerouslySetInnerHTML","defaultValue","defaultChecked","innerHTML","suppressContentEditableWarning","suppressHydrationWarning","style"];reservedProps.forEach(function(name){properties[name]=new PropertyInfoRecord(name,RESERVED,!1,name,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(_ref){var name=_ref[0],attributeName=_ref[1];properties[name]=new PropertyInfoRecord(name,STRING,!1,attributeName,null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,!1,name.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEANISH_STRING,!1,name,null,!1,!1)}),["allowFullScreen","async","autoFocus","autoPlay","controls","default","defer","disabled","disablePictureInPicture","disableRemotePlayback","formNoValidate","hidden","loop","noModule","noValidate","open","playsInline","readOnly","required","reversed","scoped","seamless","itemScope"].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,!1,name.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(name){properties[name]=new PropertyInfoRecord(name,BOOLEAN,!0,name,null,!1,!1)}),["capture","download"].forEach(function(name){properties[name]=new PropertyInfoRecord(name,OVERLOADED_BOOLEAN,!1,name,null,!1,!1)}),["cols","rows","size","span"].forEach(function(name){properties[name]=new PropertyInfoRecord(name,POSITIVE_NUMERIC,!1,name,null,!1,!1)}),["rowSpan","start"].forEach(function(name){properties[name]=new PropertyInfoRecord(name,NUMERIC,!1,name.toLowerCase(),null,!1,!1)});var CAMELIZE=/[\-\:]([a-z])/g,capitalize=function(token){return token[1].toUpperCase()};["accent-height","alignment-baseline","arabic-form","baseline-shift","cap-height","clip-path","clip-rule","color-interpolation","color-interpolation-filters","color-profile","color-rendering","dominant-baseline","enable-background","fill-opacity","fill-rule","flood-color","flood-opacity","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","glyph-name","glyph-orientation-horizontal","glyph-orientation-vertical","horiz-adv-x","horiz-origin-x","image-rendering","letter-spacing","lighting-color","marker-end","marker-mid","marker-start","overline-position","overline-thickness","paint-order","panose-1","pointer-events","rendering-intent","shape-rendering","stop-color","stop-opacity","strikethrough-position","strikethrough-thickness","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","text-anchor","text-decoration","text-rendering","underline-position","underline-thickness","unicode-bidi","unicode-range","units-per-em","v-alphabetic","v-hanging","v-ideographic","v-mathematical","vector-effect","vert-adv-y","vert-origin-x","vert-origin-y","word-spacing","writing-mode","xmlns:xlink","x-height"].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,!1,attributeName,null,!1,!1)}),["xlink:actuate","xlink:arcrole","xlink:role","xlink:show","xlink:title","xlink:type"].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,!1,attributeName,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(attributeName){var name=attributeName.replace(CAMELIZE,capitalize);properties[name]=new PropertyInfoRecord(name,STRING,!1,attributeName,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,!1,attributeName.toLowerCase(),null,!1,!1)});var xlinkHref="xlinkHref";properties[xlinkHref]=new PropertyInfoRecord("xlinkHref",STRING,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(attributeName){properties[attributeName]=new PropertyInfoRecord(attributeName,STRING,!1,attributeName.toLowerCase(),null,!0,!0)});var isJavaScriptProtocol=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i,didWarn=!1;function sanitizeURL(url){!didWarn&&isJavaScriptProtocol.test(url)&&(didWarn=!0,error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.",JSON.stringify(url)))}function getValueForProperty(node,name,expected,propertyInfo){if(propertyInfo.mustUseProperty){var propertyName=propertyInfo.propertyName;return node[propertyName]}else{checkAttributeStringCoercion(expected,name),propertyInfo.sanitizeURL&&sanitizeURL(""+expected);var attributeName=propertyInfo.attributeName,stringValue=null;if(propertyInfo.type===OVERLOADED_BOOLEAN){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);return value===""?!0:shouldRemoveAttribute(name,expected,propertyInfo,!1)?value:value===""+expected?expected:value}}else if(node.hasAttribute(attributeName)){if(shouldRemoveAttribute(name,expected,propertyInfo,!1))return node.getAttribute(attributeName);if(propertyInfo.type===BOOLEAN)return expected;stringValue=node.getAttribute(attributeName)}return shouldRemoveAttribute(name,expected,propertyInfo,!1)?stringValue===null?expected:stringValue:stringValue===""+expected?expected:stringValue}}function getValueForAttribute(node,name,expected,isCustomComponentTag){{if(!isAttributeNameSafe(name))return;if(!node.hasAttribute(name))return expected===void 0?void 0:null;var value=node.getAttribute(name);return checkAttributeStringCoercion(expected,name),value===""+expected?expected:value}}function setValueForProperty(node,name,value,isCustomComponentTag){var propertyInfo=getPropertyInfo(name);if(!shouldIgnoreAttribute(name,propertyInfo,isCustomComponentTag)){if(shouldRemoveAttribute(name,value,propertyInfo,isCustomComponentTag)&&(value=null),isCustomComponentTag||propertyInfo===null){if(isAttributeNameSafe(name)){var _attributeName=name;value===null?node.removeAttribute(_attributeName):(checkAttributeStringCoercion(value,name),node.setAttribute(_attributeName,""+value))}return}var mustUseProperty=propertyInfo.mustUseProperty;if(mustUseProperty){var propertyName=propertyInfo.propertyName;if(value===null){var type=propertyInfo.type;node[propertyName]=type===BOOLEAN?!1:""}else node[propertyName]=value;return}var attributeName=propertyInfo.attributeName,attributeNamespace=propertyInfo.attributeNamespace;if(value===null)node.removeAttribute(attributeName);else{var _type=propertyInfo.type,attributeValue;_type===BOOLEAN||_type===OVERLOADED_BOOLEAN&&value===!0?attributeValue="":(checkAttributeStringCoercion(value,attributeName),attributeValue=""+value,propertyInfo.sanitizeURL&&sanitizeURL(attributeValue.toString())),attributeNamespace?node.setAttributeNS(attributeNamespace,attributeName,attributeValue):node.setAttribute(attributeName,attributeValue)}}}var REACT_ELEMENT_TYPE=Symbol.for("react.element"),REACT_PORTAL_TYPE=Symbol.for("react.portal"),REACT_FRAGMENT_TYPE=Symbol.for("react.fragment"),REACT_STRICT_MODE_TYPE=Symbol.for("react.strict_mode"),REACT_PROFILER_TYPE=Symbol.for("react.profiler"),REACT_PROVIDER_TYPE=Symbol.for("react.provider"),REACT_CONTEXT_TYPE=Symbol.for("react.context"),REACT_FORWARD_REF_TYPE=Symbol.for("react.forward_ref"),REACT_SUSPENSE_TYPE=Symbol.for("react.suspense"),REACT_SUSPENSE_LIST_TYPE=Symbol.for("react.suspense_list"),REACT_MEMO_TYPE=Symbol.for("react.memo"),REACT_LAZY_TYPE=Symbol.for("react.lazy"),REACT_SCOPE_TYPE=Symbol.for("react.scope"),REACT_DEBUG_TRACING_MODE_TYPE=Symbol.for("react.debug_trace_mode"),REACT_OFFSCREEN_TYPE=Symbol.for("react.offscreen"),REACT_LEGACY_HIDDEN_TYPE=Symbol.for("react.legacy_hidden"),REACT_CACHE_TYPE=Symbol.for("react.cache"),REACT_TRACING_MARKER_TYPE=Symbol.for("react.tracing_marker"),MAYBE_ITERATOR_SYMBOL=Symbol.iterator,FAUX_ITERATOR_SYMBOL="@@iterator";function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable!="object")return null;var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];return typeof maybeIterator=="function"?maybeIterator:null}var assign=Object.assign,disabledDepth=0,prevLog,prevInfo,prevWarn,prevError,prevGroup,prevGroupCollapsed,prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=!0;function disableLogs(){{if(disabledDepth===0){prevLog=console.log,prevInfo=console.info,prevWarn=console.warn,prevError=console.error,prevGroup=console.group,prevGroupCollapsed=console.groupCollapsed,prevGroupEnd=console.groupEnd;var props={configurable:!0,enumerable:!0,value:disabledLog,writable:!0};Object.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props})}disabledDepth++}}function reenableLogs(){{if(disabledDepth--,disabledDepth===0){var props={configurable:!0,enumerable:!0,writable:!0};Object.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})})}disabledDepth<0&&error("disabledDepth fell below zero. This is a bug in React. Please file an issue.")}}var ReactCurrentDispatcher2=ReactSharedInternals.ReactCurrentDispatcher,prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===void 0)try{throw Error()}catch(x2){var match=x2.stack.trim().match(/\n( *(at )?)/);prefix=match&&match[1]||""}return`
`+prefix+name}}var reentry=!1,componentFrameCache;{var PossiblyWeakMap=typeof WeakMap=="function"?WeakMap:Map;componentFrameCache=new PossiblyWeakMap}function describeNativeComponentFrame(fn,construct){if(!fn||reentry)return"";{var frame2=componentFrameCache.get(fn);if(frame2!==void 0)return frame2}var control;reentry=!0;var previousPrepareStackTrace=Error.prepareStackTrace;Error.prepareStackTrace=void 0;var previousDispatcher;previousDispatcher=ReactCurrentDispatcher2.current,ReactCurrentDispatcher2.current=null,disableLogs();try{if(construct){var Fake=function(){throw Error()};if(Object.defineProperty(Fake.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Fake,[])}catch(x2){control=x2}Reflect.construct(fn,[],Fake)}else{try{Fake.call()}catch(x2){control=x2}fn.call(Fake.prototype)}}else{try{throw Error()}catch(x2){control=x2}fn()}}catch(sample){if(sample&&control&&typeof sample.stack=="string"){for(var sampleLines=sample.stack.split(`
`),controlLines=control.stack.split(`
`),s2=sampleLines.length-1,c2=controlLines.length-1;s2>=1&&c2>=0&&sampleLines[s2]!==controlLines[c2];)c2--;for(;s2>=1&&c2>=0;s2--,c2--)if(sampleLines[s2]!==controlLines[c2]){if(s2!==1||c2!==1)do if(s2--,c2--,c2<0||sampleLines[s2]!==controlLines[c2]){var _frame=`
`+sampleLines[s2].replace(" at new "," at ");return fn.displayName&&_frame.includes("<anonymous>")&&(_frame=_frame.replace("<anonymous>",fn.displayName)),typeof fn=="function"&&componentFrameCache.set(fn,_frame),_frame}while(s2>=1&&c2>=0);break}}}finally{reentry=!1,ReactCurrentDispatcher2.current=previousDispatcher,reenableLogs(),Error.prepareStackTrace=previousPrepareStackTrace}var name=fn?fn.displayName||fn.name:"",syntheticFrame=name?describeBuiltInComponentFrame(name):"";return typeof fn=="function"&&componentFrameCache.set(fn,syntheticFrame),syntheticFrame}function describeClassComponentFrame(ctor,source,ownerFn){return describeNativeComponentFrame(ctor,!0)}function describeFunctionComponentFrame(fn,source,ownerFn){return describeNativeComponentFrame(fn,!1)}function shouldConstruct(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent)}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null)return"";if(typeof type=="function")return describeNativeComponentFrame(type,shouldConstruct(type));if(typeof type=="string")return describeBuiltInComponentFrame(type);switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame("Suspense");case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame("SuspenseList")}if(typeof type=="object")switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:return describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:{var lazyComponent=type,payload=lazyComponent._payload,init=lazyComponent._init;try{return describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn)}catch{}}}return""}function describeFiber(fiber){switch(fiber._debugOwner&&fiber._debugOwner.type,fiber._debugSource,fiber.tag){case HostComponent:return describeBuiltInComponentFrame(fiber.type);case LazyComponent:return describeBuiltInComponentFrame("Lazy");case SuspenseComponent:return describeBuiltInComponentFrame("Suspense");case SuspenseListComponent:return describeBuiltInComponentFrame("SuspenseList");case FunctionComponent:case IndeterminateComponent:case SimpleMemoComponent:return describeFunctionComponentFrame(fiber.type);case ForwardRef:return describeFunctionComponentFrame(fiber.type.render);case ClassComponent:return describeClassComponentFrame(fiber.type);default:return""}}function getStackByFiberInDevAndProd(workInProgress2){try{var info="",node=workInProgress2;do info+=describeFiber(node),node=node.return;while(node);return info}catch(x2){return`
Error generating stack: `+x2.message+`
`+x2.stack}}function getWrappedName(outerType,innerType,wrapperName){var displayName=outerType.displayName;if(displayName)return displayName;var functionName=innerType.displayName||innerType.name||"";return functionName!==""?wrapperName+"("+functionName+")":wrapperName}function getContextName(type){return type.displayName||"Context"}function getComponentNameFromType(type){if(type==null)return null;if(typeof type.tag=="number"&&error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."),typeof type=="function")return type.displayName||type.name||null;if(typeof type=="string")return type;switch(type){case REACT_FRAGMENT_TYPE:return"Fragment";case REACT_PORTAL_TYPE:return"Portal";case REACT_PROFILER_TYPE:return"Profiler";case REACT_STRICT_MODE_TYPE:return"StrictMode";case REACT_SUSPENSE_TYPE:return"Suspense";case REACT_SUSPENSE_LIST_TYPE:return"SuspenseList"}if(typeof type=="object")switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context2=type;return getContextName(context2)+".Consumer";case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+".Provider";case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,"ForwardRef");case REACT_MEMO_TYPE:var outerName=type.displayName||null;return outerName!==null?outerName:getComponentNameFromType(type.type)||"Memo";case REACT_LAZY_TYPE:{var lazyComponent=type,payload=lazyComponent._payload,init=lazyComponent._init;try{return getComponentNameFromType(init(payload))}catch{return null}}}return null}function getWrappedName$1(outerType,innerType,wrapperName){var functionName=innerType.displayName||innerType.name||"";return outerType.displayName||(functionName!==""?wrapperName+"("+functionName+")":wrapperName)}function getContextName$1(type){return type.displayName||"Context"}function getComponentNameFromFiber(fiber){var tag=fiber.tag,type=fiber.type;switch(tag){case CacheComponent:return"Cache";case ContextConsumer:var context2=type;return getContextName$1(context2)+".Consumer";case ContextProvider:var provider=type;return getContextName$1(provider._context)+".Provider";case DehydratedFragment:return"DehydratedFragment";case ForwardRef:return getWrappedName$1(type,type.render,"ForwardRef");case Fragment:return"Fragment";case HostComponent:return type;case HostPortal:return"Portal";case HostRoot:return"Root";case HostText:return"Text";case LazyComponent:return getComponentNameFromType(type);case Mode:return type===REACT_STRICT_MODE_TYPE?"StrictMode":"Mode";case OffscreenComponent:return"Offscreen";case Profiler:return"Profiler";case ScopeComponent:return"Scope";case SuspenseComponent:return"Suspense";case SuspenseListComponent:return"SuspenseList";case TracingMarkerComponent:return"TracingMarker";case ClassComponent:case FunctionComponent:case IncompleteClassComponent:case IndeterminateComponent:case MemoComponent:case SimpleMemoComponent:if(typeof type=="function")return type.displayName||type.name||null;if(typeof type=="string")return type;break}return null}var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame,current=null,isRendering=!1;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null)return null;var owner=current._debugOwner;if(owner!==null&&typeof owner<"u")return getComponentNameFromFiber(owner)}return null}function getCurrentFiberStackInDev(){return current===null?"":getStackByFiberInDevAndProd(current)}function resetCurrentFiber(){ReactDebugCurrentFrame.getCurrentStack=null,current=null,isRendering=!1}function setCurrentFiber(fiber){ReactDebugCurrentFrame.getCurrentStack=fiber===null?null:getCurrentFiberStackInDev,current=fiber,isRendering=!1}function getCurrentFiber(){return current}function setIsRendering(rendering){isRendering=rendering}function toString(value){return""+value}function getToStringValue(value){switch(typeof value){case"boolean":case"number":case"string":case"undefined":return value;case"object":return checkFormFieldValueStringCoercion(value),value;default:return""}}var hasReadOnlyValue={button:!0,checkbox:!0,image:!0,hidden:!0,radio:!0,reset:!0,submit:!0};function checkControlledValueProps(tagName,props){hasReadOnlyValue[props.type]||props.onChange||props.onInput||props.readOnly||props.disabled||props.value==null||error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."),props.onChange||props.readOnly||props.disabled||props.checked==null||error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.")}function isCheckable(elem){var type=elem.type,nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==="input"&&(type==="checkbox"||type==="radio")}function getTracker(node){return node._valueTracker}function detachTracker(node){node._valueTracker=null}function getValueFromNode(node){var value="";return node&&(isCheckable(node)?value=node.checked?"true":"false":value=node.value),value}function trackValueOnNode(node){var valueField=isCheckable(node)?"checked":"value",descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);checkFormFieldValueStringCoercion(node[valueField]);var currentValue=""+node[valueField];if(!(node.hasOwnProperty(valueField)||typeof descriptor>"u"||typeof descriptor.get!="function"||typeof descriptor.set!="function")){var get2=descriptor.get,set2=descriptor.set;Object.defineProperty(node,valueField,{configurable:!0,get:function(){return get2.call(this)},set:function(value){checkFormFieldValueStringCoercion(value),currentValue=""+value,set2.call(this,value)}}),Object.defineProperty(node,valueField,{enumerable:descriptor.enumerable});var tracker={getValue:function(){return currentValue},setValue:function(value){checkFormFieldValueStringCoercion(value),currentValue=""+value},stopTracking:function(){detachTracker(node),delete node[valueField]}};return tracker}}function track(node){getTracker(node)||(node._valueTracker=trackValueOnNode(node))}function updateValueIfChanged(node){if(!node)return!1;var tracker=getTracker(node);if(!tracker)return!0;var lastValue=tracker.getValue(),nextValue=getValueFromNode(node);return nextValue!==lastValue?(tracker.setValue(nextValue),!0):!1}function getActiveElement(doc){if(doc=doc||(typeof document<"u"?document:void 0),typeof doc>"u")return null;try{return doc.activeElement||doc.body}catch{return doc.body}}var didWarnValueDefaultValue=!1,didWarnCheckedDefaultChecked=!1,didWarnControlledToUncontrolled=!1,didWarnUncontrolledToControlled=!1;function isControlled(props){var usesChecked=props.type==="checkbox"||props.type==="radio";return usesChecked?props.checked!=null:props.value!=null}function getHostProps(element,props){var node=element,checked=props.checked,hostProps=assign({},props,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:checked??node._wrapperState.initialChecked});return hostProps}function initWrapperState(element,props){checkControlledValueProps("input",props),props.checked!==void 0&&props.defaultChecked!==void 0&&!didWarnCheckedDefaultChecked&&(error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components",getCurrentFiberOwnerNameInDevOrNull()||"A component",props.type),didWarnCheckedDefaultChecked=!0),props.value!==void 0&&props.defaultValue!==void 0&&!didWarnValueDefaultValue&&(error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components",getCurrentFiberOwnerNameInDevOrNull()||"A component",props.type),didWarnValueDefaultValue=!0);var node=element,defaultValue=props.defaultValue==null?"":props.defaultValue;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:getToStringValue(props.value!=null?props.value:defaultValue),controlled:isControlled(props)}}function updateChecked(element,props){var node=element,checked=props.checked;checked!=null&&setValueForProperty(node,"checked",checked,!1)}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled&&(error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"),didWarnUncontrolledToControlled=!0),node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled&&(error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"),didWarnControlledToUncontrolled=!0)}updateChecked(element,props);var value=getToStringValue(props.value),type=props.type;if(value!=null)type==="number"?(value===0&&node.value===""||node.value!=value)&&(node.value=toString(value)):node.value!==toString(value)&&(node.value=toString(value));else if(type==="submit"||type==="reset"){node.removeAttribute("value");return}props.hasOwnProperty("value")?setDefaultValue(node,props.type,value):props.hasOwnProperty("defaultValue")&&setDefaultValue(node,props.type,getToStringValue(props.defaultValue)),props.checked==null&&props.defaultChecked!=null&&(node.defaultChecked=!!props.defaultChecked)}function postMountWrapper(element,props,isHydrating2){var node=element;if(props.hasOwnProperty("value")||props.hasOwnProperty("defaultValue")){var type=props.type,isButton=type==="submit"||type==="reset";if(isButton&&(props.value===void 0||props.value===null))return;var initialValue=toString(node._wrapperState.initialValue);isHydrating2||initialValue!==node.value&&(node.value=initialValue),node.defaultValue=initialValue}var name=node.name;name!==""&&(node.name=""),node.defaultChecked=!node.defaultChecked,node.defaultChecked=!!node._wrapperState.initialChecked,name!==""&&(node.name=name)}function restoreControlledState(element,props){var node=element;updateWrapper(node,props),updateNamedCousins(node,props)}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==="radio"&&name!=null){for(var queryRoot=rootNode;queryRoot.parentNode;)queryRoot=queryRoot.parentNode;checkAttributeStringCoercion(name,"name");for(var group=queryRoot.querySelectorAll("input[name="+JSON.stringify(""+name)+'][type="radio"]'),i2=0;i2<group.length;i2++){var otherNode=group[i2];if(!(otherNode===rootNode||otherNode.form!==rootNode.form)){var otherProps=getFiberCurrentPropsFromNode(otherNode);if(!otherProps)throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");updateValueIfChanged(otherNode),updateWrapper(otherNode,otherProps)}}}}function setDefaultValue(node,type,value){(type!=="number"||getActiveElement(node.ownerDocument)!==node)&&(value==null?node.defaultValue=toString(node._wrapperState.initialValue):node.defaultValue!==toString(value)&&(node.defaultValue=toString(value)))}var didWarnSelectedSetOnOption=!1,didWarnInvalidChild=!1,didWarnInvalidInnerHTML=!1;function validateProps(element,props){props.value==null&&(typeof props.children=="object"&&props.children!==null?React.Children.forEach(props.children,function(child){child!=null&&(typeof child=="string"||typeof child=="number"||didWarnInvalidChild||(didWarnInvalidChild=!0,error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")))}):props.dangerouslySetInnerHTML!=null&&(didWarnInvalidInnerHTML||(didWarnInvalidInnerHTML=!0,error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))),props.selected!=null&&!didWarnSelectedSetOnOption&&(error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."),didWarnSelectedSetOnOption=!0)}function postMountWrapper$1(element,props){props.value!=null&&element.setAttribute("value",toString(getToStringValue(props.value)))}var isArrayImpl=Array.isArray;function isArray(a2){return isArrayImpl(a2)}var didWarnValueDefaultValue$1;didWarnValueDefaultValue$1=!1;function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerNameInDevOrNull();return ownerName?`

Check the render method of \``+ownerName+"`.":""}var valuePropNames=["value","defaultValue"];function checkSelectPropTypes(props){{checkControlledValueProps("select",props);for(var i2=0;i2<valuePropNames.length;i2++){var propName=valuePropNames[i2];if(props[propName]!=null){var propNameIsArray=isArray(props[propName]);props.multiple&&!propNameIsArray?error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",propName,getDeclarationErrorAddendum()):!props.multiple&&propNameIsArray&&error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",propName,getDeclarationErrorAddendum())}}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options2=node.options;if(multiple){for(var selectedValues=propValue,selectedValue={},i2=0;i2<selectedValues.length;i2++)selectedValue["$"+selectedValues[i2]]=!0;for(var _i=0;_i<options2.length;_i++){var selected=selectedValue.hasOwnProperty("$"+options2[_i].value);options2[_i].selected!==selected&&(options2[_i].selected=selected),selected&&setDefaultSelected&&(options2[_i].defaultSelected=!0)}}else{for(var _selectedValue=toString(getToStringValue(propValue)),defaultSelected=null,_i2=0;_i2<options2.length;_i2++){if(options2[_i2].value===_selectedValue){options2[_i2].selected=!0,setDefaultSelected&&(options2[_i2].defaultSelected=!0);return}defaultSelected===null&&!options2[_i2].disabled&&(defaultSelected=options2[_i2])}defaultSelected!==null&&(defaultSelected.selected=!0)}}function getHostProps$1(element,props){return assign({},props,{value:void 0})}function initWrapperState$1(element,props){var node=element;checkSelectPropTypes(props),node._wrapperState={wasMultiple:!!props.multiple},props.value!==void 0&&props.defaultValue!==void 0&&!didWarnValueDefaultValue$1&&(error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"),didWarnValueDefaultValue$1=!0)}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;value!=null?updateOptions(node,!!props.multiple,value,!1):props.defaultValue!=null&&updateOptions(node,!!props.multiple,props.defaultValue,!0)}function postUpdateWrapper(element,props){var node=element,wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;value!=null?updateOptions(node,!!props.multiple,value,!1):wasMultiple!==!!props.multiple&&(props.defaultValue!=null?updateOptions(node,!!props.multiple,props.defaultValue,!0):updateOptions(node,!!props.multiple,props.multiple?[]:"",!1))}function restoreControlledState$1(element,props){var node=element,value=props.value;value!=null&&updateOptions(node,!!props.multiple,value,!1)}var didWarnValDefaultVal=!1;function getHostProps$2(element,props){var node=element;if(props.dangerouslySetInnerHTML!=null)throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");var hostProps=assign({},props,{value:void 0,defaultValue:void 0,children:toString(node._wrapperState.initialValue)});return hostProps}function initWrapperState$2(element,props){var node=element;checkControlledValueProps("textarea",props),props.value!==void 0&&props.defaultValue!==void 0&&!didWarnValDefaultVal&&(error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components",getCurrentFiberOwnerNameInDevOrNull()||"A component"),didWarnValDefaultVal=!0);var initialValue=props.value;if(initialValue==null){var children=props.children,defaultValue=props.defaultValue;if(children!=null){error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");{if(defaultValue!=null)throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");if(isArray(children)){if(children.length>1)throw new Error("<textarea> can only have at most one child.");children=children[0]}defaultValue=children}}defaultValue==null&&(defaultValue=""),initialValue=defaultValue}node._wrapperState={initialValue:getToStringValue(initialValue)}}function updateWrapper$1(element,props){var node=element,value=getToStringValue(props.value),defaultValue=getToStringValue(props.defaultValue);if(value!=null){var newValue=toString(value);newValue!==node.value&&(node.value=newValue),props.defaultValue==null&&node.defaultValue!==newValue&&(node.defaultValue=newValue)}defaultValue!=null&&(node.defaultValue=toString(defaultValue))}function postMountWrapper$3(element,props){var node=element,textContent=node.textContent;textContent===node._wrapperState.initialValue&&textContent!==""&&textContent!==null&&(node.value=textContent)}function restoreControlledState$2(element,props){updateWrapper$1(element,props)}var HTML_NAMESPACE="http://www.w3.org/1999/xhtml",MATH_NAMESPACE="http://www.w3.org/1998/Math/MathML",SVG_NAMESPACE="http://www.w3.org/2000/svg";function getIntrinsicNamespace(type){switch(type){case"svg":return SVG_NAMESPACE;case"math":return MATH_NAMESPACE;default:return HTML_NAMESPACE}}function getChildNamespace(parentNamespace,type){return parentNamespace==null||parentNamespace===HTML_NAMESPACE?getIntrinsicNamespace(type):parentNamespace===SVG_NAMESPACE&&type==="foreignObject"?HTML_NAMESPACE:parentNamespace}var createMicrosoftUnsafeLocalFunction=function(func){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3)})}:func},reusableSVGContainer,setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){if(node.namespaceURI===SVG_NAMESPACE&&!("innerHTML"in node)){reusableSVGContainer=reusableSVGContainer||document.createElement("div"),reusableSVGContainer.innerHTML="<svg>"+html.valueOf().toString()+"</svg>";for(var svgNode=reusableSVGContainer.firstChild;node.firstChild;)node.removeChild(node.firstChild);for(;svgNode.firstChild;)node.appendChild(svgNode.firstChild);return}node.innerHTML=html}),ELEMENT_NODE=1,TEXT_NODE=3,COMMENT_NODE=8,DOCUMENT_NODE=9,DOCUMENT_FRAGMENT_NODE=11,setTextContent=function(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return}}node.textContent=text},shorthandToLonghand={animation:["animationDelay","animationDirection","animationDuration","animationFillMode","animationIterationCount","animationName","animationPlayState","animationTimingFunction"],background:["backgroundAttachment","backgroundClip","backgroundColor","backgroundImage","backgroundOrigin","backgroundPositionX","backgroundPositionY","backgroundRepeat","backgroundSize"],backgroundPosition:["backgroundPositionX","backgroundPositionY"],border:["borderBottomColor","borderBottomStyle","borderBottomWidth","borderImageOutset","borderImageRepeat","borderImageSlice","borderImageSource","borderImageWidth","borderLeftColor","borderLeftStyle","borderLeftWidth","borderRightColor","borderRightStyle","borderRightWidth","borderTopColor","borderTopStyle","borderTopWidth"],borderBlockEnd:["borderBlockEndColor","borderBlockEndStyle","borderBlockEndWidth"],borderBlockStart:["borderBlockStartColor","borderBlockStartStyle","borderBlockStartWidth"],borderBottom:["borderBottomColor","borderBottomStyle","borderBottomWidth"],borderColor:["borderBottomColor","borderLeftColor","borderRightColor","borderTopColor"],borderImage:["borderImageOutset","borderImageRepeat","borderImageSlice","borderImageSource","borderImageWidth"],borderInlineEnd:["borderInlineEndColor","borderInlineEndStyle","borderInlineEndWidth"],borderInlineStart:["borderInlineStartColor","borderInlineStartStyle","borderInlineStartWidth"],borderLeft:["borderLeftColor","borderLeftStyle","borderLeftWidth"],borderRadius:["borderBottomLeftRadius","borderBottomRightRadius","borderTopLeftRadius","borderTopRightRadius"],borderRight:["borderRightColor","borderRightStyle","borderRightWidth"],borderStyle:["borderBottomStyle","borderLeftStyle","borderRightStyle","borderTopStyle"],borderTop:["borderTopColor","borderTopStyle","borderTopWidth"],borderWidth:["borderBottomWidth","borderLeftWidth","borderRightWidth","borderTopWidth"],columnRule:["columnRuleColor","columnRuleStyle","columnRuleWidth"],columns:["columnCount","columnWidth"],flex:["flexBasis","flexGrow","flexShrink"],flexFlow:["flexDirection","flexWrap"],font:["fontFamily","fontFeatureSettings","fontKerning","fontLanguageOverride","fontSize","fontSizeAdjust","fontStretch","fontStyle","fontVariant","fontVariantAlternates","fontVariantCaps","fontVariantEastAsian","fontVariantLigatures","fontVariantNumeric","fontVariantPosition","fontWeight","lineHeight"],fontVariant:["fontVariantAlternates","fontVariantCaps","fontVariantEastAsian","fontVariantLigatures","fontVariantNumeric","fontVariantPosition"],gap:["columnGap","rowGap"],grid:["gridAutoColumns","gridAutoFlow","gridAutoRows","gridTemplateAreas","gridTemplateColumns","gridTemplateRows"],gridArea:["gridColumnEnd","gridColumnStart","gridRowEnd","gridRowStart"],gridColumn:["gridColumnEnd","gridColumnStart"],gridColumnGap:["columnGap"],gridGap:["columnGap","rowGap"],gridRow:["gridRowEnd","gridRowStart"],gridRowGap:["rowGap"],gridTemplate:["gridTemplateAreas","gridTemplateColumns","gridTemplateRows"],listStyle:["listStyleImage","listStylePosition","listStyleType"],margin:["marginBottom","marginLeft","marginRight","marginTop"],marker:["markerEnd","markerMid","markerStart"],mask:["maskClip","maskComposite","maskImage","maskMode","maskOrigin","maskPositionX","maskPositionY","maskRepeat","maskSize"],maskPosition:["maskPositionX","maskPositionY"],outline:["outlineColor","outlineStyle","outlineWidth"],overflow:["overflowX","overflowY"],padding:["paddingBottom","paddingLeft","paddingRight","paddingTop"],placeContent:["alignContent","justifyContent"],placeItems:["alignItems","justifyItems"],placeSelf:["alignSelf","justifySelf"],textDecoration:["textDecorationColor","textDecorationLine","textDecorationStyle"],textEmphasis:["textEmphasisColor","textEmphasisStyle"],transition:["transitionDelay","transitionDuration","transitionProperty","transitionTimingFunction"],wordWrap:["overflowWrap"]},isUnitlessNumber={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0};function prefixKey(prefix2,key){return prefix2+key.charAt(0).toUpperCase()+key.substring(1)}var prefixes=["Webkit","ms","Moz","O"];Object.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix2){isUnitlessNumber[prefixKey(prefix2,prop)]=isUnitlessNumber[prop]})});function dangerousStyleValue(name,value,isCustomProperty){var isEmpty=value==null||typeof value=="boolean"||value==="";return isEmpty?"":!isCustomProperty&&typeof value=="number"&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])?value+"px":(checkCSSPropertyStringCoercion(value,name),(""+value).trim())}var uppercasePattern=/([A-Z])/g,msPattern=/^ms-/;function hyphenateStyleName(name){return name.replace(uppercasePattern,"-$1").toLowerCase().replace(msPattern,"-ms-")}var warnValidStyle=function(){};{var badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/,msPattern$1=/^-ms-/,hyphenPattern=/-(.)/g,badStyleValueWithSemicolonPattern=/;\s*$/,warnedStyleNames={},warnedStyleValues={},warnedForNaNValue=!1,warnedForInfinityValue=!1,camelize=function(string){return string.replace(hyphenPattern,function(_2,character){return character.toUpperCase()})},warnHyphenatedStyleName=function(name){warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]||(warnedStyleNames[name]=!0,error("Unsupported style property %s. Did you mean %s?",name,camelize(name.replace(msPattern$1,"ms-"))))},warnBadVendoredStyleName=function(name){warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]||(warnedStyleNames[name]=!0,error("Unsupported vendor-prefixed style property %s. Did you mean %s?",name,name.charAt(0).toUpperCase()+name.slice(1)))},warnStyleValueWithSemicolon=function(name,value){warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]||(warnedStyleValues[value]=!0,error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,name,value.replace(badStyleValueWithSemicolonPattern,"")))},warnStyleValueIsNaN=function(name,value){warnedForNaNValue||(warnedForNaNValue=!0,error("`NaN` is an invalid value for the `%s` css style property.",name))},warnStyleValueIsInfinity=function(name,value){warnedForInfinityValue||(warnedForInfinityValue=!0,error("`Infinity` is an invalid value for the `%s` css style property.",name))};warnValidStyle=function(name,value){name.indexOf("-")>-1?warnHyphenatedStyleName(name):badVendoredStyleNamePattern.test(name)?warnBadVendoredStyleName(name):badStyleValueWithSemicolonPattern.test(value)&&warnStyleValueWithSemicolon(name,value),typeof value=="number"&&(isNaN(value)?warnStyleValueIsNaN(name,value):isFinite(value)||warnStyleValueIsInfinity(name,value))}}var warnValidStyle$1=warnValidStyle;function createDangerousStringForStyles(styles){{var serialized="",delimiter="";for(var styleName in styles)if(styles.hasOwnProperty(styleName)){var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf("--")===0;serialized+=delimiter+(isCustomProperty?styleName:hyphenateStyleName(styleName))+":",serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty),delimiter=";"}}return serialized||null}}function setValueForStyles(node,styles){var style2=node.style;for(var styleName in styles)if(styles.hasOwnProperty(styleName)){var isCustomProperty=styleName.indexOf("--")===0;isCustomProperty||warnValidStyle$1(styleName,styles[styleName]);var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);styleName==="float"&&(styleName="cssFloat"),isCustomProperty?style2.setProperty(styleName,styleValue):style2[styleName]=styleValue}}function isValueEmpty(value){return value==null||typeof value=="boolean"||value===""}function expandShorthandMap(styles){var expanded={};for(var key in styles)for(var longhands=shorthandToLonghand[key]||[key],i2=0;i2<longhands.length;i2++)expanded[longhands[i2]]=key;return expanded}function validateShorthandPropertyCollisionInDev(styleUpdates,nextStyles){{if(!nextStyles)return;var expandedUpdates=expandShorthandMap(styleUpdates),expandedStyles=expandShorthandMap(nextStyles),warnedAbout={};for(var key in expandedUpdates){var originalKey=expandedUpdates[key],correctOriginalKey=expandedStyles[key];if(correctOriginalKey&&originalKey!==correctOriginalKey){var warningKey=originalKey+","+correctOriginalKey;if(warnedAbout[warningKey])continue;warnedAbout[warningKey]=!0,error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",isValueEmpty(styleUpdates[originalKey])?"Removing":"Updating",originalKey,correctOriginalKey)}}}}var omittedCloseTags={area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0},voidElementTags=assign({menuitem:!0},omittedCloseTags),HTML="__html";function assertValidProps(tag,props){if(props){if(voidElementTags[tag]&&(props.children!=null||props.dangerouslySetInnerHTML!=null))throw new Error(tag+" is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");if(props.dangerouslySetInnerHTML!=null){if(props.children!=null)throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");if(typeof props.dangerouslySetInnerHTML!="object"||!(HTML in props.dangerouslySetInnerHTML))throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.")}if(!props.suppressContentEditableWarning&&props.contentEditable&&props.children!=null&&error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."),props.style!=null&&typeof props.style!="object")throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.")}}function isCustomComponent(tagName,props){if(tagName.indexOf("-")===-1)return typeof props.is=="string";switch(tagName){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var possibleStandardNames={accept:"accept",acceptcharset:"acceptCharset","accept-charset":"acceptCharset",accesskey:"accessKey",action:"action",allowfullscreen:"allowFullScreen",alt:"alt",as:"as",async:"async",autocapitalize:"autoCapitalize",autocomplete:"autoComplete",autocorrect:"autoCorrect",autofocus:"autoFocus",autoplay:"autoPlay",autosave:"autoSave",capture:"capture",cellpadding:"cellPadding",cellspacing:"cellSpacing",challenge:"challenge",charset:"charSet",checked:"checked",children:"children",cite:"cite",class:"className",classid:"classID",classname:"className",cols:"cols",colspan:"colSpan",content:"content",contenteditable:"contentEditable",contextmenu:"contextMenu",controls:"controls",controlslist:"controlsList",coords:"coords",crossorigin:"crossOrigin",dangerouslysetinnerhtml:"dangerouslySetInnerHTML",data:"data",datetime:"dateTime",default:"default",defaultchecked:"defaultChecked",defaultvalue:"defaultValue",defer:"defer",dir:"dir",disabled:"disabled",disablepictureinpicture:"disablePictureInPicture",disableremoteplayback:"disableRemotePlayback",download:"download",draggable:"draggable",enctype:"encType",enterkeyhint:"enterKeyHint",for:"htmlFor",form:"form",formmethod:"formMethod",formaction:"formAction",formenctype:"formEncType",formnovalidate:"formNoValidate",formtarget:"formTarget",frameborder:"frameBorder",headers:"headers",height:"height",hidden:"hidden",high:"high",href:"href",hreflang:"hrefLang",htmlfor:"htmlFor",httpequiv:"httpEquiv","http-equiv":"httpEquiv",icon:"icon",id:"id",imagesizes:"imageSizes",imagesrcset:"imageSrcSet",innerhtml:"innerHTML",inputmode:"inputMode",integrity:"integrity",is:"is",itemid:"itemID",itemprop:"itemProp",itemref:"itemRef",itemscope:"itemScope",itemtype:"itemType",keyparams:"keyParams",keytype:"keyType",kind:"kind",label:"label",lang:"lang",list:"list",loop:"loop",low:"low",manifest:"manifest",marginwidth:"marginWidth",marginheight:"marginHeight",max:"max",maxlength:"maxLength",media:"media",mediagroup:"mediaGroup",method:"method",min:"min",minlength:"minLength",multiple:"multiple",muted:"muted",name:"name",nomodule:"noModule",nonce:"nonce",novalidate:"noValidate",open:"open",optimum:"optimum",pattern:"pattern",placeholder:"placeholder",playsinline:"playsInline",poster:"poster",preload:"preload",profile:"profile",radiogroup:"radioGroup",readonly:"readOnly",referrerpolicy:"referrerPolicy",rel:"rel",required:"required",reversed:"reversed",role:"role",rows:"rows",rowspan:"rowSpan",sandbox:"sandbox",scope:"scope",scoped:"scoped",scrolling:"scrolling",seamless:"seamless",selected:"selected",shape:"shape",size:"size",sizes:"sizes",span:"span",spellcheck:"spellCheck",src:"src",srcdoc:"srcDoc",srclang:"srcLang",srcset:"srcSet",start:"start",step:"step",style:"style",summary:"summary",tabindex:"tabIndex",target:"target",title:"title",type:"type",usemap:"useMap",value:"value",width:"width",wmode:"wmode",wrap:"wrap",about:"about",accentheight:"accentHeight","accent-height":"accentHeight",accumulate:"accumulate",additive:"additive",alignmentbaseline:"alignmentBaseline","alignment-baseline":"alignmentBaseline",allowreorder:"allowReorder",alphabetic:"alphabetic",amplitude:"amplitude",arabicform:"arabicForm","arabic-form":"arabicForm",ascent:"ascent",attributename:"attributeName",attributetype:"attributeType",autoreverse:"autoReverse",azimuth:"azimuth",basefrequency:"baseFrequency",baselineshift:"baselineShift","baseline-shift":"baselineShift",baseprofile:"baseProfile",bbox:"bbox",begin:"begin",bias:"bias",by:"by",calcmode:"calcMode",capheight:"capHeight","cap-height":"capHeight",clip:"clip",clippath:"clipPath","clip-path":"clipPath",clippathunits:"clipPathUnits",cliprule:"clipRule","clip-rule":"clipRule",color:"color",colorinterpolation:"colorInterpolation","color-interpolation":"colorInterpolation",colorinterpolationfilters:"colorInterpolationFilters","color-interpolation-filters":"colorInterpolationFilters",colorprofile:"colorProfile","color-profile":"colorProfile",colorrendering:"colorRendering","color-rendering":"colorRendering",contentscripttype:"contentScriptType",contentstyletype:"contentStyleType",cursor:"cursor",cx:"cx",cy:"cy",d:"d",datatype:"datatype",decelerate:"decelerate",descent:"descent",diffuseconstant:"diffuseConstant",direction:"direction",display:"display",divisor:"divisor",dominantbaseline:"dominantBaseline","dominant-baseline":"dominantBaseline",dur:"dur",dx:"dx",dy:"dy",edgemode:"edgeMode",elevation:"elevation",enablebackground:"enableBackground","enable-background":"enableBackground",end:"end",exponent:"exponent",externalresourcesrequired:"externalResourcesRequired",fill:"fill",fillopacity:"fillOpacity","fill-opacity":"fillOpacity",fillrule:"fillRule","fill-rule":"fillRule",filter:"filter",filterres:"filterRes",filterunits:"filterUnits",floodopacity:"floodOpacity","flood-opacity":"floodOpacity",floodcolor:"floodColor","flood-color":"floodColor",focusable:"focusable",fontfamily:"fontFamily","font-family":"fontFamily",fontsize:"fontSize","font-size":"fontSize",fontsizeadjust:"fontSizeAdjust","font-size-adjust":"fontSizeAdjust",fontstretch:"fontStretch","font-stretch":"fontStretch",fontstyle:"fontStyle","font-style":"fontStyle",fontvariant:"fontVariant","font-variant":"fontVariant",fontweight:"fontWeight","font-weight":"fontWeight",format:"format",from:"from",fx:"fx",fy:"fy",g1:"g1",g2:"g2",glyphname:"glyphName","glyph-name":"glyphName",glyphorientationhorizontal:"glyphOrientationHorizontal","glyph-orientation-horizontal":"glyphOrientationHorizontal",glyphorientationvertical:"glyphOrientationVertical","glyph-orientation-vertical":"glyphOrientationVertical",glyphref:"glyphRef",gradienttransform:"gradientTransform",gradientunits:"gradientUnits",hanging:"hanging",horizadvx:"horizAdvX","horiz-adv-x":"horizAdvX",horizoriginx:"horizOriginX","horiz-origin-x":"horizOriginX",ideographic:"ideographic",imagerendering:"imageRendering","image-rendering":"imageRendering",in2:"in2",in:"in",inlist:"inlist",intercept:"intercept",k1:"k1",k2:"k2",k3:"k3",k4:"k4",k:"k",kernelmatrix:"kernelMatrix",kernelunitlength:"kernelUnitLength",kerning:"kerning",keypoints:"keyPoints",keysplines:"keySplines",keytimes:"keyTimes",lengthadjust:"lengthAdjust",letterspacing:"letterSpacing","letter-spacing":"letterSpacing",lightingcolor:"lightingColor","lighting-color":"lightingColor",limitingconeangle:"limitingConeAngle",local:"local",markerend:"markerEnd","marker-end":"markerEnd",markerheight:"markerHeight",markermid:"markerMid","marker-mid":"markerMid",markerstart:"markerStart","marker-start":"markerStart",markerunits:"markerUnits",markerwidth:"markerWidth",mask:"mask",maskcontentunits:"maskContentUnits",maskunits:"maskUnits",mathematical:"mathematical",mode:"mode",numoctaves:"numOctaves",offset:"offset",opacity:"opacity",operator:"operator",order:"order",orient:"orient",orientation:"orientation",origin:"origin",overflow:"overflow",overlineposition:"overlinePosition","overline-position":"overlinePosition",overlinethickness:"overlineThickness","overline-thickness":"overlineThickness",paintorder:"paintOrder","paint-order":"paintOrder",panose1:"panose1","panose-1":"panose1",pathlength:"pathLength",patterncontentunits:"patternContentUnits",patterntransform:"patternTransform",patternunits:"patternUnits",pointerevents:"pointerEvents","pointer-events":"pointerEvents",points:"points",pointsatx:"pointsAtX",pointsaty:"pointsAtY",pointsatz:"pointsAtZ",prefix:"prefix",preservealpha:"preserveAlpha",preserveaspectratio:"preserveAspectRatio",primitiveunits:"primitiveUnits",property:"property",r:"r",radius:"radius",refx:"refX",refy:"refY",renderingintent:"renderingIntent","rendering-intent":"renderingIntent",repeatcount:"repeatCount",repeatdur:"repeatDur",requiredextensions:"requiredExtensions",requiredfeatures:"requiredFeatures",resource:"resource",restart:"restart",result:"result",results:"results",rotate:"rotate",rx:"rx",ry:"ry",scale:"scale",security:"security",seed:"seed",shaperendering:"shapeRendering","shape-rendering":"shapeRendering",slope:"slope",spacing:"spacing",specularconstant:"specularConstant",specularexponent:"specularExponent",speed:"speed",spreadmethod:"spreadMethod",startoffset:"startOffset",stddeviation:"stdDeviation",stemh:"stemh",stemv:"stemv",stitchtiles:"stitchTiles",stopcolor:"stopColor","stop-color":"stopColor",stopopacity:"stopOpacity","stop-opacity":"stopOpacity",strikethroughposition:"strikethroughPosition","strikethrough-position":"strikethroughPosition",strikethroughthickness:"strikethroughThickness","strikethrough-thickness":"strikethroughThickness",string:"string",stroke:"stroke",strokedasharray:"strokeDasharray","stroke-dasharray":"strokeDasharray",strokedashoffset:"strokeDashoffset","stroke-dashoffset":"strokeDashoffset",strokelinecap:"strokeLinecap","stroke-linecap":"strokeLinecap",strokelinejoin:"strokeLinejoin","stroke-linejoin":"strokeLinejoin",strokemiterlimit:"strokeMiterlimit","stroke-miterlimit":"strokeMiterlimit",strokewidth:"strokeWidth","stroke-width":"strokeWidth",strokeopacity:"strokeOpacity","stroke-opacity":"strokeOpacity",suppresscontenteditablewarning:"suppressContentEditableWarning",suppresshydrationwarning:"suppressHydrationWarning",surfacescale:"surfaceScale",systemlanguage:"systemLanguage",tablevalues:"tableValues",targetx:"targetX",targety:"targetY",textanchor:"textAnchor","text-anchor":"textAnchor",textdecoration:"textDecoration","text-decoration":"textDecoration",textlength:"textLength",textrendering:"textRendering","text-rendering":"textRendering",to:"to",transform:"transform",typeof:"typeof",u1:"u1",u2:"u2",underlineposition:"underlinePosition","underline-position":"underlinePosition",underlinethickness:"underlineThickness","underline-thickness":"underlineThickness",unicode:"unicode",unicodebidi:"unicodeBidi","unicode-bidi":"unicodeBidi",unicoderange:"unicodeRange","unicode-range":"unicodeRange",unitsperem:"unitsPerEm","units-per-em":"unitsPerEm",unselectable:"unselectable",valphabetic:"vAlphabetic","v-alphabetic":"vAlphabetic",values:"values",vectoreffect:"vectorEffect","vector-effect":"vectorEffect",version:"version",vertadvy:"vertAdvY","vert-adv-y":"vertAdvY",vertoriginx:"vertOriginX","vert-origin-x":"vertOriginX",vertoriginy:"vertOriginY","vert-origin-y":"vertOriginY",vhanging:"vHanging","v-hanging":"vHanging",videographic:"vIdeographic","v-ideographic":"vIdeographic",viewbox:"viewBox",viewtarget:"viewTarget",visibility:"visibility",vmathematical:"vMathematical","v-mathematical":"vMathematical",vocab:"vocab",widths:"widths",wordspacing:"wordSpacing","word-spacing":"wordSpacing",writingmode:"writingMode","writing-mode":"writingMode",x1:"x1",x2:"x2",x:"x",xchannelselector:"xChannelSelector",xheight:"xHeight","x-height":"xHeight",xlinkactuate:"xlinkActuate","xlink:actuate":"xlinkActuate",xlinkarcrole:"xlinkArcrole","xlink:arcrole":"xlinkArcrole",xlinkhref:"xlinkHref","xlink:href":"xlinkHref",xlinkrole:"xlinkRole","xlink:role":"xlinkRole",xlinkshow:"xlinkShow","xlink:show":"xlinkShow",xlinktitle:"xlinkTitle","xlink:title":"xlinkTitle",xlinktype:"xlinkType","xlink:type":"xlinkType",xmlbase:"xmlBase","xml:base":"xmlBase",xmllang:"xmlLang","xml:lang":"xmlLang",xmlns:"xmlns","xml:space":"xmlSpace",xmlnsxlink:"xmlnsXlink","xmlns:xlink":"xmlnsXlink",xmlspace:"xmlSpace",y1:"y1",y2:"y2",y:"y",ychannelselector:"yChannelSelector",z:"z",zoomandpan:"zoomAndPan"},ariaProperties={"aria-current":0,"aria-description":0,"aria-details":0,"aria-disabled":0,"aria-hidden":0,"aria-invalid":0,"aria-keyshortcuts":0,"aria-label":0,"aria-roledescription":0,"aria-autocomplete":0,"aria-checked":0,"aria-expanded":0,"aria-haspopup":0,"aria-level":0,"aria-modal":0,"aria-multiline":0,"aria-multiselectable":0,"aria-orientation":0,"aria-placeholder":0,"aria-pressed":0,"aria-readonly":0,"aria-required":0,"aria-selected":0,"aria-sort":0,"aria-valuemax":0,"aria-valuemin":0,"aria-valuenow":0,"aria-valuetext":0,"aria-atomic":0,"aria-busy":0,"aria-live":0,"aria-relevant":0,"aria-dropeffect":0,"aria-grabbed":0,"aria-activedescendant":0,"aria-colcount":0,"aria-colindex":0,"aria-colspan":0,"aria-controls":0,"aria-describedby":0,"aria-errormessage":0,"aria-flowto":0,"aria-labelledby":0,"aria-owns":0,"aria-posinset":0,"aria-rowcount":0,"aria-rowindex":0,"aria-rowspan":0,"aria-setsize":0},warnedProperties={},rARIA=new RegExp("^(aria)-["+ATTRIBUTE_NAME_CHAR+"]*$"),rARIACamel=new RegExp("^(aria)[A-Z]["+ATTRIBUTE_NAME_CHAR+"]*$");function validateProperty(tagName,name){{if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name])return!0;if(rARIACamel.test(name)){var ariaName="aria-"+name.slice(4).toLowerCase(),correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;if(correctName==null)return error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",name),warnedProperties[name]=!0,!0;if(name!==correctName)return error("Invalid ARIA attribute `%s`. Did you mean `%s`?",name,correctName),warnedProperties[name]=!0,!0}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase(),standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;if(standardName==null)return warnedProperties[name]=!0,!1;if(name!==standardName)return error("Unknown ARIA attribute `%s`. Did you mean `%s`?",name,standardName),warnedProperties[name]=!0,!0}}return!0}function warnInvalidARIAProps(type,props){{var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);isValid||invalidProps.push(key)}var unknownPropString=invalidProps.map(function(prop){return"`"+prop+"`"}).join(", ");invalidProps.length===1?error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props",unknownPropString,type):invalidProps.length>1&&error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props",unknownPropString,type)}}function validateProperties(type,props){isCustomComponent(type,props)||warnInvalidARIAProps(type,props)}var didWarnValueNull=!1;function validateProperties$1(type,props){{if(type!=="input"&&type!=="textarea"&&type!=="select")return;props!=null&&props.value===null&&!didWarnValueNull&&(didWarnValueNull=!0,type==="select"&&props.multiple?error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",type):error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",type))}}var validateProperty$1=function(){};{var warnedProperties$1={},EVENT_NAME_REGEX=/^on./,INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/,rARIA$1=new RegExp("^(aria)-["+ATTRIBUTE_NAME_CHAR+"]*$"),rARIACamel$1=new RegExp("^(aria)[A-Z]["+ATTRIBUTE_NAME_CHAR+"]*$");validateProperty$1=function(tagName,name,value,eventRegistry){if(hasOwnProperty.call(warnedProperties$1,name)&&warnedProperties$1[name])return!0;var lowerCasedName=name.toLowerCase();if(lowerCasedName==="onfocusin"||lowerCasedName==="onfocusout")return error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."),warnedProperties$1[name]=!0,!0;if(eventRegistry!=null){var registrationNameDependencies2=eventRegistry.registrationNameDependencies,possibleRegistrationNames2=eventRegistry.possibleRegistrationNames;if(registrationNameDependencies2.hasOwnProperty(name))return!0;var registrationName=possibleRegistrationNames2.hasOwnProperty(lowerCasedName)?possibleRegistrationNames2[lowerCasedName]:null;if(registrationName!=null)return error("Invalid event handler property `%s`. Did you mean `%s`?",name,registrationName),warnedProperties$1[name]=!0,!0;if(EVENT_NAME_REGEX.test(name))return error("Unknown event handler property `%s`. It will be ignored.",name),warnedProperties$1[name]=!0,!0}else if(EVENT_NAME_REGEX.test(name))return INVALID_EVENT_NAME_REGEX.test(name)&&error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",name),warnedProperties$1[name]=!0,!0;if(rARIA$1.test(name)||rARIACamel$1.test(name))return!0;if(lowerCasedName==="innerhtml")return error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."),warnedProperties$1[name]=!0,!0;if(lowerCasedName==="aria")return error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."),warnedProperties$1[name]=!0,!0;if(lowerCasedName==="is"&&value!==null&&value!==void 0&&typeof value!="string")return error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",typeof value),warnedProperties$1[name]=!0,!0;if(typeof value=="number"&&isNaN(value))return error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",name),warnedProperties$1[name]=!0,!0;var propertyInfo=getPropertyInfo(name),isReserved=propertyInfo!==null&&propertyInfo.type===RESERVED;if(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name)return error("Invalid DOM property `%s`. Did you mean `%s`?",name,standardName),warnedProperties$1[name]=!0,!0}else if(!isReserved&&name!==lowerCasedName)return error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",name,lowerCasedName),warnedProperties$1[name]=!0,!0;return typeof value=="boolean"&&shouldRemoveAttributeWithWarning(name,value,propertyInfo,!1)?(value?error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',value,name,name,value,name):error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',value,name,name,value,name,name,name),warnedProperties$1[name]=!0,!0):isReserved?!0:shouldRemoveAttributeWithWarning(name,value,propertyInfo,!1)?(warnedProperties$1[name]=!0,!1):((value==="false"||value==="true")&&propertyInfo!==null&&propertyInfo.type===BOOLEAN&&(error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",value,name,value==="false"?"The browser will interpret it as a truthy value.":'Although this works, it will not work as expected if you pass the string "false".',name,value),warnedProperties$1[name]=!0),!0)}}var warnUnknownProperties=function(type,props,eventRegistry){{var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],eventRegistry);isValid||unknownProps.push(key)}var unknownPropString=unknownProps.map(function(prop){return"`"+prop+"`"}).join(", ");unknownProps.length===1?error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ",unknownPropString,type):unknownProps.length>1&&error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ",unknownPropString,type)}};function validateProperties$2(type,props,eventRegistry){isCustomComponent(type,props)||warnUnknownProperties(type,props,eventRegistry)}var IS_EVENT_HANDLE_NON_MANAGED_NODE=1,IS_NON_DELEGATED=2,IS_CAPTURE_PHASE=4,SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS=IS_EVENT_HANDLE_NON_MANAGED_NODE|IS_NON_DELEGATED|IS_CAPTURE_PHASE,currentReplayingEvent=null;function setReplayingEvent(event){currentReplayingEvent!==null&&error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."),currentReplayingEvent=event}function resetReplayingEvent(){currentReplayingEvent===null&&error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."),currentReplayingEvent=null}function isReplayingEvent(event){return event===currentReplayingEvent}function getEventTarget(nativeEvent){var target=nativeEvent.target||nativeEvent.srcElement||window;return target.correspondingUseElement&&(target=target.correspondingUseElement),target.nodeType===TEXT_NODE?target.parentNode:target}var restoreImpl=null,restoreTarget=null,restoreQueue=null;function restoreStateOfTarget(target){var internalInstance=getInstanceFromNode(target);if(internalInstance){if(typeof restoreImpl!="function")throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");var stateNode=internalInstance.stateNode;if(stateNode){var _props=getFiberCurrentPropsFromNode(stateNode);restoreImpl(internalInstance.stateNode,internalInstance.type,_props)}}}function setRestoreImplementation(impl){restoreImpl=impl}function enqueueStateRestore(target){restoreTarget?restoreQueue?restoreQueue.push(target):restoreQueue=[target]:restoreTarget=target}function needsStateRestore(){return restoreTarget!==null||restoreQueue!==null}function restoreStateIfNeeded(){if(restoreTarget){var target=restoreTarget,queuedTargets=restoreQueue;if(restoreTarget=null,restoreQueue=null,restoreStateOfTarget(target),queuedTargets)for(var i2=0;i2<queuedTargets.length;i2++)restoreStateOfTarget(queuedTargets[i2])}}var batchedUpdatesImpl=function(fn,bookkeeping){return fn(bookkeeping)},flushSyncImpl=function(){},isInsideEventHandler=!1;function finishEventHandler(){var controlledComponentsHavePendingUpdates=needsStateRestore();controlledComponentsHavePendingUpdates&&(flushSyncImpl(),restoreStateIfNeeded())}function batchedUpdates(fn,a2,b2){if(isInsideEventHandler)return fn(a2,b2);isInsideEventHandler=!0;try{return batchedUpdatesImpl(fn,a2,b2)}finally{isInsideEventHandler=!1,finishEventHandler()}}function setBatchingImplementation(_batchedUpdatesImpl,_discreteUpdatesImpl,_flushSyncImpl){batchedUpdatesImpl=_batchedUpdatesImpl,flushSyncImpl=_flushSyncImpl}function isInteractive(tag){return tag==="button"||tag==="input"||tag==="select"||tag==="textarea"}function shouldPreventMouseEvent(name,type,props){switch(name){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":return!!(props.disabled&&isInteractive(type));default:return!1}}function getListener(inst,registrationName){var stateNode=inst.stateNode;if(stateNode===null)return null;var props=getFiberCurrentPropsFromNode(stateNode);if(props===null)return null;var listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props))return null;if(listener&&typeof listener!="function")throw new Error("Expected `"+registrationName+"` listener to be a function, instead got a value of `"+typeof listener+"` type.");return listener}var passiveBrowserEventsSupported=!1;if(canUseDOM)try{var options={};Object.defineProperty(options,"passive",{get:function(){passiveBrowserEventsSupported=!0}}),window.addEventListener("test",options,options),window.removeEventListener("test",options,options)}catch{passiveBrowserEventsSupported=!1}function invokeGuardedCallbackProd(name,func,context2,a2,b2,c2,d2,e2,f2){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context2,funcArgs)}catch(error2){this.onError(error2)}}var invokeGuardedCallbackImpl=invokeGuardedCallbackProd;if(typeof window<"u"&&typeof window.dispatchEvent=="function"&&typeof document<"u"&&typeof document.createEvent=="function"){var fakeNode=document.createElement("react");invokeGuardedCallbackImpl=function(name,func,context2,a2,b2,c2,d2,e2,f2){if(typeof document>"u"||document===null)throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");var evt=document.createEvent("Event"),didCall=!1,didError=!0,windowEvent=window.event,windowEventDescriptor=Object.getOwnPropertyDescriptor(window,"event");function restoreAfterDispatch(){fakeNode.removeEventListener(evtType,callCallback2,!1),typeof window.event<"u"&&window.hasOwnProperty("event")&&(window.event=windowEvent)}var funcArgs=Array.prototype.slice.call(arguments,3);function callCallback2(){didCall=!0,restoreAfterDispatch(),func.apply(context2,funcArgs),didError=!1}var error2,didSetError=!1,isCrossOriginError=!1;function handleWindowError(event){if(error2=event.error,didSetError=!0,error2===null&&event.colno===0&&event.lineno===0&&(isCrossOriginError=!0),event.defaultPrevented&&error2!=null&&typeof error2=="object")try{error2._suppressLogging=!0}catch{}}var evtType="react-"+(name||"invokeguardedcallback");if(window.addEventListener("error",handleWindowError),fakeNode.addEventListener(evtType,callCallback2,!1),evt.initEvent(evtType,!1,!1),fakeNode.dispatchEvent(evt),windowEventDescriptor&&Object.defineProperty(window,"event",windowEventDescriptor),didCall&&didError&&(didSetError?isCrossOriginError&&(error2=new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")):error2=new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`),this.onError(error2)),window.removeEventListener("error",handleWindowError),!didCall)return restoreAfterDispatch(),invokeGuardedCallbackProd.apply(this,arguments)}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl,hasError=!1,caughtError=null,hasRethrowError=!1,rethrowError=null,reporter={onError:function(error2){hasError=!0,caughtError=error2}};function invokeGuardedCallback(name,func,context2,a2,b2,c2,d2,e2,f2){hasError=!1,caughtError=null,invokeGuardedCallbackImpl$1.apply(reporter,arguments)}function invokeGuardedCallbackAndCatchFirstError(name,func,context2,a2,b2,c2,d2,e2,f2){if(invokeGuardedCallback.apply(this,arguments),hasError){var error2=clearCaughtError();hasRethrowError||(hasRethrowError=!0,rethrowError=error2)}}function rethrowCaughtError(){if(hasRethrowError){var error2=rethrowError;throw hasRethrowError=!1,rethrowError=null,error2}}function hasCaughtError(){return hasError}function clearCaughtError(){if(hasError){var error2=caughtError;return hasError=!1,caughtError=null,error2}else throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.")}function get(key){return key._reactInternals}function has(key){return key._reactInternals!==void 0}function set(key,value){key._reactInternals=value}var NoFlags=0,PerformedWork=1,Placement=2,Update=4,ChildDeletion=16,ContentReset=32,Callback=64,DidCapture=128,ForceClientRender=256,Ref=512,Snapshot=1024,Passive=2048,Hydrating=4096,Visibility=8192,StoreConsistency=16384,LifecycleEffectMask=Passive|Update|Callback|Ref|Snapshot|StoreConsistency,HostEffectMask=32767,Incomplete=32768,ShouldCapture=65536,ForceUpdateForLegacySuspense=131072,Forked=1048576,RefStatic=2097152,LayoutStatic=4194304,PassiveStatic=8388608,MountLayoutDev=16777216,MountPassiveDev=33554432,BeforeMutationMask=Update|Snapshot|0,MutationMask=Placement|Update|ChildDeletion|ContentReset|Ref|Hydrating|Visibility,LayoutMask=Update|Callback|Ref|Visibility,PassiveMask=Passive|ChildDeletion,StaticMask=LayoutStatic|PassiveStatic|RefStatic,ReactCurrentOwner2=ReactSharedInternals.ReactCurrentOwner;function getNearestMountedFiber(fiber){var node=fiber,nearestMounted=fiber;if(fiber.alternate)for(;node.return;)node=node.return;else{var nextNode=node;do node=nextNode,(node.flags&(Placement|Hydrating))!==NoFlags&&(nearestMounted=node.return),nextNode=node.return;while(nextNode)}return node.tag===HostRoot?nearestMounted:null}function getSuspenseInstanceFromFiber(fiber){if(fiber.tag===SuspenseComponent){var suspenseState=fiber.memoizedState;if(suspenseState===null){var current2=fiber.alternate;current2!==null&&(suspenseState=current2.memoizedState)}if(suspenseState!==null)return suspenseState.dehydrated}return null}function getContainerFromFiber(fiber){return fiber.tag===HostRoot?fiber.stateNode.containerInfo:null}function isFiberMounted(fiber){return getNearestMountedFiber(fiber)===fiber}function isMounted(component){{var owner=ReactCurrentOwner2.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner,instance=ownerFiber.stateNode;instance._warnedAboutRefsInRender||error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.",getComponentNameFromFiber(ownerFiber)||"A component"),instance._warnedAboutRefsInRender=!0}}var fiber=get(component);return fiber?getNearestMountedFiber(fiber)===fiber:!1}function assertIsMounted(fiber){if(getNearestMountedFiber(fiber)!==fiber)throw new Error("Unable to find node on an unmounted component.")}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){var nearestMounted=getNearestMountedFiber(fiber);if(nearestMounted===null)throw new Error("Unable to find node on an unmounted component.");return nearestMounted!==fiber?null:fiber}for(var a2=fiber,b2=alternate;;){var parentA=a2.return;if(parentA===null)break;var parentB=parentA.alternate;if(parentB===null){var nextParent=parentA.return;if(nextParent!==null){a2=b2=nextParent;continue}break}if(parentA.child===parentB.child){for(var child=parentA.child;child;){if(child===a2)return assertIsMounted(parentA),fiber;if(child===b2)return assertIsMounted(parentA),alternate;child=child.sibling}throw new Error("Unable to find node on an unmounted component.")}if(a2.return!==b2.return)a2=parentA,b2=parentB;else{for(var didFindChild=!1,_child=parentA.child;_child;){if(_child===a2){didFindChild=!0,a2=parentA,b2=parentB;break}if(_child===b2){didFindChild=!0,b2=parentA,a2=parentB;break}_child=_child.sibling}if(!didFindChild){for(_child=parentB.child;_child;){if(_child===a2){didFindChild=!0,a2=parentB,b2=parentA;break}if(_child===b2){didFindChild=!0,b2=parentB,a2=parentA;break}_child=_child.sibling}if(!didFindChild)throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.")}}if(a2.alternate!==b2)throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.")}if(a2.tag!==HostRoot)throw new Error("Unable to find node on an unmounted component.");return a2.stateNode.current===a2?fiber:alternate}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberImpl(currentParent):null}function findCurrentHostFiberImpl(node){if(node.tag===HostComponent||node.tag===HostText)return node;for(var child=node.child;child!==null;){var match=findCurrentHostFiberImpl(child);if(match!==null)return match;child=child.sibling}return null}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberWithNoPortalsImpl(currentParent):null}function findCurrentHostFiberWithNoPortalsImpl(node){if(node.tag===HostComponent||node.tag===HostText)return node;for(var child=node.child;child!==null;){if(child.tag!==HostPortal){var match=findCurrentHostFiberWithNoPortalsImpl(child);if(match!==null)return match}child=child.sibling}return null}var scheduleCallback=Scheduler.unstable_scheduleCallback,cancelCallback=Scheduler.unstable_cancelCallback,shouldYield=Scheduler.unstable_shouldYield,requestPaint=Scheduler.unstable_requestPaint,now2=Scheduler.unstable_now,getCurrentPriorityLevel=Scheduler.unstable_getCurrentPriorityLevel,ImmediatePriority=Scheduler.unstable_ImmediatePriority,UserBlockingPriority=Scheduler.unstable_UserBlockingPriority,NormalPriority=Scheduler.unstable_NormalPriority,LowPriority=Scheduler.unstable_LowPriority,IdlePriority=Scheduler.unstable_IdlePriority,unstable_yieldValue=Scheduler.unstable_yieldValue,unstable_setDisableYieldValue=Scheduler.unstable_setDisableYieldValue,rendererID=null,injectedHook=null,injectedProfilingHooks=null,hasLoggedError=!1,isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u";function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")return!1;var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled)return!0;if(!hook.supportsFiber)return error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"),!0;try{enableSchedulingProfiler&&(internals=assign({},internals,{getLaneLabelMap,injectProfilingHooks})),rendererID=hook.inject(internals),injectedHook=hook}catch(err){error("React instrumentation encountered an error: %s.",err)}return!!hook.checkDCE}function onScheduleRoot(root2,children){if(injectedHook&&typeof injectedHook.onScheduleFiberRoot=="function")try{injectedHook.onScheduleFiberRoot(rendererID,root2,children)}catch(err){hasLoggedError||(hasLoggedError=!0,error("React instrumentation encountered an error: %s",err))}}function onCommitRoot(root2,eventPriority){if(injectedHook&&typeof injectedHook.onCommitFiberRoot=="function")try{var didError=(root2.current.flags&DidCapture)===DidCapture;if(enableProfilerTimer){var schedulerPriority;switch(eventPriority){case DiscreteEventPriority:schedulerPriority=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriority=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriority=NormalPriority;break;case IdleEventPriority:schedulerPriority=IdlePriority;break;default:schedulerPriority=NormalPriority;break}injectedHook.onCommitFiberRoot(rendererID,root2,schedulerPriority,didError)}}catch(err){hasLoggedError||(hasLoggedError=!0,error("React instrumentation encountered an error: %s",err))}}function onPostCommitRoot(root2){if(injectedHook&&typeof injectedHook.onPostCommitFiberRoot=="function")try{injectedHook.onPostCommitFiberRoot(rendererID,root2)}catch(err){hasLoggedError||(hasLoggedError=!0,error("React instrumentation encountered an error: %s",err))}}function onCommitUnmount(fiber){if(injectedHook&&typeof injectedHook.onCommitFiberUnmount=="function")try{injectedHook.onCommitFiberUnmount(rendererID,fiber)}catch(err){hasLoggedError||(hasLoggedError=!0,error("React instrumentation encountered an error: %s",err))}}function setIsStrictModeForDevtools(newIsStrictMode){if(typeof unstable_yieldValue=="function"&&(unstable_setDisableYieldValue(newIsStrictMode),setSuppressWarning(newIsStrictMode)),injectedHook&&typeof injectedHook.setStrictMode=="function")try{injectedHook.setStrictMode(rendererID,newIsStrictMode)}catch(err){hasLoggedError||(hasLoggedError=!0,error("React instrumentation encountered an error: %s",err))}}function injectProfilingHooks(profilingHooks){injectedProfilingHooks=profilingHooks}function getLaneLabelMap(){{for(var map=new Map,lane=1,index2=0;index2<TotalLanes;index2++){var label=getLabelForLane(lane);map.set(lane,label),lane*=2}return map}}function markCommitStarted(lanes){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStarted=="function"&&injectedProfilingHooks.markCommitStarted(lanes)}function markCommitStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStopped=="function"&&injectedProfilingHooks.markCommitStopped()}function markComponentRenderStarted(fiber){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStarted=="function"&&injectedProfilingHooks.markComponentRenderStarted(fiber)}function markComponentRenderStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStopped=="function"&&injectedProfilingHooks.markComponentRenderStopped()}function markComponentPassiveEffectMountStarted(fiber){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted=="function"&&injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber)}function markComponentPassiveEffectMountStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped=="function"&&injectedProfilingHooks.markComponentPassiveEffectMountStopped()}function markComponentPassiveEffectUnmountStarted(fiber){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted=="function"&&injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber)}function markComponentPassiveEffectUnmountStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped=="function"&&injectedProfilingHooks.markComponentPassiveEffectUnmountStopped()}function markComponentLayoutEffectMountStarted(fiber){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted=="function"&&injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber)}function markComponentLayoutEffectMountStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped=="function"&&injectedProfilingHooks.markComponentLayoutEffectMountStopped()}function markComponentLayoutEffectUnmountStarted(fiber){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted=="function"&&injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber)}function markComponentLayoutEffectUnmountStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped=="function"&&injectedProfilingHooks.markComponentLayoutEffectUnmountStopped()}function markComponentErrored(fiber,thrownValue,lanes){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentErrored=="function"&&injectedProfilingHooks.markComponentErrored(fiber,thrownValue,lanes)}function markComponentSuspended(fiber,wakeable,lanes){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentSuspended=="function"&&injectedProfilingHooks.markComponentSuspended(fiber,wakeable,lanes)}function markLayoutEffectsStarted(lanes){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStarted=="function"&&injectedProfilingHooks.markLayoutEffectsStarted(lanes)}function markLayoutEffectsStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStopped=="function"&&injectedProfilingHooks.markLayoutEffectsStopped()}function markPassiveEffectsStarted(lanes){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStarted=="function"&&injectedProfilingHooks.markPassiveEffectsStarted(lanes)}function markPassiveEffectsStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStopped=="function"&&injectedProfilingHooks.markPassiveEffectsStopped()}function markRenderStarted(lanes){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStarted=="function"&&injectedProfilingHooks.markRenderStarted(lanes)}function markRenderYielded(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderYielded=="function"&&injectedProfilingHooks.markRenderYielded()}function markRenderStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStopped=="function"&&injectedProfilingHooks.markRenderStopped()}function markRenderScheduled(lane){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderScheduled=="function"&&injectedProfilingHooks.markRenderScheduled(lane)}function markForceUpdateScheduled(fiber,lane){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markForceUpdateScheduled=="function"&&injectedProfilingHooks.markForceUpdateScheduled(fiber,lane)}function markStateUpdateScheduled(fiber,lane){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markStateUpdateScheduled=="function"&&injectedProfilingHooks.markStateUpdateScheduled(fiber,lane)}var NoMode=0,ConcurrentMode=1,ProfileMode=2,StrictLegacyMode=8,StrictEffectsMode=16,clz32=Math.clz32?Math.clz32:clz32Fallback,log=Math.log,LN2=Math.LN2;function clz32Fallback(x2){var asUint=x2>>>0;return asUint===0?32:31-(log(asUint)/LN2|0)|0}var TotalLanes=31,NoLanes=0,NoLane=0,SyncLane=1,InputContinuousHydrationLane=2,InputContinuousLane=4,DefaultHydrationLane=8,DefaultLane=16,TransitionHydrationLane=32,TransitionLanes=4194240,TransitionLane1=64,TransitionLane2=128,TransitionLane3=256,TransitionLane4=512,TransitionLane5=1024,TransitionLane6=2048,TransitionLane7=4096,TransitionLane8=8192,TransitionLane9=16384,TransitionLane10=32768,TransitionLane11=65536,TransitionLane12=131072,TransitionLane13=262144,TransitionLane14=524288,TransitionLane15=1048576,TransitionLane16=2097152,RetryLanes=130023424,RetryLane1=4194304,RetryLane2=8388608,RetryLane3=16777216,RetryLane4=33554432,RetryLane5=67108864,SomeRetryLane=RetryLane1,SelectiveHydrationLane=134217728,NonIdleLanes=268435455,IdleHydrationLane=268435456,IdleLane=536870912,OffscreenLane=1073741824;function getLabelForLane(lane){{if(lane&SyncLane)return"Sync";if(lane&InputContinuousHydrationLane)return"InputContinuousHydration";if(lane&InputContinuousLane)return"InputContinuous";if(lane&DefaultHydrationLane)return"DefaultHydration";if(lane&DefaultLane)return"Default";if(lane&TransitionHydrationLane)return"TransitionHydration";if(lane&TransitionLanes)return"Transition";if(lane&RetryLanes)return"Retry";if(lane&SelectiveHydrationLane)return"SelectiveHydration";if(lane&IdleHydrationLane)return"IdleHydration";if(lane&IdleLane)return"Idle";if(lane&OffscreenLane)return"Offscreen"}}var NoTimestamp=-1,nextTransitionLane=TransitionLane1,nextRetryLane=RetryLane1;function getHighestPriorityLanes(lanes){switch(getHighestPriorityLane(lanes)){case SyncLane:return SyncLane;case InputContinuousHydrationLane:return InputContinuousHydrationLane;case InputContinuousLane:return InputContinuousLane;case DefaultHydrationLane:return DefaultHydrationLane;case DefaultLane:return DefaultLane;case TransitionHydrationLane:return TransitionHydrationLane;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return lanes&TransitionLanes;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:return lanes&RetryLanes;case SelectiveHydrationLane:return SelectiveHydrationLane;case IdleHydrationLane:return IdleHydrationLane;case IdleLane:return IdleLane;case OffscreenLane:return OffscreenLane;default:return error("Should have found matching lanes. This is a bug in React."),lanes}}function getNextLanes(root2,wipLanes){var pendingLanes=root2.pendingLanes;if(pendingLanes===NoLanes)return NoLanes;var nextLanes=NoLanes,suspendedLanes=root2.suspendedLanes,pingedLanes=root2.pingedLanes,nonIdlePendingLanes=pendingLanes&NonIdleLanes;if(nonIdlePendingLanes!==NoLanes){var nonIdleUnblockedLanes=nonIdlePendingLanes&~suspendedLanes;if(nonIdleUnblockedLanes!==NoLanes)nextLanes=getHighestPriorityLanes(nonIdleUnblockedLanes);else{var nonIdlePingedLanes=nonIdlePendingLanes&pingedLanes;nonIdlePingedLanes!==NoLanes&&(nextLanes=getHighestPriorityLanes(nonIdlePingedLanes))}}else{var unblockedLanes=pendingLanes&~suspendedLanes;unblockedLanes!==NoLanes?nextLanes=getHighestPriorityLanes(unblockedLanes):pingedLanes!==NoLanes&&(nextLanes=getHighestPriorityLanes(pingedLanes))}if(nextLanes===NoLanes)return NoLanes;if(wipLanes!==NoLanes&&wipLanes!==nextLanes&&(wipLanes&suspendedLanes)===NoLanes){var nextLane=getHighestPriorityLane(nextLanes),wipLane=getHighestPriorityLane(wipLanes);if(nextLane>=wipLane||nextLane===DefaultLane&&(wipLane&TransitionLanes)!==NoLanes)return wipLanes}(nextLanes&InputContinuousLane)!==NoLanes&&(nextLanes|=pendingLanes&DefaultLane);var entangledLanes=root2.entangledLanes;if(entangledLanes!==NoLanes)for(var entanglements=root2.entanglements,lanes=nextLanes&entangledLanes;lanes>0;){var index2=pickArbitraryLaneIndex(lanes),lane=1<<index2;nextLanes|=entanglements[index2],lanes&=~lane}return nextLanes}function getMostRecentEventTime(root2,lanes){for(var eventTimes=root2.eventTimes,mostRecentEventTime=NoTimestamp;lanes>0;){var index2=pickArbitraryLaneIndex(lanes),lane=1<<index2,eventTime=eventTimes[index2];eventTime>mostRecentEventTime&&(mostRecentEventTime=eventTime),lanes&=~lane}return mostRecentEventTime}function computeExpirationTime(lane,currentTime){switch(lane){case SyncLane:case InputContinuousHydrationLane:case InputContinuousLane:return currentTime+250;case DefaultHydrationLane:case DefaultLane:case TransitionHydrationLane:case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return currentTime+5e3;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:return NoTimestamp;case SelectiveHydrationLane:case IdleHydrationLane:case IdleLane:case OffscreenLane:return NoTimestamp;default:return error("Should have found matching lanes. This is a bug in React."),NoTimestamp}}function markStarvedLanesAsExpired(root2,currentTime){for(var pendingLanes=root2.pendingLanes,suspendedLanes=root2.suspendedLanes,pingedLanes=root2.pingedLanes,expirationTimes=root2.expirationTimes,lanes=pendingLanes;lanes>0;){var index2=pickArbitraryLaneIndex(lanes),lane=1<<index2,expirationTime=expirationTimes[index2];expirationTime===NoTimestamp?((lane&suspendedLanes)===NoLanes||(lane&pingedLanes)!==NoLanes)&&(expirationTimes[index2]=computeExpirationTime(lane,currentTime)):expirationTime<=currentTime&&(root2.expiredLanes|=lane),lanes&=~lane}}function getHighestPriorityPendingLanes(root2){return getHighestPriorityLanes(root2.pendingLanes)}function getLanesToRetrySynchronouslyOnError(root2){var everythingButOffscreen=root2.pendingLanes&~OffscreenLane;return everythingButOffscreen!==NoLanes?everythingButOffscreen:everythingButOffscreen&OffscreenLane?OffscreenLane:NoLanes}function includesSyncLane(lanes){return(lanes&SyncLane)!==NoLanes}function includesNonIdleWork(lanes){return(lanes&NonIdleLanes)!==NoLanes}function includesOnlyRetries(lanes){return(lanes&RetryLanes)===lanes}function includesOnlyNonUrgentLanes(lanes){var UrgentLanes=SyncLane|InputContinuousLane|DefaultLane;return(lanes&UrgentLanes)===NoLanes}function includesOnlyTransitions(lanes){return(lanes&TransitionLanes)===lanes}function includesBlockingLane(root2,lanes){var SyncDefaultLanes=InputContinuousHydrationLane|InputContinuousLane|DefaultHydrationLane|DefaultLane;return(lanes&SyncDefaultLanes)!==NoLanes}function includesExpiredLane(root2,lanes){return(lanes&root2.expiredLanes)!==NoLanes}function isTransitionLane(lane){return(lane&TransitionLanes)!==NoLanes}function claimNextTransitionLane(){var lane=nextTransitionLane;return nextTransitionLane<<=1,(nextTransitionLane&TransitionLanes)===NoLanes&&(nextTransitionLane=TransitionLane1),lane}function claimNextRetryLane(){var lane=nextRetryLane;return nextRetryLane<<=1,(nextRetryLane&RetryLanes)===NoLanes&&(nextRetryLane=RetryLane1),lane}function getHighestPriorityLane(lanes){return lanes&-lanes}function pickArbitraryLane(lanes){return getHighestPriorityLane(lanes)}function pickArbitraryLaneIndex(lanes){return 31-clz32(lanes)}function laneToIndex(lane){return pickArbitraryLaneIndex(lane)}function includesSomeLane(a2,b2){return(a2&b2)!==NoLanes}function isSubsetOfLanes(set2,subset){return(set2&subset)===subset}function mergeLanes(a2,b2){return a2|b2}function removeLanes(set2,subset){return set2&~subset}function intersectLanes(a2,b2){return a2&b2}function laneToLanes(lane){return lane}function higherPriorityLane(a2,b2){return a2!==NoLane&&a2<b2?a2:b2}function createLaneMap(initial){for(var laneMap=[],i2=0;i2<TotalLanes;i2++)laneMap.push(initial);return laneMap}function markRootUpdated(root2,updateLane,eventTime){root2.pendingLanes|=updateLane,updateLane!==IdleLane&&(root2.suspendedLanes=NoLanes,root2.pingedLanes=NoLanes);var eventTimes=root2.eventTimes,index2=laneToIndex(updateLane);eventTimes[index2]=eventTime}function markRootSuspended(root2,suspendedLanes){root2.suspendedLanes|=suspendedLanes,root2.pingedLanes&=~suspendedLanes;for(var expirationTimes=root2.expirationTimes,lanes=suspendedLanes;lanes>0;){var index2=pickArbitraryLaneIndex(lanes),lane=1<<index2;expirationTimes[index2]=NoTimestamp,lanes&=~lane}}function markRootPinged(root2,pingedLanes,eventTime){root2.pingedLanes|=root2.suspendedLanes&pingedLanes}function markRootFinished(root2,remainingLanes){var noLongerPendingLanes=root2.pendingLanes&~remainingLanes;root2.pendingLanes=remainingLanes,root2.suspendedLanes=NoLanes,root2.pingedLanes=NoLanes,root2.expiredLanes&=remainingLanes,root2.mutableReadLanes&=remainingLanes,root2.entangledLanes&=remainingLanes;for(var entanglements=root2.entanglements,eventTimes=root2.eventTimes,expirationTimes=root2.expirationTimes,lanes=noLongerPendingLanes;lanes>0;){var index2=pickArbitraryLaneIndex(lanes),lane=1<<index2;entanglements[index2]=NoLanes,eventTimes[index2]=NoTimestamp,expirationTimes[index2]=NoTimestamp,lanes&=~lane}}function markRootEntangled(root2,entangledLanes){for(var rootEntangledLanes=root2.entangledLanes|=entangledLanes,entanglements=root2.entanglements,lanes=rootEntangledLanes;lanes;){var index2=pickArbitraryLaneIndex(lanes),lane=1<<index2;lane&entangledLanes|entanglements[index2]&entangledLanes&&(entanglements[index2]|=entangledLanes),lanes&=~lane}}function getBumpedLaneForHydration(root2,renderLanes2){var renderLane=getHighestPriorityLane(renderLanes2),lane;switch(renderLane){case InputContinuousLane:lane=InputContinuousHydrationLane;break;case DefaultLane:lane=DefaultHydrationLane;break;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:lane=TransitionHydrationLane;break;case IdleLane:lane=IdleHydrationLane;break;default:lane=NoLane;break}return(lane&(root2.suspendedLanes|renderLanes2))!==NoLane?NoLane:lane}function addFiberToLanesMap(root2,fiber,lanes){if(isDevToolsPresent)for(var pendingUpdatersLaneMap=root2.pendingUpdatersLaneMap;lanes>0;){var index2=laneToIndex(lanes),lane=1<<index2,updaters=pendingUpdatersLaneMap[index2];updaters.add(fiber),lanes&=~lane}}function movePendingFibersToMemoized(root2,lanes){if(isDevToolsPresent)for(var pendingUpdatersLaneMap=root2.pendingUpdatersLaneMap,memoizedUpdaters=root2.memoizedUpdaters;lanes>0;){var index2=laneToIndex(lanes),lane=1<<index2,updaters=pendingUpdatersLaneMap[index2];updaters.size>0&&(updaters.forEach(function(fiber){var alternate=fiber.alternate;(alternate===null||!memoizedUpdaters.has(alternate))&&memoizedUpdaters.add(fiber)}),updaters.clear()),lanes&=~lane}}function getTransitionsForLanes(root2,lanes){return null}var DiscreteEventPriority=SyncLane,ContinuousEventPriority=InputContinuousLane,DefaultEventPriority=DefaultLane,IdleEventPriority=IdleLane,currentUpdatePriority=NoLane;function getCurrentUpdatePriority(){return currentUpdatePriority}function setCurrentUpdatePriority(newPriority){currentUpdatePriority=newPriority}function runWithPriority(priority,fn){var previousPriority=currentUpdatePriority;try{return currentUpdatePriority=priority,fn()}finally{currentUpdatePriority=previousPriority}}function higherEventPriority(a2,b2){return a2!==0&&a2<b2?a2:b2}function lowerEventPriority(a2,b2){return a2===0||a2>b2?a2:b2}function isHigherEventPriority(a2,b2){return a2!==0&&a2<b2}function lanesToEventPriority(lanes){var lane=getHighestPriorityLane(lanes);return isHigherEventPriority(DiscreteEventPriority,lane)?isHigherEventPriority(ContinuousEventPriority,lane)?includesNonIdleWork(lane)?DefaultEventPriority:IdleEventPriority:ContinuousEventPriority:DiscreteEventPriority}function isRootDehydrated(root2){var currentState=root2.current.memoizedState;return currentState.isDehydrated}var _attemptSynchronousHydration;function setAttemptSynchronousHydration(fn){_attemptSynchronousHydration=fn}function attemptSynchronousHydration(fiber){_attemptSynchronousHydration(fiber)}var attemptContinuousHydration;function setAttemptContinuousHydration(fn){attemptContinuousHydration=fn}var attemptHydrationAtCurrentPriority;function setAttemptHydrationAtCurrentPriority(fn){attemptHydrationAtCurrentPriority=fn}var getCurrentUpdatePriority$1;function setGetCurrentUpdatePriority(fn){getCurrentUpdatePriority$1=fn}var attemptHydrationAtPriority;function setAttemptHydrationAtPriority(fn){attemptHydrationAtPriority=fn}var hasScheduledReplayAttempt=!1,queuedDiscreteEvents=[],queuedFocus=null,queuedDrag=null,queuedMouse=null,queuedPointers=new Map,queuedPointerCaptures=new Map,queuedExplicitHydrationTargets=[],discreteReplayableEvents=["mousedown","mouseup","touchcancel","touchend","touchstart","auxclick","dblclick","pointercancel","pointerdown","pointerup","dragend","dragstart","drop","compositionend","compositionstart","keydown","keypress","keyup","input","textInput","copy","cut","paste","click","change","contextmenu","reset","submit"];function isDiscreteEventThatRequiresHydration(eventType){return discreteReplayableEvents.indexOf(eventType)>-1}function createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){return{blockedOn,domEventName,eventSystemFlags,nativeEvent,targetContainers:[targetContainer]}}function clearIfContinuousEvent(domEventName,nativeEvent){switch(domEventName){case"focusin":case"focusout":queuedFocus=null;break;case"dragenter":case"dragleave":queuedDrag=null;break;case"mouseover":case"mouseout":queuedMouse=null;break;case"pointerover":case"pointerout":{var pointerId=nativeEvent.pointerId;queuedPointers.delete(pointerId);break}case"gotpointercapture":case"lostpointercapture":{var _pointerId=nativeEvent.pointerId;queuedPointerCaptures.delete(_pointerId);break}}}function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent,blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){if(existingQueuedEvent===null||existingQueuedEvent.nativeEvent!==nativeEvent){var queuedEvent=createQueuedReplayableEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn!==null){var _fiber2=getInstanceFromNode(blockedOn);_fiber2!==null&&attemptContinuousHydration(_fiber2)}return queuedEvent}existingQueuedEvent.eventSystemFlags|=eventSystemFlags;var targetContainers=existingQueuedEvent.targetContainers;return targetContainer!==null&&targetContainers.indexOf(targetContainer)===-1&&targetContainers.push(targetContainer),existingQueuedEvent}function queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent){switch(domEventName){case"focusin":{var focusEvent=nativeEvent;return queuedFocus=accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus,blockedOn,domEventName,eventSystemFlags,targetContainer,focusEvent),!0}case"dragenter":{var dragEvent=nativeEvent;return queuedDrag=accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag,blockedOn,domEventName,eventSystemFlags,targetContainer,dragEvent),!0}case"mouseover":{var mouseEvent=nativeEvent;return queuedMouse=accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse,blockedOn,domEventName,eventSystemFlags,targetContainer,mouseEvent),!0}case"pointerover":{var pointerEvent=nativeEvent,pointerId=pointerEvent.pointerId;return queuedPointers.set(pointerId,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,pointerEvent)),!0}case"gotpointercapture":{var _pointerEvent=nativeEvent,_pointerId2=_pointerEvent.pointerId;return queuedPointerCaptures.set(_pointerId2,accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2)||null,blockedOn,domEventName,eventSystemFlags,targetContainer,_pointerEvent)),!0}}return!1}function attemptExplicitHydrationTarget(queuedTarget){var targetInst=getClosestInstanceFromNode(queuedTarget.target);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted!==null){var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null){queuedTarget.blockedOn=instance,attemptHydrationAtPriority(queuedTarget.priority,function(){attemptHydrationAtCurrentPriority(nearestMounted)});return}}else if(tag===HostRoot){var root2=nearestMounted.stateNode;if(isRootDehydrated(root2)){queuedTarget.blockedOn=getContainerFromFiber(nearestMounted);return}}}}queuedTarget.blockedOn=null}function queueExplicitHydrationTarget(target){for(var updatePriority=getCurrentUpdatePriority$1(),queuedTarget={blockedOn:null,target,priority:updatePriority},i2=0;i2<queuedExplicitHydrationTargets.length&&isHigherEventPriority(updatePriority,queuedExplicitHydrationTargets[i2].priority);i2++);queuedExplicitHydrationTargets.splice(i2,0,queuedTarget),i2===0&&attemptExplicitHydrationTarget(queuedTarget)}function attemptReplayContinuousQueuedEvent(queuedEvent){if(queuedEvent.blockedOn!==null)return!1;for(var targetContainers=queuedEvent.targetContainers;targetContainers.length>0;){var targetContainer=targetContainers[0],nextBlockedOn=findInstanceBlockingEvent(queuedEvent.domEventName,queuedEvent.eventSystemFlags,targetContainer,queuedEvent.nativeEvent);if(nextBlockedOn===null){var nativeEvent=queuedEvent.nativeEvent,nativeEventClone=new nativeEvent.constructor(nativeEvent.type,nativeEvent);setReplayingEvent(nativeEventClone),nativeEvent.target.dispatchEvent(nativeEventClone),resetReplayingEvent()}else{var _fiber3=getInstanceFromNode(nextBlockedOn);return _fiber3!==null&&attemptContinuousHydration(_fiber3),queuedEvent.blockedOn=nextBlockedOn,!1}targetContainers.shift()}return!0}function attemptReplayContinuousQueuedEventInMap(queuedEvent,key,map){attemptReplayContinuousQueuedEvent(queuedEvent)&&map.delete(key)}function replayUnblockedEvents(){hasScheduledReplayAttempt=!1,queuedFocus!==null&&attemptReplayContinuousQueuedEvent(queuedFocus)&&(queuedFocus=null),queuedDrag!==null&&attemptReplayContinuousQueuedEvent(queuedDrag)&&(queuedDrag=null),queuedMouse!==null&&attemptReplayContinuousQueuedEvent(queuedMouse)&&(queuedMouse=null),queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap),queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap)}function scheduleCallbackIfUnblocked(queuedEvent,unblocked){queuedEvent.blockedOn===unblocked&&(queuedEvent.blockedOn=null,hasScheduledReplayAttempt||(hasScheduledReplayAttempt=!0,Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority,replayUnblockedEvents)))}function retryIfBlockedOn(unblocked){if(queuedDiscreteEvents.length>0){scheduleCallbackIfUnblocked(queuedDiscreteEvents[0],unblocked);for(var i2=1;i2<queuedDiscreteEvents.length;i2++){var queuedEvent=queuedDiscreteEvents[i2];queuedEvent.blockedOn===unblocked&&(queuedEvent.blockedOn=null)}}queuedFocus!==null&&scheduleCallbackIfUnblocked(queuedFocus,unblocked),queuedDrag!==null&&scheduleCallbackIfUnblocked(queuedDrag,unblocked),queuedMouse!==null&&scheduleCallbackIfUnblocked(queuedMouse,unblocked);var unblock=function(queuedEvent2){return scheduleCallbackIfUnblocked(queuedEvent2,unblocked)};queuedPointers.forEach(unblock),queuedPointerCaptures.forEach(unblock);for(var _i=0;_i<queuedExplicitHydrationTargets.length;_i++){var queuedTarget=queuedExplicitHydrationTargets[_i];queuedTarget.blockedOn===unblocked&&(queuedTarget.blockedOn=null)}for(;queuedExplicitHydrationTargets.length>0;){var nextExplicitTarget=queuedExplicitHydrationTargets[0];if(nextExplicitTarget.blockedOn!==null)break;attemptExplicitHydrationTarget(nextExplicitTarget),nextExplicitTarget.blockedOn===null&&queuedExplicitHydrationTargets.shift()}}var ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig,_enabled=!0;function setEnabled(enabled){_enabled=!!enabled}function isEnabled(){return _enabled}function createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags){var eventPriority=getEventPriority2(domEventName),listenerWrapper;switch(eventPriority){case DiscreteEventPriority:listenerWrapper=dispatchDiscreteEvent;break;case ContinuousEventPriority:listenerWrapper=dispatchContinuousEvent;break;case DefaultEventPriority:default:listenerWrapper=dispatchEvent;break}return listenerWrapper.bind(null,domEventName,eventSystemFlags,targetContainer)}function dispatchDiscreteEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority(),prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(DiscreteEventPriority),dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent)}finally{setCurrentUpdatePriority(previousPriority),ReactCurrentBatchConfig.transition=prevTransition}}function dispatchContinuousEvent(domEventName,eventSystemFlags,container,nativeEvent){var previousPriority=getCurrentUpdatePriority(),prevTransition=ReactCurrentBatchConfig.transition;ReactCurrentBatchConfig.transition=null;try{setCurrentUpdatePriority(ContinuousEventPriority),dispatchEvent(domEventName,eventSystemFlags,container,nativeEvent)}finally{setCurrentUpdatePriority(previousPriority),ReactCurrentBatchConfig.transition=prevTransition}}function dispatchEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){_enabled&&dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent)}function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName,eventSystemFlags,targetContainer,nativeEvent){var blockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(blockedOn===null){dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer),clearIfContinuousEvent(domEventName,nativeEvent);return}if(queueIfContinuousEvent(blockedOn,domEventName,eventSystemFlags,targetContainer,nativeEvent)){nativeEvent.stopPropagation();return}if(clearIfContinuousEvent(domEventName,nativeEvent),eventSystemFlags&IS_CAPTURE_PHASE&&isDiscreteEventThatRequiresHydration(domEventName)){for(;blockedOn!==null;){var fiber=getInstanceFromNode(blockedOn);fiber!==null&&attemptSynchronousHydration(fiber);var nextBlockedOn=findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent);if(nextBlockedOn===null&&dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,return_targetInst,targetContainer),nextBlockedOn===blockedOn)break;blockedOn=nextBlockedOn}blockedOn!==null&&nativeEvent.stopPropagation();return}dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,null,targetContainer)}var return_targetInst=null;function findInstanceBlockingEvent(domEventName,eventSystemFlags,targetContainer,nativeEvent){return_targetInst=null;var nativeEventTarget=getEventTarget(nativeEvent),targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null){var nearestMounted=getNearestMountedFiber(targetInst);if(nearestMounted===null)targetInst=null;else{var tag=nearestMounted.tag;if(tag===SuspenseComponent){var instance=getSuspenseInstanceFromFiber(nearestMounted);if(instance!==null)return instance;targetInst=null}else if(tag===HostRoot){var root2=nearestMounted.stateNode;if(isRootDehydrated(root2))return getContainerFromFiber(nearestMounted);targetInst=null}else nearestMounted!==targetInst&&(targetInst=null)}}return return_targetInst=targetInst,null}function getEventPriority2(domEventName){switch(domEventName){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return DiscreteEventPriority;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return ContinuousEventPriority;case"message":{var schedulerPriority=getCurrentPriorityLevel();switch(schedulerPriority){case ImmediatePriority:return DiscreteEventPriority;case UserBlockingPriority:return ContinuousEventPriority;case NormalPriority:case LowPriority:return DefaultEventPriority;case IdlePriority:return IdleEventPriority;default:return DefaultEventPriority}}default:return DefaultEventPriority}}function addEventBubbleListener(target,eventType,listener){return target.addEventListener(eventType,listener,!1),listener}function addEventCaptureListener(target,eventType,listener){return target.addEventListener(eventType,listener,!0),listener}function addEventCaptureListenerWithPassiveFlag(target,eventType,listener,passive){return target.addEventListener(eventType,listener,{capture:!0,passive}),listener}function addEventBubbleListenerWithPassiveFlag(target,eventType,listener,passive){return target.addEventListener(eventType,listener,{passive}),listener}var root=null,startText=null,fallbackText=null;function initialize(nativeEventTarget){return root=nativeEventTarget,startText=getText(),!0}function reset(){root=null,startText=null,fallbackText=null}function getData2(){if(fallbackText)return fallbackText;var start,startValue=startText,startLength=startValue.length,end,endValue=getText(),endLength=endValue.length;for(start=0;start<startLength&&startValue[start]===endValue[start];start++);var minEnd=startLength-start;for(end=1;end<=minEnd&&startValue[startLength-end]===endValue[endLength-end];end++);var sliceTail=end>1?1-end:void 0;return fallbackText=endValue.slice(start,sliceTail),fallbackText}function getText(){return"value"in root?root.value:root.textContent}function getEventCharCode(nativeEvent){var charCode,keyCode=nativeEvent.keyCode;return"charCode"in nativeEvent?(charCode=nativeEvent.charCode,charCode===0&&keyCode===13&&(charCode=13)):charCode=keyCode,charCode===10&&(charCode=13),charCode>=32||charCode===13?charCode:0}function functionThatReturnsTrue(){return!0}function functionThatReturnsFalse(){return!1}function createSyntheticEvent(Interface){function SyntheticBaseEvent(reactName,reactEventType,targetInst,nativeEvent,nativeEventTarget){this._reactName=reactName,this._targetInst=targetInst,this.type=reactEventType,this.nativeEvent=nativeEvent,this.target=nativeEventTarget,this.currentTarget=null;for(var _propName in Interface)if(Interface.hasOwnProperty(_propName)){var normalize2=Interface[_propName];normalize2?this[_propName]=normalize2(nativeEvent):this[_propName]=nativeEvent[_propName]}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===!1;return defaultPrevented?this.isDefaultPrevented=functionThatReturnsTrue:this.isDefaultPrevented=functionThatReturnsFalse,this.isPropagationStopped=functionThatReturnsFalse,this}return assign(SyntheticBaseEvent.prototype,{preventDefault:function(){this.defaultPrevented=!0;var event=this.nativeEvent;event&&(event.preventDefault?event.preventDefault():typeof event.returnValue!="unknown"&&(event.returnValue=!1),this.isDefaultPrevented=functionThatReturnsTrue)},stopPropagation:function(){var event=this.nativeEvent;event&&(event.stopPropagation?event.stopPropagation():typeof event.cancelBubble!="unknown"&&(event.cancelBubble=!0),this.isPropagationStopped=functionThatReturnsTrue)},persist:function(){},isPersistent:functionThatReturnsTrue}),SyntheticBaseEvent}var EventInterface={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(event){return event.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},SyntheticEvent=createSyntheticEvent(EventInterface),UIEventInterface=assign({},EventInterface,{view:0,detail:0}),SyntheticUIEvent=createSyntheticEvent(UIEventInterface),lastMovementX,lastMovementY,lastMouseEvent;function updateMouseMovementPolyfillState(event){event!==lastMouseEvent&&(lastMouseEvent&&event.type==="mousemove"?(lastMovementX=event.screenX-lastMouseEvent.screenX,lastMovementY=event.screenY-lastMouseEvent.screenY):(lastMovementX=0,lastMovementY=0),lastMouseEvent=event)}var MouseEventInterface=assign({},UIEventInterface,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:getEventModifierState,button:0,buttons:0,relatedTarget:function(event){return event.relatedTarget===void 0?event.fromElement===event.srcElement?event.toElement:event.fromElement:event.relatedTarget},movementX:function(event){return"movementX"in event?event.movementX:(updateMouseMovementPolyfillState(event),lastMovementX)},movementY:function(event){return"movementY"in event?event.movementY:lastMovementY}}),SyntheticMouseEvent=createSyntheticEvent(MouseEventInterface),DragEventInterface=assign({},MouseEventInterface,{dataTransfer:0}),SyntheticDragEvent=createSyntheticEvent(DragEventInterface),FocusEventInterface=assign({},UIEventInterface,{relatedTarget:0}),SyntheticFocusEvent=createSyntheticEvent(FocusEventInterface),AnimationEventInterface=assign({},EventInterface,{animationName:0,elapsedTime:0,pseudoElement:0}),SyntheticAnimationEvent=createSyntheticEvent(AnimationEventInterface),ClipboardEventInterface=assign({},EventInterface,{clipboardData:function(event){return"clipboardData"in event?event.clipboardData:window.clipboardData}}),SyntheticClipboardEvent=createSyntheticEvent(ClipboardEventInterface),CompositionEventInterface=assign({},EventInterface,{data:0}),SyntheticCompositionEvent=createSyntheticEvent(CompositionEventInterface),SyntheticInputEvent=SyntheticCompositionEvent,normalizeKey={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},translateToKey={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"};function getEventKey(nativeEvent){if(nativeEvent.key){var key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=="Unidentified")return key}if(nativeEvent.type==="keypress"){var charCode=getEventCharCode(nativeEvent);return charCode===13?"Enter":String.fromCharCode(charCode)}return nativeEvent.type==="keydown"||nativeEvent.type==="keyup"?translateToKey[nativeEvent.keyCode]||"Unidentified":""}var modifierKeyToProp={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function modifierStateGetter(keyArg){var syntheticEvent=this,nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState)return nativeEvent.getModifierState(keyArg);var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:!1}function getEventModifierState(nativeEvent){return modifierStateGetter}var KeyboardEventInterface=assign({},UIEventInterface,{key:getEventKey,code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:getEventModifierState,charCode:function(event){return event.type==="keypress"?getEventCharCode(event):0},keyCode:function(event){return event.type==="keydown"||event.type==="keyup"?event.keyCode:0},which:function(event){return event.type==="keypress"?getEventCharCode(event):event.type==="keydown"||event.type==="keyup"?event.keyCode:0}}),SyntheticKeyboardEvent=createSyntheticEvent(KeyboardEventInterface),PointerEventInterface=assign({},MouseEventInterface,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),SyntheticPointerEvent=createSyntheticEvent(PointerEventInterface),TouchEventInterface=assign({},UIEventInterface,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:getEventModifierState}),SyntheticTouchEvent=createSyntheticEvent(TouchEventInterface),TransitionEventInterface=assign({},EventInterface,{propertyName:0,elapsedTime:0,pseudoElement:0}),SyntheticTransitionEvent=createSyntheticEvent(TransitionEventInterface),WheelEventInterface=assign({},MouseEventInterface,{deltaX:function(event){return"deltaX"in event?event.deltaX:"wheelDeltaX"in event?-event.wheelDeltaX:0},deltaY:function(event){return"deltaY"in event?event.deltaY:"wheelDeltaY"in event?-event.wheelDeltaY:"wheelDelta"in event?-event.wheelDelta:0},deltaZ:0,deltaMode:0}),SyntheticWheelEvent=createSyntheticEvent(WheelEventInterface),END_KEYCODES=[9,13,27,32],START_KEYCODE=229,canUseCompositionEvent=canUseDOM&&"CompositionEvent"in window,documentMode=null;canUseDOM&&"documentMode"in document&&(documentMode=document.documentMode);var canUseTextInputEvent=canUseDOM&&"TextEvent"in window&&!documentMode,useFallbackCompositionData=canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11),SPACEBAR_CODE=32,SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);function registerEvents(){registerTwoPhaseEvent("onBeforeInput",["compositionend","keypress","textInput","paste"]),registerTwoPhaseEvent("onCompositionEnd",["compositionend","focusout","keydown","keypress","keyup","mousedown"]),registerTwoPhaseEvent("onCompositionStart",["compositionstart","focusout","keydown","keypress","keyup","mousedown"]),registerTwoPhaseEvent("onCompositionUpdate",["compositionupdate","focusout","keydown","keypress","keyup","mousedown"])}var hasSpaceKeypress=!1;function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&!(nativeEvent.ctrlKey&&nativeEvent.altKey)}function getCompositionEventType(domEventName){switch(domEventName){case"compositionstart":return"onCompositionStart";case"compositionend":return"onCompositionEnd";case"compositionupdate":return"onCompositionUpdate"}}function isFallbackCompositionStart(domEventName,nativeEvent){return domEventName==="keydown"&&nativeEvent.keyCode===START_KEYCODE}function isFallbackCompositionEnd(domEventName,nativeEvent){switch(domEventName){case"keyup":return END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case"keydown":return nativeEvent.keyCode!==START_KEYCODE;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;return typeof detail=="object"&&"data"in detail?detail.data:null}function isUsingKoreanIME(nativeEvent){return nativeEvent.locale==="ko"}var isComposing=!1;function extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var eventType,fallbackData;if(canUseCompositionEvent?eventType=getCompositionEventType(domEventName):isComposing?isFallbackCompositionEnd(domEventName,nativeEvent)&&(eventType="onCompositionEnd"):isFallbackCompositionStart(domEventName,nativeEvent)&&(eventType="onCompositionStart"),!eventType)return null;useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)&&(!isComposing&&eventType==="onCompositionStart"?isComposing=initialize(nativeEventTarget):eventType==="onCompositionEnd"&&isComposing&&(fallbackData=getData2()));var listeners=accumulateTwoPhaseListeners(targetInst,eventType);if(listeners.length>0){var event=new SyntheticCompositionEvent(eventType,domEventName,null,nativeEvent,nativeEventTarget);if(dispatchQueue.push({event,listeners}),fallbackData)event.data=fallbackData;else{var customData=getDataFromCustomEvent(nativeEvent);customData!==null&&(event.data=customData)}}}function getNativeBeforeInputChars(domEventName,nativeEvent){switch(domEventName){case"compositionend":return getDataFromCustomEvent(nativeEvent);case"keypress":var which=nativeEvent.which;return which!==SPACEBAR_CODE?null:(hasSpaceKeypress=!0,SPACEBAR_CHAR);case"textInput":var chars=nativeEvent.data;return chars===SPACEBAR_CHAR&&hasSpaceKeypress?null:chars;default:return null}}function getFallbackBeforeInputChars(domEventName,nativeEvent){if(isComposing){if(domEventName==="compositionend"||!canUseCompositionEvent&&isFallbackCompositionEnd(domEventName,nativeEvent)){var chars=getData2();return reset(),isComposing=!1,chars}return null}switch(domEventName){case"paste":return null;case"keypress":if(!isKeypressCommand(nativeEvent)){if(nativeEvent.char&&nativeEvent.char.length>1)return nativeEvent.char;if(nativeEvent.which)return String.fromCharCode(nativeEvent.which)}return null;case"compositionend":return useFallbackCompositionData&&!isUsingKoreanIME(nativeEvent)?null:nativeEvent.data;default:return null}}function extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent?chars=getNativeBeforeInputChars(domEventName,nativeEvent):chars=getFallbackBeforeInputChars(domEventName,nativeEvent),!chars)return null;var listeners=accumulateTwoPhaseListeners(targetInst,"onBeforeInput");if(listeners.length>0){var event=new SyntheticInputEvent("onBeforeInput","beforeinput",null,nativeEvent,nativeEventTarget);dispatchQueue.push({event,listeners}),event.data=chars}}function extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){extractCompositionEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget),extractBeforeInputEvent(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget)}var supportedInputTypes={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==="input"?!!supportedInputTypes[elem.type]:nodeName==="textarea"}/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */function isEventSupported(eventNameSuffix){if(!canUseDOM)return!1;var eventName="on"+eventNameSuffix,isSupported=eventName in document;if(!isSupported){var element=document.createElement("div");element.setAttribute(eventName,"return;"),isSupported=typeof element[eventName]=="function"}return isSupported}function registerEvents$1(){registerTwoPhaseEvent("onChange",["change","click","focusin","focusout","input","keydown","keyup","selectionchange"])}function createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,target){enqueueStateRestore(target);var listeners=accumulateTwoPhaseListeners(inst,"onChange");if(listeners.length>0){var event=new SyntheticEvent("onChange","change",null,nativeEvent,target);dispatchQueue.push({event,listeners})}}var activeElement=null,activeElementInst=null;function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==="select"||nodeName==="input"&&elem.type==="file"}function manualDispatchChangeEvent(nativeEvent){var dispatchQueue=[];createAndAccumulateChangeEvent(dispatchQueue,activeElementInst,nativeEvent,getEventTarget(nativeEvent)),batchedUpdates(runEventInBatch,dispatchQueue)}function runEventInBatch(dispatchQueue){processDispatchQueue(dispatchQueue,0)}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance(targetInst);if(updateValueIfChanged(targetNode))return targetInst}function getTargetInstForChangeEvent(domEventName,targetInst){if(domEventName==="change")return targetInst}var isInputEventSupported=!1;canUseDOM&&(isInputEventSupported=isEventSupported("input")&&(!document.documentMode||document.documentMode>9));function startWatchingForValueChange(target,targetInst){activeElement=target,activeElementInst=targetInst,activeElement.attachEvent("onpropertychange",handlePropertyChange)}function stopWatchingForValueChange(){activeElement&&(activeElement.detachEvent("onpropertychange",handlePropertyChange),activeElement=null,activeElementInst=null)}function handlePropertyChange(nativeEvent){nativeEvent.propertyName==="value"&&getInstIfValueChanged(activeElementInst)&&manualDispatchChangeEvent(nativeEvent)}function handleEventsForInputEventPolyfill(domEventName,target,targetInst){domEventName==="focusin"?(stopWatchingForValueChange(),startWatchingForValueChange(target,targetInst)):domEventName==="focusout"&&stopWatchingForValueChange()}function getTargetInstForInputEventPolyfill(domEventName,targetInst){if(domEventName==="selectionchange"||domEventName==="keyup"||domEventName==="keydown")return getInstIfValueChanged(activeElementInst)}function shouldUseClickEvent(elem){var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==="input"&&(elem.type==="checkbox"||elem.type==="radio")}function getTargetInstForClickEvent(domEventName,targetInst){if(domEventName==="click")return getInstIfValueChanged(targetInst)}function getTargetInstForInputOrChangeEvent(domEventName,targetInst){if(domEventName==="input"||domEventName==="change")return getInstIfValueChanged(targetInst)}function handleControlledInputBlur(node){var state=node._wrapperState;!state||!state.controlled||node.type!=="number"||setDefaultValue(node,"number",node.value)}function extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window,getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)?getTargetInstFunc=getTargetInstForChangeEvent:isTextInputElement(targetNode)?isInputEventSupported?getTargetInstFunc=getTargetInstForInputOrChangeEvent:(getTargetInstFunc=getTargetInstForInputEventPolyfill,handleEventFunc=handleEventsForInputEventPolyfill):shouldUseClickEvent(targetNode)&&(getTargetInstFunc=getTargetInstForClickEvent),getTargetInstFunc){var inst=getTargetInstFunc(domEventName,targetInst);if(inst){createAndAccumulateChangeEvent(dispatchQueue,inst,nativeEvent,nativeEventTarget);return}}handleEventFunc&&handleEventFunc(domEventName,targetNode,targetInst),domEventName==="focusout"&&handleControlledInputBlur(targetNode)}function registerEvents$2(){registerDirectEvent("onMouseEnter",["mouseout","mouseover"]),registerDirectEvent("onMouseLeave",["mouseout","mouseover"]),registerDirectEvent("onPointerEnter",["pointerout","pointerover"]),registerDirectEvent("onPointerLeave",["pointerout","pointerover"])}function extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var isOverEvent=domEventName==="mouseover"||domEventName==="pointerover",isOutEvent=domEventName==="mouseout"||domEventName==="pointerout";if(isOverEvent&&!isReplayingEvent(nativeEvent)){var related=nativeEvent.relatedTarget||nativeEvent.fromElement;if(related&&(getClosestInstanceFromNode(related)||isContainerMarkedAsRoot(related)))return}if(!(!isOutEvent&&!isOverEvent)){var win;if(nativeEventTarget.window===nativeEventTarget)win=nativeEventTarget;else{var doc=nativeEventTarget.ownerDocument;doc?win=doc.defaultView||doc.parentWindow:win=window}var from,to;if(isOutEvent){var _related=nativeEvent.relatedTarget||nativeEvent.toElement;if(from=targetInst,to=_related?getClosestInstanceFromNode(_related):null,to!==null){var nearestMounted=getNearestMountedFiber(to);(to!==nearestMounted||to.tag!==HostComponent&&to.tag!==HostText)&&(to=null)}}else from=null,to=targetInst;if(from!==to){var SyntheticEventCtor=SyntheticMouseEvent,leaveEventType="onMouseLeave",enterEventType="onMouseEnter",eventTypePrefix="mouse";(domEventName==="pointerout"||domEventName==="pointerover")&&(SyntheticEventCtor=SyntheticPointerEvent,leaveEventType="onPointerLeave",enterEventType="onPointerEnter",eventTypePrefix="pointer");var fromNode=from==null?win:getNodeFromInstance(from),toNode=to==null?win:getNodeFromInstance(to),leave=new SyntheticEventCtor(leaveEventType,eventTypePrefix+"leave",from,nativeEvent,nativeEventTarget);leave.target=fromNode,leave.relatedTarget=toNode;var enter=null,nativeTargetInst=getClosestInstanceFromNode(nativeEventTarget);if(nativeTargetInst===targetInst){var enterEvent=new SyntheticEventCtor(enterEventType,eventTypePrefix+"enter",to,nativeEvent,nativeEventTarget);enterEvent.target=toNode,enterEvent.relatedTarget=fromNode,enter=enterEvent}accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leave,enter,from,to)}}}function is2(x2,y2){return x2===y2&&(x2!==0||1/x2===1/y2)||x2!==x2&&y2!==y2}var objectIs=typeof Object.is=="function"?Object.is:is2;function shallowEqual(objA,objB){if(objectIs(objA,objB))return!0;if(typeof objA!="object"||objA===null||typeof objB!="object"||objB===null)return!1;var keysA=Object.keys(objA),keysB=Object.keys(objB);if(keysA.length!==keysB.length)return!1;for(var i2=0;i2<keysA.length;i2++){var currentKey=keysA[i2];if(!hasOwnProperty.call(objB,currentKey)||!objectIs(objA[currentKey],objB[currentKey]))return!1}return!0}function getLeafNode(node){for(;node&&node.firstChild;)node=node.firstChild;return node}function getSiblingNode(node){for(;node;){if(node.nextSibling)return node.nextSibling;node=node.parentNode}}function getNodeForCharacterOffset(root2,offset){for(var node=getLeafNode(root2),nodeStart=0,nodeEnd=0;node;){if(node.nodeType===TEXT_NODE){if(nodeEnd=nodeStart+node.textContent.length,nodeStart<=offset&&nodeEnd>=offset)return{node,offset:offset-nodeStart};nodeStart=nodeEnd}node=getLeafNode(getSiblingNode(node))}}function getOffsets(outerNode){var ownerDocument=outerNode.ownerDocument,win=ownerDocument&&ownerDocument.defaultView||window,selection=win.getSelection&&win.getSelection();if(!selection||selection.rangeCount===0)return null;var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode=selection.focusNode,focusOffset=selection.focusOffset;try{anchorNode.nodeType,focusNode.nodeType}catch{return null}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset)}function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode,focusOffset){var length=0,start=-1,end=-1,indexWithinAnchor=0,indexWithinFocus=0,node=outerNode,parentNode=null;outer:for(;;){for(var next=null;node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)&&(start=length+anchorOffset),node===focusNode&&(focusOffset===0||node.nodeType===TEXT_NODE)&&(end=length+focusOffset),node.nodeType===TEXT_NODE&&(length+=node.nodeValue.length),(next=node.firstChild)!==null;)parentNode=node,node=next;for(;;){if(node===outerNode)break outer;if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset&&(start=length),parentNode===focusNode&&++indexWithinFocus===focusOffset&&(end=length),(next=node.nextSibling)!==null)break;node=parentNode,parentNode=node.parentNode}node=next}return start===-1||end===-1?null:{start,end}}function setOffsets(node,offsets){var doc=node.ownerDocument||document,win=doc&&doc.defaultView||window;if(win.getSelection){var selection=win.getSelection(),length=node.textContent.length,start=Math.min(offsets.start,length),end=offsets.end===void 0?start:Math.min(offsets.end,length);if(!selection.extend&&start>end){var temp=end;end=start,start=temp}var startMarker=getNodeForCharacterOffset(node,start),endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset)return;var range=doc.createRange();range.setStart(startMarker.node,startMarker.offset),selection.removeAllRanges(),start>end?(selection.addRange(range),selection.extend(endMarker.node,endMarker.offset)):(range.setEnd(endMarker.node,endMarker.offset),selection.addRange(range))}}}function isTextNode(node){return node&&node.nodeType===TEXT_NODE}function containsNode(outerNode,innerNode){return!outerNode||!innerNode?!1:outerNode===innerNode?!0:isTextNode(outerNode)?!1:isTextNode(innerNode)?containsNode(outerNode,innerNode.parentNode):"contains"in outerNode?outerNode.contains(innerNode):outerNode.compareDocumentPosition?!!(outerNode.compareDocumentPosition(innerNode)&16):!1}function isInDocument(node){return node&&node.ownerDocument&&containsNode(node.ownerDocument.documentElement,node)}function isSameOriginFrame(iframe){try{return typeof iframe.contentWindow.location.href=="string"}catch{return!1}}function getActiveElementDeep(){for(var win=window,element=getActiveElement();element instanceof win.HTMLIFrameElement;){if(isSameOriginFrame(element))win=element.contentWindow;else return element;element=getActiveElement(win.document)}return element}function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==="input"&&(elem.type==="text"||elem.type==="search"||elem.type==="tel"||elem.type==="url"||elem.type==="password")||nodeName==="textarea"||elem.contentEditable==="true")}function getSelectionInformation(){var focusedElem=getActiveElementDeep();return{focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection(focusedElem):null}}function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElementDeep(),priorFocusedElem=priorSelectionInformation.focusedElem,priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){priorSelectionRange!==null&&hasSelectionCapabilities(priorFocusedElem)&&setSelection(priorFocusedElem,priorSelectionRange);for(var ancestors=[],ancestor=priorFocusedElem;ancestor=ancestor.parentNode;)ancestor.nodeType===ELEMENT_NODE&&ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});typeof priorFocusedElem.focus=="function"&&priorFocusedElem.focus();for(var i2=0;i2<ancestors.length;i2++){var info=ancestors[i2];info.element.scrollLeft=info.left,info.element.scrollTop=info.top}}}function getSelection(input){var selection;return"selectionStart"in input?selection={start:input.selectionStart,end:input.selectionEnd}:selection=getOffsets(input),selection||{start:0,end:0}}function setSelection(input,offsets){var start=offsets.start,end=offsets.end;end===void 0&&(end=start),"selectionStart"in input?(input.selectionStart=start,input.selectionEnd=Math.min(end,input.value.length)):setOffsets(input,offsets)}var skipSelectionChangeEvent=canUseDOM&&"documentMode"in document&&document.documentMode<=11;function registerEvents$3(){registerTwoPhaseEvent("onSelect",["focusout","contextmenu","dragend","focusin","keydown","keyup","mousedown","mouseup","selectionchange"])}var activeElement$1=null,activeElementInst$1=null,lastSelection=null,mouseDown=!1;function getSelection$1(node){if("selectionStart"in node&&hasSelectionCapabilities(node))return{start:node.selectionStart,end:node.selectionEnd};var win=node.ownerDocument&&node.ownerDocument.defaultView||window,selection=win.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset}}function getEventTargetDocument(eventTarget){return eventTarget.window===eventTarget?eventTarget.document:eventTarget.nodeType===DOCUMENT_NODE?eventTarget:eventTarget.ownerDocument}function constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget){var doc=getEventTargetDocument(nativeEventTarget);if(!(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement(doc))){var currentSelection=getSelection$1(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var listeners=accumulateTwoPhaseListeners(activeElementInst$1,"onSelect");if(listeners.length>0){var event=new SyntheticEvent("onSelect","select",null,nativeEvent,nativeEventTarget);dispatchQueue.push({event,listeners}),event.target=activeElement$1}}}}function extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var targetNode=targetInst?getNodeFromInstance(targetInst):window;switch(domEventName){case"focusin":(isTextInputElement(targetNode)||targetNode.contentEditable==="true")&&(activeElement$1=targetNode,activeElementInst$1=targetInst,lastSelection=null);break;case"focusout":activeElement$1=null,activeElementInst$1=null,lastSelection=null;break;case"mousedown":mouseDown=!0;break;case"contextmenu":case"mouseup":case"dragend":mouseDown=!1,constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget);break;case"selectionchange":if(skipSelectionChangeEvent)break;case"keydown":case"keyup":constructSelectEvent(dispatchQueue,nativeEvent,nativeEventTarget)}}function makePrefixMap(styleProp,eventName){var prefixes2={};return prefixes2[styleProp.toLowerCase()]=eventName.toLowerCase(),prefixes2["Webkit"+styleProp]="webkit"+eventName,prefixes2["Moz"+styleProp]="moz"+eventName,prefixes2}var vendorPrefixes={animationend:makePrefixMap("Animation","AnimationEnd"),animationiteration:makePrefixMap("Animation","AnimationIteration"),animationstart:makePrefixMap("Animation","AnimationStart"),transitionend:makePrefixMap("Transition","TransitionEnd")},prefixedEventNames={},style={};canUseDOM&&(style=document.createElement("div").style,"AnimationEvent"in window||(delete vendorPrefixes.animationend.animation,delete vendorPrefixes.animationiteration.animation,delete vendorPrefixes.animationstart.animation),"TransitionEvent"in window||delete vendorPrefixes.transitionend.transition);function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName])return prefixedEventNames[eventName];if(!vendorPrefixes[eventName])return eventName;var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap)if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style)return prefixedEventNames[eventName]=prefixMap[styleProp];return eventName}var ANIMATION_END=getVendorPrefixedEventName("animationend"),ANIMATION_ITERATION=getVendorPrefixedEventName("animationiteration"),ANIMATION_START=getVendorPrefixedEventName("animationstart"),TRANSITION_END=getVendorPrefixedEventName("transitionend"),topLevelEventsToReactNames=new Map,simpleEventPluginEvents=["abort","auxClick","cancel","canPlay","canPlayThrough","click","close","contextMenu","copy","cut","drag","dragEnd","dragEnter","dragExit","dragLeave","dragOver","dragStart","drop","durationChange","emptied","encrypted","ended","error","gotPointerCapture","input","invalid","keyDown","keyPress","keyUp","load","loadedData","loadedMetadata","loadStart","lostPointerCapture","mouseDown","mouseMove","mouseOut","mouseOver","mouseUp","paste","pause","play","playing","pointerCancel","pointerDown","pointerMove","pointerOut","pointerOver","pointerUp","progress","rateChange","reset","resize","seeked","seeking","stalled","submit","suspend","timeUpdate","touchCancel","touchEnd","touchStart","volumeChange","scroll","toggle","touchMove","waiting","wheel"];function registerSimpleEvent(domEventName,reactName){topLevelEventsToReactNames.set(domEventName,reactName),registerTwoPhaseEvent(reactName,[domEventName])}function registerSimpleEvents(){for(var i2=0;i2<simpleEventPluginEvents.length;i2++){var eventName=simpleEventPluginEvents[i2],domEventName=eventName.toLowerCase(),capitalizedEvent=eventName[0].toUpperCase()+eventName.slice(1);registerSimpleEvent(domEventName,"on"+capitalizedEvent)}registerSimpleEvent(ANIMATION_END,"onAnimationEnd"),registerSimpleEvent(ANIMATION_ITERATION,"onAnimationIteration"),registerSimpleEvent(ANIMATION_START,"onAnimationStart"),registerSimpleEvent("dblclick","onDoubleClick"),registerSimpleEvent("focusin","onFocus"),registerSimpleEvent("focusout","onBlur"),registerSimpleEvent(TRANSITION_END,"onTransitionEnd")}function extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){var reactName=topLevelEventsToReactNames.get(domEventName);if(reactName!==void 0){var SyntheticEventCtor=SyntheticEvent,reactEventType=domEventName;switch(domEventName){case"keypress":if(getEventCharCode(nativeEvent)===0)return;case"keydown":case"keyup":SyntheticEventCtor=SyntheticKeyboardEvent;break;case"focusin":reactEventType="focus",SyntheticEventCtor=SyntheticFocusEvent;break;case"focusout":reactEventType="blur",SyntheticEventCtor=SyntheticFocusEvent;break;case"beforeblur":case"afterblur":SyntheticEventCtor=SyntheticFocusEvent;break;case"click":if(nativeEvent.button===2)return;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":SyntheticEventCtor=SyntheticMouseEvent;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":SyntheticEventCtor=SyntheticDragEvent;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":SyntheticEventCtor=SyntheticTouchEvent;break;case ANIMATION_END:case ANIMATION_ITERATION:case ANIMATION_START:SyntheticEventCtor=SyntheticAnimationEvent;break;case TRANSITION_END:SyntheticEventCtor=SyntheticTransitionEvent;break;case"scroll":SyntheticEventCtor=SyntheticUIEvent;break;case"wheel":SyntheticEventCtor=SyntheticWheelEvent;break;case"copy":case"cut":case"paste":SyntheticEventCtor=SyntheticClipboardEvent;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":SyntheticEventCtor=SyntheticPointerEvent;break}var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0;{var accumulateTargetOnly=!inCapturePhase&&domEventName==="scroll",_listeners=accumulateSinglePhaseListeners(targetInst,reactName,nativeEvent.type,inCapturePhase,accumulateTargetOnly);if(_listeners.length>0){var _event=new SyntheticEventCtor(reactName,reactEventType,null,nativeEvent,nativeEventTarget);dispatchQueue.push({event:_event,listeners:_listeners})}}}}registerSimpleEvents(),registerEvents$2(),registerEvents$1(),registerEvents$3(),registerEvents();function extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags,targetContainer){extractEvents$4(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags);var shouldProcessPolyfillPlugins=(eventSystemFlags&SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS)===0;shouldProcessPolyfillPlugins&&(extractEvents$2(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget),extractEvents$1(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget),extractEvents$3(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget),extractEvents(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget))}var mediaEventTypes=["abort","canplay","canplaythrough","durationchange","emptied","encrypted","ended","error","loadeddata","loadedmetadata","loadstart","pause","play","playing","progress","ratechange","resize","seeked","seeking","stalled","suspend","timeupdate","volumechange","waiting"],nonDelegatedEvents=new Set(["cancel","close","invalid","load","scroll","toggle"].concat(mediaEventTypes));function executeDispatch(event,listener,currentTarget){var type=event.type||"unknown-event";event.currentTarget=currentTarget,invokeGuardedCallbackAndCatchFirstError(type,listener,void 0,event),event.currentTarget=null}function processDispatchQueueItemsInOrder(event,dispatchListeners,inCapturePhase){var previousInstance;if(inCapturePhase)for(var i2=dispatchListeners.length-1;i2>=0;i2--){var _dispatchListeners$i=dispatchListeners[i2],instance=_dispatchListeners$i.instance,currentTarget=_dispatchListeners$i.currentTarget,listener=_dispatchListeners$i.listener;if(instance!==previousInstance&&event.isPropagationStopped())return;executeDispatch(event,listener,currentTarget),previousInstance=instance}else for(var _i=0;_i<dispatchListeners.length;_i++){var _dispatchListeners$_i=dispatchListeners[_i],_instance=_dispatchListeners$_i.instance,_currentTarget=_dispatchListeners$_i.currentTarget,_listener=_dispatchListeners$_i.listener;if(_instance!==previousInstance&&event.isPropagationStopped())return;executeDispatch(event,_listener,_currentTarget),previousInstance=_instance}}function processDispatchQueue(dispatchQueue,eventSystemFlags){for(var inCapturePhase=(eventSystemFlags&IS_CAPTURE_PHASE)!==0,i2=0;i2<dispatchQueue.length;i2++){var _dispatchQueue$i=dispatchQueue[i2],event=_dispatchQueue$i.event,listeners=_dispatchQueue$i.listeners;processDispatchQueueItemsInOrder(event,listeners,inCapturePhase)}rethrowCaughtError()}function dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var nativeEventTarget=getEventTarget(nativeEvent),dispatchQueue=[];extractEvents$5(dispatchQueue,domEventName,targetInst,nativeEvent,nativeEventTarget,eventSystemFlags),processDispatchQueue(dispatchQueue,eventSystemFlags)}function listenToNonDelegatedEvent(domEventName,targetElement){nonDelegatedEvents.has(domEventName)||error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',domEventName);var isCapturePhaseListener=!1,listenerSet=getEventListenerSet(targetElement),listenerSetKey=getListenerSetKey(domEventName,isCapturePhaseListener);listenerSet.has(listenerSetKey)||(addTrappedEventListener(targetElement,domEventName,IS_NON_DELEGATED,isCapturePhaseListener),listenerSet.add(listenerSetKey))}function listenToNativeEvent(domEventName,isCapturePhaseListener,target){nonDelegatedEvents.has(domEventName)&&!isCapturePhaseListener&&error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',domEventName);var eventSystemFlags=0;isCapturePhaseListener&&(eventSystemFlags|=IS_CAPTURE_PHASE),addTrappedEventListener(target,domEventName,eventSystemFlags,isCapturePhaseListener)}var listeningMarker="_reactListening"+Math.random().toString(36).slice(2);function listenToAllSupportedEvents(rootContainerElement){if(!rootContainerElement[listeningMarker]){rootContainerElement[listeningMarker]=!0,allNativeEvents.forEach(function(domEventName){domEventName!=="selectionchange"&&(nonDelegatedEvents.has(domEventName)||listenToNativeEvent(domEventName,!1,rootContainerElement),listenToNativeEvent(domEventName,!0,rootContainerElement))});var ownerDocument=rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;ownerDocument!==null&&(ownerDocument[listeningMarker]||(ownerDocument[listeningMarker]=!0,listenToNativeEvent("selectionchange",!1,ownerDocument)))}}function addTrappedEventListener(targetContainer,domEventName,eventSystemFlags,isCapturePhaseListener,isDeferredListenerForLegacyFBSupport){var listener=createEventListenerWrapperWithPriority(targetContainer,domEventName,eventSystemFlags),isPassiveListener=void 0;passiveBrowserEventsSupported&&(domEventName==="touchstart"||domEventName==="touchmove"||domEventName==="wheel")&&(isPassiveListener=!0),targetContainer=targetContainer,isCapturePhaseListener?isPassiveListener!==void 0?addEventCaptureListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener):addEventCaptureListener(targetContainer,domEventName,listener):isPassiveListener!==void 0?addEventBubbleListenerWithPassiveFlag(targetContainer,domEventName,listener,isPassiveListener):addEventBubbleListener(targetContainer,domEventName,listener)}function isMatchingRootContainer(grandContainer,targetContainer){return grandContainer===targetContainer||grandContainer.nodeType===COMMENT_NODE&&grandContainer.parentNode===targetContainer}function dispatchEventForPluginEventSystem(domEventName,eventSystemFlags,nativeEvent,targetInst,targetContainer){var ancestorInst=targetInst;if(!(eventSystemFlags&IS_EVENT_HANDLE_NON_MANAGED_NODE)&&!(eventSystemFlags&IS_NON_DELEGATED)){var targetContainerNode=targetContainer;if(targetInst!==null){var node=targetInst;mainLoop:for(;;){if(node===null)return;var nodeTag=node.tag;if(nodeTag===HostRoot||nodeTag===HostPortal){var container=node.stateNode.containerInfo;if(isMatchingRootContainer(container,targetContainerNode))break;if(nodeTag===HostPortal)for(var grandNode=node.return;grandNode!==null;){var grandTag=grandNode.tag;if(grandTag===HostRoot||grandTag===HostPortal){var grandContainer=grandNode.stateNode.containerInfo;if(isMatchingRootContainer(grandContainer,targetContainerNode))return}grandNode=grandNode.return}for(;container!==null;){var parentNode=getClosestInstanceFromNode(container);if(parentNode===null)return;var parentTag=parentNode.tag;if(parentTag===HostComponent||parentTag===HostText){node=ancestorInst=parentNode;continue mainLoop}container=container.parentNode}}node=node.return}}}batchedUpdates(function(){return dispatchEventsForPlugins(domEventName,eventSystemFlags,nativeEvent,ancestorInst)})}function createDispatchListener(instance,listener,currentTarget){return{instance,listener,currentTarget}}function accumulateSinglePhaseListeners(targetFiber,reactName,nativeEventType,inCapturePhase,accumulateTargetOnly,nativeEvent){for(var captureName=reactName!==null?reactName+"Capture":null,reactEventName=inCapturePhase?captureName:reactName,listeners=[],instance=targetFiber,lastHostComponent=null;instance!==null;){var _instance2=instance,stateNode=_instance2.stateNode,tag=_instance2.tag;if(tag===HostComponent&&stateNode!==null&&(lastHostComponent=stateNode,reactEventName!==null)){var listener=getListener(instance,reactEventName);listener!=null&&listeners.push(createDispatchListener(instance,listener,lastHostComponent))}if(accumulateTargetOnly)break;instance=instance.return}return listeners}function accumulateTwoPhaseListeners(targetFiber,reactName){for(var captureName=reactName+"Capture",listeners=[],instance=targetFiber;instance!==null;){var _instance3=instance,stateNode=_instance3.stateNode,tag=_instance3.tag;if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode,captureListener=getListener(instance,captureName);captureListener!=null&&listeners.unshift(createDispatchListener(instance,captureListener,currentTarget));var bubbleListener=getListener(instance,reactName);bubbleListener!=null&&listeners.push(createDispatchListener(instance,bubbleListener,currentTarget))}instance=instance.return}return listeners}function getParent(inst){if(inst===null)return null;do inst=inst.return;while(inst&&inst.tag!==HostComponent);return inst||null}function getLowestCommonAncestor(instA,instB){for(var nodeA=instA,nodeB=instB,depthA=0,tempA=nodeA;tempA;tempA=getParent(tempA))depthA++;for(var depthB=0,tempB=nodeB;tempB;tempB=getParent(tempB))depthB++;for(;depthA-depthB>0;)nodeA=getParent(nodeA),depthA--;for(;depthB-depthA>0;)nodeB=getParent(nodeB),depthB--;for(var depth=depthA;depth--;){if(nodeA===nodeB||nodeB!==null&&nodeA===nodeB.alternate)return nodeA;nodeA=getParent(nodeA),nodeB=getParent(nodeB)}return null}function accumulateEnterLeaveListenersForEvent(dispatchQueue,event,target,common2,inCapturePhase){for(var registrationName=event._reactName,listeners=[],instance=target;instance!==null&&instance!==common2;){var _instance4=instance,alternate=_instance4.alternate,stateNode=_instance4.stateNode,tag=_instance4.tag;if(alternate!==null&&alternate===common2)break;if(tag===HostComponent&&stateNode!==null){var currentTarget=stateNode;if(inCapturePhase){var captureListener=getListener(instance,registrationName);captureListener!=null&&listeners.unshift(createDispatchListener(instance,captureListener,currentTarget))}else if(!inCapturePhase){var bubbleListener=getListener(instance,registrationName);bubbleListener!=null&&listeners.push(createDispatchListener(instance,bubbleListener,currentTarget))}}instance=instance.return}listeners.length!==0&&dispatchQueue.push({event,listeners})}function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue,leaveEvent,enterEvent,from,to){var common2=from&&to?getLowestCommonAncestor(from,to):null;from!==null&&accumulateEnterLeaveListenersForEvent(dispatchQueue,leaveEvent,from,common2,!1),to!==null&&enterEvent!==null&&accumulateEnterLeaveListenersForEvent(dispatchQueue,enterEvent,to,common2,!0)}function getListenerSetKey(domEventName,capture){return domEventName+"__"+(capture?"capture":"bubble")}var didWarnInvalidHydration=!1,DANGEROUSLY_SET_INNER_HTML="dangerouslySetInnerHTML",SUPPRESS_CONTENT_EDITABLE_WARNING="suppressContentEditableWarning",SUPPRESS_HYDRATION_WARNING="suppressHydrationWarning",AUTOFOCUS="autoFocus",CHILDREN="children",STYLE="style",HTML$1="__html",warnedUnknownTags,validatePropertiesInDevelopment,warnForPropDifference,warnForExtraAttributes,warnForInvalidEventListener,canDiffStyleForHydrationWarning,normalizeHTML;warnedUnknownTags={dialog:!0,webview:!0},validatePropertiesInDevelopment=function(type,props){validateProperties(type,props),validateProperties$1(type,props),validateProperties$2(type,props,{registrationNameDependencies,possibleRegistrationNames})},canDiffStyleForHydrationWarning=canUseDOM&&!document.documentMode,warnForPropDifference=function(propName,serverValue,clientValue){if(!didWarnInvalidHydration){var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue),normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);normalizedServerValue!==normalizedClientValue&&(didWarnInvalidHydration=!0,error("Prop `%s` did not match. Server: %s Client: %s",propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue)))}},warnForExtraAttributes=function(attributeNames){if(!didWarnInvalidHydration){didWarnInvalidHydration=!0;var names=[];attributeNames.forEach(function(name){names.push(name)}),error("Extra attributes from the server: %s",names)}},warnForInvalidEventListener=function(registrationName,listener){listener===!1?error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",registrationName,registrationName,registrationName):error("Expected `%s` listener to be a function, instead got a value of `%s` type.",registrationName,typeof listener)},normalizeHTML=function(parent,html){var testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);return testElement.innerHTML=html,testElement.innerHTML};var NORMALIZE_NEWLINES_REGEX=/\r\n?/g,NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\u0000|\uFFFD/g;function normalizeMarkupForTextOrAttribute(markup){checkHtmlStringCoercion(markup);var markupString=typeof markup=="string"?markup:""+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,`
`).replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,"")}function checkForUnmatchedText(serverText,clientText,isConcurrentMode,shouldWarnDev){var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText),normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText!==normalizedClientText&&(shouldWarnDev&&(didWarnInvalidHydration||(didWarnInvalidHydration=!0,error('Text content did not match. Server: "%s" Client: "%s"',normalizedServerText,normalizedClientText))),isConcurrentMode&&enableClientRenderFallbackOnTextMismatch))throw new Error("Text content does not match server-rendered HTML.")}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument}function noop2(){}function trapClickOnNonInteractiveElement(node){node.onclick=noop2}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps)if(nextProps.hasOwnProperty(propKey)){var nextProp=nextProps[propKey];if(propKey===STYLE)nextProp&&Object.freeze(nextProp),setValueForStyles(domElement,nextProp);else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:void 0;nextHtml!=null&&setInnerHTML(domElement,nextHtml)}else if(propKey===CHILDREN)if(typeof nextProp=="string"){var canSetTextContent=tag!=="textarea"||nextProp!=="";canSetTextContent&&setTextContent(domElement,nextProp)}else typeof nextProp=="number"&&setTextContent(domElement,""+nextProp);else propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||propKey===AUTOFOCUS||(registrationNameDependencies.hasOwnProperty(propKey)?nextProp!=null&&(typeof nextProp!="function"&&warnForInvalidEventListener(propKey,nextProp),propKey==="onScroll"&&listenToNonDelegatedEvent("scroll",domElement)):nextProp!=null&&setValueForProperty(domElement,propKey,nextProp,isCustomComponentTag))}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){for(var i2=0;i2<updatePayload.length;i2+=2){var propKey=updatePayload[i2],propValue=updatePayload[i2+1];propKey===STYLE?setValueForStyles(domElement,propValue):propKey===DANGEROUSLY_SET_INNER_HTML?setInnerHTML(domElement,propValue):propKey===CHILDREN?setTextContent(domElement,propValue):setValueForProperty(domElement,propKey,propValue,isCustomComponentTag)}}function createElement(type,props,rootContainerElement,parentNamespace){var isCustomComponentTag,ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement),domElement,namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE&&(namespaceURI=getIntrinsicNamespace(type)),namespaceURI===HTML_NAMESPACE){if(isCustomComponentTag=isCustomComponent(type,props),!isCustomComponentTag&&type!==type.toLowerCase()&&error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",type),type==="script"){var div=ownerDocument.createElement("div");div.innerHTML="<script><\/script>";var firstChild=div.firstChild;domElement=div.removeChild(firstChild)}else if(typeof props.is=="string")domElement=ownerDocument.createElement(type,{is:props.is});else if(domElement=ownerDocument.createElement(type),type==="select"){var node=domElement;props.multiple?node.multiple=!0:props.size&&(node.size=props.size)}}else domElement=ownerDocument.createElementNS(namespaceURI,type);return namespaceURI===HTML_NAMESPACE&&!isCustomComponentTag&&Object.prototype.toString.call(domElement)==="[object HTMLUnknownElement]"&&!hasOwnProperty.call(warnedUnknownTags,type)&&(warnedUnknownTags[type]=!0,error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",type)),domElement}function createTextNode(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text)}function setInitialProperties(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);var props;switch(tag){case"dialog":listenToNonDelegatedEvent("cancel",domElement),listenToNonDelegatedEvent("close",domElement),props=rawProps;break;case"iframe":case"object":case"embed":listenToNonDelegatedEvent("load",domElement),props=rawProps;break;case"video":case"audio":for(var i2=0;i2<mediaEventTypes.length;i2++)listenToNonDelegatedEvent(mediaEventTypes[i2],domElement);props=rawProps;break;case"source":listenToNonDelegatedEvent("error",domElement),props=rawProps;break;case"img":case"image":case"link":listenToNonDelegatedEvent("error",domElement),listenToNonDelegatedEvent("load",domElement),props=rawProps;break;case"details":listenToNonDelegatedEvent("toggle",domElement),props=rawProps;break;case"input":initWrapperState(domElement,rawProps),props=getHostProps(domElement,rawProps),listenToNonDelegatedEvent("invalid",domElement);break;case"option":validateProps(domElement,rawProps),props=rawProps;break;case"select":initWrapperState$1(domElement,rawProps),props=getHostProps$1(domElement,rawProps),listenToNonDelegatedEvent("invalid",domElement);break;case"textarea":initWrapperState$2(domElement,rawProps),props=getHostProps$2(domElement,rawProps),listenToNonDelegatedEvent("invalid",domElement);break;default:props=rawProps}switch(assertValidProps(tag,props),setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag),tag){case"input":track(domElement),postMountWrapper(domElement,rawProps,!1);break;case"textarea":track(domElement),postMountWrapper$3(domElement);break;case"option":postMountWrapper$1(domElement,rawProps);break;case"select":postMountWrapper$2(domElement,rawProps);break;default:typeof props.onClick=="function"&&trapClickOnNonInteractiveElement(domElement);break}}function diffProperties(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){validatePropertiesInDevelopment(tag,nextRawProps);var updatePayload=null,lastProps,nextProps;switch(tag){case"input":lastProps=getHostProps(domElement,lastRawProps),nextProps=getHostProps(domElement,nextRawProps),updatePayload=[];break;case"select":lastProps=getHostProps$1(domElement,lastRawProps),nextProps=getHostProps$1(domElement,nextRawProps),updatePayload=[];break;case"textarea":lastProps=getHostProps$2(domElement,lastRawProps),nextProps=getHostProps$2(domElement,nextRawProps),updatePayload=[];break;default:lastProps=lastRawProps,nextProps=nextRawProps,typeof lastProps.onClick!="function"&&typeof nextProps.onClick=="function"&&trapClickOnNonInteractiveElement(domElement);break}assertValidProps(tag,nextProps);var propKey,styleName,styleUpdates=null;for(propKey in lastProps)if(!(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null))if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle)lastStyle.hasOwnProperty(styleName)&&(styleUpdates||(styleUpdates={}),styleUpdates[styleName]="")}else propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN||propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||propKey===AUTOFOCUS||(registrationNameDependencies.hasOwnProperty(propKey)?updatePayload||(updatePayload=[]):(updatePayload=updatePayload||[]).push(propKey,null));for(propKey in nextProps){var nextProp=nextProps[propKey],lastProp=lastProps!=null?lastProps[propKey]:void 0;if(!(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null))if(propKey===STYLE)if(nextProp&&Object.freeze(nextProp),lastProp){for(styleName in lastProp)lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))&&(styleUpdates||(styleUpdates={}),styleUpdates[styleName]="");for(styleName in nextProp)nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]&&(styleUpdates||(styleUpdates={}),styleUpdates[styleName]=nextProp[styleName])}else styleUpdates||(updatePayload||(updatePayload=[]),updatePayload.push(propKey,styleUpdates)),styleUpdates=nextProp;else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML$1]:void 0,lastHtml=lastProp?lastProp[HTML$1]:void 0;nextHtml!=null&&lastHtml!==nextHtml&&(updatePayload=updatePayload||[]).push(propKey,nextHtml)}else propKey===CHILDREN?(typeof nextProp=="string"||typeof nextProp=="number")&&(updatePayload=updatePayload||[]).push(propKey,""+nextProp):propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||(registrationNameDependencies.hasOwnProperty(propKey)?(nextProp!=null&&(typeof nextProp!="function"&&warnForInvalidEventListener(propKey,nextProp),propKey==="onScroll"&&listenToNonDelegatedEvent("scroll",domElement)),!updatePayload&&lastProp!==nextProp&&(updatePayload=[])):(updatePayload=updatePayload||[]).push(propKey,nextProp))}return styleUpdates&&(validateShorthandPropertyCollisionInDev(styleUpdates,nextProps[STYLE]),(updatePayload=updatePayload||[]).push(STYLE,styleUpdates)),updatePayload}function updateProperties(domElement,updatePayload,tag,lastRawProps,nextRawProps){tag==="input"&&nextRawProps.type==="radio"&&nextRawProps.name!=null&&updateChecked(domElement,nextRawProps);var wasCustomComponentTag=isCustomComponent(tag,lastRawProps),isCustomComponentTag=isCustomComponent(tag,nextRawProps);switch(updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag),tag){case"input":updateWrapper(domElement,nextRawProps);break;case"textarea":updateWrapper$1(domElement,nextRawProps);break;case"select":postUpdateWrapper(domElement,nextRawProps);break}}function getPossibleStandardName(propName){{var lowerCasedName=propName.toLowerCase();return possibleStandardNames.hasOwnProperty(lowerCasedName)&&possibleStandardNames[lowerCasedName]||null}}function diffHydratedProperties(domElement,tag,rawProps,parentNamespace,rootContainerElement,isConcurrentMode,shouldWarnDev){var isCustomComponentTag,extraAttributeNames;switch(isCustomComponentTag=isCustomComponent(tag,rawProps),validatePropertiesInDevelopment(tag,rawProps),tag){case"dialog":listenToNonDelegatedEvent("cancel",domElement),listenToNonDelegatedEvent("close",domElement);break;case"iframe":case"object":case"embed":listenToNonDelegatedEvent("load",domElement);break;case"video":case"audio":for(var i2=0;i2<mediaEventTypes.length;i2++)listenToNonDelegatedEvent(mediaEventTypes[i2],domElement);break;case"source":listenToNonDelegatedEvent("error",domElement);break;case"img":case"image":case"link":listenToNonDelegatedEvent("error",domElement),listenToNonDelegatedEvent("load",domElement);break;case"details":listenToNonDelegatedEvent("toggle",domElement);break;case"input":initWrapperState(domElement,rawProps),listenToNonDelegatedEvent("invalid",domElement);break;case"option":validateProps(domElement,rawProps);break;case"select":initWrapperState$1(domElement,rawProps),listenToNonDelegatedEvent("invalid",domElement);break;case"textarea":initWrapperState$2(domElement,rawProps),listenToNonDelegatedEvent("invalid",domElement);break}assertValidProps(tag,rawProps);{extraAttributeNames=new Set;for(var attributes=domElement.attributes,_i=0;_i<attributes.length;_i++){var name=attributes[_i].name.toLowerCase();switch(name){case"value":break;case"checked":break;case"selected":break;default:extraAttributeNames.add(attributes[_i].name)}}}var updatePayload=null;for(var propKey in rawProps)if(rawProps.hasOwnProperty(propKey)){var nextProp=rawProps[propKey];if(propKey===CHILDREN)typeof nextProp=="string"?domElement.textContent!==nextProp&&(rawProps[SUPPRESS_HYDRATION_WARNING]!==!0&&checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev),updatePayload=[CHILDREN,nextProp]):typeof nextProp=="number"&&domElement.textContent!==""+nextProp&&(rawProps[SUPPRESS_HYDRATION_WARNING]!==!0&&checkForUnmatchedText(domElement.textContent,nextProp,isConcurrentMode,shouldWarnDev),updatePayload=[CHILDREN,""+nextProp]);else if(registrationNameDependencies.hasOwnProperty(propKey))nextProp!=null&&(typeof nextProp!="function"&&warnForInvalidEventListener(propKey,nextProp),propKey==="onScroll"&&listenToNonDelegatedEvent("scroll",domElement));else if(shouldWarnDev&&typeof isCustomComponentTag=="boolean"){var serverValue=void 0,propertyInfo=isCustomComponentTag&&enableCustomElementPropertySupport?null:getPropertyInfo(propKey);if(rawProps[SUPPRESS_HYDRATION_WARNING]!==!0){if(!(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING||propKey==="value"||propKey==="checked"||propKey==="selected")){if(propKey===DANGEROUSLY_SET_INNER_HTML){var serverHTML=domElement.innerHTML,nextHtml=nextProp?nextProp[HTML$1]:void 0;if(nextHtml!=null){var expectedHTML=normalizeHTML(domElement,nextHtml);expectedHTML!==serverHTML&&warnForPropDifference(propKey,serverHTML,expectedHTML)}}else if(propKey===STYLE){if(extraAttributeNames.delete(propKey),canDiffStyleForHydrationWarning){var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute("style"),expectedStyle!==serverValue&&warnForPropDifference(propKey,serverValue,expectedStyle)}}else if(isCustomComponentTag&&!enableCustomElementPropertySupport)extraAttributeNames.delete(propKey.toLowerCase()),serverValue=getValueForAttribute(domElement,propKey,nextProp),nextProp!==serverValue&&warnForPropDifference(propKey,serverValue,nextProp);else if(!shouldIgnoreAttribute(propKey,propertyInfo,isCustomComponentTag)&&!shouldRemoveAttribute(propKey,nextProp,propertyInfo,isCustomComponentTag)){var isMismatchDueToBadCasing=!1;if(propertyInfo!==null)extraAttributeNames.delete(propertyInfo.attributeName),serverValue=getValueForProperty(domElement,propKey,nextProp,propertyInfo);else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE&&(ownNamespace=getIntrinsicNamespace(tag)),ownNamespace===HTML_NAMESPACE)extraAttributeNames.delete(propKey.toLowerCase());else{var standardName=getPossibleStandardName(propKey);standardName!==null&&standardName!==propKey&&(isMismatchDueToBadCasing=!0,extraAttributeNames.delete(standardName)),extraAttributeNames.delete(propKey)}serverValue=getValueForAttribute(domElement,propKey,nextProp)}var dontWarnCustomElement=enableCustomElementPropertySupport;!dontWarnCustomElement&&nextProp!==serverValue&&!isMismatchDueToBadCasing&&warnForPropDifference(propKey,serverValue,nextProp)}}}}}switch(shouldWarnDev&&extraAttributeNames.size>0&&rawProps[SUPPRESS_HYDRATION_WARNING]!==!0&&warnForExtraAttributes(extraAttributeNames),tag){case"input":track(domElement),postMountWrapper(domElement,rawProps,!0);break;case"textarea":track(domElement),postMountWrapper$3(domElement);break;case"select":case"option":break;default:typeof rawProps.onClick=="function"&&trapClickOnNonInteractiveElement(domElement);break}return updatePayload}function diffHydratedText(textNode,text,isConcurrentMode){var isDifferent=textNode.nodeValue!==text;return isDifferent}function warnForDeletedHydratableElement(parentNode,child){{if(didWarnInvalidHydration)return;didWarnInvalidHydration=!0,error("Did not expect server HTML to contain a <%s> in <%s>.",child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase())}}function warnForDeletedHydratableText(parentNode,child){{if(didWarnInvalidHydration)return;didWarnInvalidHydration=!0,error('Did not expect server HTML to contain the text node "%s" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase())}}function warnForInsertedHydratedElement(parentNode,tag,props){{if(didWarnInvalidHydration)return;didWarnInvalidHydration=!0,error("Expected server HTML to contain a matching <%s> in <%s>.",tag,parentNode.nodeName.toLowerCase())}}function warnForInsertedHydratedText(parentNode,text){{if(text===""||didWarnInvalidHydration)return;didWarnInvalidHydration=!0,error('Expected server HTML to contain a matching text node for "%s" in <%s>.',text,parentNode.nodeName.toLowerCase())}}function restoreControlledState$3(domElement,tag,props){switch(tag){case"input":restoreControlledState(domElement,props);return;case"textarea":restoreControlledState$2(domElement,props);return;case"select":restoreControlledState$1(domElement,props);return}}var validateDOMNesting=function(){},updatedAncestorInfo=function(){};{var specialTags=["address","applet","area","article","aside","base","basefont","bgsound","blockquote","body","br","button","caption","center","col","colgroup","dd","details","dir","div","dl","dt","embed","fieldset","figcaption","figure","footer","form","frame","frameset","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","iframe","img","input","isindex","li","link","listing","main","marquee","menu","menuitem","meta","nav","noembed","noframes","noscript","object","ol","p","param","plaintext","pre","script","section","select","source","style","summary","table","tbody","td","template","textarea","tfoot","th","thead","title","tr","track","ul","wbr","xmp"],inScopeTags=["applet","caption","html","table","td","th","marquee","object","template","foreignObject","desc","title"],buttonScopeTags=inScopeTags.concat(["button"]),impliedEndTags=["dd","dt","li","option","optgroup","p","rp","rt"],emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};updatedAncestorInfo=function(oldInfo,tag){var ancestorInfo=assign({},oldInfo||emptyAncestorInfo),info={tag};return inScopeTags.indexOf(tag)!==-1&&(ancestorInfo.aTagInScope=null,ancestorInfo.buttonTagInScope=null,ancestorInfo.nobrTagInScope=null),buttonScopeTags.indexOf(tag)!==-1&&(ancestorInfo.pTagInButtonScope=null),specialTags.indexOf(tag)!==-1&&tag!=="address"&&tag!=="div"&&tag!=="p"&&(ancestorInfo.listItemTagAutoclosing=null,ancestorInfo.dlItemTagAutoclosing=null),ancestorInfo.current=info,tag==="form"&&(ancestorInfo.formTag=info),tag==="a"&&(ancestorInfo.aTagInScope=info),tag==="button"&&(ancestorInfo.buttonTagInScope=info),tag==="nobr"&&(ancestorInfo.nobrTagInScope=info),tag==="p"&&(ancestorInfo.pTagInButtonScope=info),tag==="li"&&(ancestorInfo.listItemTagAutoclosing=info),(tag==="dd"||tag==="dt")&&(ancestorInfo.dlItemTagAutoclosing=info),ancestorInfo};var isTagValidWithParent=function(tag,parentTag){switch(parentTag){case"select":return tag==="option"||tag==="optgroup"||tag==="#text";case"optgroup":return tag==="option"||tag==="#text";case"option":return tag==="#text";case"tr":return tag==="th"||tag==="td"||tag==="style"||tag==="script"||tag==="template";case"tbody":case"thead":case"tfoot":return tag==="tr"||tag==="style"||tag==="script"||tag==="template";case"colgroup":return tag==="col"||tag==="template";case"table":return tag==="caption"||tag==="colgroup"||tag==="tbody"||tag==="tfoot"||tag==="thead"||tag==="style"||tag==="script"||tag==="template";case"head":return tag==="base"||tag==="basefont"||tag==="bgsound"||tag==="link"||tag==="meta"||tag==="title"||tag==="noscript"||tag==="noframes"||tag==="style"||tag==="script"||tag==="template";case"html":return tag==="head"||tag==="body"||tag==="frameset";case"frameset":return tag==="frame";case"#document":return tag==="html"}switch(tag){case"h1":case"h2":case"h3":case"h4":case"h5":case"h6":return parentTag!=="h1"&&parentTag!=="h2"&&parentTag!=="h3"&&parentTag!=="h4"&&parentTag!=="h5"&&parentTag!=="h6";case"rp":case"rt":return impliedEndTags.indexOf(parentTag)===-1;case"body":case"caption":case"col":case"colgroup":case"frameset":case"frame":case"head":case"html":case"tbody":case"td":case"tfoot":case"th":case"thead":case"tr":return parentTag==null}return!0},findInvalidAncestorForTag=function(tag,ancestorInfo){switch(tag){case"address":case"article":case"aside":case"blockquote":case"center":case"details":case"dialog":case"dir":case"div":case"dl":case"fieldset":case"figcaption":case"figure":case"footer":case"header":case"hgroup":case"main":case"menu":case"nav":case"ol":case"p":case"section":case"summary":case"ul":case"pre":case"listing":case"table":case"hr":case"xmp":case"h1":case"h2":case"h3":case"h4":case"h5":case"h6":return ancestorInfo.pTagInButtonScope;case"form":return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case"li":return ancestorInfo.listItemTagAutoclosing;case"dd":case"dt":return ancestorInfo.dlItemTagAutoclosing;case"button":return ancestorInfo.buttonTagInScope;case"a":return ancestorInfo.aTagInScope;case"nobr":return ancestorInfo.nobrTagInScope}return null},didWarn$1={};validateDOMNesting=function(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current,parentTag=parentInfo&&parentInfo.tag;childText!=null&&(childTag!=null&&error("validateDOMNesting: when childText is passed, childTag should be null"),childTag="#text");var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo,invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo),invalidParentOrAncestor=invalidParent||invalidAncestor;if(invalidParentOrAncestor){var ancestorTag=invalidParentOrAncestor.tag,warnKey=!!invalidParent+"|"+childTag+"|"+ancestorTag;if(!didWarn$1[warnKey]){didWarn$1[warnKey]=!0;var tagDisplayName=childTag,whitespaceInfo="";if(childTag==="#text"?/\S/.test(childText)?tagDisplayName="Text nodes":(tagDisplayName="Whitespace text nodes",whitespaceInfo=" Make sure you don't have any extra whitespace between tags on each line of your source code."):tagDisplayName="<"+childTag+">",invalidParent){var info="";ancestorTag==="table"&&childTag==="tr"&&(info+=" Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."),error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s",tagDisplayName,ancestorTag,whitespaceInfo,info)}else error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.",tagDisplayName,ancestorTag)}}}}var SUPPRESS_HYDRATION_WARNING$1="suppressHydrationWarning",SUSPENSE_START_DATA="$",SUSPENSE_END_DATA="/$",SUSPENSE_PENDING_START_DATA="$?",SUSPENSE_FALLBACK_START_DATA="$!",STYLE$1="style",eventsEnabled=null,selectionInformation=null;function getRootHostContext(rootContainerInstance){var type,namespace,nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?"#document":"#fragment";var root2=rootContainerInstance.documentElement;namespace=root2?root2.namespaceURI:getChildNamespace(null,"");break}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance,ownNamespace=container.namespaceURI||null;type=container.tagName,namespace=getChildNamespace(ownNamespace,type);break}}{var validatedTag=type.toLowerCase(),ancestorInfo=updatedAncestorInfo(null,validatedTag);return{namespace,ancestorInfo}}}function getChildHostContext(parentHostContext,type,rootContainerInstance){{var parentHostContextDev=parentHostContext,namespace=getChildNamespace(parentHostContextDev.namespace,type),ancestorInfo=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type);return{namespace,ancestorInfo}}}function getPublicInstance(instance){return instance}function prepareForCommit(containerInfo){eventsEnabled=isEnabled(),selectionInformation=getSelectionInformation();var activeInstance=null;return setEnabled(!1),activeInstance}function resetAfterCommit(containerInfo){restoreSelection(selectionInformation),setEnabled(eventsEnabled),eventsEnabled=null,selectionInformation=null}function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace;{var hostContextDev=hostContext;if(validateDOMNesting(type,null,hostContextDev.ancestorInfo),typeof props.children=="string"||typeof props.children=="number"){var string=""+props.children,ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo)}parentNamespace=hostContextDev.namespace}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);return precacheFiberNode(internalInstanceHandle,domElement),updateFiberProps(domElement,props),domElement}function appendInitialChild(parentInstance,child){parentInstance.appendChild(child)}function finalizeInitialChildren(domElement,type,props,rootContainerInstance,hostContext){switch(setInitialProperties(domElement,type,props,rootContainerInstance),type){case"button":case"input":case"select":case"textarea":return!!props.autoFocus;case"img":return!0;default:return!1}}function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(typeof newProps.children!=typeof oldProps.children&&(typeof newProps.children=="string"||typeof newProps.children=="number")){var string=""+newProps.children,ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type);validateDOMNesting(null,string,ownAncestorInfo)}}return diffProperties(domElement,type,oldProps,newProps)}function shouldSetTextContent(type,props){return type==="textarea"||type==="noscript"||typeof props.children=="string"||typeof props.children=="number"||typeof props.dangerouslySetInnerHTML=="object"&&props.dangerouslySetInnerHTML!==null&&props.dangerouslySetInnerHTML.__html!=null}function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting(null,text,hostContextDev.ancestorInfo)}var textNode=createTextNode(text,rootContainerInstance);return precacheFiberNode(internalInstanceHandle,textNode),textNode}function getCurrentEventPriority(){var currentEvent=window.event;return currentEvent===void 0?DefaultEventPriority:getEventPriority2(currentEvent.type)}var scheduleTimeout=typeof setTimeout=="function"?setTimeout:void 0,cancelTimeout=typeof clearTimeout=="function"?clearTimeout:void 0,noTimeout=-1,localPromise=typeof Promise=="function"?Promise:void 0,scheduleMicrotask=typeof queueMicrotask=="function"?queueMicrotask:typeof localPromise<"u"?function(callback){return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick)}:scheduleTimeout;function handleErrorInNextTick(error2){setTimeout(function(){throw error2})}function commitMount(domElement,type,newProps,internalInstanceHandle){switch(type){case"button":case"input":case"select":case"textarea":newProps.autoFocus&&domElement.focus();return;case"img":{newProps.src&&(domElement.src=newProps.src);return}}}function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){updateProperties(domElement,updatePayload,type,oldProps,newProps),updateFiberProps(domElement,newProps)}function resetTextContent(domElement){setTextContent(domElement,"")}function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText}function appendChild(parentInstance,child){parentInstance.appendChild(child)}function appendChildToContainer(container,child){var parentNode;container.nodeType===COMMENT_NODE?(parentNode=container.parentNode,parentNode.insertBefore(child,container)):(parentNode=container,parentNode.appendChild(child));var reactRootContainer=container._reactRootContainer;reactRootContainer==null&&parentNode.onclick===null&&trapClickOnNonInteractiveElement(parentNode)}function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild)}function insertInContainerBefore(container,child,beforeChild){container.nodeType===COMMENT_NODE?container.parentNode.insertBefore(child,beforeChild):container.insertBefore(child,beforeChild)}function removeChild(parentInstance,child){parentInstance.removeChild(child)}function removeChildFromContainer(container,child){container.nodeType===COMMENT_NODE?container.parentNode.removeChild(child):container.removeChild(child)}function clearSuspenseBoundary(parentInstance,suspenseInstance){var node=suspenseInstance,depth=0;do{var nextNode=node.nextSibling;if(parentInstance.removeChild(node),nextNode&&nextNode.nodeType===COMMENT_NODE){var data=nextNode.data;if(data===SUSPENSE_END_DATA)if(depth===0){parentInstance.removeChild(nextNode),retryIfBlockedOn(suspenseInstance);return}else depth--;else(data===SUSPENSE_START_DATA||data===SUSPENSE_PENDING_START_DATA||data===SUSPENSE_FALLBACK_START_DATA)&&depth++}node=nextNode}while(node);retryIfBlockedOn(suspenseInstance)}function clearSuspenseBoundaryFromContainer(container,suspenseInstance){container.nodeType===COMMENT_NODE?clearSuspenseBoundary(container.parentNode,suspenseInstance):container.nodeType===ELEMENT_NODE&&clearSuspenseBoundary(container,suspenseInstance),retryIfBlockedOn(container)}function hideInstance(instance){instance=instance;var style2=instance.style;typeof style2.setProperty=="function"?style2.setProperty("display","none","important"):style2.display="none"}function hideTextInstance(textInstance){textInstance.nodeValue=""}function unhideInstance(instance,props){instance=instance;var styleProp=props[STYLE$1],display=styleProp!=null&&styleProp.hasOwnProperty("display")?styleProp.display:null;instance.style.display=dangerousStyleValue("display",display)}function unhideTextInstance(textInstance,text){textInstance.nodeValue=text}function clearContainer(container){container.nodeType===ELEMENT_NODE?container.textContent="":container.nodeType===DOCUMENT_NODE&&container.documentElement&&container.removeChild(container.documentElement)}function canHydrateInstance(instance,type,props){return instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()?null:instance}function canHydrateTextInstance(instance,text){return text===""||instance.nodeType!==TEXT_NODE?null:instance}function canHydrateSuspenseInstance(instance){return instance.nodeType!==COMMENT_NODE?null:instance}function isSuspenseInstancePending(instance){return instance.data===SUSPENSE_PENDING_START_DATA}function isSuspenseInstanceFallback(instance){return instance.data===SUSPENSE_FALLBACK_START_DATA}function getSuspenseInstanceFallbackErrorDetails(instance){var dataset=instance.nextSibling&&instance.nextSibling.dataset,digest,message,stack;return dataset&&(digest=dataset.dgst,message=dataset.msg,stack=dataset.stck),{message,digest,stack}}function registerSuspenseInstanceRetry(instance,callback){instance._reactRetry=callback}function getNextHydratable(node){for(;node!=null;node=node.nextSibling){var nodeType=node.nodeType;if(nodeType===ELEMENT_NODE||nodeType===TEXT_NODE)break;if(nodeType===COMMENT_NODE){var nodeData=node.data;if(nodeData===SUSPENSE_START_DATA||nodeData===SUSPENSE_FALLBACK_START_DATA||nodeData===SUSPENSE_PENDING_START_DATA)break;if(nodeData===SUSPENSE_END_DATA)return null}}return node}function getNextHydratableSibling(instance){return getNextHydratable(instance.nextSibling)}function getFirstHydratableChild(parentInstance){return getNextHydratable(parentInstance.firstChild)}function getFirstHydratableChildWithinContainer(parentContainer){return getNextHydratable(parentContainer.firstChild)}function getFirstHydratableChildWithinSuspenseInstance(parentInstance){return getNextHydratable(parentInstance.nextSibling)}function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle,shouldWarnDev){precacheFiberNode(internalInstanceHandle,instance),updateFiberProps(instance,props);var parentNamespace;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace}var isConcurrentMode=(internalInstanceHandle.mode&ConcurrentMode)!==NoMode;return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance,isConcurrentMode,shouldWarnDev)}function hydrateTextInstance(textInstance,text,internalInstanceHandle,shouldWarnDev){return precacheFiberNode(internalInstanceHandle,textInstance),internalInstanceHandle.mode&ConcurrentMode,diffHydratedText(textInstance,text)}function hydrateSuspenseInstance(suspenseInstance,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,suspenseInstance)}function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance){for(var node=suspenseInstance.nextSibling,depth=0;node;){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_END_DATA){if(depth===0)return getNextHydratableSibling(node);depth--}else(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA)&&depth++}node=node.nextSibling}return null}function getParentSuspenseInstance(targetInstance){for(var node=targetInstance.previousSibling,depth=0;node;){if(node.nodeType===COMMENT_NODE){var data=node.data;if(data===SUSPENSE_START_DATA||data===SUSPENSE_FALLBACK_START_DATA||data===SUSPENSE_PENDING_START_DATA){if(depth===0)return node;depth--}else data===SUSPENSE_END_DATA&&depth++}node=node.previousSibling}return null}function commitHydratedContainer(container){retryIfBlockedOn(container)}function commitHydratedSuspenseInstance(suspenseInstance){retryIfBlockedOn(suspenseInstance)}function shouldDeleteUnhydratedTailInstances(parentType){return parentType!=="head"&&parentType!=="body"}function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text,isConcurrentMode){var shouldWarnDev=!0;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev)}function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text,isConcurrentMode){if(parentProps[SUPPRESS_HYDRATION_WARNING$1]!==!0){var shouldWarnDev=!0;checkForUnmatchedText(textInstance.nodeValue,text,isConcurrentMode,shouldWarnDev)}}function didNotHydrateInstanceWithinContainer(parentContainer,instance){instance.nodeType===ELEMENT_NODE?warnForDeletedHydratableElement(parentContainer,instance):instance.nodeType===COMMENT_NODE||warnForDeletedHydratableText(parentContainer,instance)}function didNotHydrateInstanceWithinSuspenseInstance(parentInstance,instance){{var parentNode=parentInstance.parentNode;parentNode!==null&&(instance.nodeType===ELEMENT_NODE?warnForDeletedHydratableElement(parentNode,instance):instance.nodeType===COMMENT_NODE||warnForDeletedHydratableText(parentNode,instance))}}function didNotHydrateInstance(parentType,parentProps,parentInstance,instance,isConcurrentMode){(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==!0)&&(instance.nodeType===ELEMENT_NODE?warnForDeletedHydratableElement(parentInstance,instance):instance.nodeType===COMMENT_NODE||warnForDeletedHydratableText(parentInstance,instance))}function didNotFindHydratableInstanceWithinContainer(parentContainer,type,props){warnForInsertedHydratedElement(parentContainer,type)}function didNotFindHydratableTextInstanceWithinContainer(parentContainer,text){warnForInsertedHydratedText(parentContainer,text)}function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance,type,props){{var parentNode=parentInstance.parentNode;parentNode!==null&&warnForInsertedHydratedElement(parentNode,type)}}function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance,text){{var parentNode=parentInstance.parentNode;parentNode!==null&&warnForInsertedHydratedText(parentNode,text)}}function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props,isConcurrentMode){(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==!0)&&warnForInsertedHydratedElement(parentInstance,type)}function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text,isConcurrentMode){(isConcurrentMode||parentProps[SUPPRESS_HYDRATION_WARNING$1]!==!0)&&warnForInsertedHydratedText(parentInstance,text)}function errorHydratingContainer(parentContainer){error("An error occurred during hydration. The server HTML was replaced with client content in <%s>.",parentContainer.nodeName.toLowerCase())}function preparePortalMount(portalInstance){listenToAllSupportedEvents(portalInstance)}var randomKey=Math.random().toString(36).slice(2),internalInstanceKey="__reactFiber$"+randomKey,internalPropsKey="__reactProps$"+randomKey,internalContainerInstanceKey="__reactContainer$"+randomKey,internalEventHandlersKey="__reactEvents$"+randomKey,internalEventHandlerListenersKey="__reactListeners$"+randomKey,internalEventHandlesSetKey="__reactHandles$"+randomKey;function detachDeletedInstance(node){delete node[internalInstanceKey],delete node[internalPropsKey],delete node[internalEventHandlersKey],delete node[internalEventHandlerListenersKey],delete node[internalEventHandlesSetKey]}function precacheFiberNode(hostInst,node){node[internalInstanceKey]=hostInst}function markContainerAsRoot(hostRoot,node){node[internalContainerInstanceKey]=hostRoot}function unmarkContainerAsRoot(node){node[internalContainerInstanceKey]=null}function isContainerMarkedAsRoot(node){return!!node[internalContainerInstanceKey]}function getClosestInstanceFromNode(targetNode){var targetInst=targetNode[internalInstanceKey];if(targetInst)return targetInst;for(var parentNode=targetNode.parentNode;parentNode;){if(targetInst=parentNode[internalContainerInstanceKey]||parentNode[internalInstanceKey],targetInst){var alternate=targetInst.alternate;if(targetInst.child!==null||alternate!==null&&alternate.child!==null)for(var suspenseInstance=getParentSuspenseInstance(targetNode);suspenseInstance!==null;){var targetSuspenseInst=suspenseInstance[internalInstanceKey];if(targetSuspenseInst)return targetSuspenseInst;suspenseInstance=getParentSuspenseInstance(suspenseInstance)}return targetInst}targetNode=parentNode,parentNode=targetNode.parentNode}return null}function getInstanceFromNode(node){var inst=node[internalInstanceKey]||node[internalContainerInstanceKey];return inst&&(inst.tag===HostComponent||inst.tag===HostText||inst.tag===SuspenseComponent||inst.tag===HostRoot)?inst:null}function getNodeFromInstance(inst){if(inst.tag===HostComponent||inst.tag===HostText)return inst.stateNode;throw new Error("getNodeFromInstance: Invalid argument.")}function getFiberCurrentPropsFromNode(node){return node[internalPropsKey]||null}function updateFiberProps(node,props){node[internalPropsKey]=props}function getEventListenerSet(node){var elementListenerSet=node[internalEventHandlersKey];return elementListenerSet===void 0&&(elementListenerSet=node[internalEventHandlersKey]=new Set),elementListenerSet}var loggedTypeFailures={},ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){if(element){var owner=element._owner,stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame$1.setExtraStackFrame(stack)}else ReactDebugCurrentFrame$1.setExtraStackFrame(null)}function checkPropTypes(typeSpecs,values,location,componentName,element){{var has2=Function.call.bind(hasOwnProperty);for(var typeSpecName in typeSpecs)if(has2(typeSpecs,typeSpecName)){var error$1=void 0;try{if(typeof typeSpecs[typeSpecName]!="function"){var err=Error((componentName||"React class")+": "+location+" type `"+typeSpecName+"` is invalid; it must be a function, usually from the `prop-types` package, but received `"+typeof typeSpecs[typeSpecName]+"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");throw err.name="Invariant Violation",err}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(ex){error$1=ex}error$1&&!(error$1 instanceof Error)&&(setCurrentlyValidatingElement(element),error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).",componentName||"React class",location,typeSpecName,typeof error$1),setCurrentlyValidatingElement(null)),error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)&&(loggedTypeFailures[error$1.message]=!0,setCurrentlyValidatingElement(element),error("Failed %s type: %s",location,error$1.message),setCurrentlyValidatingElement(null))}}}var valueStack=[],fiberStack;fiberStack=[];var index=-1;function createCursor(defaultValue){return{current:defaultValue}}function pop(cursor,fiber){if(index<0){error("Unexpected pop.");return}fiber!==fiberStack[index]&&error("Unexpected Fiber popped."),cursor.current=valueStack[index],valueStack[index]=null,fiberStack[index]=null,index--}function push(cursor,value,fiber){index++,valueStack[index]=cursor.current,fiberStack[index]=fiber,cursor.current=value}var warnedAboutMissingGetChildContext;warnedAboutMissingGetChildContext={};var emptyContextObject={};Object.freeze(emptyContextObject);var contextStackCursor=createCursor(emptyContextObject),didPerformWorkStackCursor=createCursor(!1),previousContext=emptyContextObject;function getUnmaskedContext(workInProgress2,Component,didPushOwnContextIfProvider){return didPushOwnContextIfProvider&&isContextProvider(Component)?previousContext:contextStackCursor.current}function cacheContext(workInProgress2,unmaskedContext,maskedContext){{var instance=workInProgress2.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext,instance.__reactInternalMemoizedMaskedChildContext=maskedContext}}function getMaskedContext(workInProgress2,unmaskedContext){{var type=workInProgress2.type,contextTypes=type.contextTypes;if(!contextTypes)return emptyContextObject;var instance=workInProgress2.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext)return instance.__reactInternalMemoizedMaskedChildContext;var context2={};for(var key in contextTypes)context2[key]=unmaskedContext[key];{var name=getComponentNameFromFiber(workInProgress2)||"Unknown";checkPropTypes(contextTypes,context2,"context",name)}return instance&&cacheContext(workInProgress2,unmaskedContext,context2),context2}}function hasContextChanged(){return didPerformWorkStackCursor.current}function isContextProvider(type){{var childContextTypes=type.childContextTypes;return childContextTypes!=null}}function popContext(fiber){pop(didPerformWorkStackCursor,fiber),pop(contextStackCursor,fiber)}function popTopLevelContextObject(fiber){pop(didPerformWorkStackCursor,fiber),pop(contextStackCursor,fiber)}function pushTopLevelContextObject(fiber,context2,didChange){{if(contextStackCursor.current!==emptyContextObject)throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");push(contextStackCursor,context2,fiber),push(didPerformWorkStackCursor,didChange,fiber)}}function processChildContext(fiber,type,parentContext){{var instance=fiber.stateNode,childContextTypes=type.childContextTypes;if(typeof instance.getChildContext!="function"){{var componentName=getComponentNameFromFiber(fiber)||"Unknown";warnedAboutMissingGetChildContext[componentName]||(warnedAboutMissingGetChildContext[componentName]=!0,error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.",componentName,componentName))}return parentContext}var childContext=instance.getChildContext();for(var contextKey in childContext)if(!(contextKey in childContextTypes))throw new Error((getComponentNameFromFiber(fiber)||"Unknown")+'.getChildContext(): key "'+contextKey+'" is not defined in childContextTypes.');{var name=getComponentNameFromFiber(fiber)||"Unknown";checkPropTypes(childContextTypes,childContext,"child context",name)}return assign({},parentContext,childContext)}}function pushContextProvider(workInProgress2){{var instance=workInProgress2.stateNode,memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;return previousContext=contextStackCursor.current,push(contextStackCursor,memoizedMergedChildContext,workInProgress2),push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress2),!0}}function invalidateContextProvider(workInProgress2,type,didChange){{var instance=workInProgress2.stateNode;if(!instance)throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");if(didChange){var mergedContext=processChildContext(workInProgress2,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext,pop(didPerformWorkStackCursor,workInProgress2),pop(contextStackCursor,workInProgress2),push(contextStackCursor,mergedContext,workInProgress2),push(didPerformWorkStackCursor,didChange,workInProgress2)}else pop(didPerformWorkStackCursor,workInProgress2),push(didPerformWorkStackCursor,didChange,workInProgress2)}}function findCurrentUnmaskedContext(fiber){{if(!isFiberMounted(fiber)||fiber.tag!==ClassComponent)throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component))return node.stateNode.__reactInternalMemoizedMergedChildContext;break}}node=node.return}while(node!==null);throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.")}}var LegacyRoot=0,ConcurrentRoot=1,syncQueue=null,includesLegacySyncCallbacks=!1,isFlushingSyncQueue=!1;function scheduleSyncCallback(callback){syncQueue===null?syncQueue=[callback]:syncQueue.push(callback)}function scheduleLegacySyncCallback(callback){includesLegacySyncCallbacks=!0,scheduleSyncCallback(callback)}function flushSyncCallbacksOnlyInLegacyMode(){includesLegacySyncCallbacks&&flushSyncCallbacks()}function flushSyncCallbacks(){if(!isFlushingSyncQueue&&syncQueue!==null){isFlushingSyncQueue=!0;var i2=0,previousUpdatePriority=getCurrentUpdatePriority();try{var isSync=!0,queue=syncQueue;for(setCurrentUpdatePriority(DiscreteEventPriority);i2<queue.length;i2++){var callback=queue[i2];do callback=callback(isSync);while(callback!==null)}syncQueue=null,includesLegacySyncCallbacks=!1}catch(error2){throw syncQueue!==null&&(syncQueue=syncQueue.slice(i2+1)),scheduleCallback(ImmediatePriority,flushSyncCallbacks),error2}finally{setCurrentUpdatePriority(previousUpdatePriority),isFlushingSyncQueue=!1}}return null}var forkStack=[],forkStackIndex=0,treeForkProvider=null,treeForkCount=0,idStack=[],idStackIndex=0,treeContextProvider=null,treeContextId=1,treeContextOverflow="";function isForkedChild(workInProgress2){return warnIfNotHydrating(),(workInProgress2.flags&Forked)!==NoFlags}function getForksAtLevel(workInProgress2){return warnIfNotHydrating(),treeForkCount}function getTreeId(){var overflow=treeContextOverflow,idWithLeadingBit=treeContextId,id2=idWithLeadingBit&~getLeadingBit(idWithLeadingBit);return id2.toString(32)+overflow}function pushTreeFork(workInProgress2,totalChildren){warnIfNotHydrating(),forkStack[forkStackIndex++]=treeForkCount,forkStack[forkStackIndex++]=treeForkProvider,treeForkProvider=workInProgress2,treeForkCount=totalChildren}function pushTreeId(workInProgress2,totalChildren,index2){warnIfNotHydrating(),idStack[idStackIndex++]=treeContextId,idStack[idStackIndex++]=treeContextOverflow,idStack[idStackIndex++]=treeContextProvider,treeContextProvider=workInProgress2;var baseIdWithLeadingBit=treeContextId,baseOverflow=treeContextOverflow,baseLength=getBitLength(baseIdWithLeadingBit)-1,baseId=baseIdWithLeadingBit&~(1<<baseLength),slot=index2+1,length=getBitLength(totalChildren)+baseLength;if(length>30){var numberOfOverflowBits=baseLength-baseLength%5,newOverflowBits=(1<<numberOfOverflowBits)-1,newOverflow=(baseId&newOverflowBits).toString(32),restOfBaseId=baseId>>numberOfOverflowBits,restOfBaseLength=baseLength-numberOfOverflowBits,restOfLength=getBitLength(totalChildren)+restOfBaseLength,restOfNewBits=slot<<restOfBaseLength,id2=restOfNewBits|restOfBaseId,overflow=newOverflow+baseOverflow;treeContextId=1<<restOfLength|id2,treeContextOverflow=overflow}else{var newBits=slot<<baseLength,_id2=newBits|baseId,_overflow=baseOverflow;treeContextId=1<<length|_id2,treeContextOverflow=_overflow}}function pushMaterializedTreeId(workInProgress2){warnIfNotHydrating();var returnFiber=workInProgress2.return;if(returnFiber!==null){var numberOfForks=1,slotIndex=0;pushTreeFork(workInProgress2,numberOfForks),pushTreeId(workInProgress2,numberOfForks,slotIndex)}}function getBitLength(number2){return 32-clz32(number2)}function getLeadingBit(id2){return 1<<getBitLength(id2)-1}function popTreeContext(workInProgress2){for(;workInProgress2===treeForkProvider;)treeForkProvider=forkStack[--forkStackIndex],forkStack[forkStackIndex]=null,treeForkCount=forkStack[--forkStackIndex],forkStack[forkStackIndex]=null;for(;workInProgress2===treeContextProvider;)treeContextProvider=idStack[--idStackIndex],idStack[idStackIndex]=null,treeContextOverflow=idStack[--idStackIndex],idStack[idStackIndex]=null,treeContextId=idStack[--idStackIndex],idStack[idStackIndex]=null}function getSuspendedTreeContext(){return warnIfNotHydrating(),treeContextProvider!==null?{id:treeContextId,overflow:treeContextOverflow}:null}function restoreSuspendedTreeContext(workInProgress2,suspendedContext){warnIfNotHydrating(),idStack[idStackIndex++]=treeContextId,idStack[idStackIndex++]=treeContextOverflow,idStack[idStackIndex++]=treeContextProvider,treeContextId=suspendedContext.id,treeContextOverflow=suspendedContext.overflow,treeContextProvider=workInProgress2}function warnIfNotHydrating(){getIsHydrating()||error("Expected to be hydrating. This is a bug in React. Please file an issue.")}var hydrationParentFiber=null,nextHydratableInstance=null,isHydrating=!1,didSuspendOrErrorDEV=!1,hydrationErrors=null;function warnIfHydrating(){isHydrating&&error("We should not be hydrating here. This is a bug in React. Please file a bug.")}function markDidThrowWhileHydratingDEV(){didSuspendOrErrorDEV=!0}function didSuspendOrErrorWhileHydratingDEV(){return didSuspendOrErrorDEV}function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;return nextHydratableInstance=getFirstHydratableChildWithinContainer(parentInstance),hydrationParentFiber=fiber,isHydrating=!0,hydrationErrors=null,didSuspendOrErrorDEV=!1,!0}function reenterHydrationStateFromDehydratedSuspenseInstance(fiber,suspenseInstance,treeContext){return nextHydratableInstance=getFirstHydratableChildWithinSuspenseInstance(suspenseInstance),hydrationParentFiber=fiber,isHydrating=!0,hydrationErrors=null,didSuspendOrErrorDEV=!1,treeContext!==null&&restoreSuspendedTreeContext(fiber,treeContext),!0}function warnUnhydratedInstance(returnFiber,instance){switch(returnFiber.tag){case HostRoot:{didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo,instance);break}case HostComponent:{var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance,isConcurrentMode);break}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState;suspenseState.dehydrated!==null&&didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated,instance);break}}}function deleteHydratableInstance(returnFiber,instance){warnUnhydratedInstance(returnFiber,instance);var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance,childToDelete.return=returnFiber;var deletions=returnFiber.deletions;deletions===null?(returnFiber.deletions=[childToDelete],returnFiber.flags|=ChildDeletion):deletions.push(childToDelete)}function warnNonhydratedInstance(returnFiber,fiber){{if(didSuspendOrErrorDEV)return;switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;fiber.pendingProps,didNotFindHydratableInstanceWithinContainer(parentContainer,type);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableTextInstanceWithinContainer(parentContainer,text);break}break}case HostComponent:{var parentType=returnFiber.type,parentProps=returnFiber.memoizedProps,parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:{var _type=fiber.type,_props=fiber.pendingProps,isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props,isConcurrentMode);break}case HostText:{var _text=fiber.pendingProps,_isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text,_isConcurrentMode);break}}break}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState,_parentInstance=suspenseState.dehydrated;if(_parentInstance!==null)switch(fiber.tag){case HostComponent:var _type2=fiber.type;fiber.pendingProps,didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance,_type2);break;case HostText:var _text2=fiber.pendingProps;didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance,_text2);break}break}default:return}}}function insertNonHydratedInstance(returnFiber,fiber){fiber.flags=fiber.flags&~Hydrating|Placement,warnNonhydratedInstance(returnFiber,fiber)}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type);return instance!==null?(fiber.stateNode=instance,hydrationParentFiber=fiber,nextHydratableInstance=getFirstHydratableChild(instance),!0):!1}case HostText:{var text=fiber.pendingProps,textInstance=canHydrateTextInstance(nextInstance,text);return textInstance!==null?(fiber.stateNode=textInstance,hydrationParentFiber=fiber,nextHydratableInstance=null,!0):!1}case SuspenseComponent:{var suspenseInstance=canHydrateSuspenseInstance(nextInstance);if(suspenseInstance!==null){var suspenseState={dehydrated:suspenseInstance,treeContext:getSuspendedTreeContext(),retryLane:OffscreenLane};fiber.memoizedState=suspenseState;var dehydratedFragment=createFiberFromDehydratedFragment(suspenseInstance);return dehydratedFragment.return=fiber,fiber.child=dehydratedFragment,hydrationParentFiber=fiber,nextHydratableInstance=null,!0}return!1}default:return!1}}function shouldClientRenderOnMismatch(fiber){return(fiber.mode&ConcurrentMode)!==NoMode&&(fiber.flags&DidCapture)===NoFlags}function throwOnHydrationMismatch(fiber){throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.")}function tryToClaimNextHydratableInstance(fiber){if(isHydrating){var nextInstance=nextHydratableInstance;if(!nextInstance){shouldClientRenderOnMismatch(fiber)&&(warnNonhydratedInstance(hydrationParentFiber,fiber),throwOnHydrationMismatch()),insertNonHydratedInstance(hydrationParentFiber,fiber),isHydrating=!1,hydrationParentFiber=fiber;return}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){shouldClientRenderOnMismatch(fiber)&&(warnNonhydratedInstance(hydrationParentFiber,fiber),throwOnHydrationMismatch()),nextInstance=getNextHydratableSibling(firstAttemptedInstance);var prevHydrationParentFiber=hydrationParentFiber;if(!nextInstance||!tryHydrate(fiber,nextInstance)){insertNonHydratedInstance(hydrationParentFiber,fiber),isHydrating=!1,hydrationParentFiber=fiber;return}deleteHydratableInstance(prevHydrationParentFiber,firstAttemptedInstance)}}}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode,shouldWarnIfMismatchDev=!didSuspendOrErrorDEV,updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber,shouldWarnIfMismatchDev);return fiber.updateQueue=updatePayload,updatePayload!==null}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode,textContent=fiber.memoizedProps,shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);if(shouldUpdate){var returnFiber=hydrationParentFiber;if(returnFiber!==null)switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo,isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent,isConcurrentMode);break}case HostComponent:{var parentType=returnFiber.type,parentProps=returnFiber.memoizedProps,parentInstance=returnFiber.stateNode,_isConcurrentMode2=(returnFiber.mode&ConcurrentMode)!==NoMode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent,_isConcurrentMode2);break}}}return shouldUpdate}function prepareToHydrateHostSuspenseInstance(fiber){var suspenseState=fiber.memoizedState,suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance)throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");hydrateSuspenseInstance(suspenseInstance,fiber)}function skipPastDehydratedSuspenseInstance(fiber){var suspenseState=fiber.memoizedState,suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance)throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance)}function popToNextHostParent(fiber){for(var parent=fiber.return;parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot&&parent.tag!==SuspenseComponent;)parent=parent.return;hydrationParentFiber=parent}function popHydrationState(fiber){if(fiber!==hydrationParentFiber)return!1;if(!isHydrating)return popToNextHostParent(fiber),isHydrating=!0,!1;if(fiber.tag!==HostRoot&&(fiber.tag!==HostComponent||shouldDeleteUnhydratedTailInstances(fiber.type)&&!shouldSetTextContent(fiber.type,fiber.memoizedProps))){var nextInstance=nextHydratableInstance;if(nextInstance)if(shouldClientRenderOnMismatch(fiber))warnIfUnhydratedTailNodes(fiber),throwOnHydrationMismatch();else for(;nextInstance;)deleteHydratableInstance(fiber,nextInstance),nextInstance=getNextHydratableSibling(nextInstance)}return popToNextHostParent(fiber),fiber.tag===SuspenseComponent?nextHydratableInstance=skipPastDehydratedSuspenseInstance(fiber):nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null,!0}function hasUnhydratedTailNodes(){return isHydrating&&nextHydratableInstance!==null}function warnIfUnhydratedTailNodes(fiber){for(var nextInstance=nextHydratableInstance;nextInstance;)warnUnhydratedInstance(fiber,nextInstance),nextInstance=getNextHydratableSibling(nextInstance)}function resetHydrationState(){hydrationParentFiber=null,nextHydratableInstance=null,isHydrating=!1,didSuspendOrErrorDEV=!1}function upgradeHydrationErrorsToRecoverable(){hydrationErrors!==null&&(queueRecoverableErrors(hydrationErrors),hydrationErrors=null)}function getIsHydrating(){return isHydrating}function queueHydrationError(error2){hydrationErrors===null?hydrationErrors=[error2]:hydrationErrors.push(error2)}var ReactCurrentBatchConfig$1=ReactSharedInternals.ReactCurrentBatchConfig,NoTransition=null;function requestCurrentTransition(){return ReactCurrentBatchConfig$1.transition}var ReactStrictModeWarnings={recordUnsafeLifecycleWarnings:function(fiber,instance){},flushPendingUnsafeLifecycleWarnings:function(){},recordLegacyContextWarning:function(fiber,instance){},flushLegacyContextWarning:function(){},discardPendingWarnings:function(){}};{var findStrictRoot=function(fiber){for(var maybeStrictRoot=null,node=fiber;node!==null;)node.mode&StrictLegacyMode&&(maybeStrictRoot=node),node=node.return;return maybeStrictRoot},setToSortedString=function(set2){var array=[];return set2.forEach(function(value){array.push(value)}),array.sort().join(", ")},pendingComponentWillMountWarnings=[],pendingUNSAFE_ComponentWillMountWarnings=[],pendingComponentWillReceivePropsWarnings=[],pendingUNSAFE_ComponentWillReceivePropsWarnings=[],pendingComponentWillUpdateWarnings=[],pendingUNSAFE_ComponentWillUpdateWarnings=[],didWarnAboutUnsafeLifecycles=new Set;ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){didWarnAboutUnsafeLifecycles.has(fiber.type)||(typeof instance.componentWillMount=="function"&&instance.componentWillMount.__suppressDeprecationWarning!==!0&&pendingComponentWillMountWarnings.push(fiber),fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillMount=="function"&&pendingUNSAFE_ComponentWillMountWarnings.push(fiber),typeof instance.componentWillReceiveProps=="function"&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==!0&&pendingComponentWillReceivePropsWarnings.push(fiber),fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillReceiveProps=="function"&&pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber),typeof instance.componentWillUpdate=="function"&&instance.componentWillUpdate.__suppressDeprecationWarning!==!0&&pendingComponentWillUpdateWarnings.push(fiber),fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillUpdate=="function"&&pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber))},ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){var componentWillMountUniqueNames=new Set;pendingComponentWillMountWarnings.length>0&&(pendingComponentWillMountWarnings.forEach(function(fiber){componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||"Component"),didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingComponentWillMountWarnings=[]);var UNSAFE_componentWillMountUniqueNames=new Set;pendingUNSAFE_ComponentWillMountWarnings.length>0&&(pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber){UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||"Component"),didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingUNSAFE_ComponentWillMountWarnings=[]);var componentWillReceivePropsUniqueNames=new Set;pendingComponentWillReceivePropsWarnings.length>0&&(pendingComponentWillReceivePropsWarnings.forEach(function(fiber){componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||"Component"),didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingComponentWillReceivePropsWarnings=[]);var UNSAFE_componentWillReceivePropsUniqueNames=new Set;pendingUNSAFE_ComponentWillReceivePropsWarnings.length>0&&(pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber){UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||"Component"),didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingUNSAFE_ComponentWillReceivePropsWarnings=[]);var componentWillUpdateUniqueNames=new Set;pendingComponentWillUpdateWarnings.length>0&&(pendingComponentWillUpdateWarnings.forEach(function(fiber){componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||"Component"),didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingComponentWillUpdateWarnings=[]);var UNSAFE_componentWillUpdateUniqueNames=new Set;if(pendingUNSAFE_ComponentWillUpdateWarnings.length>0&&(pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber){UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||"Component"),didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingUNSAFE_ComponentWillUpdateWarnings=[]),UNSAFE_componentWillMountUniqueNames.size>0){var sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);error(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`,sortedNames)}if(UNSAFE_componentWillReceivePropsUniqueNames.size>0){var _sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);error(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`,_sortedNames)}if(UNSAFE_componentWillUpdateUniqueNames.size>0){var _sortedNames2=setToSortedString(UNSAFE_componentWillUpdateUniqueNames);error(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`,_sortedNames2)}if(componentWillMountUniqueNames.size>0){var _sortedNames3=setToSortedString(componentWillMountUniqueNames);warn(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,_sortedNames3)}if(componentWillReceivePropsUniqueNames.size>0){var _sortedNames4=setToSortedString(componentWillReceivePropsUniqueNames);warn(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,_sortedNames4)}if(componentWillUpdateUniqueNames.size>0){var _sortedNames5=setToSortedString(componentWillUpdateUniqueNames);warn(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,_sortedNames5)}};var pendingLegacyContextWarning=new Map,didWarnAboutLegacyContext=new Set;ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");return}if(!didWarnAboutLegacyContext.has(fiber.type)){var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext=="function")&&(warningsForRoot===void 0&&(warningsForRoot=[],pendingLegacyContextWarning.set(strictRoot,warningsForRoot)),warningsForRoot.push(fiber))}},ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){if(fiberArray.length!==0){var firstFiber=fiberArray[0],uniqueNames=new Set;fiberArray.forEach(function(fiber){uniqueNames.add(getComponentNameFromFiber(fiber)||"Component"),didWarnAboutLegacyContext.add(fiber.type)});var sortedNames=setToSortedString(uniqueNames);try{setCurrentFiber(firstFiber),error(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`,sortedNames)}finally{resetCurrentFiber()}}})},ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[],pendingUNSAFE_ComponentWillMountWarnings=[],pendingComponentWillReceivePropsWarnings=[],pendingUNSAFE_ComponentWillReceivePropsWarnings=[],pendingComponentWillUpdateWarnings=[],pendingUNSAFE_ComponentWillUpdateWarnings=[],pendingLegacyContextWarning=new Map}}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){var props=assign({},baseProps),defaultProps=Component.defaultProps;for(var propName in defaultProps)props[propName]===void 0&&(props[propName]=defaultProps[propName]);return props}return baseProps}var valueCursor=createCursor(null),rendererSigil;rendererSigil={};var currentlyRenderingFiber=null,lastContextDependency=null,lastFullyObservedContext=null,isDisallowedContextReadInDEV=!1;function resetContextDependencies(){currentlyRenderingFiber=null,lastContextDependency=null,lastFullyObservedContext=null,isDisallowedContextReadInDEV=!1}function enterDisallowedContextReadInDEV(){isDisallowedContextReadInDEV=!0}function exitDisallowedContextReadInDEV(){isDisallowedContextReadInDEV=!1}function pushProvider(providerFiber,context2,nextValue){push(valueCursor,context2._currentValue,providerFiber),context2._currentValue=nextValue,context2._currentRenderer!==void 0&&context2._currentRenderer!==null&&context2._currentRenderer!==rendererSigil&&error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."),context2._currentRenderer=rendererSigil}function popProvider(context2,providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber),context2._currentValue=currentValue}function scheduleContextWorkOnParentPath(parent,renderLanes2,propagationRoot){for(var node=parent;node!==null;){var alternate=node.alternate;if(isSubsetOfLanes(node.childLanes,renderLanes2)?alternate!==null&&!isSubsetOfLanes(alternate.childLanes,renderLanes2)&&(alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes2)):(node.childLanes=mergeLanes(node.childLanes,renderLanes2),alternate!==null&&(alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes2))),node===propagationRoot)break;node=node.return}node!==propagationRoot&&error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.")}function propagateContextChange(workInProgress2,context2,renderLanes2){propagateContextChange_eager(workInProgress2,context2,renderLanes2)}function propagateContextChange_eager(workInProgress2,context2,renderLanes2){var fiber=workInProgress2.child;for(fiber!==null&&(fiber.return=workInProgress2);fiber!==null;){var nextFiber=void 0,list=fiber.dependencies;if(list!==null){nextFiber=fiber.child;for(var dependency=list.firstContext;dependency!==null;){if(dependency.context===context2){if(fiber.tag===ClassComponent){var lane=pickArbitraryLane(renderLanes2),update=createUpdate(NoTimestamp,lane);update.tag=ForceUpdate;var updateQueue=fiber.updateQueue;if(updateQueue!==null){var sharedQueue=updateQueue.shared,pending=sharedQueue.pending;pending===null?update.next=update:(update.next=pending.next,pending.next=update),sharedQueue.pending=update}}fiber.lanes=mergeLanes(fiber.lanes,renderLanes2);var alternate=fiber.alternate;alternate!==null&&(alternate.lanes=mergeLanes(alternate.lanes,renderLanes2)),scheduleContextWorkOnParentPath(fiber.return,renderLanes2,workInProgress2),list.lanes=mergeLanes(list.lanes,renderLanes2);break}dependency=dependency.next}}else if(fiber.tag===ContextProvider)nextFiber=fiber.type===workInProgress2.type?null:fiber.child;else if(fiber.tag===DehydratedFragment){var parentSuspense=fiber.return;if(parentSuspense===null)throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");parentSuspense.lanes=mergeLanes(parentSuspense.lanes,renderLanes2);var _alternate=parentSuspense.alternate;_alternate!==null&&(_alternate.lanes=mergeLanes(_alternate.lanes,renderLanes2)),scheduleContextWorkOnParentPath(parentSuspense,renderLanes2,workInProgress2),nextFiber=fiber.sibling}else nextFiber=fiber.child;if(nextFiber!==null)nextFiber.return=fiber;else for(nextFiber=fiber;nextFiber!==null;){if(nextFiber===workInProgress2){nextFiber=null;break}var sibling=nextFiber.sibling;if(sibling!==null){sibling.return=nextFiber.return,nextFiber=sibling;break}nextFiber=nextFiber.return}fiber=nextFiber}}function prepareToReadContext(workInProgress2,renderLanes2){currentlyRenderingFiber=workInProgress2,lastContextDependency=null,lastFullyObservedContext=null;var dependencies=workInProgress2.dependencies;if(dependencies!==null){var firstContext=dependencies.firstContext;firstContext!==null&&(includesSomeLane(dependencies.lanes,renderLanes2)&&markWorkInProgressReceivedUpdate(),dependencies.firstContext=null)}}function readContext(context2){isDisallowedContextReadInDEV&&error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");var value=context2._currentValue;if(lastFullyObservedContext!==context2){var contextItem={context:context2,memoizedValue:value,next:null};if(lastContextDependency===null){if(currentlyRenderingFiber===null)throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");lastContextDependency=contextItem,currentlyRenderingFiber.dependencies={lanes:NoLanes,firstContext:contextItem}}else lastContextDependency=lastContextDependency.next=contextItem}return value}var concurrentQueues=null;function pushConcurrentUpdateQueue(queue){concurrentQueues===null?concurrentQueues=[queue]:concurrentQueues.push(queue)}function finishQueueingConcurrentUpdates(){if(concurrentQueues!==null){for(var i2=0;i2<concurrentQueues.length;i2++){var queue=concurrentQueues[i2],lastInterleavedUpdate=queue.interleaved;if(lastInterleavedUpdate!==null){queue.interleaved=null;var firstInterleavedUpdate=lastInterleavedUpdate.next,lastPendingUpdate=queue.pending;if(lastPendingUpdate!==null){var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=firstInterleavedUpdate,lastInterleavedUpdate.next=firstPendingUpdate}queue.pending=lastInterleavedUpdate}}concurrentQueues=null}}function enqueueConcurrentHookUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;return interleaved===null?(update.next=update,pushConcurrentUpdateQueue(queue)):(update.next=interleaved.next,interleaved.next=update),queue.interleaved=update,markUpdateLaneFromFiberToRoot(fiber,lane)}function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane){var interleaved=queue.interleaved;interleaved===null?(update.next=update,pushConcurrentUpdateQueue(queue)):(update.next=interleaved.next,interleaved.next=update),queue.interleaved=update}function enqueueConcurrentClassUpdate(fiber,queue,update,lane){var interleaved=queue.interleaved;return interleaved===null?(update.next=update,pushConcurrentUpdateQueue(queue)):(update.next=interleaved.next,interleaved.next=update),queue.interleaved=update,markUpdateLaneFromFiberToRoot(fiber,lane)}function enqueueConcurrentRenderForLane(fiber,lane){return markUpdateLaneFromFiberToRoot(fiber,lane)}var unsafe_markUpdateLaneFromFiberToRoot=markUpdateLaneFromFiberToRoot;function markUpdateLaneFromFiberToRoot(sourceFiber,lane){sourceFiber.lanes=mergeLanes(sourceFiber.lanes,lane);var alternate=sourceFiber.alternate;alternate!==null&&(alternate.lanes=mergeLanes(alternate.lanes,lane)),alternate===null&&(sourceFiber.flags&(Placement|Hydrating))!==NoFlags&&warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);for(var node=sourceFiber,parent=sourceFiber.return;parent!==null;)parent.childLanes=mergeLanes(parent.childLanes,lane),alternate=parent.alternate,alternate!==null?alternate.childLanes=mergeLanes(alternate.childLanes,lane):(parent.flags&(Placement|Hydrating))!==NoFlags&&warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber),node=parent,parent=parent.return;if(node.tag===HostRoot){var root2=node.stateNode;return root2}else return null}var UpdateState=0,ReplaceState=1,ForceUpdate=2,CaptureUpdate=3,hasForceUpdate=!1,didWarnUpdateInsideUpdate,currentlyProcessingQueue;didWarnUpdateInsideUpdate=!1,currentlyProcessingQueue=null;function initializeUpdateQueue(fiber){var queue={baseState:fiber.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:NoLanes},effects:null};fiber.updateQueue=queue}function cloneUpdateQueue(current2,workInProgress2){var queue=workInProgress2.updateQueue,currentQueue=current2.updateQueue;if(queue===currentQueue){var clone={baseState:currentQueue.baseState,firstBaseUpdate:currentQueue.firstBaseUpdate,lastBaseUpdate:currentQueue.lastBaseUpdate,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress2.updateQueue=clone}}function createUpdate(eventTime,lane){var update={eventTime,lane,tag:UpdateState,payload:null,callback:null,next:null};return update}function enqueueUpdate(fiber,update,lane){var updateQueue=fiber.updateQueue;if(updateQueue===null)return null;var sharedQueue=updateQueue.shared;if(currentlyProcessingQueue===sharedQueue&&!didWarnUpdateInsideUpdate&&(error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."),didWarnUpdateInsideUpdate=!0),isUnsafeClassRenderPhaseUpdate()){var pending=sharedQueue.pending;return pending===null?update.next=update:(update.next=pending.next,pending.next=update),sharedQueue.pending=update,unsafe_markUpdateLaneFromFiberToRoot(fiber,lane)}else return enqueueConcurrentClassUpdate(fiber,sharedQueue,update,lane)}function entangleTransitions(root2,fiber,lane){var updateQueue=fiber.updateQueue;if(updateQueue!==null){var sharedQueue=updateQueue.shared;if(isTransitionLane(lane)){var queueLanes=sharedQueue.lanes;queueLanes=intersectLanes(queueLanes,root2.pendingLanes);var newQueueLanes=mergeLanes(queueLanes,lane);sharedQueue.lanes=newQueueLanes,markRootEntangled(root2,newQueueLanes)}}}function enqueueCapturedUpdate(workInProgress2,capturedUpdate){var queue=workInProgress2.updateQueue,current2=workInProgress2.alternate;if(current2!==null){var currentQueue=current2.updateQueue;if(queue===currentQueue){var newFirst=null,newLast=null,firstBaseUpdate=queue.firstBaseUpdate;if(firstBaseUpdate!==null){var update=firstBaseUpdate;do{var clone={eventTime:update.eventTime,lane:update.lane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLast===null?newFirst=newLast=clone:(newLast.next=clone,newLast=clone),update=update.next}while(update!==null);newLast===null?newFirst=newLast=capturedUpdate:(newLast.next=capturedUpdate,newLast=capturedUpdate)}else newFirst=newLast=capturedUpdate;queue={baseState:currentQueue.baseState,firstBaseUpdate:newFirst,lastBaseUpdate:newLast,shared:currentQueue.shared,effects:currentQueue.effects},workInProgress2.updateQueue=queue;return}}var lastBaseUpdate=queue.lastBaseUpdate;lastBaseUpdate===null?queue.firstBaseUpdate=capturedUpdate:lastBaseUpdate.next=capturedUpdate,queue.lastBaseUpdate=capturedUpdate}function getStateFromUpdate(workInProgress2,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var payload=update.payload;if(typeof payload=="function"){enterDisallowedContextReadInDEV();var nextState=payload.call(instance,prevState,nextProps);{if(workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{payload.call(instance,prevState,nextProps)}finally{setIsStrictModeForDevtools(!1)}}exitDisallowedContextReadInDEV()}return nextState}return payload}case CaptureUpdate:workInProgress2.flags=workInProgress2.flags&~ShouldCapture|DidCapture;case UpdateState:{var _payload=update.payload,partialState;if(typeof _payload=="function"){enterDisallowedContextReadInDEV(),partialState=_payload.call(instance,prevState,nextProps);{if(workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{_payload.call(instance,prevState,nextProps)}finally{setIsStrictModeForDevtools(!1)}}exitDisallowedContextReadInDEV()}}else partialState=_payload;return partialState==null?prevState:assign({},prevState,partialState)}case ForceUpdate:return hasForceUpdate=!0,prevState}return prevState}function processUpdateQueue(workInProgress2,props,instance,renderLanes2){var queue=workInProgress2.updateQueue;hasForceUpdate=!1,currentlyProcessingQueue=queue.shared;var firstBaseUpdate=queue.firstBaseUpdate,lastBaseUpdate=queue.lastBaseUpdate,pendingQueue=queue.shared.pending;if(pendingQueue!==null){queue.shared.pending=null;var lastPendingUpdate=pendingQueue,firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=null,lastBaseUpdate===null?firstBaseUpdate=firstPendingUpdate:lastBaseUpdate.next=firstPendingUpdate,lastBaseUpdate=lastPendingUpdate;var current2=workInProgress2.alternate;if(current2!==null){var currentQueue=current2.updateQueue,currentLastBaseUpdate=currentQueue.lastBaseUpdate;currentLastBaseUpdate!==lastBaseUpdate&&(currentLastBaseUpdate===null?currentQueue.firstBaseUpdate=firstPendingUpdate:currentLastBaseUpdate.next=firstPendingUpdate,currentQueue.lastBaseUpdate=lastPendingUpdate)}}if(firstBaseUpdate!==null){var newState=queue.baseState,newLanes=NoLanes,newBaseState=null,newFirstBaseUpdate=null,newLastBaseUpdate=null,update=firstBaseUpdate;do{var updateLane=update.lane,updateEventTime=update.eventTime;if(isSubsetOfLanes(renderLanes2,updateLane)){if(newLastBaseUpdate!==null){var _clone={eventTime:updateEventTime,lane:NoLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLastBaseUpdate=newLastBaseUpdate.next=_clone}newState=getStateFromUpdate(workInProgress2,queue,update,newState,props,instance);var callback=update.callback;if(callback!==null&&update.lane!==NoLane){workInProgress2.flags|=Callback;var effects=queue.effects;effects===null?queue.effects=[update]:effects.push(update)}}else{var clone={eventTime:updateEventTime,lane:updateLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLastBaseUpdate===null?(newFirstBaseUpdate=newLastBaseUpdate=clone,newBaseState=newState):newLastBaseUpdate=newLastBaseUpdate.next=clone,newLanes=mergeLanes(newLanes,updateLane)}if(update=update.next,update===null){if(pendingQueue=queue.shared.pending,pendingQueue===null)break;var _lastPendingUpdate=pendingQueue,_firstPendingUpdate=_lastPendingUpdate.next;_lastPendingUpdate.next=null,update=_firstPendingUpdate,queue.lastBaseUpdate=_lastPendingUpdate,queue.shared.pending=null}}while(!0);newLastBaseUpdate===null&&(newBaseState=newState),queue.baseState=newBaseState,queue.firstBaseUpdate=newFirstBaseUpdate,queue.lastBaseUpdate=newLastBaseUpdate;var lastInterleaved=queue.shared.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do newLanes=mergeLanes(newLanes,interleaved.lane),interleaved=interleaved.next;while(interleaved!==lastInterleaved)}else firstBaseUpdate===null&&(queue.shared.lanes=NoLanes);markSkippedUpdateLanes(newLanes),workInProgress2.lanes=newLanes,workInProgress2.memoizedState=newState}currentlyProcessingQueue=null}function callCallback(callback,context2){if(typeof callback!="function")throw new Error("Invalid argument passed as callback. Expected a function. Instead "+("received: "+callback));callback.call(context2)}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=!1}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate}function commitUpdateQueue(finishedWork,finishedQueue,instance){var effects=finishedQueue.effects;if(finishedQueue.effects=null,effects!==null)for(var i2=0;i2<effects.length;i2++){var effect=effects[i2],callback=effect.callback;callback!==null&&(effect.callback=null,callCallback(callback,instance))}}var fakeInternalInstance={},emptyRefsObject=new React.Component().refs,didWarnAboutStateAssignmentForComponent,didWarnAboutUninitializedState,didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate,didWarnAboutLegacyLifecyclesAndDerivedState,didWarnAboutUndefinedDerivedState,warnOnUndefinedDerivedState,warnOnInvalidCallback,didWarnAboutDirectlyAssigningPropsToState,didWarnAboutContextTypeAndContextTypes,didWarnAboutInvalidateContextType;{didWarnAboutStateAssignmentForComponent=new Set,didWarnAboutUninitializedState=new Set,didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set,didWarnAboutLegacyLifecyclesAndDerivedState=new Set,didWarnAboutDirectlyAssigningPropsToState=new Set,didWarnAboutUndefinedDerivedState=new Set,didWarnAboutContextTypeAndContextTypes=new Set,didWarnAboutInvalidateContextType=new Set;var didWarnOnInvalidCallback=new Set;warnOnInvalidCallback=function(callback,callerName){if(!(callback===null||typeof callback=="function")){var key=callerName+"_"+callback;didWarnOnInvalidCallback.has(key)||(didWarnOnInvalidCallback.add(key),error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.",callerName,callback))}},warnOnUndefinedDerivedState=function(type,partialState){if(partialState===void 0){var componentName=getComponentNameFromType(type)||"Component";didWarnAboutUndefinedDerivedState.has(componentName)||(didWarnAboutUndefinedDerivedState.add(componentName),error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",componentName))}},Object.defineProperty(fakeInternalInstance,"_processChildContext",{enumerable:!1,value:function(){throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).")}}),Object.freeze(fakeInternalInstance)}function applyDerivedStateFromProps(workInProgress2,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress2.memoizedState,partialState=getDerivedStateFromProps(nextProps,prevState);{if(workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{partialState=getDerivedStateFromProps(nextProps,prevState)}finally{setIsStrictModeForDevtools(!1)}}warnOnUndefinedDerivedState(ctor,partialState)}var memoizedState=partialState==null?prevState:assign({},prevState,partialState);if(workInProgress2.memoizedState=memoizedState,workInProgress2.lanes===NoLanes){var updateQueue=workInProgress2.updateQueue;updateQueue.baseState=memoizedState}}var classComponentUpdater={isMounted,enqueueSetState:function(inst,payload,callback){var fiber=get(inst),eventTime=requestEventTime(),lane=requestUpdateLane(fiber),update=createUpdate(eventTime,lane);update.payload=payload,callback!=null&&(warnOnInvalidCallback(callback,"setState"),update.callback=callback);var root2=enqueueUpdate(fiber,update,lane);root2!==null&&(scheduleUpdateOnFiber(root2,fiber,lane,eventTime),entangleTransitions(root2,fiber,lane)),markStateUpdateScheduled(fiber,lane)},enqueueReplaceState:function(inst,payload,callback){var fiber=get(inst),eventTime=requestEventTime(),lane=requestUpdateLane(fiber),update=createUpdate(eventTime,lane);update.tag=ReplaceState,update.payload=payload,callback!=null&&(warnOnInvalidCallback(callback,"replaceState"),update.callback=callback);var root2=enqueueUpdate(fiber,update,lane);root2!==null&&(scheduleUpdateOnFiber(root2,fiber,lane,eventTime),entangleTransitions(root2,fiber,lane)),markStateUpdateScheduled(fiber,lane)},enqueueForceUpdate:function(inst,callback){var fiber=get(inst),eventTime=requestEventTime(),lane=requestUpdateLane(fiber),update=createUpdate(eventTime,lane);update.tag=ForceUpdate,callback!=null&&(warnOnInvalidCallback(callback,"forceUpdate"),update.callback=callback);var root2=enqueueUpdate(fiber,update,lane);root2!==null&&(scheduleUpdateOnFiber(root2,fiber,lane,eventTime),entangleTransitions(root2,fiber,lane)),markForceUpdateScheduled(fiber,lane)}};function checkShouldComponentUpdate(workInProgress2,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress2.stateNode;if(typeof instance.shouldComponentUpdate=="function"){var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);{if(workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext)}finally{setIsStrictModeForDevtools(!1)}}shouldUpdate===void 0&&error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",getComponentNameFromType(ctor)||"Component")}return shouldUpdate}return ctor.prototype&&ctor.prototype.isPureReactComponent?!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState):!0}function checkClassInstance(workInProgress2,ctor,newProps){var instance=workInProgress2.stateNode;{var name=getComponentNameFromType(ctor)||"Component",renderPresent=instance.render;renderPresent||(ctor.prototype&&typeof ctor.prototype.render=="function"?error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?",name):error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.",name)),instance.getInitialState&&!instance.getInitialState.isReactClassApproved&&!instance.state&&error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",name),instance.getDefaultProps&&!instance.getDefaultProps.isReactClassApproved&&error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",name),instance.propTypes&&error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.",name),instance.contextType&&error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.",name),instance.contextTypes&&error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.",name),ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)&&(didWarnAboutContextTypeAndContextTypes.add(ctor),error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.",name)),typeof instance.componentShouldUpdate=="function"&&error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",name),ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate<"u"&&error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",getComponentNameFromType(ctor)||"A pure component"),typeof instance.componentDidUnmount=="function"&&error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",name),typeof instance.componentDidReceiveProps=="function"&&error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",name),typeof instance.componentWillRecieveProps=="function"&&error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",name),typeof instance.UNSAFE_componentWillRecieveProps=="function"&&error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",name);var hasMutatedProps=instance.props!==newProps;instance.props!==void 0&&hasMutatedProps&&error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",name,name),instance.defaultProps&&error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",name,name),typeof instance.getSnapshotBeforeUpdate=="function"&&typeof instance.componentDidUpdate!="function"&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)&&(didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor),error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",getComponentNameFromType(ctor))),typeof instance.getDerivedStateFromProps=="function"&&error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",name),typeof instance.getDerivedStateFromError=="function"&&error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",name),typeof ctor.getSnapshotBeforeUpdate=="function"&&error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",name);var _state=instance.state;_state&&(typeof _state!="object"||isArray(_state))&&error("%s.state: must be set to an object or null",name),typeof instance.getChildContext=="function"&&typeof ctor.childContextTypes!="object"&&error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",name)}}function adoptClassInstance(workInProgress2,instance){instance.updater=classComponentUpdater,workInProgress2.stateNode=instance,set(instance,workInProgress2),instance._reactInternalInstance=fakeInternalInstance}function constructClassInstance(workInProgress2,ctor,props){var isLegacyContextConsumer=!1,unmaskedContext=emptyContextObject,context2=emptyContextObject,contextType=ctor.contextType;if("contextType"in ctor){var isValid=contextType===null||contextType!==void 0&&contextType.$$typeof===REACT_CONTEXT_TYPE&&contextType._context===void 0;if(!isValid&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum="";contextType===void 0?addendum=" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.":typeof contextType!="object"?addendum=" However, it is set to a "+typeof contextType+".":contextType.$$typeof===REACT_PROVIDER_TYPE?addendum=" Did you accidentally pass the Context.Provider instead?":contextType._context!==void 0?addendum=" Did you accidentally pass the Context.Consumer instead?":addendum=" However, it is set to an object with keys {"+Object.keys(contextType).join(", ")+"}.",error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",getComponentNameFromType(ctor)||"Component",addendum)}}if(typeof contextType=="object"&&contextType!==null)context2=readContext(contextType);else{unmaskedContext=getUnmaskedContext(workInProgress2,ctor,!0);var contextTypes=ctor.contextTypes;isLegacyContextConsumer=contextTypes!=null,context2=isLegacyContextConsumer?getMaskedContext(workInProgress2,unmaskedContext):emptyContextObject}var instance=new ctor(props,context2);if(workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{instance=new ctor(props,context2)}finally{setIsStrictModeForDevtools(!1)}}var state=workInProgress2.memoizedState=instance.state!==null&&instance.state!==void 0?instance.state:null;adoptClassInstance(workInProgress2,instance);{if(typeof ctor.getDerivedStateFromProps=="function"&&state===null){var componentName=getComponentNameFromType(ctor)||"Component";didWarnAboutUninitializedState.has(componentName)||(didWarnAboutUninitializedState.add(componentName),error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",componentName,instance.state===null?"null":"undefined",componentName))}if(typeof ctor.getDerivedStateFromProps=="function"||typeof instance.getSnapshotBeforeUpdate=="function"){var foundWillMountName=null,foundWillReceivePropsName=null,foundWillUpdateName=null;if(typeof instance.componentWillMount=="function"&&instance.componentWillMount.__suppressDeprecationWarning!==!0?foundWillMountName="componentWillMount":typeof instance.UNSAFE_componentWillMount=="function"&&(foundWillMountName="UNSAFE_componentWillMount"),typeof instance.componentWillReceiveProps=="function"&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==!0?foundWillReceivePropsName="componentWillReceiveProps":typeof instance.UNSAFE_componentWillReceiveProps=="function"&&(foundWillReceivePropsName="UNSAFE_componentWillReceiveProps"),typeof instance.componentWillUpdate=="function"&&instance.componentWillUpdate.__suppressDeprecationWarning!==!0?foundWillUpdateName="componentWillUpdate":typeof instance.UNSAFE_componentWillUpdate=="function"&&(foundWillUpdateName="UNSAFE_componentWillUpdate"),foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentNameFromType(ctor)||"Component",newApiName=typeof ctor.getDerivedStateFromProps=="function"?"getDerivedStateFromProps()":"getSnapshotBeforeUpdate()";didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)||(didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName),error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`,_componentName,newApiName,foundWillMountName!==null?`
  `+foundWillMountName:"",foundWillReceivePropsName!==null?`
  `+foundWillReceivePropsName:"",foundWillUpdateName!==null?`
  `+foundWillUpdateName:""))}}}return isLegacyContextConsumer&&cacheContext(workInProgress2,unmaskedContext,context2),instance}function callComponentWillMount(workInProgress2,instance){var oldState=instance.state;typeof instance.componentWillMount=="function"&&instance.componentWillMount(),typeof instance.UNSAFE_componentWillMount=="function"&&instance.UNSAFE_componentWillMount(),oldState!==instance.state&&(error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",getComponentNameFromFiber(workInProgress2)||"Component"),classComponentUpdater.enqueueReplaceState(instance,instance.state,null))}function callComponentWillReceiveProps(workInProgress2,instance,newProps,nextContext){var oldState=instance.state;if(typeof instance.componentWillReceiveProps=="function"&&instance.componentWillReceiveProps(newProps,nextContext),typeof instance.UNSAFE_componentWillReceiveProps=="function"&&instance.UNSAFE_componentWillReceiveProps(newProps,nextContext),instance.state!==oldState){{var componentName=getComponentNameFromFiber(workInProgress2)||"Component";didWarnAboutStateAssignmentForComponent.has(componentName)||(didWarnAboutStateAssignmentForComponent.add(componentName),error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",componentName))}classComponentUpdater.enqueueReplaceState(instance,instance.state,null)}}function mountClassInstance(workInProgress2,ctor,newProps,renderLanes2){checkClassInstance(workInProgress2,ctor,newProps);var instance=workInProgress2.stateNode;instance.props=newProps,instance.state=workInProgress2.memoizedState,instance.refs=emptyRefsObject,initializeUpdateQueue(workInProgress2);var contextType=ctor.contextType;if(typeof contextType=="object"&&contextType!==null)instance.context=readContext(contextType);else{var unmaskedContext=getUnmaskedContext(workInProgress2,ctor,!0);instance.context=getMaskedContext(workInProgress2,unmaskedContext)}{if(instance.state===newProps){var componentName=getComponentNameFromType(ctor)||"Component";didWarnAboutDirectlyAssigningPropsToState.has(componentName)||(didWarnAboutDirectlyAssigningPropsToState.add(componentName),error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",componentName))}workInProgress2.mode&StrictLegacyMode&&ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2,instance),ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2,instance)}instance.state=workInProgress2.memoizedState;var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps=="function"&&(applyDerivedStateFromProps(workInProgress2,ctor,getDerivedStateFromProps,newProps),instance.state=workInProgress2.memoizedState),typeof ctor.getDerivedStateFromProps!="function"&&typeof instance.getSnapshotBeforeUpdate!="function"&&(typeof instance.UNSAFE_componentWillMount=="function"||typeof instance.componentWillMount=="function")&&(callComponentWillMount(workInProgress2,instance),processUpdateQueue(workInProgress2,newProps,instance,renderLanes2),instance.state=workInProgress2.memoizedState),typeof instance.componentDidMount=="function"){var fiberFlags=Update;fiberFlags|=LayoutStatic,(workInProgress2.mode&StrictEffectsMode)!==NoMode&&(fiberFlags|=MountLayoutDev),workInProgress2.flags|=fiberFlags}}function resumeMountClassInstance(workInProgress2,ctor,newProps,renderLanes2){var instance=workInProgress2.stateNode,oldProps=workInProgress2.memoizedProps;instance.props=oldProps;var oldContext=instance.context,contextType=ctor.contextType,nextContext=emptyContextObject;if(typeof contextType=="object"&&contextType!==null)nextContext=readContext(contextType);else{var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress2,ctor,!0);nextContext=getMaskedContext(workInProgress2,nextLegacyUnmaskedContext)}var getDerivedStateFromProps=ctor.getDerivedStateFromProps,hasNewLifecycles=typeof getDerivedStateFromProps=="function"||typeof instance.getSnapshotBeforeUpdate=="function";!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps=="function"||typeof instance.componentWillReceiveProps=="function")&&(oldProps!==newProps||oldContext!==nextContext)&&callComponentWillReceiveProps(workInProgress2,instance,newProps,nextContext),resetHasForceUpdateBeforeProcessing();var oldState=workInProgress2.memoizedState,newState=instance.state=oldState;if(processUpdateQueue(workInProgress2,newProps,instance,renderLanes2),newState=workInProgress2.memoizedState,oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){if(typeof instance.componentDidMount=="function"){var fiberFlags=Update;fiberFlags|=LayoutStatic,(workInProgress2.mode&StrictEffectsMode)!==NoMode&&(fiberFlags|=MountLayoutDev),workInProgress2.flags|=fiberFlags}return!1}typeof getDerivedStateFromProps=="function"&&(applyDerivedStateFromProps(workInProgress2,ctor,getDerivedStateFromProps,newProps),newState=workInProgress2.memoizedState);var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress2,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount=="function"||typeof instance.componentWillMount=="function")&&(typeof instance.componentWillMount=="function"&&instance.componentWillMount(),typeof instance.UNSAFE_componentWillMount=="function"&&instance.UNSAFE_componentWillMount()),typeof instance.componentDidMount=="function"){var _fiberFlags=Update;_fiberFlags|=LayoutStatic,(workInProgress2.mode&StrictEffectsMode)!==NoMode&&(_fiberFlags|=MountLayoutDev),workInProgress2.flags|=_fiberFlags}}else{if(typeof instance.componentDidMount=="function"){var _fiberFlags2=Update;_fiberFlags2|=LayoutStatic,(workInProgress2.mode&StrictEffectsMode)!==NoMode&&(_fiberFlags2|=MountLayoutDev),workInProgress2.flags|=_fiberFlags2}workInProgress2.memoizedProps=newProps,workInProgress2.memoizedState=newState}return instance.props=newProps,instance.state=newState,instance.context=nextContext,shouldUpdate}function updateClassInstance(current2,workInProgress2,ctor,newProps,renderLanes2){var instance=workInProgress2.stateNode;cloneUpdateQueue(current2,workInProgress2);var unresolvedOldProps=workInProgress2.memoizedProps,oldProps=workInProgress2.type===workInProgress2.elementType?unresolvedOldProps:resolveDefaultProps(workInProgress2.type,unresolvedOldProps);instance.props=oldProps;var unresolvedNewProps=workInProgress2.pendingProps,oldContext=instance.context,contextType=ctor.contextType,nextContext=emptyContextObject;if(typeof contextType=="object"&&contextType!==null)nextContext=readContext(contextType);else{var nextUnmaskedContext=getUnmaskedContext(workInProgress2,ctor,!0);nextContext=getMaskedContext(workInProgress2,nextUnmaskedContext)}var getDerivedStateFromProps=ctor.getDerivedStateFromProps,hasNewLifecycles=typeof getDerivedStateFromProps=="function"||typeof instance.getSnapshotBeforeUpdate=="function";!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps=="function"||typeof instance.componentWillReceiveProps=="function")&&(unresolvedOldProps!==unresolvedNewProps||oldContext!==nextContext)&&callComponentWillReceiveProps(workInProgress2,instance,newProps,nextContext),resetHasForceUpdateBeforeProcessing();var oldState=workInProgress2.memoizedState,newState=instance.state=oldState;if(processUpdateQueue(workInProgress2,newProps,instance,renderLanes2),newState=workInProgress2.memoizedState,unresolvedOldProps===unresolvedNewProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()&&!enableLazyContextPropagation)return typeof instance.componentDidUpdate=="function"&&(unresolvedOldProps!==current2.memoizedProps||oldState!==current2.memoizedState)&&(workInProgress2.flags|=Update),typeof instance.getSnapshotBeforeUpdate=="function"&&(unresolvedOldProps!==current2.memoizedProps||oldState!==current2.memoizedState)&&(workInProgress2.flags|=Snapshot),!1;typeof getDerivedStateFromProps=="function"&&(applyDerivedStateFromProps(workInProgress2,ctor,getDerivedStateFromProps,newProps),newState=workInProgress2.memoizedState);var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress2,ctor,oldProps,newProps,oldState,newState,nextContext)||enableLazyContextPropagation;return shouldUpdate?(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate=="function"||typeof instance.componentWillUpdate=="function")&&(typeof instance.componentWillUpdate=="function"&&instance.componentWillUpdate(newProps,newState,nextContext),typeof instance.UNSAFE_componentWillUpdate=="function"&&instance.UNSAFE_componentWillUpdate(newProps,newState,nextContext)),typeof instance.componentDidUpdate=="function"&&(workInProgress2.flags|=Update),typeof instance.getSnapshotBeforeUpdate=="function"&&(workInProgress2.flags|=Snapshot)):(typeof instance.componentDidUpdate=="function"&&(unresolvedOldProps!==current2.memoizedProps||oldState!==current2.memoizedState)&&(workInProgress2.flags|=Update),typeof instance.getSnapshotBeforeUpdate=="function"&&(unresolvedOldProps!==current2.memoizedProps||oldState!==current2.memoizedState)&&(workInProgress2.flags|=Snapshot),workInProgress2.memoizedProps=newProps,workInProgress2.memoizedState=newState),instance.props=newProps,instance.state=newState,instance.context=nextContext,shouldUpdate}var didWarnAboutMaps,didWarnAboutGenerators,didWarnAboutStringRefs,ownerHasKeyUseWarning,ownerHasFunctionTypeWarning,warnForMissingKey=function(child,returnFiber){};didWarnAboutMaps=!1,didWarnAboutGenerators=!1,didWarnAboutStringRefs={},ownerHasKeyUseWarning={},ownerHasFunctionTypeWarning={},warnForMissingKey=function(child,returnFiber){if(!(child===null||typeof child!="object")&&!(!child._store||child._store.validated||child.key!=null)){if(typeof child._store!="object")throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");child._store.validated=!0;var componentName=getComponentNameFromFiber(returnFiber)||"Component";ownerHasKeyUseWarning[componentName]||(ownerHasKeyUseWarning[componentName]=!0,error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'))}};function coerceRef(returnFiber,current2,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!="function"&&typeof mixedRef!="object"){if((returnFiber.mode&StrictLegacyMode||warnAboutStringRefs)&&!(element._owner&&element._self&&element._owner.stateNode!==element._self)){var componentName=getComponentNameFromFiber(returnFiber)||"Component";didWarnAboutStringRefs[componentName]||(error('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',mixedRef),didWarnAboutStringRefs[componentName]=!0)}if(element._owner){var owner=element._owner,inst;if(owner){var ownerFiber=owner;if(ownerFiber.tag!==ClassComponent)throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");inst=ownerFiber.stateNode}if(!inst)throw new Error("Missing owner for string ref "+mixedRef+". This error is likely caused by a bug in React. Please file an issue.");var resolvedInst=inst;checkPropStringCoercion(mixedRef,"ref");var stringRef=""+mixedRef;if(current2!==null&&current2.ref!==null&&typeof current2.ref=="function"&&current2.ref._stringRef===stringRef)return current2.ref;var ref=function(value){var refs=resolvedInst.refs;refs===emptyRefsObject&&(refs=resolvedInst.refs={}),value===null?delete refs[stringRef]:refs[stringRef]=value};return ref._stringRef=stringRef,ref}else{if(typeof mixedRef!="string")throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");if(!element._owner)throw new Error("Element ref was specified as a string ("+mixedRef+`) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`)}}return mixedRef}function throwOnInvalidObjectType(returnFiber,newChild){var childString=Object.prototype.toString.call(newChild);throw new Error("Objects are not valid as a React child (found: "+(childString==="[object Object]"?"object with keys {"+Object.keys(newChild).join(", ")+"}":childString)+"). If you meant to render a collection of children, use an array instead.")}function warnOnFunctionType(returnFiber){{var componentName=getComponentNameFromFiber(returnFiber)||"Component";if(ownerHasFunctionTypeWarning[componentName])return;ownerHasFunctionTypeWarning[componentName]=!0,error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.")}}function resolveLazy(lazyType){var payload=lazyType._payload,init=lazyType._init;return init(payload)}function ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(shouldTrackSideEffects){var deletions=returnFiber.deletions;deletions===null?(returnFiber.deletions=[childToDelete],returnFiber.flags|=ChildDeletion):deletions.push(childToDelete)}}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects)return null;for(var childToDelete=currentFirstChild;childToDelete!==null;)deleteChild(returnFiber,childToDelete),childToDelete=childToDelete.sibling;return null}function mapRemainingChildren(returnFiber,currentFirstChild){for(var existingChildren=new Map,existingChild=currentFirstChild;existingChild!==null;)existingChild.key!==null?existingChildren.set(existingChild.key,existingChild):existingChildren.set(existingChild.index,existingChild),existingChild=existingChild.sibling;return existingChildren}function useFiber2(fiber,pendingProps){var clone=createWorkInProgress(fiber,pendingProps);return clone.index=0,clone.sibling=null,clone}function placeChild(newFiber,lastPlacedIndex,newIndex){if(newFiber.index=newIndex,!shouldTrackSideEffects)return newFiber.flags|=Forked,lastPlacedIndex;var current2=newFiber.alternate;if(current2!==null){var oldIndex=current2.index;return oldIndex<lastPlacedIndex?(newFiber.flags|=Placement,lastPlacedIndex):oldIndex}else return newFiber.flags|=Placement,lastPlacedIndex}function placeSingleChild(newFiber){return shouldTrackSideEffects&&newFiber.alternate===null&&(newFiber.flags|=Placement),newFiber}function updateTextNode(returnFiber,current2,textContent,lanes){if(current2===null||current2.tag!==HostText){var created=createFiberFromText(textContent,returnFiber.mode,lanes);return created.return=returnFiber,created}else{var existing=useFiber2(current2,textContent);return existing.return=returnFiber,existing}}function updateElement(returnFiber,current2,element,lanes){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE)return updateFragment2(returnFiber,current2,element.props.children,lanes,element.key);if(current2!==null&&(current2.elementType===elementType||isCompatibleFamilyForHotReloading(current2,element)||typeof elementType=="object"&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===current2.type)){var existing=useFiber2(current2,element.props);return existing.ref=coerceRef(returnFiber,current2,element),existing.return=returnFiber,existing._debugSource=element._source,existing._debugOwner=element._owner,existing}var created=createFiberFromElement(element,returnFiber.mode,lanes);return created.ref=coerceRef(returnFiber,current2,element),created.return=returnFiber,created}function updatePortal(returnFiber,current2,portal,lanes){if(current2===null||current2.tag!==HostPortal||current2.stateNode.containerInfo!==portal.containerInfo||current2.stateNode.implementation!==portal.implementation){var created=createFiberFromPortal(portal,returnFiber.mode,lanes);return created.return=returnFiber,created}else{var existing=useFiber2(current2,portal.children||[]);return existing.return=returnFiber,existing}}function updateFragment2(returnFiber,current2,fragment2,lanes,key){if(current2===null||current2.tag!==Fragment){var created=createFiberFromFragment(fragment2,returnFiber.mode,lanes,key);return created.return=returnFiber,created}else{var existing=useFiber2(current2,fragment2);return existing.return=returnFiber,existing}}function createChild(returnFiber,newChild,lanes){if(typeof newChild=="string"&&newChild!==""||typeof newChild=="number"){var created=createFiberFromText(""+newChild,returnFiber.mode,lanes);return created.return=returnFiber,created}if(typeof newChild=="object"&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,lanes);return _created.ref=coerceRef(returnFiber,null,newChild),_created.return=returnFiber,_created}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,lanes);return _created2.return=returnFiber,_created2}case REACT_LAZY_TYPE:{var payload=newChild._payload,init=newChild._init;return createChild(returnFiber,init(payload),lanes)}}if(isArray(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,lanes,null);return _created3.return=returnFiber,_created3}throwOnInvalidObjectType(returnFiber,newChild)}return typeof newChild=="function"&&warnOnFunctionType(returnFiber),null}function updateSlot(returnFiber,oldFiber,newChild,lanes){var key=oldFiber!==null?oldFiber.key:null;if(typeof newChild=="string"&&newChild!==""||typeof newChild=="number")return key!==null?null:updateTextNode(returnFiber,oldFiber,""+newChild,lanes);if(typeof newChild=="object"&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return newChild.key===key?updateElement(returnFiber,oldFiber,newChild,lanes):null;case REACT_PORTAL_TYPE:return newChild.key===key?updatePortal(returnFiber,oldFiber,newChild,lanes):null;case REACT_LAZY_TYPE:{var payload=newChild._payload,init=newChild._init;return updateSlot(returnFiber,oldFiber,init(payload),lanes)}}if(isArray(newChild)||getIteratorFn(newChild))return key!==null?null:updateFragment2(returnFiber,oldFiber,newChild,lanes,null);throwOnInvalidObjectType(returnFiber,newChild)}return typeof newChild=="function"&&warnOnFunctionType(returnFiber),null}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes){if(typeof newChild=="string"&&newChild!==""||typeof newChild=="number"){var matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,""+newChild,lanes)}if(typeof newChild=="object"&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateElement(returnFiber,_matchedFiber,newChild,lanes)}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,lanes)}case REACT_LAZY_TYPE:var payload=newChild._payload,init=newChild._init;return updateFromMap(existingChildren,returnFiber,newIdx,init(payload),lanes)}if(isArray(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment2(returnFiber,_matchedFiber3,newChild,lanes,null)}throwOnInvalidObjectType(returnFiber,newChild)}return typeof newChild=="function"&&warnOnFunctionType(returnFiber),null}function warnOnInvalidKey(child,knownKeys,returnFiber){{if(typeof child!="object"||child===null)return knownKeys;switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child,returnFiber);var key=child.key;if(typeof key!="string")break;if(knownKeys===null){knownKeys=new Set,knownKeys.add(key);break}if(!knownKeys.has(key)){knownKeys.add(key);break}error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.",key);break;case REACT_LAZY_TYPE:var payload=child._payload,init=child._init;warnOnInvalidKey(init(payload),knownKeys,returnFiber);break}}return knownKeys}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes){for(var knownKeys=null,i2=0;i2<newChildren.length;i2++){var child=newChildren[i2];knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber)}for(var resultingFirstChild=null,previousNewFiber=null,oldFiber=currentFirstChild,lastPlacedIndex=0,newIdx=0,nextOldFiber=null;oldFiber!==null&&newIdx<newChildren.length;newIdx++){oldFiber.index>newIdx?(nextOldFiber=oldFiber,oldFiber=null):nextOldFiber=oldFiber.sibling;var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],lanes);if(newFiber===null){oldFiber===null&&(oldFiber=nextOldFiber);break}shouldTrackSideEffects&&oldFiber&&newFiber.alternate===null&&deleteChild(returnFiber,oldFiber),lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx),previousNewFiber===null?resultingFirstChild=newFiber:previousNewFiber.sibling=newFiber,previousNewFiber=newFiber,oldFiber=nextOldFiber}if(newIdx===newChildren.length){if(deleteRemainingChildren(returnFiber,oldFiber),getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks)}return resultingFirstChild}if(oldFiber===null){for(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],lanes);_newFiber!==null&&(lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx),previousNewFiber===null?resultingFirstChild=_newFiber:previousNewFiber.sibling=_newFiber,previousNewFiber=_newFiber)}if(getIsHydrating()){var _numberOfForks=newIdx;pushTreeFork(returnFiber,_numberOfForks)}return resultingFirstChild}for(var existingChildren=mapRemainingChildren(returnFiber,oldFiber);newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],lanes);_newFiber2!==null&&(shouldTrackSideEffects&&_newFiber2.alternate!==null&&existingChildren.delete(_newFiber2.key===null?newIdx:_newFiber2.key),lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx),previousNewFiber===null?resultingFirstChild=_newFiber2:previousNewFiber.sibling=_newFiber2,previousNewFiber=_newFiber2)}if(shouldTrackSideEffects&&existingChildren.forEach(function(child2){return deleteChild(returnFiber,child2)}),getIsHydrating()){var _numberOfForks2=newIdx;pushTreeFork(returnFiber,_numberOfForks2)}return resultingFirstChild}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,lanes){var iteratorFn=getIteratorFn(newChildrenIterable);if(typeof iteratorFn!="function")throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");{typeof Symbol=="function"&&newChildrenIterable[Symbol.toStringTag]==="Generator"&&(didWarnAboutGenerators||error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."),didWarnAboutGenerators=!0),newChildrenIterable.entries===iteratorFn&&(didWarnAboutMaps||error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."),didWarnAboutMaps=!0);var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren)for(var knownKeys=null,_step=_newChildren.next();!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber)}}var newChildren=iteratorFn.call(newChildrenIterable);if(newChildren==null)throw new Error("An iterable object provided no iterator.");for(var resultingFirstChild=null,previousNewFiber=null,oldFiber=currentFirstChild,lastPlacedIndex=0,newIdx=0,nextOldFiber=null,step=newChildren.next();oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){oldFiber.index>newIdx?(nextOldFiber=oldFiber,oldFiber=null):nextOldFiber=oldFiber.sibling;var newFiber=updateSlot(returnFiber,oldFiber,step.value,lanes);if(newFiber===null){oldFiber===null&&(oldFiber=nextOldFiber);break}shouldTrackSideEffects&&oldFiber&&newFiber.alternate===null&&deleteChild(returnFiber,oldFiber),lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx),previousNewFiber===null?resultingFirstChild=newFiber:previousNewFiber.sibling=newFiber,previousNewFiber=newFiber,oldFiber=nextOldFiber}if(step.done){if(deleteRemainingChildren(returnFiber,oldFiber),getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks)}return resultingFirstChild}if(oldFiber===null){for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,lanes);_newFiber3!==null&&(lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx),previousNewFiber===null?resultingFirstChild=_newFiber3:previousNewFiber.sibling=_newFiber3,previousNewFiber=_newFiber3)}if(getIsHydrating()){var _numberOfForks3=newIdx;pushTreeFork(returnFiber,_numberOfForks3)}return resultingFirstChild}for(var existingChildren=mapRemainingChildren(returnFiber,oldFiber);!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,lanes);_newFiber4!==null&&(shouldTrackSideEffects&&_newFiber4.alternate!==null&&existingChildren.delete(_newFiber4.key===null?newIdx:_newFiber4.key),lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx),previousNewFiber===null?resultingFirstChild=_newFiber4:previousNewFiber.sibling=_newFiber4,previousNewFiber=_newFiber4)}if(shouldTrackSideEffects&&existingChildren.forEach(function(child2){return deleteChild(returnFiber,child2)}),getIsHydrating()){var _numberOfForks4=newIdx;pushTreeFork(returnFiber,_numberOfForks4)}return resultingFirstChild}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,lanes){if(currentFirstChild!==null&&currentFirstChild.tag===HostText){deleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber2(currentFirstChild,textContent);return existing.return=returnFiber,existing}deleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,lanes);return created.return=returnFiber,created}function reconcileSingleElement(returnFiber,currentFirstChild,element,lanes){for(var key=element.key,child=currentFirstChild;child!==null;){if(child.key===key){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){if(child.tag===Fragment){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber2(child,element.props.children);return existing.return=returnFiber,existing._debugSource=element._source,existing._debugOwner=element._owner,existing}}else if(child.elementType===elementType||isCompatibleFamilyForHotReloading(child,element)||typeof elementType=="object"&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===child.type){deleteRemainingChildren(returnFiber,child.sibling);var _existing=useFiber2(child,element.props);return _existing.ref=coerceRef(returnFiber,child,element),_existing.return=returnFiber,_existing._debugSource=element._source,_existing._debugOwner=element._owner,_existing}deleteRemainingChildren(returnFiber,child);break}else deleteChild(returnFiber,child);child=child.sibling}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,lanes,element.key);return created.return=returnFiber,created}else{var _created4=createFiberFromElement(element,returnFiber.mode,lanes);return _created4.ref=coerceRef(returnFiber,currentFirstChild,element),_created4.return=returnFiber,_created4}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,lanes){for(var key=portal.key,child=currentFirstChild;child!==null;){if(child.key===key)if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber2(child,portal.children||[]);return existing.return=returnFiber,existing}else{deleteRemainingChildren(returnFiber,child);break}else deleteChild(returnFiber,child);child=child.sibling}var created=createFiberFromPortal(portal,returnFiber.mode,lanes);return created.return=returnFiber,created}function reconcileChildFibers2(returnFiber,currentFirstChild,newChild,lanes){var isUnkeyedTopLevelFragment=typeof newChild=="object"&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment&&(newChild=newChild.props.children),typeof newChild=="object"&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,lanes));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,lanes));case REACT_LAZY_TYPE:var payload=newChild._payload,init=newChild._init;return reconcileChildFibers2(returnFiber,currentFirstChild,init(payload),lanes)}if(isArray(newChild))return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,lanes);if(getIteratorFn(newChild))return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes);throwOnInvalidObjectType(returnFiber,newChild)}return typeof newChild=="string"&&newChild!==""||typeof newChild=="number"?placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,""+newChild,lanes)):(typeof newChild=="function"&&warnOnFunctionType(returnFiber),deleteRemainingChildren(returnFiber,currentFirstChild))}return reconcileChildFibers2}var reconcileChildFibers=ChildReconciler(!0),mountChildFibers=ChildReconciler(!1);function cloneChildFibers(current2,workInProgress2){if(current2!==null&&workInProgress2.child!==current2.child)throw new Error("Resuming work not yet implemented.");if(workInProgress2.child!==null){var currentChild=workInProgress2.child,newChild=createWorkInProgress(currentChild,currentChild.pendingProps);for(workInProgress2.child=newChild,newChild.return=workInProgress2;currentChild.sibling!==null;)currentChild=currentChild.sibling,newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps),newChild.return=workInProgress2;newChild.sibling=null}}function resetChildFibers(workInProgress2,lanes){for(var child=workInProgress2.child;child!==null;)resetWorkInProgress(child,lanes),child=child.sibling}var NO_CONTEXT={},contextStackCursor$1=createCursor(NO_CONTEXT),contextFiberStackCursor=createCursor(NO_CONTEXT),rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c2){if(c2===NO_CONTEXT)throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");return c2}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance}function pushHostContainer(fiber,nextRootInstance){push(rootInstanceStackCursor,nextRootInstance,fiber),push(contextFiberStackCursor,fiber,fiber),push(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);pop(contextStackCursor$1,fiber),push(contextStackCursor$1,nextRootContext,fiber)}function popHostContainer(fiber){pop(contextStackCursor$1,fiber),pop(contextFiberStackCursor,fiber),pop(rootInstanceStackCursor,fiber)}function getHostContext(){var context2=requiredContext(contextStackCursor$1.current);return context2}function pushHostContext(fiber){requiredContext(rootInstanceStackCursor.current);var context2=requiredContext(contextStackCursor$1.current),nextContext=getChildHostContext(context2,fiber.type);context2!==nextContext&&(push(contextFiberStackCursor,fiber,fiber),push(contextStackCursor$1,nextContext,fiber))}function popHostContext(fiber){contextFiberStackCursor.current===fiber&&(pop(contextStackCursor$1,fiber),pop(contextFiberStackCursor,fiber))}var DefaultSuspenseContext=0,SubtreeSuspenseContextMask=1,InvisibleParentSuspenseContext=1,ForceSuspenseFallback=2,suspenseStackCursor=createCursor(DefaultSuspenseContext);function hasSuspenseContext(parentContext,flag){return(parentContext&flag)!==0}function setDefaultShallowSuspenseContext(parentContext){return parentContext&SubtreeSuspenseContextMask}function setShallowSuspenseContext(parentContext,shallowContext){return parentContext&SubtreeSuspenseContextMask|shallowContext}function addSubtreeSuspenseContext(parentContext,subtreeContext){return parentContext|subtreeContext}function pushSuspenseContext(fiber,newContext){push(suspenseStackCursor,newContext,fiber)}function popSuspenseContext(fiber){pop(suspenseStackCursor,fiber)}function shouldCaptureSuspense(workInProgress2,hasInvisibleParent){var nextState=workInProgress2.memoizedState;return nextState!==null?nextState.dehydrated!==null:(workInProgress2.memoizedProps,!0)}function findFirstSuspended(row){for(var node=row;node!==null;){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){var dehydrated=state.dehydrated;if(dehydrated===null||isSuspenseInstancePending(dehydrated)||isSuspenseInstanceFallback(dehydrated))return node}}else if(node.tag===SuspenseListComponent&&node.memoizedProps.revealOrder!==void 0){var didSuspend=(node.flags&DidCapture)!==NoFlags;if(didSuspend)return node}else if(node.child!==null){node.child.return=node,node=node.child;continue}if(node===row)return null;for(;node.sibling===null;){if(node.return===null||node.return===row)return null;node=node.return}node.sibling.return=node.return,node=node.sibling}return null}var NoFlags$1=0,HasEffect=1,Insertion=2,Layout=4,Passive$1=8,workInProgressSources=[];function resetWorkInProgressVersions(){for(var i2=0;i2<workInProgressSources.length;i2++){var mutableSource=workInProgressSources[i2];mutableSource._workInProgressVersionPrimary=null}workInProgressSources.length=0}function registerMutableSourceForHydration(root2,mutableSource){var getVersion=mutableSource._getVersion,version2=getVersion(mutableSource._source);root2.mutableSourceEagerHydrationData==null?root2.mutableSourceEagerHydrationData=[mutableSource,version2]:root2.mutableSourceEagerHydrationData.push(mutableSource,version2)}var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentBatchConfig$2=ReactSharedInternals.ReactCurrentBatchConfig,didWarnAboutMismatchedHooksForComponent,didWarnUncachedGetSnapshot;didWarnAboutMismatchedHooksForComponent=new Set;var renderLanes=NoLanes,currentlyRenderingFiber$1=null,currentHook=null,workInProgressHook=null,didScheduleRenderPhaseUpdate=!1,didScheduleRenderPhaseUpdateDuringThisPass=!1,localIdCounter=0,globalClientIdCounter=0,RE_RENDER_LIMIT=25,currentHookNameInDev=null,hookTypesDev=null,hookTypesUpdateIndexDev=-1,ignorePreviousDependencies=!1;function mountHookTypesDev(){{var hookName=currentHookNameInDev;hookTypesDev===null?hookTypesDev=[hookName]:hookTypesDev.push(hookName)}}function updateHookTypesDev(){{var hookName=currentHookNameInDev;hookTypesDev!==null&&(hookTypesUpdateIndexDev++,hookTypesDev[hookTypesUpdateIndexDev]!==hookName&&warnOnHookMismatchInDev(hookName))}}function checkDepsAreArrayDev(deps){deps!=null&&!isArray(deps)&&error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",currentHookNameInDev,typeof deps)}function warnOnHookMismatchInDev(currentHookName){{var componentName=getComponentNameFromFiber(currentlyRenderingFiber$1);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)&&(didWarnAboutMismatchedHooksForComponent.add(componentName),hookTypesDev!==null)){for(var table="",secondColumnStart=30,i2=0;i2<=hookTypesUpdateIndexDev;i2++){for(var oldHookName=hookTypesDev[i2],newHookName=i2===hookTypesUpdateIndexDev?currentHookName:oldHookName,row=i2+1+". "+oldHookName;row.length<secondColumnStart;)row+=" ";row+=newHookName+`
`,table+=row}error(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`,componentName,table)}}}function throwInvalidHookError(){throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`)}function areHookInputsEqual(nextDeps,prevDeps){if(ignorePreviousDependencies)return!1;if(prevDeps===null)return error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",currentHookNameInDev),!1;nextDeps.length!==prevDeps.length&&error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`,currentHookNameInDev,"["+prevDeps.join(", ")+"]","["+nextDeps.join(", ")+"]");for(var i2=0;i2<prevDeps.length&&i2<nextDeps.length;i2++)if(!objectIs(nextDeps[i2],prevDeps[i2]))return!1;return!0}function renderWithHooks(current2,workInProgress2,Component,props,secondArg,nextRenderLanes){renderLanes=nextRenderLanes,currentlyRenderingFiber$1=workInProgress2,hookTypesDev=current2!==null?current2._debugHookTypes:null,hookTypesUpdateIndexDev=-1,ignorePreviousDependencies=current2!==null&&current2.type!==workInProgress2.type,workInProgress2.memoizedState=null,workInProgress2.updateQueue=null,workInProgress2.lanes=NoLanes,current2!==null&&current2.memoizedState!==null?ReactCurrentDispatcher$1.current=HooksDispatcherOnUpdateInDEV:hookTypesDev!==null?ReactCurrentDispatcher$1.current=HooksDispatcherOnMountWithHookTypesInDEV:ReactCurrentDispatcher$1.current=HooksDispatcherOnMountInDEV;var children=Component(props,secondArg);if(didScheduleRenderPhaseUpdateDuringThisPass){var numberOfReRenders=0;do{if(didScheduleRenderPhaseUpdateDuringThisPass=!1,localIdCounter=0,numberOfReRenders>=RE_RENDER_LIMIT)throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");numberOfReRenders+=1,ignorePreviousDependencies=!1,currentHook=null,workInProgressHook=null,workInProgress2.updateQueue=null,hookTypesUpdateIndexDev=-1,ReactCurrentDispatcher$1.current=HooksDispatcherOnRerenderInDEV,children=Component(props,secondArg)}while(didScheduleRenderPhaseUpdateDuringThisPass)}ReactCurrentDispatcher$1.current=ContextOnlyDispatcher,workInProgress2._debugHookTypes=hookTypesDev;var didRenderTooFewHooks=currentHook!==null&&currentHook.next!==null;if(renderLanes=NoLanes,currentlyRenderingFiber$1=null,currentHook=null,workInProgressHook=null,currentHookNameInDev=null,hookTypesDev=null,hookTypesUpdateIndexDev=-1,current2!==null&&(current2.flags&StaticMask)!==(workInProgress2.flags&StaticMask)&&(current2.mode&ConcurrentMode)!==NoMode&&error("Internal React error: Expected static flag was missing. Please notify the React team."),didScheduleRenderPhaseUpdate=!1,didRenderTooFewHooks)throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");return children}function checkDidRenderIdHook(){var didRenderIdHook=localIdCounter!==0;return localIdCounter=0,didRenderIdHook}function bailoutHooks(current2,workInProgress2,lanes){workInProgress2.updateQueue=current2.updateQueue,(workInProgress2.mode&StrictEffectsMode)!==NoMode?workInProgress2.flags&=~(MountPassiveDev|MountLayoutDev|Passive|Update):workInProgress2.flags&=~(Passive|Update),current2.lanes=removeLanes(current2.lanes,lanes)}function resetHooksAfterThrow(){if(ReactCurrentDispatcher$1.current=ContextOnlyDispatcher,didScheduleRenderPhaseUpdate){for(var hook=currentlyRenderingFiber$1.memoizedState;hook!==null;){var queue=hook.queue;queue!==null&&(queue.pending=null),hook=hook.next}didScheduleRenderPhaseUpdate=!1}renderLanes=NoLanes,currentlyRenderingFiber$1=null,currentHook=null,workInProgressHook=null,hookTypesDev=null,hookTypesUpdateIndexDev=-1,currentHookNameInDev=null,isUpdatingOpaqueValueInRenderPhase=!1,didScheduleRenderPhaseUpdateDuringThisPass=!1,localIdCounter=0}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return workInProgressHook===null?currentlyRenderingFiber$1.memoizedState=workInProgressHook=hook:workInProgressHook=workInProgressHook.next=hook,workInProgressHook}function updateWorkInProgressHook(){var nextCurrentHook;if(currentHook===null){var current2=currentlyRenderingFiber$1.alternate;current2!==null?nextCurrentHook=current2.memoizedState:nextCurrentHook=null}else nextCurrentHook=currentHook.next;var nextWorkInProgressHook;if(workInProgressHook===null?nextWorkInProgressHook=currentlyRenderingFiber$1.memoizedState:nextWorkInProgressHook=workInProgressHook.next,nextWorkInProgressHook!==null)workInProgressHook=nextWorkInProgressHook,nextWorkInProgressHook=workInProgressHook.next,currentHook=nextCurrentHook;else{if(nextCurrentHook===null)throw new Error("Rendered more hooks than during the previous render.");currentHook=nextCurrentHook;var newHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};workInProgressHook===null?currentlyRenderingFiber$1.memoizedState=workInProgressHook=newHook:workInProgressHook=workInProgressHook.next=newHook}return workInProgressHook}function createFunctionComponentUpdateQueue(){return{lastEffect:null,stores:null}}function basicStateReducer(state,action){return typeof action=="function"?action(state):action}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook(),initialState;init!==void 0?initialState=init(initialArg):initialState=initialArg,hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchReducerAction.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch]}function updateReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook(),queue=hook.queue;if(queue===null)throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");queue.lastRenderedReducer=reducer;var current2=currentHook,baseQueue=current2.baseQueue,pendingQueue=queue.pending;if(pendingQueue!==null){if(baseQueue!==null){var baseFirst=baseQueue.next,pendingFirst=pendingQueue.next;baseQueue.next=pendingFirst,pendingQueue.next=baseFirst}current2.baseQueue!==baseQueue&&error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."),current2.baseQueue=baseQueue=pendingQueue,queue.pending=null}if(baseQueue!==null){var first=baseQueue.next,newState=current2.baseState,newBaseState=null,newBaseQueueFirst=null,newBaseQueueLast=null,update=first;do{var updateLane=update.lane;if(isSubsetOfLanes(renderLanes,updateLane)){if(newBaseQueueLast!==null){var _clone={lane:NoLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};newBaseQueueLast=newBaseQueueLast.next=_clone}if(update.hasEagerState)newState=update.eagerState;else{var action=update.action;newState=reducer(newState,action)}}else{var clone={lane:updateLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};newBaseQueueLast===null?(newBaseQueueFirst=newBaseQueueLast=clone,newBaseState=newState):newBaseQueueLast=newBaseQueueLast.next=clone,currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,updateLane),markSkippedUpdateLanes(updateLane)}update=update.next}while(update!==null&&update!==first);newBaseQueueLast===null?newBaseState=newState:newBaseQueueLast.next=newBaseQueueFirst,objectIs(newState,hook.memoizedState)||markWorkInProgressReceivedUpdate(),hook.memoizedState=newState,hook.baseState=newBaseState,hook.baseQueue=newBaseQueueLast,queue.lastRenderedState=newState}var lastInterleaved=queue.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{var interleavedLane=interleaved.lane;currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,interleavedLane),markSkippedUpdateLanes(interleavedLane),interleaved=interleaved.next}while(interleaved!==lastInterleaved)}else baseQueue===null&&(queue.lanes=NoLanes);var dispatch=queue.dispatch;return[hook.memoizedState,dispatch]}function rerenderReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook(),queue=hook.queue;if(queue===null)throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");queue.lastRenderedReducer=reducer;var dispatch=queue.dispatch,lastRenderPhaseUpdate=queue.pending,newState=hook.memoizedState;if(lastRenderPhaseUpdate!==null){queue.pending=null;var firstRenderPhaseUpdate=lastRenderPhaseUpdate.next,update=firstRenderPhaseUpdate;do{var action=update.action;newState=reducer(newState,action),update=update.next}while(update!==firstRenderPhaseUpdate);objectIs(newState,hook.memoizedState)||markWorkInProgressReceivedUpdate(),hook.memoizedState=newState,hook.baseQueue===null&&(hook.baseState=newState),queue.lastRenderedState=newState}return[newState,dispatch]}function mountMutableSource(source,getSnapshot,subscribe){}function updateMutableSource(source,getSnapshot,subscribe){}function mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1,hook=mountWorkInProgressHook(),nextSnapshot,isHydrating2=getIsHydrating();if(isHydrating2){if(getServerSnapshot===void 0)throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");nextSnapshot=getServerSnapshot(),didWarnUncachedGetSnapshot||nextSnapshot!==getServerSnapshot()&&(error("The result of getServerSnapshot should be cached to avoid an infinite loop"),didWarnUncachedGetSnapshot=!0)}else{if(nextSnapshot=getSnapshot(),!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();objectIs(nextSnapshot,cachedSnapshot)||(error("The result of getSnapshot should be cached to avoid an infinite loop"),didWarnUncachedGetSnapshot=!0)}var root2=getWorkInProgressRoot();if(root2===null)throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");includesBlockingLane(root2,renderLanes)||pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot)}hook.memoizedState=nextSnapshot;var inst={value:nextSnapshot,getSnapshot};return hook.queue=inst,mountEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]),fiber.flags|=Passive,pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),void 0,null),nextSnapshot}function updateSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1,hook=updateWorkInProgressHook(),nextSnapshot=getSnapshot();if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();objectIs(nextSnapshot,cachedSnapshot)||(error("The result of getSnapshot should be cached to avoid an infinite loop"),didWarnUncachedGetSnapshot=!0)}var prevSnapshot=hook.memoizedState,snapshotChanged=!objectIs(prevSnapshot,nextSnapshot);snapshotChanged&&(hook.memoizedState=nextSnapshot,markWorkInProgressReceivedUpdate());var inst=hook.queue;if(updateEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]),inst.getSnapshot!==getSnapshot||snapshotChanged||workInProgressHook!==null&&workInProgressHook.memoizedState.tag&HasEffect){fiber.flags|=Passive,pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),void 0,null);var root2=getWorkInProgressRoot();if(root2===null)throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");includesBlockingLane(root2,renderLanes)||pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot)}return nextSnapshot}function pushStoreConsistencyCheck(fiber,getSnapshot,renderedSnapshot){fiber.flags|=StoreConsistency;var check={getSnapshot,value:renderedSnapshot},componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null)componentUpdateQueue=createFunctionComponentUpdateQueue(),currentlyRenderingFiber$1.updateQueue=componentUpdateQueue,componentUpdateQueue.stores=[check];else{var stores=componentUpdateQueue.stores;stores===null?componentUpdateQueue.stores=[check]:stores.push(check)}}function updateStoreInstance(fiber,inst,nextSnapshot,getSnapshot){inst.value=nextSnapshot,inst.getSnapshot=getSnapshot,checkIfSnapshotChanged(inst)&&forceStoreRerender(fiber)}function subscribeToStore(fiber,inst,subscribe){var handleStoreChange=function(){checkIfSnapshotChanged(inst)&&forceStoreRerender(fiber)};return subscribe(handleStoreChange)}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot,prevValue=inst.value;try{var nextValue=latestGetSnapshot();return!objectIs(prevValue,nextValue)}catch{return!0}}function forceStoreRerender(fiber){var root2=enqueueConcurrentRenderForLane(fiber,SyncLane);root2!==null&&scheduleUpdateOnFiber(root2,fiber,SyncLane,NoTimestamp)}function mountState(initialState){var hook=mountWorkInProgressHook();typeof initialState=="function"&&(initialState=initialState()),hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchSetState.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch]}function updateState(initialState){return updateReducer(basicStateReducer)}function rerenderState(initialState){return rerenderReducer(basicStateReducer)}function pushEffect(tag,create2,destroy,deps){var effect={tag,create:create2,destroy,deps,next:null},componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null)componentUpdateQueue=createFunctionComponentUpdateQueue(),currentlyRenderingFiber$1.updateQueue=componentUpdateQueue,componentUpdateQueue.lastEffect=effect.next=effect;else{var lastEffect=componentUpdateQueue.lastEffect;if(lastEffect===null)componentUpdateQueue.lastEffect=effect.next=effect;else{var firstEffect=lastEffect.next;lastEffect.next=effect,effect.next=firstEffect,componentUpdateQueue.lastEffect=effect}}return effect}function mountRef(initialValue){var hook=mountWorkInProgressHook();{var _ref2={current:initialValue};return hook.memoizedState=_ref2,_ref2}}function updateRef(initialValue){var hook=updateWorkInProgressHook();return hook.memoizedState}function mountEffectImpl(fiberFlags,hookFlags,create2,deps){var hook=mountWorkInProgressHook(),nextDeps=deps===void 0?null:deps;currentlyRenderingFiber$1.flags|=fiberFlags,hook.memoizedState=pushEffect(HasEffect|hookFlags,create2,void 0,nextDeps)}function updateEffectImpl(fiberFlags,hookFlags,create2,deps){var hook=updateWorkInProgressHook(),nextDeps=deps===void 0?null:deps,destroy=void 0;if(currentHook!==null){var prevEffect=currentHook.memoizedState;if(destroy=prevEffect.destroy,nextDeps!==null){var prevDeps=prevEffect.deps;if(areHookInputsEqual(nextDeps,prevDeps)){hook.memoizedState=pushEffect(hookFlags,create2,destroy,nextDeps);return}}}currentlyRenderingFiber$1.flags|=fiberFlags,hook.memoizedState=pushEffect(HasEffect|hookFlags,create2,destroy,nextDeps)}function mountEffect(create2,deps){return(currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode?mountEffectImpl(MountPassiveDev|Passive|PassiveStatic,Passive$1,create2,deps):mountEffectImpl(Passive|PassiveStatic,Passive$1,create2,deps)}function updateEffect(create2,deps){return updateEffectImpl(Passive,Passive$1,create2,deps)}function mountInsertionEffect(create2,deps){return mountEffectImpl(Update,Insertion,create2,deps)}function updateInsertionEffect(create2,deps){return updateEffectImpl(Update,Insertion,create2,deps)}function mountLayoutEffect(create2,deps){var fiberFlags=Update;return fiberFlags|=LayoutStatic,(currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode&&(fiberFlags|=MountLayoutDev),mountEffectImpl(fiberFlags,Layout,create2,deps)}function updateLayoutEffect(create2,deps){return updateEffectImpl(Update,Layout,create2,deps)}function imperativeHandleEffect(create2,ref){if(typeof ref=="function"){var refCallback=ref,_inst=create2();return refCallback(_inst),function(){refCallback(null)}}else if(ref!=null){var refObject=ref;refObject.hasOwnProperty("current")||error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.","an object with keys {"+Object.keys(refObject).join(", ")+"}");var _inst2=create2();return refObject.current=_inst2,function(){refObject.current=null}}}function mountImperativeHandle(ref,create2,deps){typeof create2!="function"&&error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",create2!==null?typeof create2:"null");var effectDeps=deps!=null?deps.concat([ref]):null,fiberFlags=Update;return fiberFlags|=LayoutStatic,(currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode&&(fiberFlags|=MountLayoutDev),mountEffectImpl(fiberFlags,Layout,imperativeHandleEffect.bind(null,create2,ref),effectDeps)}function updateImperativeHandle(ref,create2,deps){typeof create2!="function"&&error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",create2!==null?typeof create2:"null");var effectDeps=deps!=null?deps.concat([ref]):null;return updateEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create2,ref),effectDeps)}function mountDebugValue(value,formatterFn){}var updateDebugValue=mountDebugValue;function mountCallback(callback,deps){var hook=mountWorkInProgressHook(),nextDeps=deps===void 0?null:deps;return hook.memoizedState=[callback,nextDeps],callback}function updateCallback(callback,deps){var hook=updateWorkInProgressHook(),nextDeps=deps===void 0?null:deps,prevState=hook.memoizedState;if(prevState!==null&&nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps))return prevState[0]}return hook.memoizedState=[callback,nextDeps],callback}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook(),nextDeps=deps===void 0?null:deps,nextValue=nextCreate();return hook.memoizedState=[nextValue,nextDeps],nextValue}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook(),nextDeps=deps===void 0?null:deps,prevState=hook.memoizedState;if(prevState!==null&&nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps))return prevState[0]}var nextValue=nextCreate();return hook.memoizedState=[nextValue,nextDeps],nextValue}function mountDeferredValue(value){var hook=mountWorkInProgressHook();return hook.memoizedState=value,value}function updateDeferredValue(value){var hook=updateWorkInProgressHook(),resolvedCurrentHook=currentHook,prevValue=resolvedCurrentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value)}function rerenderDeferredValue(value){var hook=updateWorkInProgressHook();if(currentHook===null)return hook.memoizedState=value,value;var prevValue=currentHook.memoizedState;return updateDeferredValueImpl(hook,prevValue,value)}function updateDeferredValueImpl(hook,prevValue,value){var shouldDeferValue=!includesOnlyNonUrgentLanes(renderLanes);if(shouldDeferValue){if(!objectIs(value,prevValue)){var deferredLane=claimNextTransitionLane();currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,deferredLane),markSkippedUpdateLanes(deferredLane),hook.baseState=!0}return prevValue}else return hook.baseState&&(hook.baseState=!1,markWorkInProgressReceivedUpdate()),hook.memoizedState=value,value}function startTransition(setPending,callback,options2){var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(higherEventPriority(previousPriority,ContinuousEventPriority)),setPending(!0);var prevTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition={};var currentTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition._updatedFibers=new Set;try{setPending(!1),callback()}finally{if(setCurrentUpdatePriority(previousPriority),ReactCurrentBatchConfig$2.transition=prevTransition,prevTransition===null&&currentTransition._updatedFibers){var updatedFibersCount=currentTransition._updatedFibers.size;updatedFibersCount>10&&warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."),currentTransition._updatedFibers.clear()}}}function mountTransition(){var _mountState=mountState(!1),isPending=_mountState[0],setPending=_mountState[1],start=startTransition.bind(null,setPending),hook=mountWorkInProgressHook();return hook.memoizedState=start,[isPending,start]}function updateTransition(){var _updateState=updateState(),isPending=_updateState[0],hook=updateWorkInProgressHook(),start=hook.memoizedState;return[isPending,start]}function rerenderTransition(){var _rerenderState=rerenderState(),isPending=_rerenderState[0],hook=updateWorkInProgressHook(),start=hook.memoizedState;return[isPending,start]}var isUpdatingOpaqueValueInRenderPhase=!1;function getIsUpdatingOpaqueValueInRenderPhaseInDEV(){return isUpdatingOpaqueValueInRenderPhase}function mountId(){var hook=mountWorkInProgressHook(),root2=getWorkInProgressRoot(),identifierPrefix=root2.identifierPrefix,id2;if(getIsHydrating()){var treeId=getTreeId();id2=":"+identifierPrefix+"R"+treeId;var localId=localIdCounter++;localId>0&&(id2+="H"+localId.toString(32)),id2+=":"}else{var globalClientId=globalClientIdCounter++;id2=":"+identifierPrefix+"r"+globalClientId.toString(32)+":"}return hook.memoizedState=id2,id2}function updateId(){var hook=updateWorkInProgressHook(),id2=hook.memoizedState;return id2}function dispatchReducerAction(fiber,queue,action){typeof arguments[3]=="function"&&error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");var lane=requestUpdateLane(fiber),update={lane,action,hasEagerState:!1,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber))enqueueRenderPhaseUpdate(queue,update);else{var root2=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root2!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root2,fiber,lane,eventTime),entangleTransitionUpdate(root2,queue,lane)}}markUpdateInDevTools(fiber,lane)}function dispatchSetState(fiber,queue,action){typeof arguments[3]=="function"&&error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");var lane=requestUpdateLane(fiber),update={lane,action,hasEagerState:!1,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber))enqueueRenderPhaseUpdate(queue,update);else{var alternate=fiber.alternate;if(fiber.lanes===NoLanes&&(alternate===null||alternate.lanes===NoLanes)){var lastRenderedReducer=queue.lastRenderedReducer;if(lastRenderedReducer!==null){var prevDispatcher;prevDispatcher=ReactCurrentDispatcher$1.current,ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{var currentState=queue.lastRenderedState,eagerState=lastRenderedReducer(currentState,action);if(update.hasEagerState=!0,update.eagerState=eagerState,objectIs(eagerState,currentState)){enqueueConcurrentHookUpdateAndEagerlyBailout(fiber,queue,update,lane);return}}catch{}finally{ReactCurrentDispatcher$1.current=prevDispatcher}}}var root2=enqueueConcurrentHookUpdate(fiber,queue,update,lane);if(root2!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root2,fiber,lane,eventTime),entangleTransitionUpdate(root2,queue,lane)}}markUpdateInDevTools(fiber,lane)}function isRenderPhaseUpdate(fiber){var alternate=fiber.alternate;return fiber===currentlyRenderingFiber$1||alternate!==null&&alternate===currentlyRenderingFiber$1}function enqueueRenderPhaseUpdate(queue,update){didScheduleRenderPhaseUpdateDuringThisPass=didScheduleRenderPhaseUpdate=!0;var pending=queue.pending;pending===null?update.next=update:(update.next=pending.next,pending.next=update),queue.pending=update}function entangleTransitionUpdate(root2,queue,lane){if(isTransitionLane(lane)){var queueLanes=queue.lanes;queueLanes=intersectLanes(queueLanes,root2.pendingLanes);var newQueueLanes=mergeLanes(queueLanes,lane);queue.lanes=newQueueLanes,markRootEntangled(root2,newQueueLanes)}}function markUpdateInDevTools(fiber,lane,action){markStateUpdateScheduled(fiber,lane)}var ContextOnlyDispatcher={readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useInsertionEffect:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError,useMutableSource:throwInvalidHookError,useSyncExternalStore:throwInvalidHookError,useId:throwInvalidHookError,unstable_isNewReconciler:enableNewReconciler},HooksDispatcherOnMountInDEV=null,HooksDispatcherOnMountWithHookTypesInDEV=null,HooksDispatcherOnUpdateInDEV=null,HooksDispatcherOnRerenderInDEV=null,InvalidNestedHooksDispatcherOnMountInDEV=null,InvalidNestedHooksDispatcherOnUpdateInDEV=null,InvalidNestedHooksDispatcherOnRerenderInDEV=null;{var warnInvalidContextAccess=function(){error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().")},warnInvalidHookAccess=function(){error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks")};HooksDispatcherOnMountInDEV={readContext:function(context2){return readContext(context2)},useCallback:function(callback,deps){return currentHookNameInDev="useCallback",mountHookTypesDev(),checkDepsAreArrayDev(deps),mountCallback(callback,deps)},useContext:function(context2){return currentHookNameInDev="useContext",mountHookTypesDev(),readContext(context2)},useEffect:function(create2,deps){return currentHookNameInDev="useEffect",mountHookTypesDev(),checkDepsAreArrayDev(deps),mountEffect(create2,deps)},useImperativeHandle:function(ref,create2,deps){return currentHookNameInDev="useImperativeHandle",mountHookTypesDev(),checkDepsAreArrayDev(deps),mountImperativeHandle(ref,create2,deps)},useInsertionEffect:function(create2,deps){return currentHookNameInDev="useInsertionEffect",mountHookTypesDev(),checkDepsAreArrayDev(deps),mountInsertionEffect(create2,deps)},useLayoutEffect:function(create2,deps){return currentHookNameInDev="useLayoutEffect",mountHookTypesDev(),checkDepsAreArrayDev(deps),mountLayoutEffect(create2,deps)},useMemo:function(create2,deps){currentHookNameInDev="useMemo",mountHookTypesDev(),checkDepsAreArrayDev(deps);var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create2,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer",mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){return currentHookNameInDev="useRef",mountHookTypesDev(),mountRef(initialValue)},useState:function(initialState){currentHookNameInDev="useState",mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,formatterFn){return currentHookNameInDev="useDebugValue",mountHookTypesDev(),void 0},useDeferredValue:function(value){return currentHookNameInDev="useDeferredValue",mountHookTypesDev(),mountDeferredValue(value)},useTransition:function(){return currentHookNameInDev="useTransition",mountHookTypesDev(),mountTransition()},useMutableSource:function(source,getSnapshot,subscribe){return currentHookNameInDev="useMutableSource",mountHookTypesDev(),void 0},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){return currentHookNameInDev="useSyncExternalStore",mountHookTypesDev(),mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot)},useId:function(){return currentHookNameInDev="useId",mountHookTypesDev(),mountId()},unstable_isNewReconciler:enableNewReconciler},HooksDispatcherOnMountWithHookTypesInDEV={readContext:function(context2){return readContext(context2)},useCallback:function(callback,deps){return currentHookNameInDev="useCallback",updateHookTypesDev(),mountCallback(callback,deps)},useContext:function(context2){return currentHookNameInDev="useContext",updateHookTypesDev(),readContext(context2)},useEffect:function(create2,deps){return currentHookNameInDev="useEffect",updateHookTypesDev(),mountEffect(create2,deps)},useImperativeHandle:function(ref,create2,deps){return currentHookNameInDev="useImperativeHandle",updateHookTypesDev(),mountImperativeHandle(ref,create2,deps)},useInsertionEffect:function(create2,deps){return currentHookNameInDev="useInsertionEffect",updateHookTypesDev(),mountInsertionEffect(create2,deps)},useLayoutEffect:function(create2,deps){return currentHookNameInDev="useLayoutEffect",updateHookTypesDev(),mountLayoutEffect(create2,deps)},useMemo:function(create2,deps){currentHookNameInDev="useMemo",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create2,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){return currentHookNameInDev="useRef",updateHookTypesDev(),mountRef(initialValue)},useState:function(initialState){currentHookNameInDev="useState",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,formatterFn){return currentHookNameInDev="useDebugValue",updateHookTypesDev(),void 0},useDeferredValue:function(value){return currentHookNameInDev="useDeferredValue",updateHookTypesDev(),mountDeferredValue(value)},useTransition:function(){return currentHookNameInDev="useTransition",updateHookTypesDev(),mountTransition()},useMutableSource:function(source,getSnapshot,subscribe){return currentHookNameInDev="useMutableSource",updateHookTypesDev(),void 0},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){return currentHookNameInDev="useSyncExternalStore",updateHookTypesDev(),mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot)},useId:function(){return currentHookNameInDev="useId",updateHookTypesDev(),mountId()},unstable_isNewReconciler:enableNewReconciler},HooksDispatcherOnUpdateInDEV={readContext:function(context2){return readContext(context2)},useCallback:function(callback,deps){return currentHookNameInDev="useCallback",updateHookTypesDev(),updateCallback(callback,deps)},useContext:function(context2){return currentHookNameInDev="useContext",updateHookTypesDev(),readContext(context2)},useEffect:function(create2,deps){return currentHookNameInDev="useEffect",updateHookTypesDev(),updateEffect(create2,deps)},useImperativeHandle:function(ref,create2,deps){return currentHookNameInDev="useImperativeHandle",updateHookTypesDev(),updateImperativeHandle(ref,create2,deps)},useInsertionEffect:function(create2,deps){return currentHookNameInDev="useInsertionEffect",updateHookTypesDev(),updateInsertionEffect(create2,deps)},useLayoutEffect:function(create2,deps){return currentHookNameInDev="useLayoutEffect",updateHookTypesDev(),updateLayoutEffect(create2,deps)},useMemo:function(create2,deps){currentHookNameInDev="useMemo",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create2,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){return currentHookNameInDev="useRef",updateHookTypesDev(),updateRef()},useState:function(initialState){currentHookNameInDev="useState",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,formatterFn){return currentHookNameInDev="useDebugValue",updateHookTypesDev(),updateDebugValue()},useDeferredValue:function(value){return currentHookNameInDev="useDeferredValue",updateHookTypesDev(),updateDeferredValue(value)},useTransition:function(){return currentHookNameInDev="useTransition",updateHookTypesDev(),updateTransition()},useMutableSource:function(source,getSnapshot,subscribe){return currentHookNameInDev="useMutableSource",updateHookTypesDev(),void 0},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){return currentHookNameInDev="useSyncExternalStore",updateHookTypesDev(),updateSyncExternalStore(subscribe,getSnapshot)},useId:function(){return currentHookNameInDev="useId",updateHookTypesDev(),updateId()},unstable_isNewReconciler:enableNewReconciler},HooksDispatcherOnRerenderInDEV={readContext:function(context2){return readContext(context2)},useCallback:function(callback,deps){return currentHookNameInDev="useCallback",updateHookTypesDev(),updateCallback(callback,deps)},useContext:function(context2){return currentHookNameInDev="useContext",updateHookTypesDev(),readContext(context2)},useEffect:function(create2,deps){return currentHookNameInDev="useEffect",updateHookTypesDev(),updateEffect(create2,deps)},useImperativeHandle:function(ref,create2,deps){return currentHookNameInDev="useImperativeHandle",updateHookTypesDev(),updateImperativeHandle(ref,create2,deps)},useInsertionEffect:function(create2,deps){return currentHookNameInDev="useInsertionEffect",updateHookTypesDev(),updateInsertionEffect(create2,deps)},useLayoutEffect:function(create2,deps){return currentHookNameInDev="useLayoutEffect",updateHookTypesDev(),updateLayoutEffect(create2,deps)},useMemo:function(create2,deps){currentHookNameInDev="useMemo",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return updateMemo(create2,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){return currentHookNameInDev="useRef",updateHookTypesDev(),updateRef()},useState:function(initialState){currentHookNameInDev="useState",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,formatterFn){return currentHookNameInDev="useDebugValue",updateHookTypesDev(),updateDebugValue()},useDeferredValue:function(value){return currentHookNameInDev="useDeferredValue",updateHookTypesDev(),rerenderDeferredValue(value)},useTransition:function(){return currentHookNameInDev="useTransition",updateHookTypesDev(),rerenderTransition()},useMutableSource:function(source,getSnapshot,subscribe){return currentHookNameInDev="useMutableSource",updateHookTypesDev(),void 0},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){return currentHookNameInDev="useSyncExternalStore",updateHookTypesDev(),updateSyncExternalStore(subscribe,getSnapshot)},useId:function(){return currentHookNameInDev="useId",updateHookTypesDev(),updateId()},unstable_isNewReconciler:enableNewReconciler},InvalidNestedHooksDispatcherOnMountInDEV={readContext:function(context2){return warnInvalidContextAccess(),readContext(context2)},useCallback:function(callback,deps){return currentHookNameInDev="useCallback",warnInvalidHookAccess(),mountHookTypesDev(),mountCallback(callback,deps)},useContext:function(context2){return currentHookNameInDev="useContext",warnInvalidHookAccess(),mountHookTypesDev(),readContext(context2)},useEffect:function(create2,deps){return currentHookNameInDev="useEffect",warnInvalidHookAccess(),mountHookTypesDev(),mountEffect(create2,deps)},useImperativeHandle:function(ref,create2,deps){return currentHookNameInDev="useImperativeHandle",warnInvalidHookAccess(),mountHookTypesDev(),mountImperativeHandle(ref,create2,deps)},useInsertionEffect:function(create2,deps){return currentHookNameInDev="useInsertionEffect",warnInvalidHookAccess(),mountHookTypesDev(),mountInsertionEffect(create2,deps)},useLayoutEffect:function(create2,deps){return currentHookNameInDev="useLayoutEffect",warnInvalidHookAccess(),mountHookTypesDev(),mountLayoutEffect(create2,deps)},useMemo:function(create2,deps){currentHookNameInDev="useMemo",warnInvalidHookAccess(),mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create2,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer",warnInvalidHookAccess(),mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){return currentHookNameInDev="useRef",warnInvalidHookAccess(),mountHookTypesDev(),mountRef(initialValue)},useState:function(initialState){currentHookNameInDev="useState",warnInvalidHookAccess(),mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,formatterFn){return currentHookNameInDev="useDebugValue",warnInvalidHookAccess(),mountHookTypesDev(),void 0},useDeferredValue:function(value){return currentHookNameInDev="useDeferredValue",warnInvalidHookAccess(),mountHookTypesDev(),mountDeferredValue(value)},useTransition:function(){return currentHookNameInDev="useTransition",warnInvalidHookAccess(),mountHookTypesDev(),mountTransition()},useMutableSource:function(source,getSnapshot,subscribe){return currentHookNameInDev="useMutableSource",warnInvalidHookAccess(),mountHookTypesDev(),void 0},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){return currentHookNameInDev="useSyncExternalStore",warnInvalidHookAccess(),mountHookTypesDev(),mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot)},useId:function(){return currentHookNameInDev="useId",warnInvalidHookAccess(),mountHookTypesDev(),mountId()},unstable_isNewReconciler:enableNewReconciler},InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function(context2){return warnInvalidContextAccess(),readContext(context2)},useCallback:function(callback,deps){return currentHookNameInDev="useCallback",warnInvalidHookAccess(),updateHookTypesDev(),updateCallback(callback,deps)},useContext:function(context2){return currentHookNameInDev="useContext",warnInvalidHookAccess(),updateHookTypesDev(),readContext(context2)},useEffect:function(create2,deps){return currentHookNameInDev="useEffect",warnInvalidHookAccess(),updateHookTypesDev(),updateEffect(create2,deps)},useImperativeHandle:function(ref,create2,deps){return currentHookNameInDev="useImperativeHandle",warnInvalidHookAccess(),updateHookTypesDev(),updateImperativeHandle(ref,create2,deps)},useInsertionEffect:function(create2,deps){return currentHookNameInDev="useInsertionEffect",warnInvalidHookAccess(),updateHookTypesDev(),updateInsertionEffect(create2,deps)},useLayoutEffect:function(create2,deps){return currentHookNameInDev="useLayoutEffect",warnInvalidHookAccess(),updateHookTypesDev(),updateLayoutEffect(create2,deps)},useMemo:function(create2,deps){currentHookNameInDev="useMemo",warnInvalidHookAccess(),updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create2,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer",warnInvalidHookAccess(),updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){return currentHookNameInDev="useRef",warnInvalidHookAccess(),updateHookTypesDev(),updateRef()},useState:function(initialState){currentHookNameInDev="useState",warnInvalidHookAccess(),updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,formatterFn){return currentHookNameInDev="useDebugValue",warnInvalidHookAccess(),updateHookTypesDev(),updateDebugValue()},useDeferredValue:function(value){return currentHookNameInDev="useDeferredValue",warnInvalidHookAccess(),updateHookTypesDev(),updateDeferredValue(value)},useTransition:function(){return currentHookNameInDev="useTransition",warnInvalidHookAccess(),updateHookTypesDev(),updateTransition()},useMutableSource:function(source,getSnapshot,subscribe){return currentHookNameInDev="useMutableSource",warnInvalidHookAccess(),updateHookTypesDev(),void 0},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){return currentHookNameInDev="useSyncExternalStore",warnInvalidHookAccess(),updateHookTypesDev(),updateSyncExternalStore(subscribe,getSnapshot)},useId:function(){return currentHookNameInDev="useId",warnInvalidHookAccess(),updateHookTypesDev(),updateId()},unstable_isNewReconciler:enableNewReconciler},InvalidNestedHooksDispatcherOnRerenderInDEV={readContext:function(context2){return warnInvalidContextAccess(),readContext(context2)},useCallback:function(callback,deps){return currentHookNameInDev="useCallback",warnInvalidHookAccess(),updateHookTypesDev(),updateCallback(callback,deps)},useContext:function(context2){return currentHookNameInDev="useContext",warnInvalidHookAccess(),updateHookTypesDev(),readContext(context2)},useEffect:function(create2,deps){return currentHookNameInDev="useEffect",warnInvalidHookAccess(),updateHookTypesDev(),updateEffect(create2,deps)},useImperativeHandle:function(ref,create2,deps){return currentHookNameInDev="useImperativeHandle",warnInvalidHookAccess(),updateHookTypesDev(),updateImperativeHandle(ref,create2,deps)},useInsertionEffect:function(create2,deps){return currentHookNameInDev="useInsertionEffect",warnInvalidHookAccess(),updateHookTypesDev(),updateInsertionEffect(create2,deps)},useLayoutEffect:function(create2,deps){return currentHookNameInDev="useLayoutEffect",warnInvalidHookAccess(),updateHookTypesDev(),updateLayoutEffect(create2,deps)},useMemo:function(create2,deps){currentHookNameInDev="useMemo",warnInvalidHookAccess(),updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create2,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer",warnInvalidHookAccess(),updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){return currentHookNameInDev="useRef",warnInvalidHookAccess(),updateHookTypesDev(),updateRef()},useState:function(initialState){currentHookNameInDev="useState",warnInvalidHookAccess(),updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,formatterFn){return currentHookNameInDev="useDebugValue",warnInvalidHookAccess(),updateHookTypesDev(),updateDebugValue()},useDeferredValue:function(value){return currentHookNameInDev="useDeferredValue",warnInvalidHookAccess(),updateHookTypesDev(),rerenderDeferredValue(value)},useTransition:function(){return currentHookNameInDev="useTransition",warnInvalidHookAccess(),updateHookTypesDev(),rerenderTransition()},useMutableSource:function(source,getSnapshot,subscribe){return currentHookNameInDev="useMutableSource",warnInvalidHookAccess(),updateHookTypesDev(),void 0},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){return currentHookNameInDev="useSyncExternalStore",warnInvalidHookAccess(),updateHookTypesDev(),updateSyncExternalStore(subscribe,getSnapshot)},useId:function(){return currentHookNameInDev="useId",warnInvalidHookAccess(),updateHookTypesDev(),updateId()},unstable_isNewReconciler:enableNewReconciler}}var now$1=Scheduler.unstable_now,commitTime=0,layoutEffectStartTime=-1,profilerStartTime=-1,passiveEffectStartTime=-1,currentUpdateIsNested=!1,nestedUpdateScheduled=!1;function isCurrentUpdateNested(){return currentUpdateIsNested}function markNestedUpdateScheduled(){nestedUpdateScheduled=!0}function resetNestedUpdateFlag(){currentUpdateIsNested=!1,nestedUpdateScheduled=!1}function syncNestedUpdateFlag(){currentUpdateIsNested=nestedUpdateScheduled,nestedUpdateScheduled=!1}function getCommitTime(){return commitTime}function recordCommitTime(){commitTime=now$1()}function startProfilerTimer(fiber){profilerStartTime=now$1(),fiber.actualStartTime<0&&(fiber.actualStartTime=now$1())}function stopProfilerTimerIfRunning(fiber){profilerStartTime=-1}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(profilerStartTime>=0){var elapsedTime=now$1()-profilerStartTime;fiber.actualDuration+=elapsedTime,overrideBaseTime&&(fiber.selfBaseDuration=elapsedTime),profilerStartTime=-1}}function recordLayoutEffectDuration(fiber){if(layoutEffectStartTime>=0){var elapsedTime=now$1()-layoutEffectStartTime;layoutEffectStartTime=-1;for(var parentFiber=fiber.return;parentFiber!==null;){switch(parentFiber.tag){case HostRoot:var root2=parentFiber.stateNode;root2.effectDuration+=elapsedTime;return;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=elapsedTime;return}parentFiber=parentFiber.return}}}function recordPassiveEffectDuration(fiber){if(passiveEffectStartTime>=0){var elapsedTime=now$1()-passiveEffectStartTime;passiveEffectStartTime=-1;for(var parentFiber=fiber.return;parentFiber!==null;){switch(parentFiber.tag){case HostRoot:var root2=parentFiber.stateNode;root2!==null&&(root2.passiveEffectDuration+=elapsedTime);return;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode!==null&&(parentStateNode.passiveEffectDuration+=elapsedTime);return}parentFiber=parentFiber.return}}}function startLayoutEffectTimer(){layoutEffectStartTime=now$1()}function startPassiveEffectTimer(){passiveEffectStartTime=now$1()}function transferActualDuration(fiber){for(var child=fiber.child;child;)fiber.actualDuration+=child.actualDuration,child=child.sibling}function createCapturedValueAtFiber(value,source){return{value,source,stack:getStackByFiberInDevAndProd(source),digest:null}}function createCapturedValue(value,digest,stack){return{value,source:null,stack:stack??null,digest:digest??null}}function showErrorDialog(boundary,errorInfo){return!0}function logCapturedError(boundary,errorInfo){try{var logError=showErrorDialog(boundary,errorInfo);if(logError===!1)return;var error2=errorInfo.value,source=errorInfo.source,stack=errorInfo.stack,componentStack=stack!==null?stack:"";if(error2!=null&&error2._suppressLogging){if(boundary.tag===ClassComponent)return;console.error(error2)}var componentName=source?getComponentNameFromFiber(source):null,componentNameMessage=componentName?"The above error occurred in the <"+componentName+"> component:":"The above error occurred in one of your React components:",errorBoundaryMessage;if(boundary.tag===HostRoot)errorBoundaryMessage=`Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;else{var errorBoundaryName=getComponentNameFromFiber(boundary)||"Anonymous";errorBoundaryMessage="React will try to recreate this component tree from scratch "+("using the error boundary you provided, "+errorBoundaryName+".")}var combinedMessage=componentNameMessage+`
`+componentStack+`

`+(""+errorBoundaryMessage);console.error(combinedMessage)}catch(e2){setTimeout(function(){throw e2})}}var PossiblyWeakMap$1=typeof WeakMap=="function"?WeakMap:Map;function createRootErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);update.tag=CaptureUpdate,update.payload={element:null};var error2=errorInfo.value;return update.callback=function(){onUncaughtError(error2),logCapturedError(fiber,errorInfo)},update}function createClassErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);update.tag=CaptureUpdate;var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if(typeof getDerivedStateFromError=="function"){var error$1=errorInfo.value;update.payload=function(){return getDerivedStateFromError(error$1)},update.callback=function(){markFailedErrorBoundaryForHotReloading(fiber),logCapturedError(fiber,errorInfo)}}var inst=fiber.stateNode;return inst!==null&&typeof inst.componentDidCatch=="function"&&(update.callback=function(){markFailedErrorBoundaryForHotReloading(fiber),logCapturedError(fiber,errorInfo),typeof getDerivedStateFromError!="function"&&markLegacyErrorBoundaryAsFailed(this);var error$12=errorInfo.value,stack=errorInfo.stack;this.componentDidCatch(error$12,{componentStack:stack!==null?stack:""}),typeof getDerivedStateFromError!="function"&&(includesSomeLane(fiber.lanes,SyncLane)||error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",getComponentNameFromFiber(fiber)||"Unknown"))}),update}function attachPingListener(root2,wakeable,lanes){var pingCache=root2.pingCache,threadIDs;if(pingCache===null?(pingCache=root2.pingCache=new PossiblyWeakMap$1,threadIDs=new Set,pingCache.set(wakeable,threadIDs)):(threadIDs=pingCache.get(wakeable),threadIDs===void 0&&(threadIDs=new Set,pingCache.set(wakeable,threadIDs))),!threadIDs.has(lanes)){threadIDs.add(lanes);var ping=pingSuspendedRoot.bind(null,root2,wakeable,lanes);isDevToolsPresent&&restorePendingUpdaters(root2,lanes),wakeable.then(ping,ping)}}function attachRetryListener(suspenseBoundary,root2,wakeable,lanes){var wakeables=suspenseBoundary.updateQueue;if(wakeables===null){var updateQueue=new Set;updateQueue.add(wakeable),suspenseBoundary.updateQueue=updateQueue}else wakeables.add(wakeable)}function resetSuspendedComponent(sourceFiber,rootRenderLanes){var tag=sourceFiber.tag;if((sourceFiber.mode&ConcurrentMode)===NoMode&&(tag===FunctionComponent||tag===ForwardRef||tag===SimpleMemoComponent)){var currentSource=sourceFiber.alternate;currentSource?(sourceFiber.updateQueue=currentSource.updateQueue,sourceFiber.memoizedState=currentSource.memoizedState,sourceFiber.lanes=currentSource.lanes):(sourceFiber.updateQueue=null,sourceFiber.memoizedState=null)}}function getNearestSuspenseBoundaryToCapture(returnFiber){var node=returnFiber;do{if(node.tag===SuspenseComponent&&shouldCaptureSuspense(node))return node;node=node.return}while(node!==null);return null}function markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root2,rootRenderLanes){if((suspenseBoundary.mode&ConcurrentMode)===NoMode){if(suspenseBoundary===returnFiber)suspenseBoundary.flags|=ShouldCapture;else{if(suspenseBoundary.flags|=DidCapture,sourceFiber.flags|=ForceUpdateForLegacySuspense,sourceFiber.flags&=~(LifecycleEffectMask|Incomplete),sourceFiber.tag===ClassComponent){var currentSourceFiber=sourceFiber.alternate;if(currentSourceFiber===null)sourceFiber.tag=IncompleteClassComponent;else{var update=createUpdate(NoTimestamp,SyncLane);update.tag=ForceUpdate,enqueueUpdate(sourceFiber,update,SyncLane)}}sourceFiber.lanes=mergeLanes(sourceFiber.lanes,SyncLane)}return suspenseBoundary}return suspenseBoundary.flags|=ShouldCapture,suspenseBoundary.lanes=rootRenderLanes,suspenseBoundary}function throwException(root2,returnFiber,sourceFiber,value,rootRenderLanes){if(sourceFiber.flags|=Incomplete,isDevToolsPresent&&restorePendingUpdaters(root2,rootRenderLanes),value!==null&&typeof value=="object"&&typeof value.then=="function"){var wakeable=value;resetSuspendedComponent(sourceFiber),getIsHydrating()&&sourceFiber.mode&ConcurrentMode&&markDidThrowWhileHydratingDEV();var suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(suspenseBoundary!==null){suspenseBoundary.flags&=~ForceClientRender,markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root2,rootRenderLanes),suspenseBoundary.mode&ConcurrentMode&&attachPingListener(root2,wakeable,rootRenderLanes),attachRetryListener(suspenseBoundary,root2,wakeable);return}else{if(!includesSyncLane(rootRenderLanes)){attachPingListener(root2,wakeable,rootRenderLanes),renderDidSuspendDelayIfPossible();return}var uncaughtSuspenseError=new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");value=uncaughtSuspenseError}}else if(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidThrowWhileHydratingDEV();var _suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(_suspenseBoundary!==null){(_suspenseBoundary.flags&ShouldCapture)===NoFlags&&(_suspenseBoundary.flags|=ForceClientRender),markSuspenseBoundaryShouldCapture(_suspenseBoundary,returnFiber,sourceFiber,root2,rootRenderLanes),queueHydrationError(createCapturedValueAtFiber(value,sourceFiber));return}}value=createCapturedValueAtFiber(value,sourceFiber),renderDidError(value);var workInProgress2=returnFiber;do{switch(workInProgress2.tag){case HostRoot:{var _errorInfo=value;workInProgress2.flags|=ShouldCapture;var lane=pickArbitraryLane(rootRenderLanes);workInProgress2.lanes=mergeLanes(workInProgress2.lanes,lane);var update=createRootErrorUpdate(workInProgress2,_errorInfo,lane);enqueueCapturedUpdate(workInProgress2,update);return}case ClassComponent:var errorInfo=value,ctor=workInProgress2.type,instance=workInProgress2.stateNode;if((workInProgress2.flags&DidCapture)===NoFlags&&(typeof ctor.getDerivedStateFromError=="function"||instance!==null&&typeof instance.componentDidCatch=="function"&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress2.flags|=ShouldCapture;var _lane=pickArbitraryLane(rootRenderLanes);workInProgress2.lanes=mergeLanes(workInProgress2.lanes,_lane);var _update=createClassErrorUpdate(workInProgress2,errorInfo,_lane);enqueueCapturedUpdate(workInProgress2,_update);return}break}workInProgress2=workInProgress2.return}while(workInProgress2!==null)}function getSuspendedCache(){return null}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner,didReceiveUpdate=!1,didWarnAboutBadClass,didWarnAboutModulePatternComponent,didWarnAboutContextTypeOnFunctionComponent,didWarnAboutGetDerivedStateOnFunctionComponent,didWarnAboutFunctionRefs,didWarnAboutReassigningProps,didWarnAboutRevealOrder,didWarnAboutTailOptions;didWarnAboutBadClass={},didWarnAboutModulePatternComponent={},didWarnAboutContextTypeOnFunctionComponent={},didWarnAboutGetDerivedStateOnFunctionComponent={},didWarnAboutFunctionRefs={},didWarnAboutReassigningProps=!1,didWarnAboutRevealOrder={},didWarnAboutTailOptions={};function reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2){current2===null?workInProgress2.child=mountChildFibers(workInProgress2,null,nextChildren,renderLanes2):workInProgress2.child=reconcileChildFibers(workInProgress2,current2.child,nextChildren,renderLanes2)}function forceUnmountCurrentAndReconcile(current2,workInProgress2,nextChildren,renderLanes2){workInProgress2.child=reconcileChildFibers(workInProgress2,current2.child,null,renderLanes2),workInProgress2.child=reconcileChildFibers(workInProgress2,null,nextChildren,renderLanes2)}function updateForwardRef(current2,workInProgress2,Component,nextProps,renderLanes2){if(workInProgress2.type!==workInProgress2.elementType){var innerPropTypes=Component.propTypes;innerPropTypes&&checkPropTypes(innerPropTypes,nextProps,"prop",getComponentNameFromType(Component))}var render2=Component.render,ref=workInProgress2.ref,nextChildren,hasId;prepareToReadContext(workInProgress2,renderLanes2),markComponentRenderStarted(workInProgress2);{if(ReactCurrentOwner$1.current=workInProgress2,setIsRendering(!0),nextChildren=renderWithHooks(current2,workInProgress2,render2,nextProps,ref,renderLanes2),hasId=checkDidRenderIdHook(),workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{nextChildren=renderWithHooks(current2,workInProgress2,render2,nextProps,ref,renderLanes2),hasId=checkDidRenderIdHook()}finally{setIsStrictModeForDevtools(!1)}}setIsRendering(!1)}return markComponentRenderStopped(),current2!==null&&!didReceiveUpdate?(bailoutHooks(current2,workInProgress2,renderLanes2),bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2)):(getIsHydrating()&&hasId&&pushMaterializedTreeId(workInProgress2),workInProgress2.flags|=PerformedWork,reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child)}function updateMemoComponent(current2,workInProgress2,Component,nextProps,renderLanes2){if(current2===null){var type=Component.type;if(isSimpleFunctionComponent(type)&&Component.compare===null&&Component.defaultProps===void 0){var resolvedType=type;return resolvedType=resolveFunctionForHotReloading(type),workInProgress2.tag=SimpleMemoComponent,workInProgress2.type=resolvedType,validateFunctionComponentInDev(workInProgress2,type),updateSimpleMemoComponent(current2,workInProgress2,resolvedType,nextProps,renderLanes2)}{var innerPropTypes=type.propTypes;innerPropTypes&&checkPropTypes(innerPropTypes,nextProps,"prop",getComponentNameFromType(type))}var child=createFiberFromTypeAndProps(Component.type,null,nextProps,workInProgress2,workInProgress2.mode,renderLanes2);return child.ref=workInProgress2.ref,child.return=workInProgress2,workInProgress2.child=child,child}{var _type=Component.type,_innerPropTypes=_type.propTypes;_innerPropTypes&&checkPropTypes(_innerPropTypes,nextProps,"prop",getComponentNameFromType(_type))}var currentChild=current2.child,hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current2,renderLanes2);if(!hasScheduledUpdateOrContext){var prevProps=currentChild.memoizedProps,compare=Component.compare;if(compare=compare!==null?compare:shallowEqual,compare(prevProps,nextProps)&&current2.ref===workInProgress2.ref)return bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2)}workInProgress2.flags|=PerformedWork;var newChild=createWorkInProgress(currentChild,nextProps);return newChild.ref=workInProgress2.ref,newChild.return=workInProgress2,workInProgress2.child=newChild,newChild}function updateSimpleMemoComponent(current2,workInProgress2,Component,nextProps,renderLanes2){if(workInProgress2.type!==workInProgress2.elementType){var outerMemoType=workInProgress2.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){var lazyComponent=outerMemoType,payload=lazyComponent._payload,init=lazyComponent._init;try{outerMemoType=init(payload)}catch{outerMemoType=null}var outerPropTypes=outerMemoType&&outerMemoType.propTypes;outerPropTypes&&checkPropTypes(outerPropTypes,nextProps,"prop",getComponentNameFromType(outerMemoType))}}if(current2!==null){var prevProps=current2.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current2.ref===workInProgress2.ref&&workInProgress2.type===current2.type)if(didReceiveUpdate=!1,workInProgress2.pendingProps=nextProps=prevProps,checkScheduledUpdateOrContext(current2,renderLanes2))(current2.flags&ForceUpdateForLegacySuspense)!==NoFlags&&(didReceiveUpdate=!0);else return workInProgress2.lanes=current2.lanes,bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2)}return updateFunctionComponent(current2,workInProgress2,Component,nextProps,renderLanes2)}function updateOffscreenComponent(current2,workInProgress2,renderLanes2){var nextProps=workInProgress2.pendingProps,nextChildren=nextProps.children,prevState=current2!==null?current2.memoizedState:null;if(nextProps.mode==="hidden"||enableLegacyHidden)if((workInProgress2.mode&ConcurrentMode)===NoMode){var nextState={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress2.memoizedState=nextState,pushRenderLanes(workInProgress2,renderLanes2)}else if(includesSomeLane(renderLanes2,OffscreenLane)){var _nextState2={baseLanes:NoLanes,cachePool:null,transitions:null};workInProgress2.memoizedState=_nextState2;var subtreeRenderLanes2=prevState!==null?prevState.baseLanes:renderLanes2;pushRenderLanes(workInProgress2,subtreeRenderLanes2)}else{var spawnedCachePool=null,nextBaseLanes;if(prevState!==null){var prevBaseLanes=prevState.baseLanes;nextBaseLanes=mergeLanes(prevBaseLanes,renderLanes2)}else nextBaseLanes=renderLanes2;workInProgress2.lanes=workInProgress2.childLanes=OffscreenLane;var _nextState={baseLanes:nextBaseLanes,cachePool:spawnedCachePool,transitions:null};return workInProgress2.memoizedState=_nextState,workInProgress2.updateQueue=null,pushRenderLanes(workInProgress2,nextBaseLanes),null}else{var _subtreeRenderLanes;prevState!==null?(_subtreeRenderLanes=mergeLanes(prevState.baseLanes,renderLanes2),workInProgress2.memoizedState=null):_subtreeRenderLanes=renderLanes2,pushRenderLanes(workInProgress2,_subtreeRenderLanes)}return reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child}function updateFragment(current2,workInProgress2,renderLanes2){var nextChildren=workInProgress2.pendingProps;return reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child}function updateMode(current2,workInProgress2,renderLanes2){var nextChildren=workInProgress2.pendingProps.children;return reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child}function updateProfiler(current2,workInProgress2,renderLanes2){{workInProgress2.flags|=Update;{var stateNode=workInProgress2.stateNode;stateNode.effectDuration=0,stateNode.passiveEffectDuration=0}}var nextProps=workInProgress2.pendingProps,nextChildren=nextProps.children;return reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child}function markRef(current2,workInProgress2){var ref=workInProgress2.ref;(current2===null&&ref!==null||current2!==null&&current2.ref!==ref)&&(workInProgress2.flags|=Ref,workInProgress2.flags|=RefStatic)}function updateFunctionComponent(current2,workInProgress2,Component,nextProps,renderLanes2){if(workInProgress2.type!==workInProgress2.elementType){var innerPropTypes=Component.propTypes;innerPropTypes&&checkPropTypes(innerPropTypes,nextProps,"prop",getComponentNameFromType(Component))}var context2;{var unmaskedContext=getUnmaskedContext(workInProgress2,Component,!0);context2=getMaskedContext(workInProgress2,unmaskedContext)}var nextChildren,hasId;prepareToReadContext(workInProgress2,renderLanes2),markComponentRenderStarted(workInProgress2);{if(ReactCurrentOwner$1.current=workInProgress2,setIsRendering(!0),nextChildren=renderWithHooks(current2,workInProgress2,Component,nextProps,context2,renderLanes2),hasId=checkDidRenderIdHook(),workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{nextChildren=renderWithHooks(current2,workInProgress2,Component,nextProps,context2,renderLanes2),hasId=checkDidRenderIdHook()}finally{setIsStrictModeForDevtools(!1)}}setIsRendering(!1)}return markComponentRenderStopped(),current2!==null&&!didReceiveUpdate?(bailoutHooks(current2,workInProgress2,renderLanes2),bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2)):(getIsHydrating()&&hasId&&pushMaterializedTreeId(workInProgress2),workInProgress2.flags|=PerformedWork,reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child)}function updateClassComponent(current2,workInProgress2,Component,nextProps,renderLanes2){{switch(shouldError(workInProgress2)){case!1:{var _instance=workInProgress2.stateNode,ctor=workInProgress2.type,tempInstance=new ctor(workInProgress2.memoizedProps,_instance.context),state=tempInstance.state;_instance.updater.enqueueSetState(_instance,state,null);break}case!0:{workInProgress2.flags|=DidCapture,workInProgress2.flags|=ShouldCapture;var error$1=new Error("Simulated error coming from DevTools"),lane=pickArbitraryLane(renderLanes2);workInProgress2.lanes=mergeLanes(workInProgress2.lanes,lane);var update=createClassErrorUpdate(workInProgress2,createCapturedValueAtFiber(error$1,workInProgress2),lane);enqueueCapturedUpdate(workInProgress2,update);break}}if(workInProgress2.type!==workInProgress2.elementType){var innerPropTypes=Component.propTypes;innerPropTypes&&checkPropTypes(innerPropTypes,nextProps,"prop",getComponentNameFromType(Component))}}var hasContext;isContextProvider(Component)?(hasContext=!0,pushContextProvider(workInProgress2)):hasContext=!1,prepareToReadContext(workInProgress2,renderLanes2);var instance=workInProgress2.stateNode,shouldUpdate;instance===null?(resetSuspendedCurrentOnMountInLegacyMode(current2,workInProgress2),constructClassInstance(workInProgress2,Component,nextProps),mountClassInstance(workInProgress2,Component,nextProps,renderLanes2),shouldUpdate=!0):current2===null?shouldUpdate=resumeMountClassInstance(workInProgress2,Component,nextProps,renderLanes2):shouldUpdate=updateClassInstance(current2,workInProgress2,Component,nextProps,renderLanes2);var nextUnitOfWork=finishClassComponent(current2,workInProgress2,Component,shouldUpdate,hasContext,renderLanes2);{var inst=workInProgress2.stateNode;shouldUpdate&&inst.props!==nextProps&&(didWarnAboutReassigningProps||error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",getComponentNameFromFiber(workInProgress2)||"a component"),didWarnAboutReassigningProps=!0)}return nextUnitOfWork}function finishClassComponent(current2,workInProgress2,Component,shouldUpdate,hasContext,renderLanes2){markRef(current2,workInProgress2);var didCaptureError=(workInProgress2.flags&DidCapture)!==NoFlags;if(!shouldUpdate&&!didCaptureError)return hasContext&&invalidateContextProvider(workInProgress2,Component,!1),bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2);var instance=workInProgress2.stateNode;ReactCurrentOwner$1.current=workInProgress2;var nextChildren;if(didCaptureError&&typeof Component.getDerivedStateFromError!="function")nextChildren=null,stopProfilerTimerIfRunning();else{markComponentRenderStarted(workInProgress2);{if(setIsRendering(!0),nextChildren=instance.render(),workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{instance.render()}finally{setIsStrictModeForDevtools(!1)}}setIsRendering(!1)}markComponentRenderStopped()}return workInProgress2.flags|=PerformedWork,current2!==null&&didCaptureError?forceUnmountCurrentAndReconcile(current2,workInProgress2,nextChildren,renderLanes2):reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.memoizedState=instance.state,hasContext&&invalidateContextProvider(workInProgress2,Component,!0),workInProgress2.child}function pushHostRootContext(workInProgress2){var root2=workInProgress2.stateNode;root2.pendingContext?pushTopLevelContextObject(workInProgress2,root2.pendingContext,root2.pendingContext!==root2.context):root2.context&&pushTopLevelContextObject(workInProgress2,root2.context,!1),pushHostContainer(workInProgress2,root2.containerInfo)}function updateHostRoot(current2,workInProgress2,renderLanes2){if(pushHostRootContext(workInProgress2),current2===null)throw new Error("Should have a current fiber. This is a bug in React.");var nextProps=workInProgress2.pendingProps,prevState=workInProgress2.memoizedState,prevChildren=prevState.element;cloneUpdateQueue(current2,workInProgress2),processUpdateQueue(workInProgress2,nextProps,null,renderLanes2);var nextState=workInProgress2.memoizedState;workInProgress2.stateNode;var nextChildren=nextState.element;if(prevState.isDehydrated){var overrideState={element:nextChildren,isDehydrated:!1,cache:nextState.cache,pendingSuspenseBoundaries:nextState.pendingSuspenseBoundaries,transitions:nextState.transitions},updateQueue=workInProgress2.updateQueue;if(updateQueue.baseState=overrideState,workInProgress2.memoizedState=overrideState,workInProgress2.flags&ForceClientRender){var recoverableError=createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."),workInProgress2);return mountHostRootWithoutHydrating(current2,workInProgress2,nextChildren,renderLanes2,recoverableError)}else if(nextChildren!==prevChildren){var _recoverableError=createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."),workInProgress2);return mountHostRootWithoutHydrating(current2,workInProgress2,nextChildren,renderLanes2,_recoverableError)}else{enterHydrationState(workInProgress2);var child=mountChildFibers(workInProgress2,null,nextChildren,renderLanes2);workInProgress2.child=child;for(var node=child;node;)node.flags=node.flags&~Placement|Hydrating,node=node.sibling}}else{if(resetHydrationState(),nextChildren===prevChildren)return bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2);reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2)}return workInProgress2.child}function mountHostRootWithoutHydrating(current2,workInProgress2,nextChildren,renderLanes2,recoverableError){return resetHydrationState(),queueHydrationError(recoverableError),workInProgress2.flags|=ForceClientRender,reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child}function updateHostComponent(current2,workInProgress2,renderLanes2){pushHostContext(workInProgress2),current2===null&&tryToClaimNextHydratableInstance(workInProgress2);var type=workInProgress2.type,nextProps=workInProgress2.pendingProps,prevProps=current2!==null?current2.memoizedProps:null,nextChildren=nextProps.children,isDirectTextChild=shouldSetTextContent(type,nextProps);return isDirectTextChild?nextChildren=null:prevProps!==null&&shouldSetTextContent(type,prevProps)&&(workInProgress2.flags|=ContentReset),markRef(current2,workInProgress2),reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child}function updateHostText(current2,workInProgress2){return current2===null&&tryToClaimNextHydratableInstance(workInProgress2),null}function mountLazyComponent(_current,workInProgress2,elementType,renderLanes2){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress2);var props=workInProgress2.pendingProps,lazyComponent=elementType,payload=lazyComponent._payload,init=lazyComponent._init,Component=init(payload);workInProgress2.type=Component;var resolvedTag=workInProgress2.tag=resolveLazyComponentTag(Component),resolvedProps=resolveDefaultProps(Component,props),child;switch(resolvedTag){case FunctionComponent:return validateFunctionComponentInDev(workInProgress2,Component),workInProgress2.type=Component=resolveFunctionForHotReloading(Component),child=updateFunctionComponent(null,workInProgress2,Component,resolvedProps,renderLanes2),child;case ClassComponent:return workInProgress2.type=Component=resolveClassForHotReloading(Component),child=updateClassComponent(null,workInProgress2,Component,resolvedProps,renderLanes2),child;case ForwardRef:return workInProgress2.type=Component=resolveForwardRefForHotReloading(Component),child=updateForwardRef(null,workInProgress2,Component,resolvedProps,renderLanes2),child;case MemoComponent:{if(workInProgress2.type!==workInProgress2.elementType){var outerPropTypes=Component.propTypes;outerPropTypes&&checkPropTypes(outerPropTypes,resolvedProps,"prop",getComponentNameFromType(Component))}return child=updateMemoComponent(null,workInProgress2,Component,resolveDefaultProps(Component.type,resolvedProps),renderLanes2),child}}var hint="";throw Component!==null&&typeof Component=="object"&&Component.$$typeof===REACT_LAZY_TYPE&&(hint=" Did you wrap a component in React.lazy() more than once?"),new Error("Element type is invalid. Received a promise that resolves to: "+Component+". "+("Lazy element type must resolve to a class or function."+hint))}function mountIncompleteClassComponent(_current,workInProgress2,Component,nextProps,renderLanes2){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress2),workInProgress2.tag=ClassComponent;var hasContext;return isContextProvider(Component)?(hasContext=!0,pushContextProvider(workInProgress2)):hasContext=!1,prepareToReadContext(workInProgress2,renderLanes2),constructClassInstance(workInProgress2,Component,nextProps),mountClassInstance(workInProgress2,Component,nextProps,renderLanes2),finishClassComponent(null,workInProgress2,Component,!0,hasContext,renderLanes2)}function mountIndeterminateComponent(_current,workInProgress2,Component,renderLanes2){resetSuspendedCurrentOnMountInLegacyMode(_current,workInProgress2);var props=workInProgress2.pendingProps,context2;{var unmaskedContext=getUnmaskedContext(workInProgress2,Component,!1);context2=getMaskedContext(workInProgress2,unmaskedContext)}prepareToReadContext(workInProgress2,renderLanes2);var value,hasId;markComponentRenderStarted(workInProgress2);{if(Component.prototype&&typeof Component.prototype.render=="function"){var componentName=getComponentNameFromType(Component)||"Unknown";didWarnAboutBadClass[componentName]||(error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",componentName,componentName),didWarnAboutBadClass[componentName]=!0)}workInProgress2.mode&StrictLegacyMode&&ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2,null),setIsRendering(!0),ReactCurrentOwner$1.current=workInProgress2,value=renderWithHooks(null,workInProgress2,Component,props,context2,renderLanes2),hasId=checkDidRenderIdHook(),setIsRendering(!1)}if(markComponentRenderStopped(),workInProgress2.flags|=PerformedWork,typeof value=="object"&&value!==null&&typeof value.render=="function"&&value.$$typeof===void 0){var _componentName=getComponentNameFromType(Component)||"Unknown";didWarnAboutModulePatternComponent[_componentName]||(error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",_componentName,_componentName,_componentName),didWarnAboutModulePatternComponent[_componentName]=!0)}if(typeof value=="object"&&value!==null&&typeof value.render=="function"&&value.$$typeof===void 0){{var _componentName2=getComponentNameFromType(Component)||"Unknown";didWarnAboutModulePatternComponent[_componentName2]||(error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",_componentName2,_componentName2,_componentName2),didWarnAboutModulePatternComponent[_componentName2]=!0)}workInProgress2.tag=ClassComponent,workInProgress2.memoizedState=null,workInProgress2.updateQueue=null;var hasContext=!1;return isContextProvider(Component)?(hasContext=!0,pushContextProvider(workInProgress2)):hasContext=!1,workInProgress2.memoizedState=value.state!==null&&value.state!==void 0?value.state:null,initializeUpdateQueue(workInProgress2),adoptClassInstance(workInProgress2,value),mountClassInstance(workInProgress2,Component,props,renderLanes2),finishClassComponent(null,workInProgress2,Component,!0,hasContext,renderLanes2)}else{if(workInProgress2.tag=FunctionComponent,workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{value=renderWithHooks(null,workInProgress2,Component,props,context2,renderLanes2),hasId=checkDidRenderIdHook()}finally{setIsStrictModeForDevtools(!1)}}return getIsHydrating()&&hasId&&pushMaterializedTreeId(workInProgress2),reconcileChildren(null,workInProgress2,value,renderLanes2),validateFunctionComponentInDev(workInProgress2,Component),workInProgress2.child}}function validateFunctionComponentInDev(workInProgress2,Component){{if(Component&&Component.childContextTypes&&error("%s(...): childContextTypes cannot be defined on a function component.",Component.displayName||Component.name||"Component"),workInProgress2.ref!==null){var info="",ownerName=getCurrentFiberOwnerNameInDevOrNull();ownerName&&(info+=`

Check the render method of \``+ownerName+"`.");var warningKey=ownerName||"",debugSource=workInProgress2._debugSource;debugSource&&(warningKey=debugSource.fileName+":"+debugSource.lineNumber),didWarnAboutFunctionRefs[warningKey]||(didWarnAboutFunctionRefs[warningKey]=!0,error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s",info))}if(typeof Component.getDerivedStateFromProps=="function"){var _componentName3=getComponentNameFromType(Component)||"Unknown";didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]||(error("%s: Function components do not support getDerivedStateFromProps.",_componentName3),didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]=!0)}if(typeof Component.contextType=="object"&&Component.contextType!==null){var _componentName4=getComponentNameFromType(Component)||"Unknown";didWarnAboutContextTypeOnFunctionComponent[_componentName4]||(error("%s: Function components do not support contextType.",_componentName4),didWarnAboutContextTypeOnFunctionComponent[_componentName4]=!0)}}}var SUSPENDED_MARKER={dehydrated:null,treeContext:null,retryLane:NoLane};function mountSuspenseOffscreenState(renderLanes2){return{baseLanes:renderLanes2,cachePool:getSuspendedCache(),transitions:null}}function updateSuspenseOffscreenState(prevOffscreenState,renderLanes2){var cachePool=null;return{baseLanes:mergeLanes(prevOffscreenState.baseLanes,renderLanes2),cachePool,transitions:prevOffscreenState.transitions}}function shouldRemainOnFallback(suspenseContext,current2,workInProgress2,renderLanes2){if(current2!==null){var suspenseState=current2.memoizedState;if(suspenseState===null)return!1}return hasSuspenseContext(suspenseContext,ForceSuspenseFallback)}function getRemainingWorkInPrimaryTree(current2,renderLanes2){return removeLanes(current2.childLanes,renderLanes2)}function updateSuspenseComponent(current2,workInProgress2,renderLanes2){var nextProps=workInProgress2.pendingProps;shouldSuspend(workInProgress2)&&(workInProgress2.flags|=DidCapture);var suspenseContext=suspenseStackCursor.current,showFallback=!1,didSuspend=(workInProgress2.flags&DidCapture)!==NoFlags;if(didSuspend||shouldRemainOnFallback(suspenseContext,current2)?(showFallback=!0,workInProgress2.flags&=~DidCapture):(current2===null||current2.memoizedState!==null)&&(suspenseContext=addSubtreeSuspenseContext(suspenseContext,InvisibleParentSuspenseContext)),suspenseContext=setDefaultShallowSuspenseContext(suspenseContext),pushSuspenseContext(workInProgress2,suspenseContext),current2===null){tryToClaimNextHydratableInstance(workInProgress2);var suspenseState=workInProgress2.memoizedState;if(suspenseState!==null){var dehydrated=suspenseState.dehydrated;if(dehydrated!==null)return mountDehydratedSuspenseComponent(workInProgress2,dehydrated)}var nextPrimaryChildren=nextProps.children,nextFallbackChildren=nextProps.fallback;if(showFallback){var fallbackFragment=mountSuspenseFallbackChildren(workInProgress2,nextPrimaryChildren,nextFallbackChildren,renderLanes2),primaryChildFragment=workInProgress2.child;return primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes2),workInProgress2.memoizedState=SUSPENDED_MARKER,fallbackFragment}else return mountSuspensePrimaryChildren(workInProgress2,nextPrimaryChildren)}else{var prevState=current2.memoizedState;if(prevState!==null){var _dehydrated=prevState.dehydrated;if(_dehydrated!==null)return updateDehydratedSuspenseComponent(current2,workInProgress2,didSuspend,nextProps,_dehydrated,prevState,renderLanes2)}if(showFallback){var _nextFallbackChildren=nextProps.fallback,_nextPrimaryChildren=nextProps.children,fallbackChildFragment=updateSuspenseFallbackChildren(current2,workInProgress2,_nextPrimaryChildren,_nextFallbackChildren,renderLanes2),_primaryChildFragment2=workInProgress2.child,prevOffscreenState=current2.child.memoizedState;return _primaryChildFragment2.memoizedState=prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes2):updateSuspenseOffscreenState(prevOffscreenState,renderLanes2),_primaryChildFragment2.childLanes=getRemainingWorkInPrimaryTree(current2,renderLanes2),workInProgress2.memoizedState=SUSPENDED_MARKER,fallbackChildFragment}else{var _nextPrimaryChildren2=nextProps.children,_primaryChildFragment3=updateSuspensePrimaryChildren(current2,workInProgress2,_nextPrimaryChildren2,renderLanes2);return workInProgress2.memoizedState=null,_primaryChildFragment3}}}function mountSuspensePrimaryChildren(workInProgress2,primaryChildren,renderLanes2){var mode=workInProgress2.mode,primaryChildProps={mode:"visible",children:primaryChildren},primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);return primaryChildFragment.return=workInProgress2,workInProgress2.child=primaryChildFragment,primaryChildFragment}function mountSuspenseFallbackChildren(workInProgress2,primaryChildren,fallbackChildren,renderLanes2){var mode=workInProgress2.mode,progressedPrimaryFragment=workInProgress2.child,primaryChildProps={mode:"hidden",children:primaryChildren},primaryChildFragment,fallbackChildFragment;return(mode&ConcurrentMode)===NoMode&&progressedPrimaryFragment!==null?(primaryChildFragment=progressedPrimaryFragment,primaryChildFragment.childLanes=NoLanes,primaryChildFragment.pendingProps=primaryChildProps,workInProgress2.mode&ProfileMode&&(primaryChildFragment.actualDuration=0,primaryChildFragment.actualStartTime=-1,primaryChildFragment.selfBaseDuration=0,primaryChildFragment.treeBaseDuration=0),fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes2,null)):(primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode),fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes2,null)),primaryChildFragment.return=workInProgress2,fallbackChildFragment.return=workInProgress2,primaryChildFragment.sibling=fallbackChildFragment,workInProgress2.child=primaryChildFragment,fallbackChildFragment}function mountWorkInProgressOffscreenFiber(offscreenProps,mode,renderLanes2){return createFiberFromOffscreen(offscreenProps,mode,NoLanes,null)}function updateWorkInProgressOffscreenFiber(current2,offscreenProps){return createWorkInProgress(current2,offscreenProps)}function updateSuspensePrimaryChildren(current2,workInProgress2,primaryChildren,renderLanes2){var currentPrimaryChildFragment=current2.child,currentFallbackChildFragment=currentPrimaryChildFragment.sibling,primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,{mode:"visible",children:primaryChildren});if((workInProgress2.mode&ConcurrentMode)===NoMode&&(primaryChildFragment.lanes=renderLanes2),primaryChildFragment.return=workInProgress2,primaryChildFragment.sibling=null,currentFallbackChildFragment!==null){var deletions=workInProgress2.deletions;deletions===null?(workInProgress2.deletions=[currentFallbackChildFragment],workInProgress2.flags|=ChildDeletion):deletions.push(currentFallbackChildFragment)}return workInProgress2.child=primaryChildFragment,primaryChildFragment}function updateSuspenseFallbackChildren(current2,workInProgress2,primaryChildren,fallbackChildren,renderLanes2){var mode=workInProgress2.mode,currentPrimaryChildFragment=current2.child,currentFallbackChildFragment=currentPrimaryChildFragment.sibling,primaryChildProps={mode:"hidden",children:primaryChildren},primaryChildFragment;if((mode&ConcurrentMode)===NoMode&&workInProgress2.child!==currentPrimaryChildFragment){var progressedPrimaryFragment=workInProgress2.child;primaryChildFragment=progressedPrimaryFragment,primaryChildFragment.childLanes=NoLanes,primaryChildFragment.pendingProps=primaryChildProps,workInProgress2.mode&ProfileMode&&(primaryChildFragment.actualDuration=0,primaryChildFragment.actualStartTime=-1,primaryChildFragment.selfBaseDuration=currentPrimaryChildFragment.selfBaseDuration,primaryChildFragment.treeBaseDuration=currentPrimaryChildFragment.treeBaseDuration),workInProgress2.deletions=null}else primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,primaryChildProps),primaryChildFragment.subtreeFlags=currentPrimaryChildFragment.subtreeFlags&StaticMask;var fallbackChildFragment;return currentFallbackChildFragment!==null?fallbackChildFragment=createWorkInProgress(currentFallbackChildFragment,fallbackChildren):(fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes2,null),fallbackChildFragment.flags|=Placement),fallbackChildFragment.return=workInProgress2,primaryChildFragment.return=workInProgress2,primaryChildFragment.sibling=fallbackChildFragment,workInProgress2.child=primaryChildFragment,fallbackChildFragment}function retrySuspenseComponentWithoutHydrating(current2,workInProgress2,renderLanes2,recoverableError){recoverableError!==null&&queueHydrationError(recoverableError),reconcileChildFibers(workInProgress2,current2.child,null,renderLanes2);var nextProps=workInProgress2.pendingProps,primaryChildren=nextProps.children,primaryChildFragment=mountSuspensePrimaryChildren(workInProgress2,primaryChildren);return primaryChildFragment.flags|=Placement,workInProgress2.memoizedState=null,primaryChildFragment}function mountSuspenseFallbackAfterRetryWithoutHydrating(current2,workInProgress2,primaryChildren,fallbackChildren,renderLanes2){var fiberMode=workInProgress2.mode,primaryChildProps={mode:"visible",children:primaryChildren},primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,fiberMode),fallbackChildFragment=createFiberFromFragment(fallbackChildren,fiberMode,renderLanes2,null);return fallbackChildFragment.flags|=Placement,primaryChildFragment.return=workInProgress2,fallbackChildFragment.return=workInProgress2,primaryChildFragment.sibling=fallbackChildFragment,workInProgress2.child=primaryChildFragment,(workInProgress2.mode&ConcurrentMode)!==NoMode&&reconcileChildFibers(workInProgress2,current2.child,null,renderLanes2),fallbackChildFragment}function mountDehydratedSuspenseComponent(workInProgress2,suspenseInstance,renderLanes2){return(workInProgress2.mode&ConcurrentMode)===NoMode?(error("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."),workInProgress2.lanes=SyncLane):isSuspenseInstanceFallback(suspenseInstance)?workInProgress2.lanes=DefaultHydrationLane:workInProgress2.lanes=OffscreenLane,null}function updateDehydratedSuspenseComponent(current2,workInProgress2,didSuspend,nextProps,suspenseInstance,suspenseState,renderLanes2){if(didSuspend)if(workInProgress2.flags&ForceClientRender){workInProgress2.flags&=~ForceClientRender;var _capturedValue2=createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));return retrySuspenseComponentWithoutHydrating(current2,workInProgress2,renderLanes2,_capturedValue2)}else{if(workInProgress2.memoizedState!==null)return workInProgress2.child=current2.child,workInProgress2.flags|=DidCapture,null;var nextPrimaryChildren=nextProps.children,nextFallbackChildren=nextProps.fallback,fallbackChildFragment=mountSuspenseFallbackAfterRetryWithoutHydrating(current2,workInProgress2,nextPrimaryChildren,nextFallbackChildren,renderLanes2),_primaryChildFragment4=workInProgress2.child;return _primaryChildFragment4.memoizedState=mountSuspenseOffscreenState(renderLanes2),workInProgress2.memoizedState=SUSPENDED_MARKER,fallbackChildFragment}else{if(warnIfHydrating(),(workInProgress2.mode&ConcurrentMode)===NoMode)return retrySuspenseComponentWithoutHydrating(current2,workInProgress2,renderLanes2,null);if(isSuspenseInstanceFallback(suspenseInstance)){var digest,message,stack;{var _getSuspenseInstanceF=getSuspenseInstanceFallbackErrorDetails(suspenseInstance);digest=_getSuspenseInstanceF.digest,message=_getSuspenseInstanceF.message,stack=_getSuspenseInstanceF.stack}var error2;message?error2=new Error(message):error2=new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");var capturedValue=createCapturedValue(error2,digest,stack);return retrySuspenseComponentWithoutHydrating(current2,workInProgress2,renderLanes2,capturedValue)}var hasContextChanged2=includesSomeLane(renderLanes2,current2.childLanes);if(didReceiveUpdate||hasContextChanged2){var root2=getWorkInProgressRoot();if(root2!==null){var attemptHydrationAtLane=getBumpedLaneForHydration(root2,renderLanes2);if(attemptHydrationAtLane!==NoLane&&attemptHydrationAtLane!==suspenseState.retryLane){suspenseState.retryLane=attemptHydrationAtLane;var eventTime=NoTimestamp;enqueueConcurrentRenderForLane(current2,attemptHydrationAtLane),scheduleUpdateOnFiber(root2,current2,attemptHydrationAtLane,eventTime)}}renderDidSuspendDelayIfPossible();var _capturedValue=createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));return retrySuspenseComponentWithoutHydrating(current2,workInProgress2,renderLanes2,_capturedValue)}else if(isSuspenseInstancePending(suspenseInstance)){workInProgress2.flags|=DidCapture,workInProgress2.child=current2.child;var retry=retryDehydratedSuspenseBoundary.bind(null,current2);return registerSuspenseInstanceRetry(suspenseInstance,retry),null}else{reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2,suspenseInstance,suspenseState.treeContext);var primaryChildren=nextProps.children,primaryChildFragment=mountSuspensePrimaryChildren(workInProgress2,primaryChildren);return primaryChildFragment.flags|=Hydrating,primaryChildFragment}}}function scheduleSuspenseWorkOnFiber(fiber,renderLanes2,propagationRoot){fiber.lanes=mergeLanes(fiber.lanes,renderLanes2);var alternate=fiber.alternate;alternate!==null&&(alternate.lanes=mergeLanes(alternate.lanes,renderLanes2)),scheduleContextWorkOnParentPath(fiber.return,renderLanes2,propagationRoot)}function propagateSuspenseContextChange(workInProgress2,firstChild,renderLanes2){for(var node=firstChild;node!==null;){if(node.tag===SuspenseComponent){var state=node.memoizedState;state!==null&&scheduleSuspenseWorkOnFiber(node,renderLanes2,workInProgress2)}else if(node.tag===SuspenseListComponent)scheduleSuspenseWorkOnFiber(node,renderLanes2,workInProgress2);else if(node.child!==null){node.child.return=node,node=node.child;continue}if(node===workInProgress2)return;for(;node.sibling===null;){if(node.return===null||node.return===workInProgress2)return;node=node.return}node.sibling.return=node.return,node=node.sibling}}function findLastContentRow(firstChild){for(var row=firstChild,lastContentRow=null;row!==null;){var currentRow=row.alternate;currentRow!==null&&findFirstSuspended(currentRow)===null&&(lastContentRow=row),row=row.sibling}return lastContentRow}function validateRevealOrder(revealOrder){if(revealOrder!==void 0&&revealOrder!=="forwards"&&revealOrder!=="backwards"&&revealOrder!=="together"&&!didWarnAboutRevealOrder[revealOrder])if(didWarnAboutRevealOrder[revealOrder]=!0,typeof revealOrder=="string")switch(revealOrder.toLowerCase()){case"together":case"forwards":case"backwards":{error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',revealOrder,revealOrder.toLowerCase());break}case"forward":case"backward":{error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',revealOrder,revealOrder.toLowerCase());break}default:error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',revealOrder);break}else error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',revealOrder)}function validateTailOptions(tailMode,revealOrder){tailMode!==void 0&&!didWarnAboutTailOptions[tailMode]&&(tailMode!=="collapsed"&&tailMode!=="hidden"?(didWarnAboutTailOptions[tailMode]=!0,error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',tailMode)):revealOrder!=="forwards"&&revealOrder!=="backwards"&&(didWarnAboutTailOptions[tailMode]=!0,error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',tailMode)))}function validateSuspenseListNestedChild(childSlot,index2){{var isAnArray=isArray(childSlot),isIterable=!isAnArray&&typeof getIteratorFn(childSlot)=="function";if(isAnArray||isIterable){var type=isAnArray?"array":"iterable";return error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",type,index2,type),!1}}return!0}function validateSuspenseListChildren(children,revealOrder){if((revealOrder==="forwards"||revealOrder==="backwards")&&children!==void 0&&children!==null&&children!==!1)if(isArray(children)){for(var i2=0;i2<children.length;i2++)if(!validateSuspenseListNestedChild(children[i2],i2))return}else{var iteratorFn=getIteratorFn(children);if(typeof iteratorFn=="function"){var childrenIterator=iteratorFn.call(children);if(childrenIterator)for(var step=childrenIterator.next(),_i=0;!step.done;step=childrenIterator.next()){if(!validateSuspenseListNestedChild(step.value,_i))return;_i++}}else error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',revealOrder)}}function initSuspenseListRenderState(workInProgress2,isBackwards,tail,lastContentRow,tailMode){var renderState=workInProgress2.memoizedState;renderState===null?workInProgress2.memoizedState={isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail,tailMode}:(renderState.isBackwards=isBackwards,renderState.rendering=null,renderState.renderingStartTime=0,renderState.last=lastContentRow,renderState.tail=tail,renderState.tailMode=tailMode)}function updateSuspenseListComponent(current2,workInProgress2,renderLanes2){var nextProps=workInProgress2.pendingProps,revealOrder=nextProps.revealOrder,tailMode=nextProps.tail,newChildren=nextProps.children;validateRevealOrder(revealOrder),validateTailOptions(tailMode,revealOrder),validateSuspenseListChildren(newChildren,revealOrder),reconcileChildren(current2,workInProgress2,newChildren,renderLanes2);var suspenseContext=suspenseStackCursor.current,shouldForceFallback=hasSuspenseContext(suspenseContext,ForceSuspenseFallback);if(shouldForceFallback)suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback),workInProgress2.flags|=DidCapture;else{var didSuspendBefore=current2!==null&&(current2.flags&DidCapture)!==NoFlags;didSuspendBefore&&propagateSuspenseContextChange(workInProgress2,workInProgress2.child,renderLanes2),suspenseContext=setDefaultShallowSuspenseContext(suspenseContext)}if(pushSuspenseContext(workInProgress2,suspenseContext),(workInProgress2.mode&ConcurrentMode)===NoMode)workInProgress2.memoizedState=null;else switch(revealOrder){case"forwards":{var lastContentRow=findLastContentRow(workInProgress2.child),tail;lastContentRow===null?(tail=workInProgress2.child,workInProgress2.child=null):(tail=lastContentRow.sibling,lastContentRow.sibling=null),initSuspenseListRenderState(workInProgress2,!1,tail,lastContentRow,tailMode);break}case"backwards":{var _tail=null,row=workInProgress2.child;for(workInProgress2.child=null;row!==null;){var currentRow=row.alternate;if(currentRow!==null&&findFirstSuspended(currentRow)===null){workInProgress2.child=row;break}var nextRow=row.sibling;row.sibling=_tail,_tail=row,row=nextRow}initSuspenseListRenderState(workInProgress2,!0,_tail,null,tailMode);break}case"together":{initSuspenseListRenderState(workInProgress2,!1,null,null,void 0);break}default:workInProgress2.memoizedState=null}return workInProgress2.child}function updatePortalComponent(current2,workInProgress2,renderLanes2){pushHostContainer(workInProgress2,workInProgress2.stateNode.containerInfo);var nextChildren=workInProgress2.pendingProps;return current2===null?workInProgress2.child=reconcileChildFibers(workInProgress2,null,nextChildren,renderLanes2):reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child}var hasWarnedAboutUsingNoValuePropOnContextProvider=!1;function updateContextProvider(current2,workInProgress2,renderLanes2){var providerType=workInProgress2.type,context2=providerType._context,newProps=workInProgress2.pendingProps,oldProps=workInProgress2.memoizedProps,newValue=newProps.value;{"value"in newProps||hasWarnedAboutUsingNoValuePropOnContextProvider||(hasWarnedAboutUsingNoValuePropOnContextProvider=!0,error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));var providerPropTypes=workInProgress2.type.propTypes;providerPropTypes&&checkPropTypes(providerPropTypes,newProps,"prop","Context.Provider")}if(pushProvider(workInProgress2,context2,newValue),oldProps!==null){var oldValue=oldProps.value;if(objectIs(oldValue,newValue)){if(oldProps.children===newProps.children&&!hasContextChanged())return bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2)}else propagateContextChange(workInProgress2,context2,renderLanes2)}var newChildren=newProps.children;return reconcileChildren(current2,workInProgress2,newChildren,renderLanes2),workInProgress2.child}var hasWarnedAboutUsingContextAsConsumer=!1;function updateContextConsumer(current2,workInProgress2,renderLanes2){var context2=workInProgress2.type;context2._context===void 0?context2!==context2.Consumer&&(hasWarnedAboutUsingContextAsConsumer||(hasWarnedAboutUsingContextAsConsumer=!0,error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))):context2=context2._context;var newProps=workInProgress2.pendingProps,render2=newProps.children;typeof render2!="function"&&error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."),prepareToReadContext(workInProgress2,renderLanes2);var newValue=readContext(context2);markComponentRenderStarted(workInProgress2);var newChildren;return ReactCurrentOwner$1.current=workInProgress2,setIsRendering(!0),newChildren=render2(newValue),setIsRendering(!1),markComponentRenderStopped(),workInProgress2.flags|=PerformedWork,reconcileChildren(current2,workInProgress2,newChildren,renderLanes2),workInProgress2.child}function markWorkInProgressReceivedUpdate(){didReceiveUpdate=!0}function resetSuspendedCurrentOnMountInLegacyMode(current2,workInProgress2){(workInProgress2.mode&ConcurrentMode)===NoMode&&current2!==null&&(current2.alternate=null,workInProgress2.alternate=null,workInProgress2.flags|=Placement)}function bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2){return current2!==null&&(workInProgress2.dependencies=current2.dependencies),stopProfilerTimerIfRunning(),markSkippedUpdateLanes(workInProgress2.lanes),includesSomeLane(renderLanes2,workInProgress2.childLanes)?(cloneChildFibers(current2,workInProgress2),workInProgress2.child):null}function remountFiber(current2,oldWorkInProgress,newWorkInProgress){{var returnFiber=oldWorkInProgress.return;if(returnFiber===null)throw new Error("Cannot swap the root fiber.");if(current2.alternate=null,oldWorkInProgress.alternate=null,newWorkInProgress.index=oldWorkInProgress.index,newWorkInProgress.sibling=oldWorkInProgress.sibling,newWorkInProgress.return=oldWorkInProgress.return,newWorkInProgress.ref=oldWorkInProgress.ref,oldWorkInProgress===returnFiber.child)returnFiber.child=newWorkInProgress;else{var prevSibling=returnFiber.child;if(prevSibling===null)throw new Error("Expected parent to have a child.");for(;prevSibling.sibling!==oldWorkInProgress;)if(prevSibling=prevSibling.sibling,prevSibling===null)throw new Error("Expected to find the previous sibling.");prevSibling.sibling=newWorkInProgress}var deletions=returnFiber.deletions;return deletions===null?(returnFiber.deletions=[current2],returnFiber.flags|=ChildDeletion):deletions.push(current2),newWorkInProgress.flags|=Placement,newWorkInProgress}}function checkScheduledUpdateOrContext(current2,renderLanes2){var updateLanes=current2.lanes;return!!includesSomeLane(updateLanes,renderLanes2)}function attemptEarlyBailoutIfNoScheduledUpdate(current2,workInProgress2,renderLanes2){switch(workInProgress2.tag){case HostRoot:pushHostRootContext(workInProgress2),workInProgress2.stateNode,resetHydrationState();break;case HostComponent:pushHostContext(workInProgress2);break;case ClassComponent:{var Component=workInProgress2.type;isContextProvider(Component)&&pushContextProvider(workInProgress2);break}case HostPortal:pushHostContainer(workInProgress2,workInProgress2.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress2.memoizedProps.value,context2=workInProgress2.type._context;pushProvider(workInProgress2,context2,newValue);break}case Profiler:{var hasChildWork=includesSomeLane(renderLanes2,workInProgress2.childLanes);hasChildWork&&(workInProgress2.flags|=Update);{var stateNode=workInProgress2.stateNode;stateNode.effectDuration=0,stateNode.passiveEffectDuration=0}}break;case SuspenseComponent:{var state=workInProgress2.memoizedState;if(state!==null){if(state.dehydrated!==null)return pushSuspenseContext(workInProgress2,setDefaultShallowSuspenseContext(suspenseStackCursor.current)),workInProgress2.flags|=DidCapture,null;var primaryChildFragment=workInProgress2.child,primaryChildLanes=primaryChildFragment.childLanes;if(includesSomeLane(renderLanes2,primaryChildLanes))return updateSuspenseComponent(current2,workInProgress2,renderLanes2);pushSuspenseContext(workInProgress2,setDefaultShallowSuspenseContext(suspenseStackCursor.current));var child=bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2);return child!==null?child.sibling:null}else pushSuspenseContext(workInProgress2,setDefaultShallowSuspenseContext(suspenseStackCursor.current));break}case SuspenseListComponent:{var didSuspendBefore=(current2.flags&DidCapture)!==NoFlags,_hasChildWork=includesSomeLane(renderLanes2,workInProgress2.childLanes);if(didSuspendBefore){if(_hasChildWork)return updateSuspenseListComponent(current2,workInProgress2,renderLanes2);workInProgress2.flags|=DidCapture}var renderState=workInProgress2.memoizedState;if(renderState!==null&&(renderState.rendering=null,renderState.tail=null,renderState.lastEffect=null),pushSuspenseContext(workInProgress2,suspenseStackCursor.current),_hasChildWork)break;return null}case OffscreenComponent:case LegacyHiddenComponent:return workInProgress2.lanes=NoLanes,updateOffscreenComponent(current2,workInProgress2,renderLanes2)}return bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2)}function beginWork(current2,workInProgress2,renderLanes2){if(workInProgress2._debugNeedsRemount&&current2!==null)return remountFiber(current2,workInProgress2,createFiberFromTypeAndProps(workInProgress2.type,workInProgress2.key,workInProgress2.pendingProps,workInProgress2._debugOwner||null,workInProgress2.mode,workInProgress2.lanes));if(current2!==null){var oldProps=current2.memoizedProps,newProps=workInProgress2.pendingProps;if(oldProps!==newProps||hasContextChanged()||workInProgress2.type!==current2.type)didReceiveUpdate=!0;else{var hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current2,renderLanes2);if(!hasScheduledUpdateOrContext&&(workInProgress2.flags&DidCapture)===NoFlags)return didReceiveUpdate=!1,attemptEarlyBailoutIfNoScheduledUpdate(current2,workInProgress2,renderLanes2);(current2.flags&ForceUpdateForLegacySuspense)!==NoFlags?didReceiveUpdate=!0:didReceiveUpdate=!1}}else if(didReceiveUpdate=!1,getIsHydrating()&&isForkedChild(workInProgress2)){var slotIndex=workInProgress2.index,numberOfForks=getForksAtLevel();pushTreeId(workInProgress2,numberOfForks,slotIndex)}switch(workInProgress2.lanes=NoLanes,workInProgress2.tag){case IndeterminateComponent:return mountIndeterminateComponent(current2,workInProgress2,workInProgress2.type,renderLanes2);case LazyComponent:{var elementType=workInProgress2.elementType;return mountLazyComponent(current2,workInProgress2,elementType,renderLanes2)}case FunctionComponent:{var Component=workInProgress2.type,unresolvedProps=workInProgress2.pendingProps,resolvedProps=workInProgress2.elementType===Component?unresolvedProps:resolveDefaultProps(Component,unresolvedProps);return updateFunctionComponent(current2,workInProgress2,Component,resolvedProps,renderLanes2)}case ClassComponent:{var _Component=workInProgress2.type,_unresolvedProps=workInProgress2.pendingProps,_resolvedProps=workInProgress2.elementType===_Component?_unresolvedProps:resolveDefaultProps(_Component,_unresolvedProps);return updateClassComponent(current2,workInProgress2,_Component,_resolvedProps,renderLanes2)}case HostRoot:return updateHostRoot(current2,workInProgress2,renderLanes2);case HostComponent:return updateHostComponent(current2,workInProgress2,renderLanes2);case HostText:return updateHostText(current2,workInProgress2);case SuspenseComponent:return updateSuspenseComponent(current2,workInProgress2,renderLanes2);case HostPortal:return updatePortalComponent(current2,workInProgress2,renderLanes2);case ForwardRef:{var type=workInProgress2.type,_unresolvedProps2=workInProgress2.pendingProps,_resolvedProps2=workInProgress2.elementType===type?_unresolvedProps2:resolveDefaultProps(type,_unresolvedProps2);return updateForwardRef(current2,workInProgress2,type,_resolvedProps2,renderLanes2)}case Fragment:return updateFragment(current2,workInProgress2,renderLanes2);case Mode:return updateMode(current2,workInProgress2,renderLanes2);case Profiler:return updateProfiler(current2,workInProgress2,renderLanes2);case ContextProvider:return updateContextProvider(current2,workInProgress2,renderLanes2);case ContextConsumer:return updateContextConsumer(current2,workInProgress2,renderLanes2);case MemoComponent:{var _type2=workInProgress2.type,_unresolvedProps3=workInProgress2.pendingProps,_resolvedProps3=resolveDefaultProps(_type2,_unresolvedProps3);if(workInProgress2.type!==workInProgress2.elementType){var outerPropTypes=_type2.propTypes;outerPropTypes&&checkPropTypes(outerPropTypes,_resolvedProps3,"prop",getComponentNameFromType(_type2))}return _resolvedProps3=resolveDefaultProps(_type2.type,_resolvedProps3),updateMemoComponent(current2,workInProgress2,_type2,_resolvedProps3,renderLanes2)}case SimpleMemoComponent:return updateSimpleMemoComponent(current2,workInProgress2,workInProgress2.type,workInProgress2.pendingProps,renderLanes2);case IncompleteClassComponent:{var _Component2=workInProgress2.type,_unresolvedProps4=workInProgress2.pendingProps,_resolvedProps4=workInProgress2.elementType===_Component2?_unresolvedProps4:resolveDefaultProps(_Component2,_unresolvedProps4);return mountIncompleteClassComponent(current2,workInProgress2,_Component2,_resolvedProps4,renderLanes2)}case SuspenseListComponent:return updateSuspenseListComponent(current2,workInProgress2,renderLanes2);case ScopeComponent:break;case OffscreenComponent:return updateOffscreenComponent(current2,workInProgress2,renderLanes2)}throw new Error("Unknown unit of work tag ("+workInProgress2.tag+"). This error is likely caused by a bug in React. Please file an issue.")}function markUpdate(workInProgress2){workInProgress2.flags|=Update}function markRef$1(workInProgress2){workInProgress2.flags|=Ref,workInProgress2.flags|=RefStatic}var appendAllChildren,updateHostContainer,updateHostComponent$1,updateHostText$1;appendAllChildren=function(parent,workInProgress2,needsVisibilityToggle,isHidden){for(var node=workInProgress2.child;node!==null;){if(node.tag===HostComponent||node.tag===HostText)appendInitialChild(parent,node.stateNode);else if(node.tag!==HostPortal){if(node.child!==null){node.child.return=node,node=node.child;continue}}if(node===workInProgress2)return;for(;node.sibling===null;){if(node.return===null||node.return===workInProgress2)return;node=node.return}node.sibling.return=node.return,node=node.sibling}},updateHostContainer=function(current2,workInProgress2){},updateHostComponent$1=function(current2,workInProgress2,type,newProps,rootContainerInstance){var oldProps=current2.memoizedProps;if(oldProps!==newProps){var instance=workInProgress2.stateNode,currentHostContext=getHostContext(),updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);workInProgress2.updateQueue=updatePayload,updatePayload&&markUpdate(workInProgress2)}},updateHostText$1=function(current2,workInProgress2,oldText,newText){oldText!==newText&&markUpdate(workInProgress2)};function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){if(!getIsHydrating())switch(renderState.tailMode){case"hidden":{for(var tailNode=renderState.tail,lastTailNode=null;tailNode!==null;)tailNode.alternate!==null&&(lastTailNode=tailNode),tailNode=tailNode.sibling;lastTailNode===null?renderState.tail=null:lastTailNode.sibling=null;break}case"collapsed":{for(var _tailNode=renderState.tail,_lastTailNode=null;_tailNode!==null;)_tailNode.alternate!==null&&(_lastTailNode=_tailNode),_tailNode=_tailNode.sibling;_lastTailNode===null?!hasRenderedATailFallback&&renderState.tail!==null?renderState.tail.sibling=null:renderState.tail=null:_lastTailNode.sibling=null;break}}}function bubbleProperties(completedWork){var didBailout=completedWork.alternate!==null&&completedWork.alternate.child===completedWork.child,newChildLanes=NoLanes,subtreeFlags=NoFlags;if(didBailout){if((completedWork.mode&ProfileMode)!==NoMode){for(var _treeBaseDuration=completedWork.selfBaseDuration,_child2=completedWork.child;_child2!==null;)newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child2.lanes,_child2.childLanes)),subtreeFlags|=_child2.subtreeFlags&StaticMask,subtreeFlags|=_child2.flags&StaticMask,_treeBaseDuration+=_child2.treeBaseDuration,_child2=_child2.sibling;completedWork.treeBaseDuration=_treeBaseDuration}else for(var _child3=completedWork.child;_child3!==null;)newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child3.lanes,_child3.childLanes)),subtreeFlags|=_child3.subtreeFlags&StaticMask,subtreeFlags|=_child3.flags&StaticMask,_child3.return=completedWork,_child3=_child3.sibling;completedWork.subtreeFlags|=subtreeFlags}else{if((completedWork.mode&ProfileMode)!==NoMode){for(var actualDuration=completedWork.actualDuration,treeBaseDuration=completedWork.selfBaseDuration,child=completedWork.child;child!==null;)newChildLanes=mergeLanes(newChildLanes,mergeLanes(child.lanes,child.childLanes)),subtreeFlags|=child.subtreeFlags,subtreeFlags|=child.flags,actualDuration+=child.actualDuration,treeBaseDuration+=child.treeBaseDuration,child=child.sibling;completedWork.actualDuration=actualDuration,completedWork.treeBaseDuration=treeBaseDuration}else for(var _child=completedWork.child;_child!==null;)newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child.lanes,_child.childLanes)),subtreeFlags|=_child.subtreeFlags,subtreeFlags|=_child.flags,_child.return=completedWork,_child=_child.sibling;completedWork.subtreeFlags|=subtreeFlags}return completedWork.childLanes=newChildLanes,didBailout}function completeDehydratedSuspenseBoundary(current2,workInProgress2,nextState){if(hasUnhydratedTailNodes()&&(workInProgress2.mode&ConcurrentMode)!==NoMode&&(workInProgress2.flags&DidCapture)===NoFlags)return warnIfUnhydratedTailNodes(workInProgress2),resetHydrationState(),workInProgress2.flags|=ForceClientRender|Incomplete|ShouldCapture,!1;var wasHydrated=popHydrationState(workInProgress2);if(nextState!==null&&nextState.dehydrated!==null)if(current2===null){if(!wasHydrated)throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");if(prepareToHydrateHostSuspenseInstance(workInProgress2),bubbleProperties(workInProgress2),(workInProgress2.mode&ProfileMode)!==NoMode){var isTimedOutSuspense=nextState!==null;if(isTimedOutSuspense){var primaryChildFragment=workInProgress2.child;primaryChildFragment!==null&&(workInProgress2.treeBaseDuration-=primaryChildFragment.treeBaseDuration)}}return!1}else{if(resetHydrationState(),(workInProgress2.flags&DidCapture)===NoFlags&&(workInProgress2.memoizedState=null),workInProgress2.flags|=Update,bubbleProperties(workInProgress2),(workInProgress2.mode&ProfileMode)!==NoMode){var _isTimedOutSuspense=nextState!==null;if(_isTimedOutSuspense){var _primaryChildFragment=workInProgress2.child;_primaryChildFragment!==null&&(workInProgress2.treeBaseDuration-=_primaryChildFragment.treeBaseDuration)}}return!1}else return upgradeHydrationErrorsToRecoverable(),!0}function completeWork(current2,workInProgress2,renderLanes2){var newProps=workInProgress2.pendingProps;switch(popTreeContext(workInProgress2),workInProgress2.tag){case IndeterminateComponent:case LazyComponent:case SimpleMemoComponent:case FunctionComponent:case ForwardRef:case Fragment:case Mode:case Profiler:case ContextConsumer:case MemoComponent:return bubbleProperties(workInProgress2),null;case ClassComponent:{var Component=workInProgress2.type;return isContextProvider(Component)&&popContext(workInProgress2),bubbleProperties(workInProgress2),null}case HostRoot:{var fiberRoot=workInProgress2.stateNode;if(popHostContainer(workInProgress2),popTopLevelContextObject(workInProgress2),resetWorkInProgressVersions(),fiberRoot.pendingContext&&(fiberRoot.context=fiberRoot.pendingContext,fiberRoot.pendingContext=null),current2===null||current2.child===null){var wasHydrated=popHydrationState(workInProgress2);if(wasHydrated)markUpdate(workInProgress2);else if(current2!==null){var prevState=current2.memoizedState;(!prevState.isDehydrated||(workInProgress2.flags&ForceClientRender)!==NoFlags)&&(workInProgress2.flags|=Snapshot,upgradeHydrationErrorsToRecoverable())}}return updateHostContainer(current2,workInProgress2),bubbleProperties(workInProgress2),null}case HostComponent:{popHostContext(workInProgress2);var rootContainerInstance=getRootHostContainer(),type=workInProgress2.type;if(current2!==null&&workInProgress2.stateNode!=null)updateHostComponent$1(current2,workInProgress2,type,newProps,rootContainerInstance),current2.ref!==workInProgress2.ref&&markRef$1(workInProgress2);else{if(!newProps){if(workInProgress2.stateNode===null)throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");return bubbleProperties(workInProgress2),null}var currentHostContext=getHostContext(),_wasHydrated=popHydrationState(workInProgress2);if(_wasHydrated)prepareToHydrateHostInstance(workInProgress2,rootContainerInstance,currentHostContext)&&markUpdate(workInProgress2);else{var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress2);appendAllChildren(instance,workInProgress2,!1,!1),workInProgress2.stateNode=instance,finalizeInitialChildren(instance,type,newProps,rootContainerInstance)&&markUpdate(workInProgress2)}workInProgress2.ref!==null&&markRef$1(workInProgress2)}return bubbleProperties(workInProgress2),null}case HostText:{var newText=newProps;if(current2&&workInProgress2.stateNode!=null){var oldText=current2.memoizedProps;updateHostText$1(current2,workInProgress2,oldText,newText)}else{if(typeof newText!="string"&&workInProgress2.stateNode===null)throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");var _rootContainerInstance=getRootHostContainer(),_currentHostContext=getHostContext(),_wasHydrated2=popHydrationState(workInProgress2);_wasHydrated2?prepareToHydrateHostTextInstance(workInProgress2)&&markUpdate(workInProgress2):workInProgress2.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress2)}return bubbleProperties(workInProgress2),null}case SuspenseComponent:{popSuspenseContext(workInProgress2);var nextState=workInProgress2.memoizedState;if(current2===null||current2.memoizedState!==null&&current2.memoizedState.dehydrated!==null){var fallthroughToNormalSuspensePath=completeDehydratedSuspenseBoundary(current2,workInProgress2,nextState);if(!fallthroughToNormalSuspensePath)return workInProgress2.flags&ShouldCapture?workInProgress2:null}if((workInProgress2.flags&DidCapture)!==NoFlags)return workInProgress2.lanes=renderLanes2,(workInProgress2.mode&ProfileMode)!==NoMode&&transferActualDuration(workInProgress2),workInProgress2;var nextDidTimeout=nextState!==null,prevDidTimeout=current2!==null&&current2.memoizedState!==null;if(nextDidTimeout!==prevDidTimeout&&nextDidTimeout){var _offscreenFiber2=workInProgress2.child;if(_offscreenFiber2.flags|=Visibility,(workInProgress2.mode&ConcurrentMode)!==NoMode){var hasInvisibleChildContext=current2===null&&(workInProgress2.memoizedProps.unstable_avoidThisFallback!==!0||!enableSuspenseAvoidThisFallback);hasInvisibleChildContext||hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext)?renderDidSuspend():renderDidSuspendDelayIfPossible()}}var wakeables=workInProgress2.updateQueue;if(wakeables!==null&&(workInProgress2.flags|=Update),bubbleProperties(workInProgress2),(workInProgress2.mode&ProfileMode)!==NoMode&&nextDidTimeout){var primaryChildFragment=workInProgress2.child;primaryChildFragment!==null&&(workInProgress2.treeBaseDuration-=primaryChildFragment.treeBaseDuration)}return null}case HostPortal:return popHostContainer(workInProgress2),updateHostContainer(current2,workInProgress2),current2===null&&preparePortalMount(workInProgress2.stateNode.containerInfo),bubbleProperties(workInProgress2),null;case ContextProvider:var context2=workInProgress2.type._context;return popProvider(context2,workInProgress2),bubbleProperties(workInProgress2),null;case IncompleteClassComponent:{var _Component=workInProgress2.type;return isContextProvider(_Component)&&popContext(workInProgress2),bubbleProperties(workInProgress2),null}case SuspenseListComponent:{popSuspenseContext(workInProgress2);var renderState=workInProgress2.memoizedState;if(renderState===null)return bubbleProperties(workInProgress2),null;var didSuspendAlready=(workInProgress2.flags&DidCapture)!==NoFlags,renderedTail=renderState.rendering;if(renderedTail===null)if(didSuspendAlready)cutOffTailIfNeeded(renderState,!1);else{var cannotBeSuspended=renderHasNotSuspendedYet()&&(current2===null||(current2.flags&DidCapture)===NoFlags);if(!cannotBeSuspended)for(var row=workInProgress2.child;row!==null;){var suspended=findFirstSuspended(row);if(suspended!==null){didSuspendAlready=!0,workInProgress2.flags|=DidCapture,cutOffTailIfNeeded(renderState,!1);var newThenables=suspended.updateQueue;return newThenables!==null&&(workInProgress2.updateQueue=newThenables,workInProgress2.flags|=Update),workInProgress2.subtreeFlags=NoFlags,resetChildFibers(workInProgress2,renderLanes2),pushSuspenseContext(workInProgress2,setShallowSuspenseContext(suspenseStackCursor.current,ForceSuspenseFallback)),workInProgress2.child}row=row.sibling}renderState.tail!==null&&now2()>getRenderTargetTime()&&(workInProgress2.flags|=DidCapture,didSuspendAlready=!0,cutOffTailIfNeeded(renderState,!1),workInProgress2.lanes=SomeRetryLane)}else{if(!didSuspendAlready){var _suspended=findFirstSuspended(renderedTail);if(_suspended!==null){workInProgress2.flags|=DidCapture,didSuspendAlready=!0;var _newThenables=_suspended.updateQueue;if(_newThenables!==null&&(workInProgress2.updateQueue=_newThenables,workInProgress2.flags|=Update),cutOffTailIfNeeded(renderState,!0),renderState.tail===null&&renderState.tailMode==="hidden"&&!renderedTail.alternate&&!getIsHydrating())return bubbleProperties(workInProgress2),null}else now2()*2-renderState.renderingStartTime>getRenderTargetTime()&&renderLanes2!==OffscreenLane&&(workInProgress2.flags|=DidCapture,didSuspendAlready=!0,cutOffTailIfNeeded(renderState,!1),workInProgress2.lanes=SomeRetryLane)}if(renderState.isBackwards)renderedTail.sibling=workInProgress2.child,workInProgress2.child=renderedTail;else{var previousSibling=renderState.last;previousSibling!==null?previousSibling.sibling=renderedTail:workInProgress2.child=renderedTail,renderState.last=renderedTail}}if(renderState.tail!==null){var next=renderState.tail;renderState.rendering=next,renderState.tail=next.sibling,renderState.renderingStartTime=now2(),next.sibling=null;var suspenseContext=suspenseStackCursor.current;return didSuspendAlready?suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback):suspenseContext=setDefaultShallowSuspenseContext(suspenseContext),pushSuspenseContext(workInProgress2,suspenseContext),next}return bubbleProperties(workInProgress2),null}case ScopeComponent:break;case OffscreenComponent:case LegacyHiddenComponent:{popRenderLanes(workInProgress2);var _nextState=workInProgress2.memoizedState,nextIsHidden=_nextState!==null;if(current2!==null){var _prevState=current2.memoizedState,prevIsHidden=_prevState!==null;prevIsHidden!==nextIsHidden&&!enableLegacyHidden&&(workInProgress2.flags|=Visibility)}return!nextIsHidden||(workInProgress2.mode&ConcurrentMode)===NoMode?bubbleProperties(workInProgress2):includesSomeLane(subtreeRenderLanes,OffscreenLane)&&(bubbleProperties(workInProgress2),workInProgress2.subtreeFlags&(Placement|Update)&&(workInProgress2.flags|=Visibility)),null}case CacheComponent:return null;case TracingMarkerComponent:return null}throw new Error("Unknown unit of work tag ("+workInProgress2.tag+"). This error is likely caused by a bug in React. Please file an issue.")}function unwindWork(current2,workInProgress2,renderLanes2){switch(popTreeContext(workInProgress2),workInProgress2.tag){case ClassComponent:{var Component=workInProgress2.type;isContextProvider(Component)&&popContext(workInProgress2);var flags=workInProgress2.flags;return flags&ShouldCapture?(workInProgress2.flags=flags&~ShouldCapture|DidCapture,(workInProgress2.mode&ProfileMode)!==NoMode&&transferActualDuration(workInProgress2),workInProgress2):null}case HostRoot:{workInProgress2.stateNode,popHostContainer(workInProgress2),popTopLevelContextObject(workInProgress2),resetWorkInProgressVersions();var _flags=workInProgress2.flags;return(_flags&ShouldCapture)!==NoFlags&&(_flags&DidCapture)===NoFlags?(workInProgress2.flags=_flags&~ShouldCapture|DidCapture,workInProgress2):null}case HostComponent:return popHostContext(workInProgress2),null;case SuspenseComponent:{popSuspenseContext(workInProgress2);var suspenseState=workInProgress2.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){if(workInProgress2.alternate===null)throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");resetHydrationState()}var _flags2=workInProgress2.flags;return _flags2&ShouldCapture?(workInProgress2.flags=_flags2&~ShouldCapture|DidCapture,(workInProgress2.mode&ProfileMode)!==NoMode&&transferActualDuration(workInProgress2),workInProgress2):null}case SuspenseListComponent:return popSuspenseContext(workInProgress2),null;case HostPortal:return popHostContainer(workInProgress2),null;case ContextProvider:var context2=workInProgress2.type._context;return popProvider(context2,workInProgress2),null;case OffscreenComponent:case LegacyHiddenComponent:return popRenderLanes(workInProgress2),null;case CacheComponent:return null;default:return null}}function unwindInterruptedWork(current2,interruptedWork,renderLanes2){switch(popTreeContext(interruptedWork),interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;childContextTypes!=null&&popContext(interruptedWork);break}case HostRoot:{interruptedWork.stateNode,popHostContainer(interruptedWork),popTopLevelContextObject(interruptedWork),resetWorkInProgressVersions();break}case HostComponent:{popHostContext(interruptedWork);break}case HostPortal:popHostContainer(interruptedWork);break;case SuspenseComponent:popSuspenseContext(interruptedWork);break;case SuspenseListComponent:popSuspenseContext(interruptedWork);break;case ContextProvider:var context2=interruptedWork.type._context;popProvider(context2,interruptedWork);break;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(interruptedWork);break}}var didWarnAboutUndefinedSnapshotBeforeUpdate=null;didWarnAboutUndefinedSnapshotBeforeUpdate=new Set;var offscreenSubtreeIsHidden=!1,offscreenSubtreeWasHidden=!1,PossiblyWeakSet=typeof WeakSet=="function"?WeakSet:Set,nextEffect=null,inProgressLanes=null,inProgressRoot=null;function reportUncaughtErrorInDEV(error2){invokeGuardedCallback(null,function(){throw error2}),clearCaughtError()}var callComponentWillUnmountWithTimer=function(current2,instance){if(instance.props=current2.memoizedProps,instance.state=current2.memoizedState,current2.mode&ProfileMode)try{startLayoutEffectTimer(),instance.componentWillUnmount()}finally{recordLayoutEffectDuration(current2)}else instance.componentWillUnmount()};function safelyCallCommitHookLayoutEffectListMount(current2,nearestMountedAncestor){try{commitHookEffectListMount(Layout,current2)}catch(error2){captureCommitPhaseError(current2,nearestMountedAncestor,error2)}}function safelyCallComponentWillUnmount(current2,nearestMountedAncestor,instance){try{callComponentWillUnmountWithTimer(current2,instance)}catch(error2){captureCommitPhaseError(current2,nearestMountedAncestor,error2)}}function safelyCallComponentDidMount(current2,nearestMountedAncestor,instance){try{instance.componentDidMount()}catch(error2){captureCommitPhaseError(current2,nearestMountedAncestor,error2)}}function safelyAttachRef(current2,nearestMountedAncestor){try{commitAttachRef(current2)}catch(error2){captureCommitPhaseError(current2,nearestMountedAncestor,error2)}}function safelyDetachRef(current2,nearestMountedAncestor){var ref=current2.ref;if(ref!==null)if(typeof ref=="function"){var retVal;try{if(enableProfilerTimer&&enableProfilerCommitHooks&&current2.mode&ProfileMode)try{startLayoutEffectTimer(),retVal=ref(null)}finally{recordLayoutEffectDuration(current2)}else retVal=ref(null)}catch(error2){captureCommitPhaseError(current2,nearestMountedAncestor,error2)}typeof retVal=="function"&&error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.",getComponentNameFromFiber(current2))}else ref.current=null}function safelyCallDestroy(current2,nearestMountedAncestor,destroy){try{destroy()}catch(error2){captureCommitPhaseError(current2,nearestMountedAncestor,error2)}}var shouldFireAfterActiveInstanceBlur=!1;function commitBeforeMutationEffects(root2,firstChild){prepareForCommit(root2.containerInfo),nextEffect=firstChild,commitBeforeMutationEffects_begin();var shouldFire=shouldFireAfterActiveInstanceBlur;return shouldFireAfterActiveInstanceBlur=!1,shouldFire}function commitBeforeMutationEffects_begin(){for(;nextEffect!==null;){var fiber=nextEffect,child=fiber.child;(fiber.subtreeFlags&BeforeMutationMask)!==NoFlags&&child!==null?(child.return=fiber,nextEffect=child):commitBeforeMutationEffects_complete()}}function commitBeforeMutationEffects_complete(){for(;nextEffect!==null;){var fiber=nextEffect;setCurrentFiber(fiber);try{commitBeforeMutationEffectsOnFiber(fiber)}catch(error2){captureCommitPhaseError(fiber,fiber.return,error2)}resetCurrentFiber();var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return,nextEffect=sibling;return}nextEffect=fiber.return}}function commitBeforeMutationEffectsOnFiber(finishedWork){var current2=finishedWork.alternate,flags=finishedWork.flags;if((flags&Snapshot)!==NoFlags){switch(setCurrentFiber(finishedWork),finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:break;case ClassComponent:{if(current2!==null){var prevProps=current2.memoizedProps,prevState=current2.memoizedState,instance=finishedWork.stateNode;finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps&&(instance.props!==finishedWork.memoizedProps&&error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance"),instance.state!==finishedWork.memoizedState&&error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance"));var snapshot=instance.getSnapshotBeforeUpdate(finishedWork.elementType===finishedWork.type?prevProps:resolveDefaultProps(finishedWork.type,prevProps),prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;snapshot===void 0&&!didWarnSet.has(finishedWork.type)&&(didWarnSet.add(finishedWork.type),error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",getComponentNameFromFiber(finishedWork)))}instance.__reactInternalSnapshotBeforeUpdate=snapshot}break}case HostRoot:{{var root2=finishedWork.stateNode;clearContainer(root2.containerInfo)}break}case HostComponent:case HostText:case HostPortal:case IncompleteClassComponent:break;default:throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.")}resetCurrentFiber()}}function commitHookEffectListUnmount(flags,finishedWork,nearestMountedAncestor){var updateQueue=finishedWork.updateQueue,lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next,effect=firstEffect;do{if((effect.tag&flags)===flags){var destroy=effect.destroy;effect.destroy=void 0,destroy!==void 0&&((flags&Passive$1)!==NoFlags$1?markComponentPassiveEffectUnmountStarted(finishedWork):(flags&Layout)!==NoFlags$1&&markComponentLayoutEffectUnmountStarted(finishedWork),(flags&Insertion)!==NoFlags$1&&setIsRunningInsertionEffect(!0),safelyCallDestroy(finishedWork,nearestMountedAncestor,destroy),(flags&Insertion)!==NoFlags$1&&setIsRunningInsertionEffect(!1),(flags&Passive$1)!==NoFlags$1?markComponentPassiveEffectUnmountStopped():(flags&Layout)!==NoFlags$1&&markComponentLayoutEffectUnmountStopped())}effect=effect.next}while(effect!==firstEffect)}}function commitHookEffectListMount(flags,finishedWork){var updateQueue=finishedWork.updateQueue,lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next,effect=firstEffect;do{if((effect.tag&flags)===flags){(flags&Passive$1)!==NoFlags$1?markComponentPassiveEffectMountStarted(finishedWork):(flags&Layout)!==NoFlags$1&&markComponentLayoutEffectMountStarted(finishedWork);var create2=effect.create;(flags&Insertion)!==NoFlags$1&&setIsRunningInsertionEffect(!0),effect.destroy=create2(),(flags&Insertion)!==NoFlags$1&&setIsRunningInsertionEffect(!1),(flags&Passive$1)!==NoFlags$1?markComponentPassiveEffectMountStopped():(flags&Layout)!==NoFlags$1&&markComponentLayoutEffectMountStopped();{var destroy=effect.destroy;if(destroy!==void 0&&typeof destroy!="function"){var hookName=void 0;(effect.tag&Layout)!==NoFlags?hookName="useLayoutEffect":(effect.tag&Insertion)!==NoFlags?hookName="useInsertionEffect":hookName="useEffect";var addendum=void 0;destroy===null?addendum=" You returned null. If your effect does not require clean up, return undefined (or nothing).":typeof destroy.then=="function"?addendum=`

It looks like you wrote `+hookName+`(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

`+hookName+`(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching`:addendum=" You returned: "+destroy,error("%s must not return anything besides a function, which is used for clean-up.%s",hookName,addendum)}}}effect=effect.next}while(effect!==firstEffect)}}function commitPassiveEffectDurations(finishedRoot,finishedWork){if((finishedWork.flags&Update)!==NoFlags)switch(finishedWork.tag){case Profiler:{var passiveEffectDuration=finishedWork.stateNode.passiveEffectDuration,_finishedWork$memoize=finishedWork.memoizedProps,id2=_finishedWork$memoize.id,onPostCommit=_finishedWork$memoize.onPostCommit,commitTime2=getCommitTime(),phase=finishedWork.alternate===null?"mount":"update";isCurrentUpdateNested()&&(phase="nested-update"),typeof onPostCommit=="function"&&onPostCommit(id2,phase,passiveEffectDuration,commitTime2);var parentFiber=finishedWork.return;outer:for(;parentFiber!==null;){switch(parentFiber.tag){case HostRoot:var root2=parentFiber.stateNode;root2.passiveEffectDuration+=passiveEffectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.passiveEffectDuration+=passiveEffectDuration;break outer}parentFiber=parentFiber.return}break}}}function commitLayoutEffectOnFiber(finishedRoot,current2,finishedWork,committedLanes){if((finishedWork.flags&LayoutMask)!==NoFlags)switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden)if(finishedWork.mode&ProfileMode)try{startLayoutEffectTimer(),commitHookEffectListMount(Layout|HasEffect,finishedWork)}finally{recordLayoutEffectDuration(finishedWork)}else commitHookEffectListMount(Layout|HasEffect,finishedWork);break}case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.flags&Update&&!offscreenSubtreeWasHidden)if(current2===null)if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps&&(instance.props!==finishedWork.memoizedProps&&error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance"),instance.state!==finishedWork.memoizedState&&error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance")),finishedWork.mode&ProfileMode)try{startLayoutEffectTimer(),instance.componentDidMount()}finally{recordLayoutEffectDuration(finishedWork)}else instance.componentDidMount();else{var prevProps=finishedWork.elementType===finishedWork.type?current2.memoizedProps:resolveDefaultProps(finishedWork.type,current2.memoizedProps),prevState=current2.memoizedState;if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps&&(instance.props!==finishedWork.memoizedProps&&error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance"),instance.state!==finishedWork.memoizedState&&error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance")),finishedWork.mode&ProfileMode)try{startLayoutEffectTimer(),instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate)}finally{recordLayoutEffectDuration(finishedWork)}else instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate)}var updateQueue=finishedWork.updateQueue;updateQueue!==null&&(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps&&(instance.props!==finishedWork.memoizedProps&&error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance"),instance.state!==finishedWork.memoizedState&&error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance")),commitUpdateQueue(finishedWork,updateQueue,instance));break}case HostRoot:{var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null)switch(finishedWork.child.tag){case HostComponent:_instance=finishedWork.child.stateNode;break;case ClassComponent:_instance=finishedWork.child.stateNode;break}commitUpdateQueue(finishedWork,_updateQueue,_instance)}break}case HostComponent:{var _instance2=finishedWork.stateNode;if(current2===null&&finishedWork.flags&Update){var type=finishedWork.type,props=finishedWork.memoizedProps;commitMount(_instance2,type,props)}break}case HostText:break;case HostPortal:break;case Profiler:{{var _finishedWork$memoize2=finishedWork.memoizedProps,onCommit=_finishedWork$memoize2.onCommit,onRender=_finishedWork$memoize2.onRender,effectDuration=finishedWork.stateNode.effectDuration,commitTime2=getCommitTime(),phase=current2===null?"mount":"update";isCurrentUpdateNested()&&(phase="nested-update"),typeof onRender=="function"&&onRender(finishedWork.memoizedProps.id,phase,finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,commitTime2);{typeof onCommit=="function"&&onCommit(finishedWork.memoizedProps.id,phase,effectDuration,commitTime2),enqueuePendingPassiveProfilerEffect(finishedWork);var parentFiber=finishedWork.return;outer:for(;parentFiber!==null;){switch(parentFiber.tag){case HostRoot:var root2=parentFiber.stateNode;root2.effectDuration+=effectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=effectDuration;break outer}parentFiber=parentFiber.return}}}break}case SuspenseComponent:{commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);break}case SuspenseListComponent:case IncompleteClassComponent:case ScopeComponent:case OffscreenComponent:case LegacyHiddenComponent:case TracingMarkerComponent:break;default:throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.")}offscreenSubtreeWasHidden||finishedWork.flags&Ref&&commitAttachRef(finishedWork)}function reappearLayoutEffectsOnFiber(node){switch(node.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(node.mode&ProfileMode)try{startLayoutEffectTimer(),safelyCallCommitHookLayoutEffectListMount(node,node.return)}finally{recordLayoutEffectDuration(node)}else safelyCallCommitHookLayoutEffectListMount(node,node.return);break}case ClassComponent:{var instance=node.stateNode;typeof instance.componentDidMount=="function"&&safelyCallComponentDidMount(node,node.return,instance),safelyAttachRef(node,node.return);break}case HostComponent:{safelyAttachRef(node,node.return);break}}}function hideOrUnhideAllChildren(finishedWork,isHidden){for(var hostSubtreeRoot=null,node=finishedWork;;){if(node.tag===HostComponent){if(hostSubtreeRoot===null){hostSubtreeRoot=node;try{var instance=node.stateNode;isHidden?hideInstance(instance):unhideInstance(node.stateNode,node.memoizedProps)}catch(error2){captureCommitPhaseError(finishedWork,finishedWork.return,error2)}}}else if(node.tag===HostText){if(hostSubtreeRoot===null)try{var _instance3=node.stateNode;isHidden?hideTextInstance(_instance3):unhideTextInstance(_instance3,node.memoizedProps)}catch(error2){captureCommitPhaseError(finishedWork,finishedWork.return,error2)}}else if(!((node.tag===OffscreenComponent||node.tag===LegacyHiddenComponent)&&node.memoizedState!==null&&node!==finishedWork)){if(node.child!==null){node.child.return=node,node=node.child;continue}}if(node===finishedWork)return;for(;node.sibling===null;){if(node.return===null||node.return===finishedWork)return;hostSubtreeRoot===node&&(hostSubtreeRoot=null),node=node.return}hostSubtreeRoot===node&&(hostSubtreeRoot=null),node.sibling.return=node.return,node=node.sibling}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode,instanceToUse;switch(finishedWork.tag){case HostComponent:instanceToUse=instance;break;default:instanceToUse=instance}if(typeof ref=="function"){var retVal;if(finishedWork.mode&ProfileMode)try{startLayoutEffectTimer(),retVal=ref(instanceToUse)}finally{recordLayoutEffectDuration(finishedWork)}else retVal=ref(instanceToUse);typeof retVal=="function"&&error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.",getComponentNameFromFiber(finishedWork))}else ref.hasOwnProperty("current")||error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",getComponentNameFromFiber(finishedWork)),ref.current=instanceToUse}}function detachFiberMutation(fiber){var alternate=fiber.alternate;alternate!==null&&(alternate.return=null),fiber.return=null}function detachFiberAfterEffects(fiber){var alternate=fiber.alternate;alternate!==null&&(fiber.alternate=null,detachFiberAfterEffects(alternate));{if(fiber.child=null,fiber.deletions=null,fiber.sibling=null,fiber.tag===HostComponent){var hostInstance=fiber.stateNode;hostInstance!==null&&detachDeletedInstance(hostInstance)}fiber.stateNode=null,fiber._debugOwner=null,fiber.return=null,fiber.dependencies=null,fiber.memoizedProps=null,fiber.memoizedState=null,fiber.pendingProps=null,fiber.stateNode=null,fiber.updateQueue=null}}function getHostParentFiber(fiber){for(var parent=fiber.return;parent!==null;){if(isHostParent(parent))return parent;parent=parent.return}throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.")}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal}function getHostSibling(fiber){var node=fiber;siblings:for(;;){for(;node.sibling===null;){if(node.return===null||isHostParent(node.return))return null;node=node.return}for(node.sibling.return=node.return,node=node.sibling;node.tag!==HostComponent&&node.tag!==HostText&&node.tag!==DehydratedFragment;){if(node.flags&Placement||node.child===null||node.tag===HostPortal)continue siblings;node.child.return=node,node=node.child}if(!(node.flags&Placement))return node.stateNode}}function commitPlacement(finishedWork){var parentFiber=getHostParentFiber(finishedWork);switch(parentFiber.tag){case HostComponent:{var parent=parentFiber.stateNode;parentFiber.flags&ContentReset&&(resetTextContent(parent),parentFiber.flags&=~ContentReset);var before=getHostSibling(finishedWork);insertOrAppendPlacementNode(finishedWork,before,parent);break}case HostRoot:case HostPortal:{var _parent=parentFiber.stateNode.containerInfo,_before=getHostSibling(finishedWork);insertOrAppendPlacementNodeIntoContainer(finishedWork,_before,_parent);break}default:throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.")}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag,isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;before?insertInContainerBefore(parent,stateNode,before):appendChildToContainer(parent,stateNode)}else if(tag!==HostPortal){var child=node.child;if(child!==null){insertOrAppendPlacementNodeIntoContainer(child,before,parent);for(var sibling=child.sibling;sibling!==null;)insertOrAppendPlacementNodeIntoContainer(sibling,before,parent),sibling=sibling.sibling}}}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag,isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;before?insertBefore(parent,stateNode,before):appendChild(parent,stateNode)}else if(tag!==HostPortal){var child=node.child;if(child!==null){insertOrAppendPlacementNode(child,before,parent);for(var sibling=child.sibling;sibling!==null;)insertOrAppendPlacementNode(sibling,before,parent),sibling=sibling.sibling}}}var hostParent=null,hostParentIsContainer=!1;function commitDeletionEffects(root2,returnFiber,deletedFiber){{var parent=returnFiber;findParent:for(;parent!==null;){switch(parent.tag){case HostComponent:{hostParent=parent.stateNode,hostParentIsContainer=!1;break findParent}case HostRoot:{hostParent=parent.stateNode.containerInfo,hostParentIsContainer=!0;break findParent}case HostPortal:{hostParent=parent.stateNode.containerInfo,hostParentIsContainer=!0;break findParent}}parent=parent.return}if(hostParent===null)throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");commitDeletionEffectsOnFiber(root2,returnFiber,deletedFiber),hostParent=null,hostParentIsContainer=!1}detachFiberMutation(deletedFiber)}function recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,parent){for(var child=parent.child;child!==null;)commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,child),child=child.sibling}function commitDeletionEffectsOnFiber(finishedRoot,nearestMountedAncestor,deletedFiber){switch(onCommitUnmount(deletedFiber),deletedFiber.tag){case HostComponent:offscreenSubtreeWasHidden||safelyDetachRef(deletedFiber,nearestMountedAncestor);case HostText:{{var prevHostParent=hostParent,prevHostParentIsContainer=hostParentIsContainer;hostParent=null,recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber),hostParent=prevHostParent,hostParentIsContainer=prevHostParentIsContainer,hostParent!==null&&(hostParentIsContainer?removeChildFromContainer(hostParent,deletedFiber.stateNode):removeChild(hostParent,deletedFiber.stateNode))}return}case DehydratedFragment:{hostParent!==null&&(hostParentIsContainer?clearSuspenseBoundaryFromContainer(hostParent,deletedFiber.stateNode):clearSuspenseBoundary(hostParent,deletedFiber.stateNode));return}case HostPortal:{{var _prevHostParent=hostParent,_prevHostParentIsContainer=hostParentIsContainer;hostParent=deletedFiber.stateNode.containerInfo,hostParentIsContainer=!0,recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber),hostParent=_prevHostParent,hostParentIsContainer=_prevHostParentIsContainer}return}case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden){var updateQueue=deletedFiber.updateQueue;if(updateQueue!==null){var lastEffect=updateQueue.lastEffect;if(lastEffect!==null){var firstEffect=lastEffect.next,effect=firstEffect;do{var _effect=effect,destroy=_effect.destroy,tag=_effect.tag;destroy!==void 0&&((tag&Insertion)!==NoFlags$1?safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy):(tag&Layout)!==NoFlags$1&&(markComponentLayoutEffectUnmountStarted(deletedFiber),deletedFiber.mode&ProfileMode?(startLayoutEffectTimer(),safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy),recordLayoutEffectDuration(deletedFiber)):safelyCallDestroy(deletedFiber,nearestMountedAncestor,destroy),markComponentLayoutEffectUnmountStopped())),effect=effect.next}while(effect!==firstEffect)}}}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return}case ClassComponent:{if(!offscreenSubtreeWasHidden){safelyDetachRef(deletedFiber,nearestMountedAncestor);var instance=deletedFiber.stateNode;typeof instance.componentWillUnmount=="function"&&safelyCallComponentWillUnmount(deletedFiber,nearestMountedAncestor,instance)}recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return}case ScopeComponent:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return}case OffscreenComponent:{if(deletedFiber.mode&ConcurrentMode){var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||deletedFiber.memoizedState!==null,recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber),offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden}else recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);break}default:{recursivelyTraverseDeletionEffects(finishedRoot,nearestMountedAncestor,deletedFiber);return}}}function commitSuspenseCallback(finishedWork){finishedWork.memoizedState}function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork){var newState=finishedWork.memoizedState;if(newState===null){var current2=finishedWork.alternate;if(current2!==null){var prevState=current2.memoizedState;if(prevState!==null){var suspenseInstance=prevState.dehydrated;suspenseInstance!==null&&commitHydratedSuspenseInstance(suspenseInstance)}}}}function attachSuspenseRetryListeners(finishedWork){var wakeables=finishedWork.updateQueue;if(wakeables!==null){finishedWork.updateQueue=null;var retryCache=finishedWork.stateNode;retryCache===null&&(retryCache=finishedWork.stateNode=new PossiblyWeakSet),wakeables.forEach(function(wakeable){var retry=resolveRetryWakeable.bind(null,finishedWork,wakeable);if(!retryCache.has(wakeable)){if(retryCache.add(wakeable),isDevToolsPresent)if(inProgressLanes!==null&&inProgressRoot!==null)restorePendingUpdaters(inProgressRoot,inProgressLanes);else throw Error("Expected finished root and lanes to be set. This is a bug in React.");wakeable.then(retry,retry)}})}}function commitMutationEffects(root2,finishedWork,committedLanes){inProgressLanes=committedLanes,inProgressRoot=root2,setCurrentFiber(finishedWork),commitMutationEffectsOnFiber(finishedWork,root2),setCurrentFiber(finishedWork),inProgressLanes=null,inProgressRoot=null}function recursivelyTraverseMutationEffects(root2,parentFiber,lanes){var deletions=parentFiber.deletions;if(deletions!==null)for(var i2=0;i2<deletions.length;i2++){var childToDelete=deletions[i2];try{commitDeletionEffects(root2,parentFiber,childToDelete)}catch(error2){captureCommitPhaseError(childToDelete,parentFiber,error2)}}var prevDebugFiber=getCurrentFiber();if(parentFiber.subtreeFlags&MutationMask)for(var child=parentFiber.child;child!==null;)setCurrentFiber(child),commitMutationEffectsOnFiber(child,root2),child=child.sibling;setCurrentFiber(prevDebugFiber)}function commitMutationEffectsOnFiber(finishedWork,root2,lanes){var current2=finishedWork.alternate,flags=finishedWork.flags;switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(recursivelyTraverseMutationEffects(root2,finishedWork),commitReconciliationEffects(finishedWork),flags&Update){try{commitHookEffectListUnmount(Insertion|HasEffect,finishedWork,finishedWork.return),commitHookEffectListMount(Insertion|HasEffect,finishedWork)}catch(error2){captureCommitPhaseError(finishedWork,finishedWork.return,error2)}if(finishedWork.mode&ProfileMode){try{startLayoutEffectTimer(),commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return)}catch(error2){captureCommitPhaseError(finishedWork,finishedWork.return,error2)}recordLayoutEffectDuration(finishedWork)}else try{commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return)}catch(error2){captureCommitPhaseError(finishedWork,finishedWork.return,error2)}}return}case ClassComponent:{recursivelyTraverseMutationEffects(root2,finishedWork),commitReconciliationEffects(finishedWork),flags&Ref&&current2!==null&&safelyDetachRef(current2,current2.return);return}case HostComponent:{recursivelyTraverseMutationEffects(root2,finishedWork),commitReconciliationEffects(finishedWork),flags&Ref&&current2!==null&&safelyDetachRef(current2,current2.return);{if(finishedWork.flags&ContentReset){var instance=finishedWork.stateNode;try{resetTextContent(instance)}catch(error2){captureCommitPhaseError(finishedWork,finishedWork.return,error2)}}if(flags&Update){var _instance4=finishedWork.stateNode;if(_instance4!=null){var newProps=finishedWork.memoizedProps,oldProps=current2!==null?current2.memoizedProps:newProps,type=finishedWork.type,updatePayload=finishedWork.updateQueue;if(finishedWork.updateQueue=null,updatePayload!==null)try{commitUpdate(_instance4,updatePayload,type,oldProps,newProps,finishedWork)}catch(error2){captureCommitPhaseError(finishedWork,finishedWork.return,error2)}}}}return}case HostText:{if(recursivelyTraverseMutationEffects(root2,finishedWork),commitReconciliationEffects(finishedWork),flags&Update){if(finishedWork.stateNode===null)throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");var textInstance=finishedWork.stateNode,newText=finishedWork.memoizedProps,oldText=current2!==null?current2.memoizedProps:newText;try{commitTextUpdate(textInstance,oldText,newText)}catch(error2){captureCommitPhaseError(finishedWork,finishedWork.return,error2)}}return}case HostRoot:{if(recursivelyTraverseMutationEffects(root2,finishedWork),commitReconciliationEffects(finishedWork),flags&Update&&current2!==null){var prevRootState=current2.memoizedState;if(prevRootState.isDehydrated)try{commitHydratedContainer(root2.containerInfo)}catch(error2){captureCommitPhaseError(finishedWork,finishedWork.return,error2)}}return}case HostPortal:{recursivelyTraverseMutationEffects(root2,finishedWork),commitReconciliationEffects(finishedWork);return}case SuspenseComponent:{recursivelyTraverseMutationEffects(root2,finishedWork),commitReconciliationEffects(finishedWork);var offscreenFiber=finishedWork.child;if(offscreenFiber.flags&Visibility){var offscreenInstance=offscreenFiber.stateNode,newState=offscreenFiber.memoizedState,isHidden=newState!==null;if(offscreenInstance.isHidden=isHidden,isHidden){var wasHidden=offscreenFiber.alternate!==null&&offscreenFiber.alternate.memoizedState!==null;wasHidden||markCommitTimeOfFallback()}}if(flags&Update){try{commitSuspenseCallback(finishedWork)}catch(error2){captureCommitPhaseError(finishedWork,finishedWork.return,error2)}attachSuspenseRetryListeners(finishedWork)}return}case OffscreenComponent:{var _wasHidden=current2!==null&&current2.memoizedState!==null;if(finishedWork.mode&ConcurrentMode){var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden||_wasHidden,recursivelyTraverseMutationEffects(root2,finishedWork),offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden}else recursivelyTraverseMutationEffects(root2,finishedWork);if(commitReconciliationEffects(finishedWork),flags&Visibility){var _offscreenInstance=finishedWork.stateNode,_newState=finishedWork.memoizedState,_isHidden=_newState!==null,offscreenBoundary=finishedWork;if(_offscreenInstance.isHidden=_isHidden,_isHidden&&!_wasHidden&&(offscreenBoundary.mode&ConcurrentMode)!==NoMode){nextEffect=offscreenBoundary;for(var offscreenChild=offscreenBoundary.child;offscreenChild!==null;)nextEffect=offscreenChild,disappearLayoutEffects_begin(offscreenChild),offscreenChild=offscreenChild.sibling}hideOrUnhideAllChildren(offscreenBoundary,_isHidden)}return}case SuspenseListComponent:{recursivelyTraverseMutationEffects(root2,finishedWork),commitReconciliationEffects(finishedWork),flags&Update&&attachSuspenseRetryListeners(finishedWork);return}case ScopeComponent:return;default:{recursivelyTraverseMutationEffects(root2,finishedWork),commitReconciliationEffects(finishedWork);return}}}function commitReconciliationEffects(finishedWork){var flags=finishedWork.flags;if(flags&Placement){try{commitPlacement(finishedWork)}catch(error2){captureCommitPhaseError(finishedWork,finishedWork.return,error2)}finishedWork.flags&=~Placement}flags&Hydrating&&(finishedWork.flags&=~Hydrating)}function commitLayoutEffects(finishedWork,root2,committedLanes){inProgressLanes=committedLanes,inProgressRoot=root2,nextEffect=finishedWork,commitLayoutEffects_begin(finishedWork,root2,committedLanes),inProgressLanes=null,inProgressRoot=null}function commitLayoutEffects_begin(subtreeRoot,root2,committedLanes){for(var isModernRoot=(subtreeRoot.mode&ConcurrentMode)!==NoMode;nextEffect!==null;){var fiber=nextEffect,firstChild=fiber.child;if(fiber.tag===OffscreenComponent&&isModernRoot){var isHidden=fiber.memoizedState!==null,newOffscreenSubtreeIsHidden=isHidden||offscreenSubtreeIsHidden;if(newOffscreenSubtreeIsHidden){commitLayoutMountEffects_complete(subtreeRoot,root2,committedLanes);continue}else{var current2=fiber.alternate,wasHidden=current2!==null&&current2.memoizedState!==null,newOffscreenSubtreeWasHidden=wasHidden||offscreenSubtreeWasHidden,prevOffscreenSubtreeIsHidden=offscreenSubtreeIsHidden,prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeIsHidden=newOffscreenSubtreeIsHidden,offscreenSubtreeWasHidden=newOffscreenSubtreeWasHidden,offscreenSubtreeWasHidden&&!prevOffscreenSubtreeWasHidden&&(nextEffect=fiber,reappearLayoutEffects_begin(fiber));for(var child=firstChild;child!==null;)nextEffect=child,commitLayoutEffects_begin(child,root2,committedLanes),child=child.sibling;nextEffect=fiber,offscreenSubtreeIsHidden=prevOffscreenSubtreeIsHidden,offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden,commitLayoutMountEffects_complete(subtreeRoot,root2,committedLanes);continue}}(fiber.subtreeFlags&LayoutMask)!==NoFlags&&firstChild!==null?(firstChild.return=fiber,nextEffect=firstChild):commitLayoutMountEffects_complete(subtreeRoot,root2,committedLanes)}}function commitLayoutMountEffects_complete(subtreeRoot,root2,committedLanes){for(;nextEffect!==null;){var fiber=nextEffect;if((fiber.flags&LayoutMask)!==NoFlags){var current2=fiber.alternate;setCurrentFiber(fiber);try{commitLayoutEffectOnFiber(root2,current2,fiber,committedLanes)}catch(error2){captureCommitPhaseError(fiber,fiber.return,error2)}resetCurrentFiber()}if(fiber===subtreeRoot){nextEffect=null;return}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return,nextEffect=sibling;return}nextEffect=fiber.return}}function disappearLayoutEffects_begin(subtreeRoot){for(;nextEffect!==null;){var fiber=nextEffect,firstChild=fiber.child;switch(fiber.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(fiber.mode&ProfileMode)try{startLayoutEffectTimer(),commitHookEffectListUnmount(Layout,fiber,fiber.return)}finally{recordLayoutEffectDuration(fiber)}else commitHookEffectListUnmount(Layout,fiber,fiber.return);break}case ClassComponent:{safelyDetachRef(fiber,fiber.return);var instance=fiber.stateNode;typeof instance.componentWillUnmount=="function"&&safelyCallComponentWillUnmount(fiber,fiber.return,instance);break}case HostComponent:{safelyDetachRef(fiber,fiber.return);break}case OffscreenComponent:{var isHidden=fiber.memoizedState!==null;if(isHidden){disappearLayoutEffects_complete(subtreeRoot);continue}break}}firstChild!==null?(firstChild.return=fiber,nextEffect=firstChild):disappearLayoutEffects_complete(subtreeRoot)}}function disappearLayoutEffects_complete(subtreeRoot){for(;nextEffect!==null;){var fiber=nextEffect;if(fiber===subtreeRoot){nextEffect=null;return}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return,nextEffect=sibling;return}nextEffect=fiber.return}}function reappearLayoutEffects_begin(subtreeRoot){for(;nextEffect!==null;){var fiber=nextEffect,firstChild=fiber.child;if(fiber.tag===OffscreenComponent){var isHidden=fiber.memoizedState!==null;if(isHidden){reappearLayoutEffects_complete(subtreeRoot);continue}}firstChild!==null?(firstChild.return=fiber,nextEffect=firstChild):reappearLayoutEffects_complete(subtreeRoot)}}function reappearLayoutEffects_complete(subtreeRoot){for(;nextEffect!==null;){var fiber=nextEffect;setCurrentFiber(fiber);try{reappearLayoutEffectsOnFiber(fiber)}catch(error2){captureCommitPhaseError(fiber,fiber.return,error2)}if(resetCurrentFiber(),fiber===subtreeRoot){nextEffect=null;return}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return,nextEffect=sibling;return}nextEffect=fiber.return}}function commitPassiveMountEffects(root2,finishedWork,committedLanes,committedTransitions){nextEffect=finishedWork,commitPassiveMountEffects_begin(finishedWork,root2,committedLanes,committedTransitions)}function commitPassiveMountEffects_begin(subtreeRoot,root2,committedLanes,committedTransitions){for(;nextEffect!==null;){var fiber=nextEffect,firstChild=fiber.child;(fiber.subtreeFlags&PassiveMask)!==NoFlags&&firstChild!==null?(firstChild.return=fiber,nextEffect=firstChild):commitPassiveMountEffects_complete(subtreeRoot,root2,committedLanes,committedTransitions)}}function commitPassiveMountEffects_complete(subtreeRoot,root2,committedLanes,committedTransitions){for(;nextEffect!==null;){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);try{commitPassiveMountOnFiber(root2,fiber,committedLanes,committedTransitions)}catch(error2){captureCommitPhaseError(fiber,fiber.return,error2)}resetCurrentFiber()}if(fiber===subtreeRoot){nextEffect=null;return}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return,nextEffect=sibling;return}nextEffect=fiber.return}}function commitPassiveMountOnFiber(finishedRoot,finishedWork,committedLanes,committedTransitions){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();try{commitHookEffectListMount(Passive$1|HasEffect,finishedWork)}finally{recordPassiveEffectDuration(finishedWork)}}else commitHookEffectListMount(Passive$1|HasEffect,finishedWork);break}}}function commitPassiveUnmountEffects(firstChild){nextEffect=firstChild,commitPassiveUnmountEffects_begin()}function commitPassiveUnmountEffects_begin(){for(;nextEffect!==null;){var fiber=nextEffect,child=fiber.child;if((nextEffect.flags&ChildDeletion)!==NoFlags){var deletions=fiber.deletions;if(deletions!==null){for(var i2=0;i2<deletions.length;i2++){var fiberToDelete=deletions[i2];nextEffect=fiberToDelete,commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete,fiber)}{var previousFiber=fiber.alternate;if(previousFiber!==null){var detachedChild=previousFiber.child;if(detachedChild!==null){previousFiber.child=null;do{var detachedSibling=detachedChild.sibling;detachedChild.sibling=null,detachedChild=detachedSibling}while(detachedChild!==null)}}}nextEffect=fiber}}(fiber.subtreeFlags&PassiveMask)!==NoFlags&&child!==null?(child.return=fiber,nextEffect=child):commitPassiveUnmountEffects_complete()}}function commitPassiveUnmountEffects_complete(){for(;nextEffect!==null;){var fiber=nextEffect;(fiber.flags&Passive)!==NoFlags&&(setCurrentFiber(fiber),commitPassiveUnmountOnFiber(fiber),resetCurrentFiber());var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return,nextEffect=sibling;return}nextEffect=fiber.return}}function commitPassiveUnmountOnFiber(finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{finishedWork.mode&ProfileMode?(startPassiveEffectTimer(),commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return),recordPassiveEffectDuration(finishedWork)):commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return);break}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot,nearestMountedAncestor){for(;nextEffect!==null;){var fiber=nextEffect;setCurrentFiber(fiber),commitPassiveUnmountInsideDeletedTreeOnFiber(fiber,nearestMountedAncestor),resetCurrentFiber();var child=fiber.child;child!==null?(child.return=fiber,nextEffect=child):commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot)}}function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot){for(;nextEffect!==null;){var fiber=nextEffect,sibling=fiber.sibling,returnFiber=fiber.return;if(detachFiberAfterEffects(fiber),fiber===deletedSubtreeRoot){nextEffect=null;return}if(sibling!==null){sibling.return=returnFiber,nextEffect=sibling;return}nextEffect=returnFiber}}function commitPassiveUnmountInsideDeletedTreeOnFiber(current2,nearestMountedAncestor){switch(current2.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{current2.mode&ProfileMode?(startPassiveEffectTimer(),commitHookEffectListUnmount(Passive$1,current2,nearestMountedAncestor),recordPassiveEffectDuration(current2)):commitHookEffectListUnmount(Passive$1,current2,nearestMountedAncestor);break}}}function invokeLayoutEffectMountInDEV(fiber){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Layout|HasEffect,fiber)}catch(error2){captureCommitPhaseError(fiber,fiber.return,error2)}break}case ClassComponent:{var instance=fiber.stateNode;try{instance.componentDidMount()}catch(error2){captureCommitPhaseError(fiber,fiber.return,error2)}break}}}function invokePassiveEffectMountInDEV(fiber){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Passive$1|HasEffect,fiber)}catch(error2){captureCommitPhaseError(fiber,fiber.return,error2)}break}}}function invokeLayoutEffectUnmountInDEV(fiber){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Layout|HasEffect,fiber,fiber.return)}catch(error2){captureCommitPhaseError(fiber,fiber.return,error2)}break}case ClassComponent:{var instance=fiber.stateNode;typeof instance.componentWillUnmount=="function"&&safelyCallComponentWillUnmount(fiber,fiber.return,instance);break}}}function invokePassiveEffectUnmountInDEV(fiber){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:try{commitHookEffectListUnmount(Passive$1|HasEffect,fiber,fiber.return)}catch(error2){captureCommitPhaseError(fiber,fiber.return,error2)}}}if(typeof Symbol=="function"&&Symbol.for){var symbolFor=Symbol.for;symbolFor("selector.component"),symbolFor("selector.has_pseudo_class"),symbolFor("selector.role"),symbolFor("selector.test_id"),symbolFor("selector.text")}var commitHooks=[];function onCommitRoot$1(){commitHooks.forEach(function(commitHook){return commitHook()})}var ReactCurrentActQueue=ReactSharedInternals.ReactCurrentActQueue;function isLegacyActEnvironment(fiber){{var isReactActEnvironmentGlobal=typeof IS_REACT_ACT_ENVIRONMENT<"u"?IS_REACT_ACT_ENVIRONMENT:void 0,jestIsDefined=typeof jest<"u";return jestIsDefined&&isReactActEnvironmentGlobal!==!1}}function isConcurrentActEnvironment(){{var isReactActEnvironmentGlobal=typeof IS_REACT_ACT_ENVIRONMENT<"u"?IS_REACT_ACT_ENVIRONMENT:void 0;return!isReactActEnvironmentGlobal&&ReactCurrentActQueue.current!==null&&error("The current testing environment is not configured to support act(...)"),isReactActEnvironmentGlobal}}var ceil=Math.ceil,ReactCurrentDispatcher$2=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner,ReactCurrentBatchConfig$3=ReactSharedInternals.ReactCurrentBatchConfig,ReactCurrentActQueue$1=ReactSharedInternals.ReactCurrentActQueue,NoContext=0,BatchedContext=1,RenderContext=2,CommitContext=4,RootInProgress=0,RootFatalErrored=1,RootErrored=2,RootSuspended=3,RootSuspendedWithDelay=4,RootCompleted=5,RootDidNotComplete=6,executionContext=NoContext,workInProgressRoot=null,workInProgress=null,workInProgressRootRenderLanes=NoLanes,subtreeRenderLanes=NoLanes,subtreeRenderLanesCursor=createCursor(NoLanes),workInProgressRootExitStatus=RootInProgress,workInProgressRootFatalError=null,workInProgressRootSkippedLanes=NoLanes,workInProgressRootInterleavedUpdatedLanes=NoLanes,workInProgressRootPingedLanes=NoLanes,workInProgressRootConcurrentErrors=null,workInProgressRootRecoverableErrors=null,globalMostRecentFallbackTime=0,FALLBACK_THROTTLE_MS=500,workInProgressRootRenderTargetTime=1/0,RENDER_TIMEOUT_MS=500,workInProgressTransitions=null;function resetRenderTimer(){workInProgressRootRenderTargetTime=now2()+RENDER_TIMEOUT_MS}function getRenderTargetTime(){return workInProgressRootRenderTargetTime}var hasUncaughtError=!1,firstUncaughtError=null,legacyErrorBoundariesThatAlreadyFailed=null,rootDoesHavePassiveEffects=!1,rootWithPendingPassiveEffects=null,pendingPassiveEffectsLanes=NoLanes,pendingPassiveProfilerEffects=[],pendingPassiveTransitions=null,NESTED_UPDATE_LIMIT=50,nestedUpdateCount=0,rootWithNestedUpdates=null,isFlushingPassiveEffects=!1,didScheduleUpdateDuringPassiveEffects=!1,NESTED_PASSIVE_UPDATE_LIMIT=50,nestedPassiveUpdateCount=0,rootWithPassiveNestedUpdates=null,currentEventTime=NoTimestamp,currentEventTransitionLane=NoLanes,isRunningInsertionEffect=!1;function getWorkInProgressRoot(){return workInProgressRoot}function requestEventTime(){return(executionContext&(RenderContext|CommitContext))!==NoContext?now2():(currentEventTime!==NoTimestamp||(currentEventTime=now2()),currentEventTime)}function requestUpdateLane(fiber){var mode=fiber.mode;if((mode&ConcurrentMode)===NoMode)return SyncLane;if((executionContext&RenderContext)!==NoContext&&workInProgressRootRenderLanes!==NoLanes)return pickArbitraryLane(workInProgressRootRenderLanes);var isTransition=requestCurrentTransition()!==NoTransition;if(isTransition){if(ReactCurrentBatchConfig$3.transition!==null){var transition=ReactCurrentBatchConfig$3.transition;transition._updatedFibers||(transition._updatedFibers=new Set),transition._updatedFibers.add(fiber)}return currentEventTransitionLane===NoLane&&(currentEventTransitionLane=claimNextTransitionLane()),currentEventTransitionLane}var updateLane=getCurrentUpdatePriority();if(updateLane!==NoLane)return updateLane;var eventLane=getCurrentEventPriority();return eventLane}function requestRetryLane(fiber){var mode=fiber.mode;return(mode&ConcurrentMode)===NoMode?SyncLane:claimNextRetryLane()}function scheduleUpdateOnFiber(root2,fiber,lane,eventTime){checkForNestedUpdates(),isRunningInsertionEffect&&error("useInsertionEffect must not schedule updates."),isFlushingPassiveEffects&&(didScheduleUpdateDuringPassiveEffects=!0),markRootUpdated(root2,lane,eventTime),(executionContext&RenderContext)!==NoLanes&&root2===workInProgressRoot?warnAboutRenderPhaseUpdatesInDEV(fiber):(isDevToolsPresent&&addFiberToLanesMap(root2,fiber,lane),warnIfUpdatesNotWrappedWithActDEV(fiber),root2===workInProgressRoot&&((executionContext&RenderContext)===NoContext&&(workInProgressRootInterleavedUpdatedLanes=mergeLanes(workInProgressRootInterleavedUpdatedLanes,lane)),workInProgressRootExitStatus===RootSuspendedWithDelay&&markRootSuspended$1(root2,workInProgressRootRenderLanes)),ensureRootIsScheduled(root2,eventTime),lane===SyncLane&&executionContext===NoContext&&(fiber.mode&ConcurrentMode)===NoMode&&!ReactCurrentActQueue$1.isBatchingLegacy&&(resetRenderTimer(),flushSyncCallbacksOnlyInLegacyMode()))}function scheduleInitialHydrationOnRoot(root2,lane,eventTime){var current2=root2.current;current2.lanes=lane,markRootUpdated(root2,lane,eventTime),ensureRootIsScheduled(root2,eventTime)}function isUnsafeClassRenderPhaseUpdate(fiber){return(executionContext&RenderContext)!==NoContext}function ensureRootIsScheduled(root2,currentTime){var existingCallbackNode=root2.callbackNode;markStarvedLanesAsExpired(root2,currentTime);var nextLanes=getNextLanes(root2,root2===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(nextLanes===NoLanes){existingCallbackNode!==null&&cancelCallback$1(existingCallbackNode),root2.callbackNode=null,root2.callbackPriority=NoLane;return}var newCallbackPriority=getHighestPriorityLane(nextLanes),existingCallbackPriority=root2.callbackPriority;if(existingCallbackPriority===newCallbackPriority&&!(ReactCurrentActQueue$1.current!==null&&existingCallbackNode!==fakeActCallbackNode)){existingCallbackNode==null&&existingCallbackPriority!==SyncLane&&error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");return}existingCallbackNode!=null&&cancelCallback$1(existingCallbackNode);var newCallbackNode;if(newCallbackPriority===SyncLane)root2.tag===LegacyRoot?(ReactCurrentActQueue$1.isBatchingLegacy!==null&&(ReactCurrentActQueue$1.didScheduleLegacyUpdate=!0),scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null,root2))):scheduleSyncCallback(performSyncWorkOnRoot.bind(null,root2)),ReactCurrentActQueue$1.current!==null?ReactCurrentActQueue$1.current.push(flushSyncCallbacks):scheduleMicrotask(function(){(executionContext&(RenderContext|CommitContext))===NoContext&&flushSyncCallbacks()}),newCallbackNode=null;else{var schedulerPriorityLevel;switch(lanesToEventPriority(nextLanes)){case DiscreteEventPriority:schedulerPriorityLevel=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriorityLevel=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriorityLevel=NormalPriority;break;case IdleEventPriority:schedulerPriorityLevel=IdlePriority;break;default:schedulerPriorityLevel=NormalPriority;break}newCallbackNode=scheduleCallback$1(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null,root2))}root2.callbackPriority=newCallbackPriority,root2.callbackNode=newCallbackNode}function performConcurrentWorkOnRoot(root2,didTimeout){if(resetNestedUpdateFlag(),currentEventTime=NoTimestamp,currentEventTransitionLane=NoLanes,(executionContext&(RenderContext|CommitContext))!==NoContext)throw new Error("Should not already be working.");var originalCallbackNode=root2.callbackNode,didFlushPassiveEffects=flushPassiveEffects();if(didFlushPassiveEffects&&root2.callbackNode!==originalCallbackNode)return null;var lanes=getNextLanes(root2,root2===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(lanes===NoLanes)return null;var shouldTimeSlice=!includesBlockingLane(root2,lanes)&&!includesExpiredLane(root2,lanes)&&!didTimeout,exitStatus=shouldTimeSlice?renderRootConcurrent(root2,lanes):renderRootSync(root2,lanes);if(exitStatus!==RootInProgress){if(exitStatus===RootErrored){var errorRetryLanes=getLanesToRetrySynchronouslyOnError(root2);errorRetryLanes!==NoLanes&&(lanes=errorRetryLanes,exitStatus=recoverFromConcurrentError(root2,errorRetryLanes))}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;throw prepareFreshStack(root2,NoLanes),markRootSuspended$1(root2,lanes),ensureRootIsScheduled(root2,now2()),fatalError}if(exitStatus===RootDidNotComplete)markRootSuspended$1(root2,lanes);else{var renderWasConcurrent=!includesBlockingLane(root2,lanes),finishedWork=root2.current.alternate;if(renderWasConcurrent&&!isRenderConsistentWithExternalStores(finishedWork)){if(exitStatus=renderRootSync(root2,lanes),exitStatus===RootErrored){var _errorRetryLanes=getLanesToRetrySynchronouslyOnError(root2);_errorRetryLanes!==NoLanes&&(lanes=_errorRetryLanes,exitStatus=recoverFromConcurrentError(root2,_errorRetryLanes))}if(exitStatus===RootFatalErrored){var _fatalError=workInProgressRootFatalError;throw prepareFreshStack(root2,NoLanes),markRootSuspended$1(root2,lanes),ensureRootIsScheduled(root2,now2()),_fatalError}}root2.finishedWork=finishedWork,root2.finishedLanes=lanes,finishConcurrentRender(root2,exitStatus,lanes)}}return ensureRootIsScheduled(root2,now2()),root2.callbackNode===originalCallbackNode?performConcurrentWorkOnRoot.bind(null,root2):null}function recoverFromConcurrentError(root2,errorRetryLanes){var errorsFromFirstAttempt=workInProgressRootConcurrentErrors;if(isRootDehydrated(root2)){var rootWorkInProgress=prepareFreshStack(root2,errorRetryLanes);rootWorkInProgress.flags|=ForceClientRender,errorHydratingContainer(root2.containerInfo)}var exitStatus=renderRootSync(root2,errorRetryLanes);if(exitStatus!==RootErrored){var errorsFromSecondAttempt=workInProgressRootRecoverableErrors;workInProgressRootRecoverableErrors=errorsFromFirstAttempt,errorsFromSecondAttempt!==null&&queueRecoverableErrors(errorsFromSecondAttempt)}return exitStatus}function queueRecoverableErrors(errors){workInProgressRootRecoverableErrors===null?workInProgressRootRecoverableErrors=errors:workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors,errors)}function finishConcurrentRender(root2,exitStatus,lanes){switch(exitStatus){case RootInProgress:case RootFatalErrored:throw new Error("Root did not complete. This is a bug in React.");case RootErrored:{commitRoot(root2,workInProgressRootRecoverableErrors,workInProgressTransitions);break}case RootSuspended:{if(markRootSuspended$1(root2,lanes),includesOnlyRetries(lanes)&&!shouldForceFlushFallbacksInDEV()){var msUntilTimeout=globalMostRecentFallbackTime+FALLBACK_THROTTLE_MS-now2();if(msUntilTimeout>10){var nextLanes=getNextLanes(root2,NoLanes);if(nextLanes!==NoLanes)break;var suspendedLanes=root2.suspendedLanes;if(!isSubsetOfLanes(suspendedLanes,lanes)){requestEventTime(),markRootPinged(root2,suspendedLanes);break}root2.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root2,workInProgressRootRecoverableErrors,workInProgressTransitions),msUntilTimeout);break}}commitRoot(root2,workInProgressRootRecoverableErrors,workInProgressTransitions);break}case RootSuspendedWithDelay:{if(markRootSuspended$1(root2,lanes),includesOnlyTransitions(lanes))break;if(!shouldForceFlushFallbacksInDEV()){var mostRecentEventTime=getMostRecentEventTime(root2,lanes),eventTimeMs=mostRecentEventTime,timeElapsedMs=now2()-eventTimeMs,_msUntilTimeout=jnd(timeElapsedMs)-timeElapsedMs;if(_msUntilTimeout>10){root2.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root2,workInProgressRootRecoverableErrors,workInProgressTransitions),_msUntilTimeout);break}}commitRoot(root2,workInProgressRootRecoverableErrors,workInProgressTransitions);break}case RootCompleted:{commitRoot(root2,workInProgressRootRecoverableErrors,workInProgressTransitions);break}default:throw new Error("Unknown root exit status.")}}function isRenderConsistentWithExternalStores(finishedWork){for(var node=finishedWork;;){if(node.flags&StoreConsistency){var updateQueue=node.updateQueue;if(updateQueue!==null){var checks=updateQueue.stores;if(checks!==null)for(var i2=0;i2<checks.length;i2++){var check=checks[i2],getSnapshot=check.getSnapshot,renderedValue=check.value;try{if(!objectIs(getSnapshot(),renderedValue))return!1}catch{return!1}}}}var child=node.child;if(node.subtreeFlags&StoreConsistency&&child!==null){child.return=node,node=child;continue}if(node===finishedWork)return!0;for(;node.sibling===null;){if(node.return===null||node.return===finishedWork)return!0;node=node.return}node.sibling.return=node.return,node=node.sibling}return!0}function markRootSuspended$1(root2,suspendedLanes){suspendedLanes=removeLanes(suspendedLanes,workInProgressRootPingedLanes),suspendedLanes=removeLanes(suspendedLanes,workInProgressRootInterleavedUpdatedLanes),markRootSuspended(root2,suspendedLanes)}function performSyncWorkOnRoot(root2){if(syncNestedUpdateFlag(),(executionContext&(RenderContext|CommitContext))!==NoContext)throw new Error("Should not already be working.");flushPassiveEffects();var lanes=getNextLanes(root2,NoLanes);if(!includesSomeLane(lanes,SyncLane))return ensureRootIsScheduled(root2,now2()),null;var exitStatus=renderRootSync(root2,lanes);if(root2.tag!==LegacyRoot&&exitStatus===RootErrored){var errorRetryLanes=getLanesToRetrySynchronouslyOnError(root2);errorRetryLanes!==NoLanes&&(lanes=errorRetryLanes,exitStatus=recoverFromConcurrentError(root2,errorRetryLanes))}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;throw prepareFreshStack(root2,NoLanes),markRootSuspended$1(root2,lanes),ensureRootIsScheduled(root2,now2()),fatalError}if(exitStatus===RootDidNotComplete)throw new Error("Root did not complete. This is a bug in React.");var finishedWork=root2.current.alternate;return root2.finishedWork=finishedWork,root2.finishedLanes=lanes,commitRoot(root2,workInProgressRootRecoverableErrors,workInProgressTransitions),ensureRootIsScheduled(root2,now2()),null}function flushRoot(root2,lanes){lanes!==NoLanes&&(markRootEntangled(root2,mergeLanes(lanes,SyncLane)),ensureRootIsScheduled(root2,now2()),(executionContext&(RenderContext|CommitContext))===NoContext&&(resetRenderTimer(),flushSyncCallbacks()))}function batchedUpdates$1(fn,a2){var prevExecutionContext=executionContext;executionContext|=BatchedContext;try{return fn(a2)}finally{executionContext=prevExecutionContext,executionContext===NoContext&&!ReactCurrentActQueue$1.isBatchingLegacy&&(resetRenderTimer(),flushSyncCallbacksOnlyInLegacyMode())}}function discreteUpdates(fn,a2,b2,c2,d2){var previousPriority=getCurrentUpdatePriority(),prevTransition=ReactCurrentBatchConfig$3.transition;try{return ReactCurrentBatchConfig$3.transition=null,setCurrentUpdatePriority(DiscreteEventPriority),fn(a2,b2,c2,d2)}finally{setCurrentUpdatePriority(previousPriority),ReactCurrentBatchConfig$3.transition=prevTransition,executionContext===NoContext&&resetRenderTimer()}}function flushSync(fn){rootWithPendingPassiveEffects!==null&&rootWithPendingPassiveEffects.tag===LegacyRoot&&(executionContext&(RenderContext|CommitContext))===NoContext&&flushPassiveEffects();var prevExecutionContext=executionContext;executionContext|=BatchedContext;var prevTransition=ReactCurrentBatchConfig$3.transition,previousPriority=getCurrentUpdatePriority();try{return ReactCurrentBatchConfig$3.transition=null,setCurrentUpdatePriority(DiscreteEventPriority),fn?fn():void 0}finally{setCurrentUpdatePriority(previousPriority),ReactCurrentBatchConfig$3.transition=prevTransition,executionContext=prevExecutionContext,(executionContext&(RenderContext|CommitContext))===NoContext&&flushSyncCallbacks()}}function isAlreadyRendering(){return(executionContext&(RenderContext|CommitContext))!==NoContext}function pushRenderLanes(fiber,lanes){push(subtreeRenderLanesCursor,subtreeRenderLanes,fiber),subtreeRenderLanes=mergeLanes(subtreeRenderLanes,lanes)}function popRenderLanes(fiber){subtreeRenderLanes=subtreeRenderLanesCursor.current,pop(subtreeRenderLanesCursor,fiber)}function prepareFreshStack(root2,lanes){root2.finishedWork=null,root2.finishedLanes=NoLanes;var timeoutHandle=root2.timeoutHandle;if(timeoutHandle!==noTimeout&&(root2.timeoutHandle=noTimeout,cancelTimeout(timeoutHandle)),workInProgress!==null)for(var interruptedWork=workInProgress.return;interruptedWork!==null;){var current2=interruptedWork.alternate;unwindInterruptedWork(current2,interruptedWork),interruptedWork=interruptedWork.return}workInProgressRoot=root2;var rootWorkInProgress=createWorkInProgress(root2.current,null);return workInProgress=rootWorkInProgress,workInProgressRootRenderLanes=subtreeRenderLanes=lanes,workInProgressRootExitStatus=RootInProgress,workInProgressRootFatalError=null,workInProgressRootSkippedLanes=NoLanes,workInProgressRootInterleavedUpdatedLanes=NoLanes,workInProgressRootPingedLanes=NoLanes,workInProgressRootConcurrentErrors=null,workInProgressRootRecoverableErrors=null,finishQueueingConcurrentUpdates(),ReactStrictModeWarnings.discardPendingWarnings(),rootWorkInProgress}function handleError(root2,thrownValue){do{var erroredWork=workInProgress;try{if(resetContextDependencies(),resetHooksAfterThrow(),resetCurrentFiber(),ReactCurrentOwner$2.current=null,erroredWork===null||erroredWork.return===null){workInProgressRootExitStatus=RootFatalErrored,workInProgressRootFatalError=thrownValue,workInProgress=null;return}if(enableProfilerTimer&&erroredWork.mode&ProfileMode&&stopProfilerTimerIfRunningAndRecordDelta(erroredWork,!0),enableSchedulingProfiler)if(markComponentRenderStopped(),thrownValue!==null&&typeof thrownValue=="object"&&typeof thrownValue.then=="function"){var wakeable=thrownValue;markComponentSuspended(erroredWork,wakeable,workInProgressRootRenderLanes)}else markComponentErrored(erroredWork,thrownValue,workInProgressRootRenderLanes);throwException(root2,erroredWork.return,erroredWork,thrownValue,workInProgressRootRenderLanes),completeUnitOfWork(erroredWork)}catch(yetAnotherThrownValue){thrownValue=yetAnotherThrownValue,workInProgress===erroredWork&&erroredWork!==null?(erroredWork=erroredWork.return,workInProgress=erroredWork):erroredWork=workInProgress;continue}return}while(!0)}function pushDispatcher(){var prevDispatcher=ReactCurrentDispatcher$2.current;return ReactCurrentDispatcher$2.current=ContextOnlyDispatcher,prevDispatcher===null?ContextOnlyDispatcher:prevDispatcher}function popDispatcher(prevDispatcher){ReactCurrentDispatcher$2.current=prevDispatcher}function markCommitTimeOfFallback(){globalMostRecentFallbackTime=now2()}function markSkippedUpdateLanes(lane){workInProgressRootSkippedLanes=mergeLanes(lane,workInProgressRootSkippedLanes)}function renderDidSuspend(){workInProgressRootExitStatus===RootInProgress&&(workInProgressRootExitStatus=RootSuspended)}function renderDidSuspendDelayIfPossible(){(workInProgressRootExitStatus===RootInProgress||workInProgressRootExitStatus===RootSuspended||workInProgressRootExitStatus===RootErrored)&&(workInProgressRootExitStatus=RootSuspendedWithDelay),workInProgressRoot!==null&&(includesNonIdleWork(workInProgressRootSkippedLanes)||includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))&&markRootSuspended$1(workInProgressRoot,workInProgressRootRenderLanes)}function renderDidError(error2){workInProgressRootExitStatus!==RootSuspendedWithDelay&&(workInProgressRootExitStatus=RootErrored),workInProgressRootConcurrentErrors===null?workInProgressRootConcurrentErrors=[error2]:workInProgressRootConcurrentErrors.push(error2)}function renderHasNotSuspendedYet(){return workInProgressRootExitStatus===RootInProgress}function renderRootSync(root2,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();if(workInProgressRoot!==root2||workInProgressRootRenderLanes!==lanes){if(isDevToolsPresent){var memoizedUpdaters=root2.memoizedUpdaters;memoizedUpdaters.size>0&&(restorePendingUpdaters(root2,workInProgressRootRenderLanes),memoizedUpdaters.clear()),movePendingFibersToMemoized(root2,lanes)}workInProgressTransitions=getTransitionsForLanes(),prepareFreshStack(root2,lanes)}markRenderStarted(lanes);do try{workLoopSync();break}catch(thrownValue){handleError(root2,thrownValue)}while(!0);if(resetContextDependencies(),executionContext=prevExecutionContext,popDispatcher(prevDispatcher),workInProgress!==null)throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");return markRenderStopped(),workInProgressRoot=null,workInProgressRootRenderLanes=NoLanes,workInProgressRootExitStatus}function workLoopSync(){for(;workInProgress!==null;)performUnitOfWork(workInProgress)}function renderRootConcurrent(root2,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();if(workInProgressRoot!==root2||workInProgressRootRenderLanes!==lanes){if(isDevToolsPresent){var memoizedUpdaters=root2.memoizedUpdaters;memoizedUpdaters.size>0&&(restorePendingUpdaters(root2,workInProgressRootRenderLanes),memoizedUpdaters.clear()),movePendingFibersToMemoized(root2,lanes)}workInProgressTransitions=getTransitionsForLanes(),resetRenderTimer(),prepareFreshStack(root2,lanes)}markRenderStarted(lanes);do try{workLoopConcurrent();break}catch(thrownValue){handleError(root2,thrownValue)}while(!0);return resetContextDependencies(),popDispatcher(prevDispatcher),executionContext=prevExecutionContext,workInProgress!==null?(markRenderYielded(),RootInProgress):(markRenderStopped(),workInProgressRoot=null,workInProgressRootRenderLanes=NoLanes,workInProgressRootExitStatus)}function workLoopConcurrent(){for(;workInProgress!==null&&!shouldYield();)performUnitOfWork(workInProgress)}function performUnitOfWork(unitOfWork){var current2=unitOfWork.alternate;setCurrentFiber(unitOfWork);var next;(unitOfWork.mode&ProfileMode)!==NoMode?(startProfilerTimer(unitOfWork),next=beginWork$1(current2,unitOfWork,subtreeRenderLanes),stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,!0)):next=beginWork$1(current2,unitOfWork,subtreeRenderLanes),resetCurrentFiber(),unitOfWork.memoizedProps=unitOfWork.pendingProps,next===null?completeUnitOfWork(unitOfWork):workInProgress=next,ReactCurrentOwner$2.current=null}function completeUnitOfWork(unitOfWork){var completedWork=unitOfWork;do{var current2=completedWork.alternate,returnFiber=completedWork.return;if((completedWork.flags&Incomplete)===NoFlags){setCurrentFiber(completedWork);var next=void 0;if((completedWork.mode&ProfileMode)===NoMode?next=completeWork(current2,completedWork,subtreeRenderLanes):(startProfilerTimer(completedWork),next=completeWork(current2,completedWork,subtreeRenderLanes),stopProfilerTimerIfRunningAndRecordDelta(completedWork,!1)),resetCurrentFiber(),next!==null){workInProgress=next;return}}else{var _next=unwindWork(current2,completedWork);if(_next!==null){_next.flags&=HostEffectMask,workInProgress=_next;return}if((completedWork.mode&ProfileMode)!==NoMode){stopProfilerTimerIfRunningAndRecordDelta(completedWork,!1);for(var actualDuration=completedWork.actualDuration,child=completedWork.child;child!==null;)actualDuration+=child.actualDuration,child=child.sibling;completedWork.actualDuration=actualDuration}if(returnFiber!==null)returnFiber.flags|=Incomplete,returnFiber.subtreeFlags=NoFlags,returnFiber.deletions=null;else{workInProgressRootExitStatus=RootDidNotComplete,workInProgress=null;return}}var siblingFiber=completedWork.sibling;if(siblingFiber!==null){workInProgress=siblingFiber;return}completedWork=returnFiber,workInProgress=completedWork}while(completedWork!==null);workInProgressRootExitStatus===RootInProgress&&(workInProgressRootExitStatus=RootCompleted)}function commitRoot(root2,recoverableErrors,transitions){var previousUpdateLanePriority=getCurrentUpdatePriority(),prevTransition=ReactCurrentBatchConfig$3.transition;try{ReactCurrentBatchConfig$3.transition=null,setCurrentUpdatePriority(DiscreteEventPriority),commitRootImpl(root2,recoverableErrors,transitions,previousUpdateLanePriority)}finally{ReactCurrentBatchConfig$3.transition=prevTransition,setCurrentUpdatePriority(previousUpdateLanePriority)}return null}function commitRootImpl(root2,recoverableErrors,transitions,renderPriorityLevel){do flushPassiveEffects();while(rootWithPendingPassiveEffects!==null);if(flushRenderPhaseStrictModeWarningsInDEV(),(executionContext&(RenderContext|CommitContext))!==NoContext)throw new Error("Should not already be working.");var finishedWork=root2.finishedWork,lanes=root2.finishedLanes;if(markCommitStarted(lanes),finishedWork===null)return markCommitStopped(),null;if(lanes===NoLanes&&error("root.finishedLanes should not be empty during a commit. This is a bug in React."),root2.finishedWork=null,root2.finishedLanes=NoLanes,finishedWork===root2.current)throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");root2.callbackNode=null,root2.callbackPriority=NoLane;var remainingLanes=mergeLanes(finishedWork.lanes,finishedWork.childLanes);markRootFinished(root2,remainingLanes),root2===workInProgressRoot&&(workInProgressRoot=null,workInProgress=null,workInProgressRootRenderLanes=NoLanes),((finishedWork.subtreeFlags&PassiveMask)!==NoFlags||(finishedWork.flags&PassiveMask)!==NoFlags)&&(rootDoesHavePassiveEffects||(rootDoesHavePassiveEffects=!0,pendingPassiveTransitions=transitions,scheduleCallback$1(NormalPriority,function(){return flushPassiveEffects(),null})));var subtreeHasEffects=(finishedWork.subtreeFlags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags,rootHasEffect=(finishedWork.flags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;if(subtreeHasEffects||rootHasEffect){var prevTransition=ReactCurrentBatchConfig$3.transition;ReactCurrentBatchConfig$3.transition=null;var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(DiscreteEventPriority);var prevExecutionContext=executionContext;executionContext|=CommitContext,ReactCurrentOwner$2.current=null,commitBeforeMutationEffects(root2,finishedWork),recordCommitTime(),commitMutationEffects(root2,finishedWork,lanes),resetAfterCommit(root2.containerInfo),root2.current=finishedWork,markLayoutEffectsStarted(lanes),commitLayoutEffects(finishedWork,root2,lanes),markLayoutEffectsStopped(),requestPaint(),executionContext=prevExecutionContext,setCurrentUpdatePriority(previousPriority),ReactCurrentBatchConfig$3.transition=prevTransition}else root2.current=finishedWork,recordCommitTime();var rootDidHavePassiveEffects=rootDoesHavePassiveEffects;if(rootDoesHavePassiveEffects?(rootDoesHavePassiveEffects=!1,rootWithPendingPassiveEffects=root2,pendingPassiveEffectsLanes=lanes):(nestedPassiveUpdateCount=0,rootWithPassiveNestedUpdates=null),remainingLanes=root2.pendingLanes,remainingLanes===NoLanes&&(legacyErrorBoundariesThatAlreadyFailed=null),rootDidHavePassiveEffects||commitDoubleInvokeEffectsInDEV(root2.current,!1),onCommitRoot(finishedWork.stateNode,renderPriorityLevel),isDevToolsPresent&&root2.memoizedUpdaters.clear(),onCommitRoot$1(),ensureRootIsScheduled(root2,now2()),recoverableErrors!==null)for(var onRecoverableError=root2.onRecoverableError,i2=0;i2<recoverableErrors.length;i2++){var recoverableError=recoverableErrors[i2],componentStack=recoverableError.stack,digest=recoverableError.digest;onRecoverableError(recoverableError.value,{componentStack,digest})}if(hasUncaughtError){hasUncaughtError=!1;var error$1=firstUncaughtError;throw firstUncaughtError=null,error$1}return includesSomeLane(pendingPassiveEffectsLanes,SyncLane)&&root2.tag!==LegacyRoot&&flushPassiveEffects(),remainingLanes=root2.pendingLanes,includesSomeLane(remainingLanes,SyncLane)?(markNestedUpdateScheduled(),root2===rootWithNestedUpdates?nestedUpdateCount++:(nestedUpdateCount=0,rootWithNestedUpdates=root2)):nestedUpdateCount=0,flushSyncCallbacks(),markCommitStopped(),null}function flushPassiveEffects(){if(rootWithPendingPassiveEffects!==null){var renderPriority=lanesToEventPriority(pendingPassiveEffectsLanes),priority=lowerEventPriority(DefaultEventPriority,renderPriority),prevTransition=ReactCurrentBatchConfig$3.transition,previousPriority=getCurrentUpdatePriority();try{return ReactCurrentBatchConfig$3.transition=null,setCurrentUpdatePriority(priority),flushPassiveEffectsImpl()}finally{setCurrentUpdatePriority(previousPriority),ReactCurrentBatchConfig$3.transition=prevTransition}}return!1}function enqueuePendingPassiveProfilerEffect(fiber){pendingPassiveProfilerEffects.push(fiber),rootDoesHavePassiveEffects||(rootDoesHavePassiveEffects=!0,scheduleCallback$1(NormalPriority,function(){return flushPassiveEffects(),null}))}function flushPassiveEffectsImpl(){if(rootWithPendingPassiveEffects===null)return!1;var transitions=pendingPassiveTransitions;pendingPassiveTransitions=null;var root2=rootWithPendingPassiveEffects,lanes=pendingPassiveEffectsLanes;if(rootWithPendingPassiveEffects=null,pendingPassiveEffectsLanes=NoLanes,(executionContext&(RenderContext|CommitContext))!==NoContext)throw new Error("Cannot flush passive effects while already rendering.");isFlushingPassiveEffects=!0,didScheduleUpdateDuringPassiveEffects=!1,markPassiveEffectsStarted(lanes);var prevExecutionContext=executionContext;executionContext|=CommitContext,commitPassiveUnmountEffects(root2.current),commitPassiveMountEffects(root2,root2.current,lanes,transitions);{var profilerEffects=pendingPassiveProfilerEffects;pendingPassiveProfilerEffects=[];for(var i2=0;i2<profilerEffects.length;i2++){var _fiber=profilerEffects[i2];commitPassiveEffectDurations(root2,_fiber)}}markPassiveEffectsStopped(),commitDoubleInvokeEffectsInDEV(root2.current,!0),executionContext=prevExecutionContext,flushSyncCallbacks(),didScheduleUpdateDuringPassiveEffects?root2===rootWithPassiveNestedUpdates?nestedPassiveUpdateCount++:(nestedPassiveUpdateCount=0,rootWithPassiveNestedUpdates=root2):nestedPassiveUpdateCount=0,isFlushingPassiveEffects=!1,didScheduleUpdateDuringPassiveEffects=!1,onPostCommitRoot(root2);{var stateNode=root2.current.stateNode;stateNode.effectDuration=0,stateNode.passiveEffectDuration=0}return!0}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance)}function markLegacyErrorBoundaryAsFailed(instance){legacyErrorBoundariesThatAlreadyFailed===null?legacyErrorBoundariesThatAlreadyFailed=new Set([instance]):legacyErrorBoundariesThatAlreadyFailed.add(instance)}function prepareToThrowUncaughtError(error2){hasUncaughtError||(hasUncaughtError=!0,firstUncaughtError=error2)}var onUncaughtError=prepareToThrowUncaughtError;function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error2){var errorInfo=createCapturedValueAtFiber(error2,sourceFiber),update=createRootErrorUpdate(rootFiber,errorInfo,SyncLane),root2=enqueueUpdate(rootFiber,update,SyncLane),eventTime=requestEventTime();root2!==null&&(markRootUpdated(root2,SyncLane,eventTime),ensureRootIsScheduled(root2,eventTime))}function captureCommitPhaseError(sourceFiber,nearestMountedAncestor,error$1){if(reportUncaughtErrorInDEV(error$1),setIsRunningInsertionEffect(!1),sourceFiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error$1);return}var fiber=null;for(fiber=nearestMountedAncestor;fiber!==null;){if(fiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(fiber,sourceFiber,error$1);return}else if(fiber.tag===ClassComponent){var ctor=fiber.type,instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromError=="function"||typeof instance.componentDidCatch=="function"&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValueAtFiber(error$1,sourceFiber),update=createClassErrorUpdate(fiber,errorInfo,SyncLane),root2=enqueueUpdate(fiber,update,SyncLane),eventTime=requestEventTime();root2!==null&&(markRootUpdated(root2,SyncLane,eventTime),ensureRootIsScheduled(root2,eventTime));return}}fiber=fiber.return}error(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`,error$1)}function pingSuspendedRoot(root2,wakeable,pingedLanes){var pingCache=root2.pingCache;pingCache!==null&&pingCache.delete(wakeable);var eventTime=requestEventTime();markRootPinged(root2,pingedLanes),warnIfSuspenseResolutionNotWrappedWithActDEV(root2),workInProgressRoot===root2&&isSubsetOfLanes(workInProgressRootRenderLanes,pingedLanes)&&(workInProgressRootExitStatus===RootSuspendedWithDelay||workInProgressRootExitStatus===RootSuspended&&includesOnlyRetries(workInProgressRootRenderLanes)&&now2()-globalMostRecentFallbackTime<FALLBACK_THROTTLE_MS?prepareFreshStack(root2,NoLanes):workInProgressRootPingedLanes=mergeLanes(workInProgressRootPingedLanes,pingedLanes)),ensureRootIsScheduled(root2,eventTime)}function retryTimedOutBoundary(boundaryFiber,retryLane){retryLane===NoLane&&(retryLane=requestRetryLane(boundaryFiber));var eventTime=requestEventTime(),root2=enqueueConcurrentRenderForLane(boundaryFiber,retryLane);root2!==null&&(markRootUpdated(root2,retryLane,eventTime),ensureRootIsScheduled(root2,eventTime))}function retryDehydratedSuspenseBoundary(boundaryFiber){var suspenseState=boundaryFiber.memoizedState,retryLane=NoLane;suspenseState!==null&&(retryLane=suspenseState.retryLane),retryTimedOutBoundary(boundaryFiber,retryLane)}function resolveRetryWakeable(boundaryFiber,wakeable){var retryLane=NoLane,retryCache;switch(boundaryFiber.tag){case SuspenseComponent:retryCache=boundaryFiber.stateNode;var suspenseState=boundaryFiber.memoizedState;suspenseState!==null&&(retryLane=suspenseState.retryLane);break;case SuspenseListComponent:retryCache=boundaryFiber.stateNode;break;default:throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.")}retryCache!==null&&retryCache.delete(wakeable),retryTimedOutBoundary(boundaryFiber,retryLane)}function jnd(timeElapsed){return timeElapsed<120?120:timeElapsed<480?480:timeElapsed<1080?1080:timeElapsed<1920?1920:timeElapsed<3e3?3e3:timeElapsed<4320?4320:ceil(timeElapsed/1960)*1960}function checkForNestedUpdates(){if(nestedUpdateCount>NESTED_UPDATE_LIMIT)throw nestedUpdateCount=0,rootWithNestedUpdates=null,new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");nestedPassiveUpdateCount>NESTED_PASSIVE_UPDATE_LIMIT&&(nestedPassiveUpdateCount=0,rootWithPassiveNestedUpdates=null,error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."))}function flushRenderPhaseStrictModeWarningsInDEV(){ReactStrictModeWarnings.flushLegacyContextWarning(),ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings()}function commitDoubleInvokeEffectsInDEV(fiber,hasPassiveEffects){setCurrentFiber(fiber),invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectUnmountInDEV),hasPassiveEffects&&invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectUnmountInDEV),invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectMountInDEV),hasPassiveEffects&&invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectMountInDEV),resetCurrentFiber()}function invokeEffectsInDev(firstChild,fiberFlags,invokeEffectFn){for(var current2=firstChild,subtreeRoot=null;current2!==null;){var primarySubtreeFlag=current2.subtreeFlags&fiberFlags;current2!==subtreeRoot&&current2.child!==null&&primarySubtreeFlag!==NoFlags?current2=current2.child:((current2.flags&fiberFlags)!==NoFlags&&invokeEffectFn(current2),current2.sibling!==null?current2=current2.sibling:current2=subtreeRoot=current2.return)}}var didWarnStateUpdateForNotYetMountedComponent=null;function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber){{if((executionContext&RenderContext)!==NoContext||!(fiber.mode&ConcurrentMode))return;var tag=fiber.tag;if(tag!==IndeterminateComponent&&tag!==HostRoot&&tag!==ClassComponent&&tag!==FunctionComponent&&tag!==ForwardRef&&tag!==MemoComponent&&tag!==SimpleMemoComponent)return;var componentName=getComponentNameFromFiber(fiber)||"ReactComponent";if(didWarnStateUpdateForNotYetMountedComponent!==null){if(didWarnStateUpdateForNotYetMountedComponent.has(componentName))return;didWarnStateUpdateForNotYetMountedComponent.add(componentName)}else didWarnStateUpdateForNotYetMountedComponent=new Set([componentName]);var previousFiber=current;try{setCurrentFiber(fiber),error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.")}finally{previousFiber?setCurrentFiber(fiber):resetCurrentFiber()}}}var beginWork$1;{var dummyFiber=null;beginWork$1=function(current2,unitOfWork,lanes){var originalWorkInProgressCopy=assignFiberPropertiesInDEV(dummyFiber,unitOfWork);try{return beginWork(current2,unitOfWork,lanes)}catch(originalError){if(didSuspendOrErrorWhileHydratingDEV()||originalError!==null&&typeof originalError=="object"&&typeof originalError.then=="function")throw originalError;if(resetContextDependencies(),resetHooksAfterThrow(),unwindInterruptedWork(current2,unitOfWork),assignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy),unitOfWork.mode&ProfileMode&&startProfilerTimer(unitOfWork),invokeGuardedCallback(null,beginWork,null,current2,unitOfWork,lanes),hasCaughtError()){var replayError=clearCaughtError();typeof replayError=="object"&&replayError!==null&&replayError._suppressLogging&&typeof originalError=="object"&&originalError!==null&&!originalError._suppressLogging&&(originalError._suppressLogging=!0)}throw originalError}}}var didWarnAboutUpdateInRender=!1,didWarnAboutUpdateInRenderForAnotherComponent;didWarnAboutUpdateInRenderForAnotherComponent=new Set;function warnAboutRenderPhaseUpdatesInDEV(fiber){if(isRendering&&!getIsUpdatingOpaqueValueInRenderPhaseInDEV())switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{var renderingComponentName=workInProgress&&getComponentNameFromFiber(workInProgress)||"Unknown",dedupeKey=renderingComponentName;if(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)){didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);var setStateComponentName=getComponentNameFromFiber(fiber)||"Unknown";error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render",setStateComponentName,renderingComponentName,renderingComponentName)}break}case ClassComponent:{didWarnAboutUpdateInRender||(error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."),didWarnAboutUpdateInRender=!0);break}}}function restorePendingUpdaters(root2,lanes){if(isDevToolsPresent){var memoizedUpdaters=root2.memoizedUpdaters;memoizedUpdaters.forEach(function(schedulingFiber){addFiberToLanesMap(root2,schedulingFiber,lanes)})}}var fakeActCallbackNode={};function scheduleCallback$1(priorityLevel,callback){{var actQueue=ReactCurrentActQueue$1.current;return actQueue!==null?(actQueue.push(callback),fakeActCallbackNode):scheduleCallback(priorityLevel,callback)}}function cancelCallback$1(callbackNode){if(callbackNode!==fakeActCallbackNode)return cancelCallback(callbackNode)}function shouldForceFlushFallbacksInDEV(){return ReactCurrentActQueue$1.current!==null}function warnIfUpdatesNotWrappedWithActDEV(fiber){{if(fiber.mode&ConcurrentMode){if(!isConcurrentActEnvironment())return}else if(!isLegacyActEnvironment()||executionContext!==NoContext||fiber.tag!==FunctionComponent&&fiber.tag!==ForwardRef&&fiber.tag!==SimpleMemoComponent)return;if(ReactCurrentActQueue$1.current===null){var previousFiber=current;try{setCurrentFiber(fiber),error(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`,getComponentNameFromFiber(fiber))}finally{previousFiber?setCurrentFiber(fiber):resetCurrentFiber()}}}}function warnIfSuspenseResolutionNotWrappedWithActDEV(root2){root2.tag!==LegacyRoot&&isConcurrentActEnvironment()&&ReactCurrentActQueue$1.current===null&&error(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`)}function setIsRunningInsertionEffect(isRunning){isRunningInsertionEffect=isRunning}var resolveFamily=null,failedBoundaries=null,setRefreshHandler=function(handler){resolveFamily=handler};function resolveFunctionForHotReloading(type){{if(resolveFamily===null)return type;var family=resolveFamily(type);return family===void 0?type:family.current}}function resolveClassForHotReloading(type){return resolveFunctionForHotReloading(type)}function resolveForwardRefForHotReloading(type){{if(resolveFamily===null)return type;var family=resolveFamily(type);if(family===void 0){if(type!=null&&typeof type.render=="function"){var currentRender=resolveFunctionForHotReloading(type.render);if(type.render!==currentRender){var syntheticType={$$typeof:REACT_FORWARD_REF_TYPE,render:currentRender};return type.displayName!==void 0&&(syntheticType.displayName=type.displayName),syntheticType}}return type}return family.current}}function isCompatibleFamilyForHotReloading(fiber,element){{if(resolveFamily===null)return!1;var prevType=fiber.elementType,nextType=element.type,needsCompareFamilies=!1,$$typeofNextType=typeof nextType=="object"&&nextType!==null?nextType.$$typeof:null;switch(fiber.tag){case ClassComponent:{typeof nextType=="function"&&(needsCompareFamilies=!0);break}case FunctionComponent:{(typeof nextType=="function"||$$typeofNextType===REACT_LAZY_TYPE)&&(needsCompareFamilies=!0);break}case ForwardRef:{($$typeofNextType===REACT_FORWARD_REF_TYPE||$$typeofNextType===REACT_LAZY_TYPE)&&(needsCompareFamilies=!0);break}case MemoComponent:case SimpleMemoComponent:{($$typeofNextType===REACT_MEMO_TYPE||$$typeofNextType===REACT_LAZY_TYPE)&&(needsCompareFamilies=!0);break}default:return!1}if(needsCompareFamilies){var prevFamily=resolveFamily(prevType);if(prevFamily!==void 0&&prevFamily===resolveFamily(nextType))return!0}return!1}}function markFailedErrorBoundaryForHotReloading(fiber){{if(resolveFamily===null||typeof WeakSet!="function")return;failedBoundaries===null&&(failedBoundaries=new WeakSet),failedBoundaries.add(fiber)}}var scheduleRefresh=function(root2,update){{if(resolveFamily===null)return;var staleFamilies=update.staleFamilies,updatedFamilies=update.updatedFamilies;flushPassiveEffects(),flushSync(function(){scheduleFibersWithFamiliesRecursively(root2.current,updatedFamilies,staleFamilies)})}},scheduleRoot=function(root2,element){{if(root2.context!==emptyContextObject)return;flushPassiveEffects(),flushSync(function(){updateContainer(element,root2,null,null)})}};function scheduleFibersWithFamiliesRecursively(fiber,updatedFamilies,staleFamilies){{var alternate=fiber.alternate,child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type,candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break}if(resolveFamily===null)throw new Error("Expected resolveFamily to be set during hot reload.");var needsRender=!1,needsRemount=!1;if(candidateType!==null){var family=resolveFamily(candidateType);family!==void 0&&(staleFamilies.has(family)?needsRemount=!0:updatedFamilies.has(family)&&(tag===ClassComponent?needsRemount=!0:needsRender=!0))}if(failedBoundaries!==null&&(failedBoundaries.has(fiber)||alternate!==null&&failedBoundaries.has(alternate))&&(needsRemount=!0),needsRemount&&(fiber._debugNeedsRemount=!0),needsRemount||needsRender){var _root=enqueueConcurrentRenderForLane(fiber,SyncLane);_root!==null&&scheduleUpdateOnFiber(_root,fiber,SyncLane,NoTimestamp)}child!==null&&!needsRemount&&scheduleFibersWithFamiliesRecursively(child,updatedFamilies,staleFamilies),sibling!==null&&scheduleFibersWithFamiliesRecursively(sibling,updatedFamilies,staleFamilies)}}var findHostInstancesForRefresh=function(root2,families){{var hostInstances=new Set,types2=new Set(families.map(function(family){return family.current}));return findHostInstancesForMatchingFibersRecursively(root2.current,types2,hostInstances),hostInstances}};function findHostInstancesForMatchingFibersRecursively(fiber,types2,hostInstances){{var child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type,candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break}var didMatch=!1;candidateType!==null&&types2.has(candidateType)&&(didMatch=!0),didMatch?findHostInstancesForFiberShallowly(fiber,hostInstances):child!==null&&findHostInstancesForMatchingFibersRecursively(child,types2,hostInstances),sibling!==null&&findHostInstancesForMatchingFibersRecursively(sibling,types2,hostInstances)}}function findHostInstancesForFiberShallowly(fiber,hostInstances){{var foundHostInstances=findChildHostInstancesForFiberShallowly(fiber,hostInstances);if(foundHostInstances)return;for(var node=fiber;;){switch(node.tag){case HostComponent:hostInstances.add(node.stateNode);return;case HostPortal:hostInstances.add(node.stateNode.containerInfo);return;case HostRoot:hostInstances.add(node.stateNode.containerInfo);return}if(node.return===null)throw new Error("Expected to reach root first.");node=node.return}}}function findChildHostInstancesForFiberShallowly(fiber,hostInstances){for(var node=fiber,foundHostInstances=!1;;){if(node.tag===HostComponent)foundHostInstances=!0,hostInstances.add(node.stateNode);else if(node.child!==null){node.child.return=node,node=node.child;continue}if(node===fiber)return foundHostInstances;for(;node.sibling===null;){if(node.return===null||node.return===fiber)return foundHostInstances;node=node.return}node.sibling.return=node.return,node=node.sibling}return!1}var hasBadMapPolyfill;{hasBadMapPolyfill=!1;try{var nonExtensibleObject=Object.preventExtensions({})}catch{hasBadMapPolyfill=!0}}function FiberNode(tag,pendingProps,key,mode){this.tag=tag,this.key=key,this.elementType=null,this.type=null,this.stateNode=null,this.return=null,this.child=null,this.sibling=null,this.index=0,this.ref=null,this.pendingProps=pendingProps,this.memoizedProps=null,this.updateQueue=null,this.memoizedState=null,this.dependencies=null,this.mode=mode,this.flags=NoFlags,this.subtreeFlags=NoFlags,this.deletions=null,this.lanes=NoLanes,this.childLanes=NoLanes,this.alternate=null,this.actualDuration=Number.NaN,this.actualStartTime=Number.NaN,this.selfBaseDuration=Number.NaN,this.treeBaseDuration=Number.NaN,this.actualDuration=0,this.actualStartTime=-1,this.selfBaseDuration=0,this.treeBaseDuration=0,this._debugSource=null,this._debugOwner=null,this._debugNeedsRemount=!1,this._debugHookTypes=null,!hasBadMapPolyfill&&typeof Object.preventExtensions=="function"&&Object.preventExtensions(this)}var createFiber=function(tag,pendingProps,key,mode){return new FiberNode(tag,pendingProps,key,mode)};function shouldConstruct$1(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent)}function isSimpleFunctionComponent(type){return typeof type=="function"&&!shouldConstruct$1(type)&&type.defaultProps===void 0}function resolveLazyComponentTag(Component){if(typeof Component=="function")return shouldConstruct$1(Component)?ClassComponent:FunctionComponent;if(Component!=null){var $$typeof=Component.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE)return ForwardRef;if($$typeof===REACT_MEMO_TYPE)return MemoComponent}return IndeterminateComponent}function createWorkInProgress(current2,pendingProps){var workInProgress2=current2.alternate;workInProgress2===null?(workInProgress2=createFiber(current2.tag,pendingProps,current2.key,current2.mode),workInProgress2.elementType=current2.elementType,workInProgress2.type=current2.type,workInProgress2.stateNode=current2.stateNode,workInProgress2._debugSource=current2._debugSource,workInProgress2._debugOwner=current2._debugOwner,workInProgress2._debugHookTypes=current2._debugHookTypes,workInProgress2.alternate=current2,current2.alternate=workInProgress2):(workInProgress2.pendingProps=pendingProps,workInProgress2.type=current2.type,workInProgress2.flags=NoFlags,workInProgress2.subtreeFlags=NoFlags,workInProgress2.deletions=null,workInProgress2.actualDuration=0,workInProgress2.actualStartTime=-1),workInProgress2.flags=current2.flags&StaticMask,workInProgress2.childLanes=current2.childLanes,workInProgress2.lanes=current2.lanes,workInProgress2.child=current2.child,workInProgress2.memoizedProps=current2.memoizedProps,workInProgress2.memoizedState=current2.memoizedState,workInProgress2.updateQueue=current2.updateQueue;var currentDependencies=current2.dependencies;switch(workInProgress2.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext},workInProgress2.sibling=current2.sibling,workInProgress2.index=current2.index,workInProgress2.ref=current2.ref,workInProgress2.selfBaseDuration=current2.selfBaseDuration,workInProgress2.treeBaseDuration=current2.treeBaseDuration,workInProgress2._debugNeedsRemount=current2._debugNeedsRemount,workInProgress2.tag){case IndeterminateComponent:case FunctionComponent:case SimpleMemoComponent:workInProgress2.type=resolveFunctionForHotReloading(current2.type);break;case ClassComponent:workInProgress2.type=resolveClassForHotReloading(current2.type);break;case ForwardRef:workInProgress2.type=resolveForwardRefForHotReloading(current2.type);break}return workInProgress2}function resetWorkInProgress(workInProgress2,renderLanes2){workInProgress2.flags&=StaticMask|Placement;var current2=workInProgress2.alternate;if(current2===null)workInProgress2.childLanes=NoLanes,workInProgress2.lanes=renderLanes2,workInProgress2.child=null,workInProgress2.subtreeFlags=NoFlags,workInProgress2.memoizedProps=null,workInProgress2.memoizedState=null,workInProgress2.updateQueue=null,workInProgress2.dependencies=null,workInProgress2.stateNode=null,workInProgress2.selfBaseDuration=0,workInProgress2.treeBaseDuration=0;else{workInProgress2.childLanes=current2.childLanes,workInProgress2.lanes=current2.lanes,workInProgress2.child=current2.child,workInProgress2.subtreeFlags=NoFlags,workInProgress2.deletions=null,workInProgress2.memoizedProps=current2.memoizedProps,workInProgress2.memoizedState=current2.memoizedState,workInProgress2.updateQueue=current2.updateQueue,workInProgress2.type=current2.type;var currentDependencies=current2.dependencies;workInProgress2.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext},workInProgress2.selfBaseDuration=current2.selfBaseDuration,workInProgress2.treeBaseDuration=current2.treeBaseDuration}return workInProgress2}function createHostRootFiber(tag,isStrictMode,concurrentUpdatesByDefaultOverride){var mode;return tag===ConcurrentRoot?(mode=ConcurrentMode,isStrictMode===!0&&(mode|=StrictLegacyMode,mode|=StrictEffectsMode)):mode=NoMode,isDevToolsPresent&&(mode|=ProfileMode),createFiber(HostRoot,null,null,mode)}function createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes){var fiberTag=IndeterminateComponent,resolvedType=type;if(typeof type=="function")shouldConstruct$1(type)?(fiberTag=ClassComponent,resolvedType=resolveClassForHotReloading(resolvedType)):resolvedType=resolveFunctionForHotReloading(resolvedType);else if(typeof type=="string")fiberTag=HostComponent;else getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,lanes,key);case REACT_STRICT_MODE_TYPE:fiberTag=Mode,mode|=StrictLegacyMode,(mode&ConcurrentMode)!==NoMode&&(mode|=StrictEffectsMode);break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,lanes,key);case REACT_SUSPENSE_TYPE:return createFiberFromSuspense(pendingProps,mode,lanes,key);case REACT_SUSPENSE_LIST_TYPE:return createFiberFromSuspenseList(pendingProps,mode,lanes,key);case REACT_OFFSCREEN_TYPE:return createFiberFromOffscreen(pendingProps,mode,lanes,key);case REACT_LEGACY_HIDDEN_TYPE:case REACT_SCOPE_TYPE:case REACT_CACHE_TYPE:case REACT_TRACING_MARKER_TYPE:case REACT_DEBUG_TRACING_MODE_TYPE:default:{if(typeof type=="object"&&type!==null)switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:fiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef,resolvedType=resolveForwardRefForHotReloading(resolvedType);break getTag;case REACT_MEMO_TYPE:fiberTag=MemoComponent;break getTag;case REACT_LAZY_TYPE:fiberTag=LazyComponent,resolvedType=null;break getTag}var info="";{(type===void 0||typeof type=="object"&&type!==null&&Object.keys(type).length===0)&&(info+=" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");var ownerName=owner?getComponentNameFromFiber(owner):null;ownerName&&(info+=`

Check the render method of \``+ownerName+"`.")}throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) "+("but got: "+(type==null?type:typeof type)+"."+info))}}var fiber=createFiber(fiberTag,pendingProps,key,mode);return fiber.elementType=type,fiber.type=resolvedType,fiber.lanes=lanes,fiber._debugOwner=owner,fiber}function createFiberFromElement(element,mode,lanes){var owner=null;owner=element._owner;var type=element.type,key=element.key,pendingProps=element.props,fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes);return fiber._debugSource=element._source,fiber._debugOwner=element._owner,fiber}function createFiberFromFragment(elements,mode,lanes,key){var fiber=createFiber(Fragment,elements,key,mode);return fiber.lanes=lanes,fiber}function createFiberFromProfiler(pendingProps,mode,lanes,key){typeof pendingProps.id!="string"&&error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',typeof pendingProps.id);var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);return fiber.elementType=REACT_PROFILER_TYPE,fiber.lanes=lanes,fiber.stateNode={effectDuration:0,passiveEffectDuration:0},fiber}function createFiberFromSuspense(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseComponent,pendingProps,key,mode);return fiber.elementType=REACT_SUSPENSE_TYPE,fiber.lanes=lanes,fiber}function createFiberFromSuspenseList(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseListComponent,pendingProps,key,mode);return fiber.elementType=REACT_SUSPENSE_LIST_TYPE,fiber.lanes=lanes,fiber}function createFiberFromOffscreen(pendingProps,mode,lanes,key){var fiber=createFiber(OffscreenComponent,pendingProps,key,mode);fiber.elementType=REACT_OFFSCREEN_TYPE,fiber.lanes=lanes;var primaryChildInstance={isHidden:!1};return fiber.stateNode=primaryChildInstance,fiber}function createFiberFromText(content,mode,lanes){var fiber=createFiber(HostText,content,null,mode);return fiber.lanes=lanes,fiber}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoMode);return fiber.elementType="DELETED",fiber}function createFiberFromDehydratedFragment(dehydratedNode){var fiber=createFiber(DehydratedFragment,null,null,NoMode);return fiber.stateNode=dehydratedNode,fiber}function createFiberFromPortal(portal,mode,lanes){var pendingProps=portal.children!==null?portal.children:[],fiber=createFiber(HostPortal,pendingProps,portal.key,mode);return fiber.lanes=lanes,fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,implementation:portal.implementation},fiber}function assignFiberPropertiesInDEV(target,source){return target===null&&(target=createFiber(IndeterminateComponent,null,null,NoMode)),target.tag=source.tag,target.key=source.key,target.elementType=source.elementType,target.type=source.type,target.stateNode=source.stateNode,target.return=source.return,target.child=source.child,target.sibling=source.sibling,target.index=source.index,target.ref=source.ref,target.pendingProps=source.pendingProps,target.memoizedProps=source.memoizedProps,target.updateQueue=source.updateQueue,target.memoizedState=source.memoizedState,target.dependencies=source.dependencies,target.mode=source.mode,target.flags=source.flags,target.subtreeFlags=source.subtreeFlags,target.deletions=source.deletions,target.lanes=source.lanes,target.childLanes=source.childLanes,target.alternate=source.alternate,target.actualDuration=source.actualDuration,target.actualStartTime=source.actualStartTime,target.selfBaseDuration=source.selfBaseDuration,target.treeBaseDuration=source.treeBaseDuration,target._debugSource=source._debugSource,target._debugOwner=source._debugOwner,target._debugNeedsRemount=source._debugNeedsRemount,target._debugHookTypes=source._debugHookTypes,target}function FiberRootNode(containerInfo,tag,hydrate2,identifierPrefix,onRecoverableError){this.tag=tag,this.containerInfo=containerInfo,this.pendingChildren=null,this.current=null,this.pingCache=null,this.finishedWork=null,this.timeoutHandle=noTimeout,this.context=null,this.pendingContext=null,this.callbackNode=null,this.callbackPriority=NoLane,this.eventTimes=createLaneMap(NoLanes),this.expirationTimes=createLaneMap(NoTimestamp),this.pendingLanes=NoLanes,this.suspendedLanes=NoLanes,this.pingedLanes=NoLanes,this.expiredLanes=NoLanes,this.mutableReadLanes=NoLanes,this.finishedLanes=NoLanes,this.entangledLanes=NoLanes,this.entanglements=createLaneMap(NoLanes),this.identifierPrefix=identifierPrefix,this.onRecoverableError=onRecoverableError,this.mutableSourceEagerHydrationData=null,this.effectDuration=0,this.passiveEffectDuration=0;{this.memoizedUpdaters=new Set;for(var pendingUpdatersLaneMap=this.pendingUpdatersLaneMap=[],_i=0;_i<TotalLanes;_i++)pendingUpdatersLaneMap.push(new Set)}switch(tag){case ConcurrentRoot:this._debugRootType=hydrate2?"hydrateRoot()":"createRoot()";break;case LegacyRoot:this._debugRootType=hydrate2?"hydrate()":"render()";break}}function createFiberRoot(containerInfo,tag,hydrate2,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var root2=new FiberRootNode(containerInfo,tag,hydrate2,identifierPrefix,onRecoverableError),uninitializedFiber=createHostRootFiber(tag,isStrictMode);root2.current=uninitializedFiber,uninitializedFiber.stateNode=root2;{var _initialState={element:initialChildren,isDehydrated:hydrate2,cache:null,transitions:null,pendingSuspenseBoundaries:null};uninitializedFiber.memoizedState=_initialState}return initializeUpdateQueue(uninitializedFiber),root2}var ReactVersion="18.2.0";function createPortal(children,containerInfo,implementation){var key=arguments.length>3&&arguments[3]!==void 0?arguments[3]:null;return checkKeyStringCoercion(key),{$$typeof:REACT_PORTAL_TYPE,key:key==null?null:""+key,children,containerInfo,implementation}}var didWarnAboutNestedUpdates,didWarnAboutFindNodeInStrictMode;didWarnAboutNestedUpdates=!1,didWarnAboutFindNodeInStrictMode={};function getContextForSubtree(parentComponent){if(!parentComponent)return emptyContextObject;var fiber=get(parentComponent),parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component))return processChildContext(fiber,Component,parentContext)}return parentContext}function findHostInstanceWithWarning(component,methodName){{var fiber=get(component);if(fiber===void 0){if(typeof component.render=="function")throw new Error("Unable to find node on an unmounted component.");var keys2=Object.keys(component).join(",");throw new Error("Argument appears to not be a ReactComponent. Keys: "+keys2)}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null)return null;if(hostFiber.mode&StrictLegacyMode){var componentName=getComponentNameFromFiber(fiber)||"Component";if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=!0;var previousFiber=current;try{setCurrentFiber(hostFiber),fiber.mode&StrictLegacyMode?error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node",methodName,methodName,componentName):error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node",methodName,methodName,componentName)}finally{previousFiber?setCurrentFiber(previousFiber):resetCurrentFiber()}}}return hostFiber.stateNode}}function createContainer(containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate2=!1,initialChildren=null;return createFiberRoot(containerInfo,tag,hydrate2,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError)}function createHydrationContainer(initialChildren,callback,containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate2=!0,root2=createFiberRoot(containerInfo,tag,hydrate2,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);root2.context=getContextForSubtree(null);var current2=root2.current,eventTime=requestEventTime(),lane=requestUpdateLane(current2),update=createUpdate(eventTime,lane);return update.callback=callback??null,enqueueUpdate(current2,update,lane),scheduleInitialHydrationOnRoot(root2,lane,eventTime),root2}function updateContainer(element,container,parentComponent,callback){onScheduleRoot(container,element);var current$1=container.current,eventTime=requestEventTime(),lane=requestUpdateLane(current$1);markRenderScheduled(lane);var context2=getContextForSubtree(parentComponent);container.context===null?container.context=context2:container.pendingContext=context2,isRendering&&current!==null&&!didWarnAboutNestedUpdates&&(didWarnAboutNestedUpdates=!0,error(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`,getComponentNameFromFiber(current)||"Unknown"));var update=createUpdate(eventTime,lane);update.payload={element},callback=callback===void 0?null:callback,callback!==null&&(typeof callback!="function"&&error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.",callback),update.callback=callback);var root2=enqueueUpdate(current$1,update,lane);return root2!==null&&(scheduleUpdateOnFiber(root2,current$1,lane,eventTime),entangleTransitions(root2,current$1,lane)),lane}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child)return null;switch(containerFiber.child.tag){case HostComponent:return containerFiber.child.stateNode;default:return containerFiber.child.stateNode}}function attemptSynchronousHydration$1(fiber){switch(fiber.tag){case HostRoot:{var root2=fiber.stateNode;if(isRootDehydrated(root2)){var lanes=getHighestPriorityPendingLanes(root2);flushRoot(root2,lanes)}break}case SuspenseComponent:{flushSync(function(){var root3=enqueueConcurrentRenderForLane(fiber,SyncLane);if(root3!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root3,fiber,SyncLane,eventTime)}});var retryLane=SyncLane;markRetryLaneIfNotHydrated(fiber,retryLane);break}}}function markRetryLaneImpl(fiber,retryLane){var suspenseState=fiber.memoizedState;suspenseState!==null&&suspenseState.dehydrated!==null&&(suspenseState.retryLane=higherPriorityLane(suspenseState.retryLane,retryLane))}function markRetryLaneIfNotHydrated(fiber,retryLane){markRetryLaneImpl(fiber,retryLane);var alternate=fiber.alternate;alternate&&markRetryLaneImpl(alternate,retryLane)}function attemptContinuousHydration$1(fiber){if(fiber.tag===SuspenseComponent){var lane=SelectiveHydrationLane,root2=enqueueConcurrentRenderForLane(fiber,lane);if(root2!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root2,fiber,lane,eventTime)}markRetryLaneIfNotHydrated(fiber,lane)}}function attemptHydrationAtCurrentPriority$1(fiber){if(fiber.tag===SuspenseComponent){var lane=requestUpdateLane(fiber),root2=enqueueConcurrentRenderForLane(fiber,lane);if(root2!==null){var eventTime=requestEventTime();scheduleUpdateOnFiber(root2,fiber,lane,eventTime)}markRetryLaneIfNotHydrated(fiber,lane)}}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);return hostFiber===null?null:hostFiber.stateNode}var shouldErrorImpl=function(fiber){return null};function shouldError(fiber){return shouldErrorImpl(fiber)}var shouldSuspendImpl=function(fiber){return!1};function shouldSuspend(fiber){return shouldSuspendImpl(fiber)}var overrideHookState=null,overrideHookStateDeletePath=null,overrideHookStateRenamePath=null,overrideProps=null,overridePropsDeletePath=null,overridePropsRenamePath=null,scheduleUpdate=null,setErrorHandler=null,setSuspenseHandler=null;{var copyWithDeleteImpl=function(obj,path2,index2){var key=path2[index2],updated=isArray(obj)?obj.slice():assign({},obj);return index2+1===path2.length?(isArray(updated)?updated.splice(key,1):delete updated[key],updated):(updated[key]=copyWithDeleteImpl(obj[key],path2,index2+1),updated)},copyWithDelete=function(obj,path2){return copyWithDeleteImpl(obj,path2,0)},copyWithRenameImpl=function(obj,oldPath,newPath,index2){var oldKey=oldPath[index2],updated=isArray(obj)?obj.slice():assign({},obj);if(index2+1===oldPath.length){var newKey=newPath[index2];updated[newKey]=updated[oldKey],isArray(updated)?updated.splice(oldKey,1):delete updated[oldKey]}else updated[oldKey]=copyWithRenameImpl(obj[oldKey],oldPath,newPath,index2+1);return updated},copyWithRename=function(obj,oldPath,newPath){if(oldPath.length!==newPath.length){warn("copyWithRename() expects paths of the same length");return}else for(var i2=0;i2<newPath.length-1;i2++)if(oldPath[i2]!==newPath[i2]){warn("copyWithRename() expects paths to be the same except for the deepest key");return}return copyWithRenameImpl(obj,oldPath,newPath,0)},copyWithSetImpl=function(obj,path2,index2,value){if(index2>=path2.length)return value;var key=path2[index2],updated=isArray(obj)?obj.slice():assign({},obj);return updated[key]=copyWithSetImpl(obj[key],path2,index2+1,value),updated},copyWithSet=function(obj,path2,value){return copyWithSetImpl(obj,path2,0,value)},findHook=function(fiber,id2){for(var currentHook2=fiber.memoizedState;currentHook2!==null&&id2>0;)currentHook2=currentHook2.next,id2--;return currentHook2};overrideHookState=function(fiber,id2,path2,value){var hook=findHook(fiber,id2);if(hook!==null){var newState=copyWithSet(hook.memoizedState,path2,value);hook.memoizedState=newState,hook.baseState=newState,fiber.memoizedProps=assign({},fiber.memoizedProps);var root2=enqueueConcurrentRenderForLane(fiber,SyncLane);root2!==null&&scheduleUpdateOnFiber(root2,fiber,SyncLane,NoTimestamp)}},overrideHookStateDeletePath=function(fiber,id2,path2){var hook=findHook(fiber,id2);if(hook!==null){var newState=copyWithDelete(hook.memoizedState,path2);hook.memoizedState=newState,hook.baseState=newState,fiber.memoizedProps=assign({},fiber.memoizedProps);var root2=enqueueConcurrentRenderForLane(fiber,SyncLane);root2!==null&&scheduleUpdateOnFiber(root2,fiber,SyncLane,NoTimestamp)}},overrideHookStateRenamePath=function(fiber,id2,oldPath,newPath){var hook=findHook(fiber,id2);if(hook!==null){var newState=copyWithRename(hook.memoizedState,oldPath,newPath);hook.memoizedState=newState,hook.baseState=newState,fiber.memoizedProps=assign({},fiber.memoizedProps);var root2=enqueueConcurrentRenderForLane(fiber,SyncLane);root2!==null&&scheduleUpdateOnFiber(root2,fiber,SyncLane,NoTimestamp)}},overrideProps=function(fiber,path2,value){fiber.pendingProps=copyWithSet(fiber.memoizedProps,path2,value),fiber.alternate&&(fiber.alternate.pendingProps=fiber.pendingProps);var root2=enqueueConcurrentRenderForLane(fiber,SyncLane);root2!==null&&scheduleUpdateOnFiber(root2,fiber,SyncLane,NoTimestamp)},overridePropsDeletePath=function(fiber,path2){fiber.pendingProps=copyWithDelete(fiber.memoizedProps,path2),fiber.alternate&&(fiber.alternate.pendingProps=fiber.pendingProps);var root2=enqueueConcurrentRenderForLane(fiber,SyncLane);root2!==null&&scheduleUpdateOnFiber(root2,fiber,SyncLane,NoTimestamp)},overridePropsRenamePath=function(fiber,oldPath,newPath){fiber.pendingProps=copyWithRename(fiber.memoizedProps,oldPath,newPath),fiber.alternate&&(fiber.alternate.pendingProps=fiber.pendingProps);var root2=enqueueConcurrentRenderForLane(fiber,SyncLane);root2!==null&&scheduleUpdateOnFiber(root2,fiber,SyncLane,NoTimestamp)},scheduleUpdate=function(fiber){var root2=enqueueConcurrentRenderForLane(fiber,SyncLane);root2!==null&&scheduleUpdateOnFiber(root2,fiber,SyncLane,NoTimestamp)},setErrorHandler=function(newShouldErrorImpl){shouldErrorImpl=newShouldErrorImpl},setSuspenseHandler=function(newShouldSuspendImpl){shouldSuspendImpl=newShouldSuspendImpl}}function findHostInstanceByFiber(fiber){var hostFiber=findCurrentHostFiber(fiber);return hostFiber===null?null:hostFiber.stateNode}function emptyFindFiberByHostInstance(instance){return null}function getCurrentFiberForDevTools(){return current}function injectIntoDevTools(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance,ReactCurrentDispatcher3=ReactSharedInternals.ReactCurrentDispatcher;return injectInternals({bundleType:devToolsConfig.bundleType,version:devToolsConfig.version,rendererPackageName:devToolsConfig.rendererPackageName,rendererConfig:devToolsConfig.rendererConfig,overrideHookState,overrideHookStateDeletePath,overrideHookStateRenamePath,overrideProps,overridePropsDeletePath,overridePropsRenamePath,setErrorHandler,setSuspenseHandler,scheduleUpdate,currentDispatcherRef:ReactCurrentDispatcher3,findHostInstanceByFiber,findFiberByHostInstance:findFiberByHostInstance||emptyFindFiberByHostInstance,findHostInstancesForRefresh,scheduleRefresh,scheduleRoot,setRefreshHandler,getCurrentFiber:getCurrentFiberForDevTools,reconcilerVersion:ReactVersion})}var defaultOnRecoverableError=typeof reportError=="function"?reportError:function(error2){console.error(error2)};function ReactDOMRoot(internalRoot){this._internalRoot=internalRoot}ReactDOMHydrationRoot.prototype.render=ReactDOMRoot.prototype.render=function(children){var root2=this._internalRoot;if(root2===null)throw new Error("Cannot update an unmounted root.");{typeof arguments[1]=="function"?error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."):isValidContainer(arguments[1])?error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."):typeof arguments[1]<"u"&&error("You passed a second argument to root.render(...) but it only accepts one argument.");var container=root2.containerInfo;if(container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(root2.current);hostInstance&&hostInstance.parentNode!==container&&error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.")}}updateContainer(children,root2,null,null)},ReactDOMHydrationRoot.prototype.unmount=ReactDOMRoot.prototype.unmount=function(){typeof arguments[0]=="function"&&error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");var root2=this._internalRoot;if(root2!==null){this._internalRoot=null;var container=root2.containerInfo;isAlreadyRendering()&&error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."),flushSync(function(){updateContainer(null,root2,null,null)}),unmarkContainerAsRoot(container)}};function createRoot2(container,options2){if(!isValidContainer(container))throw new Error("createRoot(...): Target container is not a DOM element.");warnIfReactDOMContainerInDEV(container);var isStrictMode=!1,concurrentUpdatesByDefaultOverride=!1,identifierPrefix="",onRecoverableError=defaultOnRecoverableError;options2!=null&&(options2.hydrate?warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."):typeof options2=="object"&&options2!==null&&options2.$$typeof===REACT_ELEMENT_TYPE&&error(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`),options2.unstable_strictMode===!0&&(isStrictMode=!0),options2.identifierPrefix!==void 0&&(identifierPrefix=options2.identifierPrefix),options2.onRecoverableError!==void 0&&(onRecoverableError=options2.onRecoverableError),options2.transitionCallbacks!==void 0&&options2.transitionCallbacks);var root2=createContainer(container,ConcurrentRoot,null,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);markContainerAsRoot(root2.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;return listenToAllSupportedEvents(rootContainerElement),new ReactDOMRoot(root2)}function ReactDOMHydrationRoot(internalRoot){this._internalRoot=internalRoot}function scheduleHydration(target){target&&queueExplicitHydrationTarget(target)}ReactDOMHydrationRoot.prototype.unstable_scheduleHydration=scheduleHydration;function hydrateRoot(container,initialChildren,options2){if(!isValidContainer(container))throw new Error("hydrateRoot(...): Target container is not a DOM element.");warnIfReactDOMContainerInDEV(container),initialChildren===void 0&&error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");var hydrationCallbacks=options2??null,mutableSources=options2!=null&&options2.hydratedSources||null,isStrictMode=!1,concurrentUpdatesByDefaultOverride=!1,identifierPrefix="",onRecoverableError=defaultOnRecoverableError;options2!=null&&(options2.unstable_strictMode===!0&&(isStrictMode=!0),options2.identifierPrefix!==void 0&&(identifierPrefix=options2.identifierPrefix),options2.onRecoverableError!==void 0&&(onRecoverableError=options2.onRecoverableError));var root2=createHydrationContainer(initialChildren,null,container,ConcurrentRoot,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);if(markContainerAsRoot(root2.current,container),listenToAllSupportedEvents(container),mutableSources)for(var i2=0;i2<mutableSources.length;i2++){var mutableSource=mutableSources[i2];registerMutableSourceForHydration(root2,mutableSource)}return new ReactDOMHydrationRoot(root2)}function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||!disableCommentsAsDOMContainers))}function isValidContainerLegacy(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===" react-mount-point-unstable "))}function warnIfReactDOMContainerInDEV(container){container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==="BODY"&&error("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."),isContainerMarkedAsRoot(container)&&(container._reactRootContainer?error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."):error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."))}var ReactCurrentOwner$3=ReactSharedInternals.ReactCurrentOwner,topLevelUpdateWarnings;topLevelUpdateWarnings=function(container){if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=findHostInstanceWithNoPortals(container._reactRootContainer.current);hostInstance&&hostInstance.parentNode!==container&&error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.")}var isRootRenderedBySomeReact=!!container._reactRootContainer,rootEl=getReactRootElementInContainer(container),hasNonRootReactChild=!!(rootEl&&getInstanceFromNode(rootEl));hasNonRootReactChild&&!isRootRenderedBySomeReact&&error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."),container.nodeType===ELEMENT_NODE&&container.tagName&&container.tagName.toUpperCase()==="BODY"&&error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.")};function getReactRootElementInContainer(container){return container?container.nodeType===DOCUMENT_NODE?container.documentElement:container.firstChild:null}function noopOnRecoverableError(){}function legacyCreateRootFromDOMContainer(container,initialChildren,parentComponent,callback,isHydrationContainer){if(isHydrationContainer){if(typeof callback=="function"){var originalCallback=callback;callback=function(){var instance=getPublicRootInstance(root2);originalCallback.call(instance)}}var root2=createHydrationContainer(initialChildren,callback,container,LegacyRoot,null,!1,!1,"",noopOnRecoverableError);container._reactRootContainer=root2,markContainerAsRoot(root2.current,container);var rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;return listenToAllSupportedEvents(rootContainerElement),flushSync(),root2}else{for(var rootSibling;rootSibling=container.lastChild;)container.removeChild(rootSibling);if(typeof callback=="function"){var _originalCallback=callback;callback=function(){var instance=getPublicRootInstance(_root);_originalCallback.call(instance)}}var _root=createContainer(container,LegacyRoot,null,!1,!1,"",noopOnRecoverableError);container._reactRootContainer=_root,markContainerAsRoot(_root.current,container);var _rootContainerElement=container.nodeType===COMMENT_NODE?container.parentNode:container;return listenToAllSupportedEvents(_rootContainerElement),flushSync(function(){updateContainer(initialChildren,_root,parentComponent,callback)}),_root}}function warnOnInvalidCallback$1(callback,callerName){callback!==null&&typeof callback!="function"&&error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.",callerName,callback)}function legacyRenderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){topLevelUpdateWarnings(container),warnOnInvalidCallback$1(callback===void 0?null:callback,"render");var maybeRoot=container._reactRootContainer,root2;if(!maybeRoot)root2=legacyCreateRootFromDOMContainer(container,children,parentComponent,callback,forceHydrate);else{if(root2=maybeRoot,typeof callback=="function"){var originalCallback=callback;callback=function(){var instance=getPublicRootInstance(root2);originalCallback.call(instance)}}updateContainer(children,root2,parentComponent,callback)}return getPublicRootInstance(root2)}function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner$3.current;if(owner!==null&&owner.stateNode!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;warnedAboutRefsInRender||error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.",getComponentNameFromType(owner.type)||"A component"),owner.stateNode._warnedAboutRefsInRender=!0}}return componentOrElement==null?null:componentOrElement.nodeType===ELEMENT_NODE?componentOrElement:findHostInstanceWithWarning(componentOrElement,"findDOMNode")}function hydrate(element,container,callback){if(error("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"),!isValidContainerLegacy(container))throw new Error("Target container is not a DOM element.");{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===void 0;isModernRoot&&error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?")}return legacyRenderSubtreeIntoContainer(null,element,container,!0,callback)}function render(element,container,callback){if(error("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"),!isValidContainerLegacy(container))throw new Error("Target container is not a DOM element.");{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===void 0;isModernRoot&&error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?")}return legacyRenderSubtreeIntoContainer(null,element,container,!1,callback)}function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){if(error("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"),!isValidContainerLegacy(containerNode))throw new Error("Target container is not a DOM element.");if(parentComponent==null||!has(parentComponent))throw new Error("parentComponent must be a valid React Component");return legacyRenderSubtreeIntoContainer(parentComponent,element,containerNode,!1,callback)}function unmountComponentAtNode2(container){if(!isValidContainerLegacy(container))throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");{var isModernRoot=isContainerMarkedAsRoot(container)&&container._reactRootContainer===void 0;isModernRoot&&error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?")}if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container),renderedByDifferentReact=rootEl&&!getInstanceFromNode(rootEl);renderedByDifferentReact&&error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.")}return flushSync(function(){legacyRenderSubtreeIntoContainer(null,null,container,!1,function(){container._reactRootContainer=null,unmarkContainerAsRoot(container)})}),!0}else{{var _rootEl=getReactRootElementInContainer(container),hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode(_rootEl)),isContainerReactRoot=container.nodeType===ELEMENT_NODE&&isValidContainerLegacy(container.parentNode)&&!!container.parentNode._reactRootContainer;hasNonRootReactChild&&error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s",isContainerReactRoot?"You may have accidentally passed in a React root node instead of its container.":"Instead, have the parent component update its state and rerender in order to remove this component.")}return!1}}setAttemptSynchronousHydration(attemptSynchronousHydration$1),setAttemptContinuousHydration(attemptContinuousHydration$1),setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1),setGetCurrentUpdatePriority(getCurrentUpdatePriority),setAttemptHydrationAtPriority(runWithPriority),(typeof Map!="function"||Map.prototype==null||typeof Map.prototype.forEach!="function"||typeof Set!="function"||Set.prototype==null||typeof Set.prototype.clear!="function"||typeof Set.prototype.forEach!="function")&&error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"),setRestoreImplementation(restoreControlledState$3),setBatchingImplementation(batchedUpdates$1,discreteUpdates,flushSync);function createPortal$1(children,container){var key=arguments.length>2&&arguments[2]!==void 0?arguments[2]:null;if(!isValidContainer(container))throw new Error("Target container is not a DOM element.");return createPortal(children,container,null,key)}function renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){return unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback)}var Internals={usingClientEntryPoint:!1,Events:[getInstanceFromNode,getNodeFromInstance,getFiberCurrentPropsFromNode,enqueueStateRestore,restoreStateIfNeeded,batchedUpdates$1]};function createRoot$12(container,options2){return Internals.usingClientEntryPoint||error('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'),createRoot2(container,options2)}function hydrateRoot$1(container,initialChildren,options2){return Internals.usingClientEntryPoint||error('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'),hydrateRoot(container,initialChildren,options2)}function flushSync$1(fn){return isAlreadyRendering()&&error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."),flushSync(fn)}var foundDevTools=injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:"react-dom"});if(!foundDevTools&&canUseDOM&&window.top===window.self&&(navigator.userAgent.indexOf("Chrome")>-1&&navigator.userAgent.indexOf("Edge")===-1||navigator.userAgent.indexOf("Firefox")>-1)){var protocol=window.location.protocol;/^(https?|file):$/.test(protocol)&&console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools"+(protocol==="file:"?`
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq`:""),"font-weight:bold")}reactDom_development.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Internals,reactDom_development.createPortal=createPortal$1,reactDom_development.createRoot=createRoot$12,reactDom_development.findDOMNode=findDOMNode,reactDom_development.flushSync=flushSync$1,reactDom_development.hydrate=hydrate,reactDom_development.hydrateRoot=hydrateRoot$1,reactDom_development.render=render,reactDom_development.unmountComponentAtNode=unmountComponentAtNode2,reactDom_development.unstable_batchedUpdates=batchedUpdates$1,reactDom_development.unstable_renderSubtreeIntoContainer=renderSubtreeIntoContainer,reactDom_development.version=ReactVersion,typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop=="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error)})();reactDom.exports=reactDom_development;var reactDomExports=reactDom.exports,createRoot$1,m$1=reactDomExports;{var i$3=m$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;createRoot$1=function(c2,o2){i$3.usingClientEntryPoint=!0;try{return m$1.createRoot(c2,o2)}finally{i$3.usingClientEntryPoint=!1}}}const MotionConfigContext=reactExports.createContext({transformPagePoint:p2=>p2,isStatic:!1,reducedMotion:"never"}),MotionContext=reactExports.createContext({}),PresenceContext=reactExports.createContext(null),isBrowser=typeof document<"u",useIsomorphicLayoutEffect$2=isBrowser?reactExports.useLayoutEffect:reactExports.useEffect,LazyContext=reactExports.createContext({strict:!1});function useVisualElement(Component,visualState,props,createVisualElement){const{visualElement:parent}=reactExports.useContext(MotionContext),lazyContext=reactExports.useContext(LazyContext),presenceContext=reactExports.useContext(PresenceContext),reducedMotionConfig=reactExports.useContext(MotionConfigContext).reducedMotion,visualElementRef=reactExports.useRef();createVisualElement=createVisualElement||lazyContext.renderer,!visualElementRef.current&&createVisualElement&&(visualElementRef.current=createVisualElement(Component,{visualState,parent,props,presenceContext,blockInitialAnimation:presenceContext?presenceContext.initial===!1:!1,reducedMotionConfig}));const visualElement=visualElementRef.current;reactExports.useInsertionEffect(()=>{visualElement&&visualElement.update(props,presenceContext)});const canHandoff=reactExports.useRef(!!window.HandoffAppearAnimations);return useIsomorphicLayoutEffect$2(()=>{visualElement&&(visualElement.render(),canHandoff.current&&visualElement.animationState&&visualElement.animationState.animateChanges())}),reactExports.useEffect(()=>{visualElement&&(visualElement.updateFeatures(),!canHandoff.current&&visualElement.animationState&&visualElement.animationState.animateChanges(),window.HandoffAppearAnimations=void 0,canHandoff.current=!1)}),visualElement}function isRefObject$1(ref){return typeof ref=="object"&&Object.prototype.hasOwnProperty.call(ref,"current")}function useMotionRef(visualState,visualElement,externalRef){return reactExports.useCallback(instance=>{instance&&visualState.mount&&visualState.mount(instance),visualElement&&(instance?visualElement.mount(instance):visualElement.unmount()),externalRef&&(typeof externalRef=="function"?externalRef(instance):isRefObject$1(externalRef)&&(externalRef.current=instance))},[visualElement])}function isVariantLabel(v4){return typeof v4=="string"||Array.isArray(v4)}function isAnimationControls(v4){return typeof v4=="object"&&typeof v4.start=="function"}const variantPriorityOrder=["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],variantProps=["initial",...variantPriorityOrder];function isControllingVariants(props){return isAnimationControls(props.animate)||variantProps.some(name=>isVariantLabel(props[name]))}function isVariantNode(props){return!!(isControllingVariants(props)||props.variants)}function getCurrentTreeVariants(props,context2){if(isControllingVariants(props)){const{initial,animate}=props;return{initial:initial===!1||isVariantLabel(initial)?initial:void 0,animate:isVariantLabel(animate)?animate:void 0}}return props.inherit!==!1?context2:{}}function useCreateMotionContext(props){const{initial,animate}=getCurrentTreeVariants(props,reactExports.useContext(MotionContext));return reactExports.useMemo(()=>({initial,animate}),[variantLabelsAsDependency(initial),variantLabelsAsDependency(animate)])}function variantLabelsAsDependency(prop){return Array.isArray(prop)?prop.join(" "):prop}const featureProps={animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},featureDefinitions={};for(const key in featureProps)featureDefinitions[key]={isEnabled:props=>featureProps[key].some(name=>!!props[name])};function loadFeatures(features){for(const key in features)featureDefinitions[key]={...featureDefinitions[key],...features[key]}}const LayoutGroupContext=reactExports.createContext({}),SwitchLayoutGroupContext=reactExports.createContext({}),motionComponentSymbol=Symbol.for("motionComponentSymbol");function createMotionComponent({preloadedFeatures:preloadedFeatures2,createVisualElement,useRender,useVisualState,Component}){preloadedFeatures2&&loadFeatures(preloadedFeatures2);function MotionComponent(props,externalRef){let MeasureLayout2;const configAndProps={...reactExports.useContext(MotionConfigContext),...props,layoutId:useLayoutId(props)},{isStatic}=configAndProps,context2=useCreateMotionContext(props),visualState=useVisualState(props,isStatic);if(!isStatic&&isBrowser){context2.visualElement=useVisualElement(Component,visualState,configAndProps,createVisualElement);const initialLayoutGroupConfig=reactExports.useContext(SwitchLayoutGroupContext),isStrict=reactExports.useContext(LazyContext).strict;context2.visualElement&&(MeasureLayout2=context2.visualElement.loadFeatures(configAndProps,isStrict,preloadedFeatures2,initialLayoutGroupConfig))}return reactExports.createElement(MotionContext.Provider,{value:context2},MeasureLayout2&&context2.visualElement?reactExports.createElement(MeasureLayout2,{visualElement:context2.visualElement,...configAndProps}):null,useRender(Component,props,useMotionRef(visualState,context2.visualElement,externalRef),visualState,isStatic,context2.visualElement))}const ForwardRefComponent=reactExports.forwardRef(MotionComponent);return ForwardRefComponent[motionComponentSymbol]=Component,ForwardRefComponent}function useLayoutId({layoutId}){const layoutGroupId=reactExports.useContext(LayoutGroupContext).id;return layoutGroupId&&layoutId!==void 0?layoutGroupId+"-"+layoutId:layoutId}function createMotionProxy(createConfig){function custom(Component,customMotionComponentConfig={}){return createMotionComponent(createConfig(Component,customMotionComponentConfig))}if(typeof Proxy>"u")return custom;const componentCache=new Map;return new Proxy(custom,{get:(_target2,key)=>(componentCache.has(key)||componentCache.set(key,custom(key)),componentCache.get(key))})}const lowercaseSVGElements=["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];function isSVGComponent(Component){return typeof Component!="string"||Component.includes("-")?!1:!!(lowercaseSVGElements.indexOf(Component)>-1||/[A-Z]/.test(Component))}const scaleCorrectors={};function addScaleCorrector(correctors){Object.assign(scaleCorrectors,correctors)}const transformPropOrder=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],transformProps=new Set(transformPropOrder);function isForcedMotionValue(key,{layout:layout2,layoutId}){return transformProps.has(key)||key.startsWith("origin")||(layout2||layoutId!==void 0)&&(!!scaleCorrectors[key]||key==="opacity")}const isMotionValue=value=>!!(value&&value.getVelocity),translateAlias={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},numTransforms=transformPropOrder.length;function buildTransform(transform,{enableHardwareAcceleration=!0,allowTransformNone=!0},transformIsDefault,transformTemplate){let transformString="";for(let i2=0;i2<numTransforms;i2++){const key=transformPropOrder[i2];if(transform[key]!==void 0){const transformName=translateAlias[key]||key;transformString+=`${transformName}(${transform[key]}) `}}return enableHardwareAcceleration&&!transform.z&&(transformString+="translateZ(0)"),transformString=transformString.trim(),transformTemplate?transformString=transformTemplate(transform,transformIsDefault?"":transformString):allowTransformNone&&transformIsDefault&&(transformString="none"),transformString}const checkStringStartsWith=token=>key=>typeof key=="string"&&key.startsWith(token),isCSSVariableName=checkStringStartsWith("--"),isCSSVariableToken=checkStringStartsWith("var(--"),cssVariableRegex=/var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,getValueAsType=(value,type)=>type&&typeof value=="number"?type.transform(value):value,clamp$1=(min,max2,v4)=>Math.min(Math.max(v4,min),max2),number={test:v4=>typeof v4=="number",parse:parseFloat,transform:v4=>v4},alpha={...number,transform:v4=>clamp$1(0,1,v4)},scale={...number,default:1},sanitize=v4=>Math.round(v4*1e5)/1e5,floatRegex=/(-)?([\d]*\.?[\d])+/g,colorRegex=/(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,singleColorRegex=/^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;function isString(v4){return typeof v4=="string"}const createUnitType=unit=>({test:v4=>isString(v4)&&v4.endsWith(unit)&&v4.split(" ").length===1,parse:parseFloat,transform:v4=>`${v4}${unit}`}),degrees=createUnitType("deg"),percent=createUnitType("%"),px$1=createUnitType("px"),vh=createUnitType("vh"),vw=createUnitType("vw"),progressPercentage={...percent,parse:v4=>percent.parse(v4)/100,transform:v4=>percent.transform(v4*100)},int={...number,transform:Math.round},numberValueTypes={borderWidth:px$1,borderTopWidth:px$1,borderRightWidth:px$1,borderBottomWidth:px$1,borderLeftWidth:px$1,borderRadius:px$1,radius:px$1,borderTopLeftRadius:px$1,borderTopRightRadius:px$1,borderBottomRightRadius:px$1,borderBottomLeftRadius:px$1,width:px$1,maxWidth:px$1,height:px$1,maxHeight:px$1,size:px$1,top:px$1,right:px$1,bottom:px$1,left:px$1,padding:px$1,paddingTop:px$1,paddingRight:px$1,paddingBottom:px$1,paddingLeft:px$1,margin:px$1,marginTop:px$1,marginRight:px$1,marginBottom:px$1,marginLeft:px$1,rotate:degrees,rotateX:degrees,rotateY:degrees,rotateZ:degrees,scale,scaleX:scale,scaleY:scale,scaleZ:scale,skew:degrees,skewX:degrees,skewY:degrees,distance:px$1,translateX:px$1,translateY:px$1,translateZ:px$1,x:px$1,y:px$1,z:px$1,perspective:px$1,transformPerspective:px$1,opacity:alpha,originX:progressPercentage,originY:progressPercentage,originZ:px$1,zIndex:int,fillOpacity:alpha,strokeOpacity:alpha,numOctaves:int};function buildHTMLStyles(state,latestValues,options,transformTemplate){const{style,vars,transform,transformOrigin}=state;let hasTransform2=!1,hasTransformOrigin=!1,transformIsNone=!0;for(const key in latestValues){const value=latestValues[key];if(isCSSVariableName(key)){vars[key]=value;continue}const valueType=numberValueTypes[key],valueAsType=getValueAsType(value,valueType);if(transformProps.has(key)){if(hasTransform2=!0,transform[key]=valueAsType,!transformIsNone)continue;value!==(valueType.default||0)&&(transformIsNone=!1)}else key.startsWith("origin")?(hasTransformOrigin=!0,transformOrigin[key]=valueAsType):style[key]=valueAsType}if(latestValues.transform||(hasTransform2||transformTemplate?style.transform=buildTransform(state.transform,options,transformIsNone,transformTemplate):style.transform&&(style.transform="none")),hasTransformOrigin){const{originX="50%",originY="50%",originZ=0}=transformOrigin;style.transformOrigin=`${originX} ${originY} ${originZ}`}}const createHtmlRenderState=()=>({style:{},transform:{},transformOrigin:{},vars:{}});function copyRawValuesOnly(target,source,props){for(const key in source)!isMotionValue(source[key])&&!isForcedMotionValue(key,props)&&(target[key]=source[key])}function useInitialMotionValues({transformTemplate},visualState,isStatic){return reactExports.useMemo(()=>{const state=createHtmlRenderState();return buildHTMLStyles(state,visualState,{enableHardwareAcceleration:!isStatic},transformTemplate),Object.assign({},state.vars,state.style)},[visualState])}function useStyle(props,visualState,isStatic){const styleProp=props.style||{},style={};return copyRawValuesOnly(style,styleProp,props),Object.assign(style,useInitialMotionValues(props,visualState,isStatic)),props.transformValues?props.transformValues(style):style}function useHTMLProps(props,visualState,isStatic){const htmlProps={},style=useStyle(props,visualState,isStatic);return props.drag&&props.dragListener!==!1&&(htmlProps.draggable=!1,style.userSelect=style.WebkitUserSelect=style.WebkitTouchCallout="none",style.touchAction=props.drag===!0?"none":`pan-${props.drag==="x"?"y":"x"}`),props.tabIndex===void 0&&(props.onTap||props.onTapStart||props.whileTap)&&(htmlProps.tabIndex=0),htmlProps.style=style,htmlProps}const validMotionProps=new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","transformValues","custom","inherit","onLayoutAnimationStart","onLayoutAnimationComplete","onLayoutMeasure","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","ignoreStrict","viewport"]);function isValidMotionProp(key){return key.startsWith("while")||key.startsWith("drag")&&key!=="draggable"||key.startsWith("layout")||key.startsWith("onTap")||key.startsWith("onPan")||validMotionProps.has(key)}let shouldForward=key=>!isValidMotionProp(key);function loadExternalIsValidProp(isValidProp){isValidProp&&(shouldForward=key=>key.startsWith("on")?!isValidMotionProp(key):isValidProp(key))}try{loadExternalIsValidProp(require("@emotion/is-prop-valid").default)}catch{}function filterProps(props,isDom,forwardMotionProps){const filteredProps={};for(const key in props)key==="values"&&typeof props.values=="object"||(shouldForward(key)||forwardMotionProps===!0&&isValidMotionProp(key)||!isDom&&!isValidMotionProp(key)||props.draggable&&key.startsWith("onDrag"))&&(filteredProps[key]=props[key]);return filteredProps}function calcOrigin$1(origin,offset,size){return typeof origin=="string"?origin:px$1.transform(offset+size*origin)}function calcSVGTransformOrigin(dimensions,originX,originY){const pxOriginX=calcOrigin$1(originX,dimensions.x,dimensions.width),pxOriginY=calcOrigin$1(originY,dimensions.y,dimensions.height);return`${pxOriginX} ${pxOriginY}`}const dashKeys={offset:"stroke-dashoffset",array:"stroke-dasharray"},camelKeys={offset:"strokeDashoffset",array:"strokeDasharray"};function buildSVGPath(attrs,length,spacing=1,offset=0,useDashCase=!0){attrs.pathLength=1;const keys2=useDashCase?dashKeys:camelKeys;attrs[keys2.offset]=px$1.transform(-offset);const pathLength=px$1.transform(length),pathSpacing=px$1.transform(spacing);attrs[keys2.array]=`${pathLength} ${pathSpacing}`}function buildSVGAttrs(state,{attrX,attrY,attrScale,originX,originY,pathLength,pathSpacing=1,pathOffset=0,...latest},options,isSVGTag2,transformTemplate){if(buildHTMLStyles(state,latest,options,transformTemplate),isSVGTag2){state.style.viewBox&&(state.attrs.viewBox=state.style.viewBox);return}state.attrs=state.style,state.style={};const{attrs,style,dimensions}=state;attrs.transform&&(dimensions&&(style.transform=attrs.transform),delete attrs.transform),dimensions&&(originX!==void 0||originY!==void 0||style.transform)&&(style.transformOrigin=calcSVGTransformOrigin(dimensions,originX!==void 0?originX:.5,originY!==void 0?originY:.5)),attrX!==void 0&&(attrs.x=attrX),attrY!==void 0&&(attrs.y=attrY),attrScale!==void 0&&(attrs.scale=attrScale),pathLength!==void 0&&buildSVGPath(attrs,pathLength,pathSpacing,pathOffset,!1)}const createSvgRenderState=()=>({...createHtmlRenderState(),attrs:{}}),isSVGTag=tag=>typeof tag=="string"&&tag.toLowerCase()==="svg";function useSVGProps(props,visualState,_isStatic,Component){const visualProps=reactExports.useMemo(()=>{const state=createSvgRenderState();return buildSVGAttrs(state,visualState,{enableHardwareAcceleration:!1},isSVGTag(Component),props.transformTemplate),{...state.attrs,style:{...state.style}}},[visualState]);if(props.style){const rawStyles={};copyRawValuesOnly(rawStyles,props.style,props),visualProps.style={...rawStyles,...visualProps.style}}return visualProps}function createUseRender(forwardMotionProps=!1){return(Component,props,ref,{latestValues},isStatic)=>{const visualProps=(isSVGComponent(Component)?useSVGProps:useHTMLProps)(props,latestValues,isStatic,Component),elementProps={...filterProps(props,typeof Component=="string",forwardMotionProps),...visualProps,ref},{children}=props,renderedChildren=reactExports.useMemo(()=>isMotionValue(children)?children.get():children,[children]);return reactExports.createElement(Component,{...elementProps,children:renderedChildren})}}const camelToDash=str=>str.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase();function renderHTML(element,{style,vars},styleProp,projection){Object.assign(element.style,style,projection&&projection.getProjectionStyles(styleProp));for(const key in vars)element.style.setProperty(key,vars[key])}const camelCaseAttributes=new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);function renderSVG(element,renderState,_styleProp,projection){renderHTML(element,renderState,void 0,projection);for(const key in renderState.attrs)element.setAttribute(camelCaseAttributes.has(key)?key:camelToDash(key),renderState.attrs[key])}function scrapeMotionValuesFromProps$1(props,prevProps){const{style}=props,newValues={};for(const key in style)(isMotionValue(style[key])||prevProps.style&&isMotionValue(prevProps.style[key])||isForcedMotionValue(key,props))&&(newValues[key]=style[key]);return newValues}function scrapeMotionValuesFromProps(props,prevProps){const newValues=scrapeMotionValuesFromProps$1(props,prevProps);for(const key in props)if(isMotionValue(props[key])||isMotionValue(prevProps[key])){const targetKey=transformPropOrder.indexOf(key)!==-1?"attr"+key.charAt(0).toUpperCase()+key.substring(1):key;newValues[targetKey]=props[key]}return newValues}function resolveVariantFromProps(props,definition,custom,currentValues={},currentVelocity={}){return typeof definition=="function"&&(definition=definition(custom!==void 0?custom:props.custom,currentValues,currentVelocity)),typeof definition=="string"&&(definition=props.variants&&props.variants[definition]),typeof definition=="function"&&(definition=definition(custom!==void 0?custom:props.custom,currentValues,currentVelocity)),definition}function useConstant(init){const ref=reactExports.useRef(null);return ref.current===null&&(ref.current=init()),ref.current}const isKeyframesTarget=v4=>Array.isArray(v4),isCustomValue=v4=>!!(v4&&typeof v4=="object"&&v4.mix&&v4.toValue),resolveFinalValueInKeyframes=v4=>isKeyframesTarget(v4)?v4[v4.length-1]||0:v4;function resolveMotionValue(value){const unwrappedValue=isMotionValue(value)?value.get():value;return isCustomValue(unwrappedValue)?unwrappedValue.toValue():unwrappedValue}function makeState({scrapeMotionValuesFromProps:scrapeMotionValuesFromProps2,createRenderState,onMount},props,context2,presenceContext){const state={latestValues:makeLatestValues(props,context2,presenceContext,scrapeMotionValuesFromProps2),renderState:createRenderState()};return onMount&&(state.mount=instance=>onMount(props,instance,state)),state}const makeUseVisualState=config=>(props,isStatic)=>{const context2=reactExports.useContext(MotionContext),presenceContext=reactExports.useContext(PresenceContext),make=()=>makeState(config,props,context2,presenceContext);return isStatic?make():useConstant(make)};function makeLatestValues(props,context2,presenceContext,scrapeMotionValues){const values={},motionValues=scrapeMotionValues(props,{});for(const key in motionValues)values[key]=resolveMotionValue(motionValues[key]);let{initial,animate}=props;const isControllingVariants$1=isControllingVariants(props),isVariantNode$1=isVariantNode(props);context2&&isVariantNode$1&&!isControllingVariants$1&&props.inherit!==!1&&(initial===void 0&&(initial=context2.initial),animate===void 0&&(animate=context2.animate));let isInitialAnimationBlocked=presenceContext?presenceContext.initial===!1:!1;isInitialAnimationBlocked=isInitialAnimationBlocked||initial===!1;const variantToSet=isInitialAnimationBlocked?animate:initial;return variantToSet&&typeof variantToSet!="boolean"&&!isAnimationControls(variantToSet)&&(Array.isArray(variantToSet)?variantToSet:[variantToSet]).forEach(definition=>{const resolved=resolveVariantFromProps(props,definition);if(!resolved)return;const{transitionEnd,transition,...target}=resolved;for(const key in target){let valueTarget=target[key];if(Array.isArray(valueTarget)){const index=isInitialAnimationBlocked?valueTarget.length-1:0;valueTarget=valueTarget[index]}valueTarget!==null&&(values[key]=valueTarget)}for(const key in transitionEnd)values[key]=transitionEnd[key]}),values}const noop=any=>any;class Queue{constructor(){this.order=[],this.scheduled=new Set}add(process2){if(!this.scheduled.has(process2))return this.scheduled.add(process2),this.order.push(process2),!0}remove(process2){const index=this.order.indexOf(process2);index!==-1&&(this.order.splice(index,1),this.scheduled.delete(process2))}clear(){this.order.length=0,this.scheduled.clear()}}function createRenderStep(runNextFrame){let thisFrame=new Queue,nextFrame=new Queue,numToRun=0,isProcessing=!1,flushNextFrame=!1;const toKeepAlive=new WeakSet,step={schedule:(callback,keepAlive=!1,immediate=!1)=>{const addToCurrentFrame=immediate&&isProcessing,queue=addToCurrentFrame?thisFrame:nextFrame;return keepAlive&&toKeepAlive.add(callback),queue.add(callback)&&addToCurrentFrame&&isProcessing&&(numToRun=thisFrame.order.length),callback},cancel:callback=>{nextFrame.remove(callback),toKeepAlive.delete(callback)},process:frameData2=>{if(isProcessing){flushNextFrame=!0;return}if(isProcessing=!0,[thisFrame,nextFrame]=[nextFrame,thisFrame],nextFrame.clear(),numToRun=thisFrame.order.length,numToRun)for(let i2=0;i2<numToRun;i2++){const callback=thisFrame.order[i2];callback(frameData2),toKeepAlive.has(callback)&&(step.schedule(callback),runNextFrame())}isProcessing=!1,flushNextFrame&&(flushNextFrame=!1,step.process(frameData2))}};return step}const stepsOrder=["prepare","read","update","preRender","render","postRender"],maxElapsed=40;function createRenderBatcher(scheduleNextBatch,allowKeepAlive){let runNextFrame=!1,useDefaultElapsed=!0;const state={delta:0,timestamp:0,isProcessing:!1},steps2=stepsOrder.reduce((acc,key)=>(acc[key]=createRenderStep(()=>runNextFrame=!0),acc),{}),processStep=stepId=>steps2[stepId].process(state),processBatch=()=>{const timestamp=performance.now();runNextFrame=!1,state.delta=useDefaultElapsed?1e3/60:Math.max(Math.min(timestamp-state.timestamp,maxElapsed),1),state.timestamp=timestamp,state.isProcessing=!0,stepsOrder.forEach(processStep),state.isProcessing=!1,runNextFrame&&allowKeepAlive&&(useDefaultElapsed=!1,scheduleNextBatch(processBatch))},wake=()=>{runNextFrame=!0,useDefaultElapsed=!0,state.isProcessing||scheduleNextBatch(processBatch)};return{schedule:stepsOrder.reduce((acc,key)=>{const step=steps2[key];return acc[key]=(process2,keepAlive=!1,immediate=!1)=>(runNextFrame||wake(),step.schedule(process2,keepAlive,immediate)),acc},{}),cancel:process2=>stepsOrder.forEach(key=>steps2[key].cancel(process2)),state,steps:steps2}}const{schedule:frame,cancel:cancelFrame,state:frameData,steps}=createRenderBatcher(typeof requestAnimationFrame<"u"?requestAnimationFrame:noop,!0),svgMotionConfig={useVisualState:makeUseVisualState({scrapeMotionValuesFromProps,createRenderState:createSvgRenderState,onMount:(props,instance,{renderState,latestValues})=>{frame.read(()=>{try{renderState.dimensions=typeof instance.getBBox=="function"?instance.getBBox():instance.getBoundingClientRect()}catch{renderState.dimensions={x:0,y:0,width:0,height:0}}}),frame.render(()=>{buildSVGAttrs(renderState,latestValues,{enableHardwareAcceleration:!1},isSVGTag(instance.tagName),props.transformTemplate),renderSVG(instance,renderState)})}})},htmlMotionConfig={useVisualState:makeUseVisualState({scrapeMotionValuesFromProps:scrapeMotionValuesFromProps$1,createRenderState:createHtmlRenderState})};function createDomMotionConfig(Component,{forwardMotionProps=!1},preloadedFeatures2,createVisualElement){return{...isSVGComponent(Component)?svgMotionConfig:htmlMotionConfig,preloadedFeatures:preloadedFeatures2,useRender:createUseRender(forwardMotionProps),createVisualElement,Component}}function addDomEvent(target,eventName,handler,options={passive:!0}){return target.addEventListener(eventName,handler,options),()=>target.removeEventListener(eventName,handler)}const isPrimaryPointer=event=>event.pointerType==="mouse"?typeof event.button!="number"||event.button<=0:event.isPrimary!==!1;function extractEventInfo(event,pointType="page"){return{point:{x:event[pointType+"X"],y:event[pointType+"Y"]}}}const addPointerInfo=handler=>event=>isPrimaryPointer(event)&&handler(event,extractEventInfo(event));function addPointerEvent(target,eventName,handler,options){return addDomEvent(target,eventName,addPointerInfo(handler),options)}const combineFunctions=(a2,b2)=>v4=>b2(a2(v4)),pipe=(...transformers)=>transformers.reduce(combineFunctions);function createLock(name){let lock=null;return()=>{const openLock=()=>{lock=null};return lock===null?(lock=name,openLock):!1}}const globalHorizontalLock=createLock("dragHorizontal"),globalVerticalLock=createLock("dragVertical");function getGlobalLock(drag2){let lock=!1;if(drag2==="y")lock=globalVerticalLock();else if(drag2==="x")lock=globalHorizontalLock();else{const openHorizontal=globalHorizontalLock(),openVertical=globalVerticalLock();openHorizontal&&openVertical?lock=()=>{openHorizontal(),openVertical()}:(openHorizontal&&openHorizontal(),openVertical&&openVertical())}return lock}function isDragActive(){const openGestureLock=getGlobalLock(!0);return openGestureLock?(openGestureLock(),!1):!0}class Feature{constructor(node){this.isMounted=!1,this.node=node}update(){}}function addHoverEvent(node,isActive){const eventName="pointer"+(isActive?"enter":"leave"),callbackName="onHover"+(isActive?"Start":"End"),handleEvent=(event,info)=>{if(event.type==="touch"||isDragActive())return;const props=node.getProps();node.animationState&&props.whileHover&&node.animationState.setActive("whileHover",isActive),props[callbackName]&&frame.update(()=>props[callbackName](event,info))};return addPointerEvent(node.current,eventName,handleEvent,{passive:!node.getProps()[callbackName]})}class HoverGesture extends Feature{mount(){this.unmount=pipe(addHoverEvent(this.node,!0),addHoverEvent(this.node,!1))}unmount(){}}class FocusGesture extends Feature{constructor(){super(...arguments),this.isActive=!1}onFocus(){let isFocusVisible=!1;try{isFocusVisible=this.node.current.matches(":focus-visible")}catch{isFocusVisible=!0}!isFocusVisible||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}onBlur(){!this.isActive||!this.node.animationState||(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}mount(){this.unmount=pipe(addDomEvent(this.node.current,"focus",()=>this.onFocus()),addDomEvent(this.node.current,"blur",()=>this.onBlur()))}unmount(){}}const isNodeOrChild=(parent,child)=>child?parent===child?!0:isNodeOrChild(parent,child.parentElement):!1;function fireSyntheticPointerEvent(name,handler){if(!handler)return;const syntheticPointerEvent=new PointerEvent("pointer"+name);handler(syntheticPointerEvent,extractEventInfo(syntheticPointerEvent))}class PressGesture extends Feature{constructor(){super(...arguments),this.removeStartListeners=noop,this.removeEndListeners=noop,this.removeAccessibleListeners=noop,this.startPointerPress=(startEvent,startInfo)=>{if(this.removeEndListeners(),this.isPressing)return;const props=this.node.getProps(),removePointerUpListener=addPointerEvent(window,"pointerup",(endEvent,endInfo)=>{if(!this.checkPressEnd())return;const{onTap,onTapCancel}=this.node.getProps();frame.update(()=>{isNodeOrChild(this.node.current,endEvent.target)?onTap&&onTap(endEvent,endInfo):onTapCancel&&onTapCancel(endEvent,endInfo)})},{passive:!(props.onTap||props.onPointerUp)}),removePointerCancelListener=addPointerEvent(window,"pointercancel",(cancelEvent,cancelInfo)=>this.cancelPress(cancelEvent,cancelInfo),{passive:!(props.onTapCancel||props.onPointerCancel)});this.removeEndListeners=pipe(removePointerUpListener,removePointerCancelListener),this.startPress(startEvent,startInfo)},this.startAccessiblePress=()=>{const handleKeydown=keydownEvent=>{if(keydownEvent.key!=="Enter"||this.isPressing)return;const handleKeyup=keyupEvent=>{keyupEvent.key!=="Enter"||!this.checkPressEnd()||fireSyntheticPointerEvent("up",(event,info)=>{const{onTap}=this.node.getProps();onTap&&frame.update(()=>onTap(event,info))})};this.removeEndListeners(),this.removeEndListeners=addDomEvent(this.node.current,"keyup",handleKeyup),fireSyntheticPointerEvent("down",(event,info)=>{this.startPress(event,info)})},removeKeydownListener=addDomEvent(this.node.current,"keydown",handleKeydown),handleBlur=()=>{this.isPressing&&fireSyntheticPointerEvent("cancel",(cancelEvent,cancelInfo)=>this.cancelPress(cancelEvent,cancelInfo))},removeBlurListener=addDomEvent(this.node.current,"blur",handleBlur);this.removeAccessibleListeners=pipe(removeKeydownListener,removeBlurListener)}}startPress(event,info){this.isPressing=!0;const{onTapStart,whileTap}=this.node.getProps();whileTap&&this.node.animationState&&this.node.animationState.setActive("whileTap",!0),onTapStart&&frame.update(()=>onTapStart(event,info))}checkPressEnd(){return this.removeEndListeners(),this.isPressing=!1,this.node.getProps().whileTap&&this.node.animationState&&this.node.animationState.setActive("whileTap",!1),!isDragActive()}cancelPress(event,info){if(!this.checkPressEnd())return;const{onTapCancel}=this.node.getProps();onTapCancel&&frame.update(()=>onTapCancel(event,info))}mount(){const props=this.node.getProps(),removePointerListener=addPointerEvent(this.node.current,"pointerdown",this.startPointerPress,{passive:!(props.onTapStart||props.onPointerStart)}),removeFocusListener=addDomEvent(this.node.current,"focus",this.startAccessiblePress);this.removeStartListeners=pipe(removePointerListener,removeFocusListener)}unmount(){this.removeStartListeners(),this.removeEndListeners(),this.removeAccessibleListeners()}}const observerCallbacks=new WeakMap,observers=new WeakMap,fireObserverCallback=entry=>{const callback=observerCallbacks.get(entry.target);callback&&callback(entry)},fireAllObserverCallbacks=entries=>{entries.forEach(fireObserverCallback)};function initIntersectionObserver({root,...options}){const lookupRoot=root||document;observers.has(lookupRoot)||observers.set(lookupRoot,{});const rootObservers=observers.get(lookupRoot),key=JSON.stringify(options);return rootObservers[key]||(rootObservers[key]=new IntersectionObserver(fireAllObserverCallbacks,{root,...options})),rootObservers[key]}function observeIntersection(element,options,callback){const rootInteresectionObserver=initIntersectionObserver(options);return observerCallbacks.set(element,callback),rootInteresectionObserver.observe(element),()=>{observerCallbacks.delete(element),rootInteresectionObserver.unobserve(element)}}const thresholdNames={some:0,all:1};class InViewFeature extends Feature{constructor(){super(...arguments),this.hasEnteredView=!1,this.isInView=!1}startObserver(){this.unmount();const{viewport={}}=this.node.getProps(),{root,margin:rootMargin,amount="some",once}=viewport,options={root:root?root.current:void 0,rootMargin,threshold:typeof amount=="number"?amount:thresholdNames[amount]},onIntersectionUpdate=entry=>{const{isIntersecting}=entry;if(this.isInView===isIntersecting||(this.isInView=isIntersecting,once&&!isIntersecting&&this.hasEnteredView))return;isIntersecting&&(this.hasEnteredView=!0),this.node.animationState&&this.node.animationState.setActive("whileInView",isIntersecting);const{onViewportEnter,onViewportLeave}=this.node.getProps(),callback=isIntersecting?onViewportEnter:onViewportLeave;callback&&callback(entry)};return observeIntersection(this.node.current,options,onIntersectionUpdate)}mount(){this.startObserver()}update(){if(typeof IntersectionObserver>"u")return;const{props,prevProps}=this.node;["amount","margin","root"].some(hasViewportOptionChanged(props,prevProps))&&this.startObserver()}unmount(){}}function hasViewportOptionChanged({viewport={}},{viewport:prevViewport={}}={}){return name=>viewport[name]!==prevViewport[name]}const gestureAnimations={inView:{Feature:InViewFeature},tap:{Feature:PressGesture},focus:{Feature:FocusGesture},hover:{Feature:HoverGesture}};function shallowCompare(next,prev){if(!Array.isArray(prev))return!1;const prevLength=prev.length;if(prevLength!==next.length)return!1;for(let i2=0;i2<prevLength;i2++)if(prev[i2]!==next[i2])return!1;return!0}function getCurrent(visualElement){const current={};return visualElement.values.forEach((value,key)=>current[key]=value.get()),current}function getVelocity$1(visualElement){const velocity={};return visualElement.values.forEach((value,key)=>velocity[key]=value.getVelocity()),velocity}function resolveVariant(visualElement,definition,custom){const props=visualElement.getProps();return resolveVariantFromProps(props,definition,custom!==void 0?custom:props.custom,getCurrent(visualElement),getVelocity$1(visualElement))}const optimizedAppearDataId="framerAppearId",optimizedAppearDataAttribute="data-"+camelToDash(optimizedAppearDataId);let warning=noop,invariant=noop;warning=(check,message)=>{!check&&typeof console<"u"&&console.warn(message)},invariant=(check,message)=>{if(!check)throw new Error(message)};const secondsToMilliseconds=seconds=>seconds*1e3,millisecondsToSeconds=milliseconds=>milliseconds/1e3,instantAnimationState={current:!1},isBezierDefinition=easing=>Array.isArray(easing)&&typeof easing[0]=="number";function isWaapiSupportedEasing(easing){return!!(!easing||typeof easing=="string"&&supportedWaapiEasing[easing]||isBezierDefinition(easing)||Array.isArray(easing)&&easing.every(isWaapiSupportedEasing))}const cubicBezierAsString=([a2,b2,c2,d2])=>`cubic-bezier(${a2}, ${b2}, ${c2}, ${d2})`,supportedWaapiEasing={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:cubicBezierAsString([0,.65,.55,1]),circOut:cubicBezierAsString([.55,0,1,.45]),backIn:cubicBezierAsString([.31,.01,.66,-.59]),backOut:cubicBezierAsString([.33,1.53,.69,.99])};function mapEasingToNativeEasing(easing){if(easing)return isBezierDefinition(easing)?cubicBezierAsString(easing):Array.isArray(easing)?easing.map(mapEasingToNativeEasing):supportedWaapiEasing[easing]}function animateStyle(element,valueName,keyframes2,{delay:delay2=0,duration,repeat=0,repeatType="loop",ease:ease2,times}={}){const keyframeOptions={[valueName]:keyframes2};times&&(keyframeOptions.offset=times);const easing=mapEasingToNativeEasing(ease2);return Array.isArray(easing)&&(keyframeOptions.easing=easing),element.animate(keyframeOptions,{delay:delay2,duration,easing:Array.isArray(easing)?"linear":easing,fill:"both",iterations:repeat+1,direction:repeatType==="reverse"?"alternate":"normal"})}function getFinalKeyframe(keyframes2,{repeat,repeatType="loop"}){const index=repeat&&repeatType!=="loop"&&repeat%2===1?0:keyframes2.length-1;return keyframes2[index]}const calcBezier=(t2,a1,a2)=>(((1-3*a2+3*a1)*t2+(3*a2-6*a1))*t2+3*a1)*t2,subdivisionPrecision=1e-7,subdivisionMaxIterations=12;function binarySubdivide(x2,lowerBound,upperBound,mX1,mX2){let currentX,currentT,i2=0;do currentT=lowerBound+(upperBound-lowerBound)/2,currentX=calcBezier(currentT,mX1,mX2)-x2,currentX>0?upperBound=currentT:lowerBound=currentT;while(Math.abs(currentX)>subdivisionPrecision&&++i2<subdivisionMaxIterations);return currentT}function cubicBezier(mX1,mY1,mX2,mY2){if(mX1===mY1&&mX2===mY2)return noop;const getTForX=aX=>binarySubdivide(aX,0,1,mX1,mX2);return t2=>t2===0||t2===1?t2:calcBezier(getTForX(t2),mY1,mY2)}const easeIn=cubicBezier(.42,0,1,1),easeOut=cubicBezier(0,0,.58,1),easeInOut=cubicBezier(.42,0,.58,1),isEasingArray=ease2=>Array.isArray(ease2)&&typeof ease2[0]!="number",mirrorEasing=easing=>p2=>p2<=.5?easing(2*p2)/2:(2-easing(2*(1-p2)))/2,reverseEasing=easing=>p2=>1-easing(1-p2),circIn=p2=>1-Math.sin(Math.acos(p2)),circOut=reverseEasing(circIn),circInOut=mirrorEasing(circOut),backOut=cubicBezier(.33,1.53,.69,.99),backIn=reverseEasing(backOut),backInOut=mirrorEasing(backIn),anticipate=p2=>(p2*=2)<1?.5*backIn(p2):.5*(2-Math.pow(2,-10*(p2-1))),easingLookup={linear:noop,easeIn,easeInOut,easeOut,circIn,circInOut,circOut,backIn,backInOut,backOut,anticipate},easingDefinitionToFunction=definition=>{if(Array.isArray(definition)){invariant(definition.length===4,"Cubic bezier arrays must contain four numerical values.");const[x1,y1,x2,y2]=definition;return cubicBezier(x1,y1,x2,y2)}else if(typeof definition=="string")return invariant(easingLookup[definition]!==void 0,`Invalid easing type '${definition}'`),easingLookup[definition];return definition},isColorString=(type,testProp)=>v4=>!!(isString(v4)&&singleColorRegex.test(v4)&&v4.startsWith(type)||testProp&&Object.prototype.hasOwnProperty.call(v4,testProp)),splitColor=(aName,bName,cName)=>v4=>{if(!isString(v4))return v4;const[a2,b2,c2,alpha2]=v4.match(floatRegex);return{[aName]:parseFloat(a2),[bName]:parseFloat(b2),[cName]:parseFloat(c2),alpha:alpha2!==void 0?parseFloat(alpha2):1}},clampRgbUnit=v4=>clamp$1(0,255,v4),rgbUnit={...number,transform:v4=>Math.round(clampRgbUnit(v4))},rgba={test:isColorString("rgb","red"),parse:splitColor("red","green","blue"),transform:({red,green,blue,alpha:alpha$1=1})=>"rgba("+rgbUnit.transform(red)+", "+rgbUnit.transform(green)+", "+rgbUnit.transform(blue)+", "+sanitize(alpha.transform(alpha$1))+")"};function parseHex(v4){let r2="",g2="",b2="",a2="";return v4.length>5?(r2=v4.substring(1,3),g2=v4.substring(3,5),b2=v4.substring(5,7),a2=v4.substring(7,9)):(r2=v4.substring(1,2),g2=v4.substring(2,3),b2=v4.substring(3,4),a2=v4.substring(4,5),r2+=r2,g2+=g2,b2+=b2,a2+=a2),{red:parseInt(r2,16),green:parseInt(g2,16),blue:parseInt(b2,16),alpha:a2?parseInt(a2,16)/255:1}}const hex={test:isColorString("#"),parse:parseHex,transform:rgba.transform},hsla={test:isColorString("hsl","hue"),parse:splitColor("hue","saturation","lightness"),transform:({hue,saturation,lightness,alpha:alpha$1=1})=>"hsla("+Math.round(hue)+", "+percent.transform(sanitize(saturation))+", "+percent.transform(sanitize(lightness))+", "+sanitize(alpha.transform(alpha$1))+")"},color={test:v4=>rgba.test(v4)||hex.test(v4)||hsla.test(v4),parse:v4=>rgba.test(v4)?rgba.parse(v4):hsla.test(v4)?hsla.parse(v4):hex.parse(v4),transform:v4=>isString(v4)?v4:v4.hasOwnProperty("red")?rgba.transform(v4):hsla.transform(v4)},mix=(from,to,progress2)=>-progress2*from+progress2*to+from;function hueToRgb(p2,q,t2){return t2<0&&(t2+=1),t2>1&&(t2-=1),t2<1/6?p2+(q-p2)*6*t2:t2<1/2?q:t2<2/3?p2+(q-p2)*(2/3-t2)*6:p2}function hslaToRgba({hue,saturation,lightness,alpha:alpha2}){hue/=360,saturation/=100,lightness/=100;let red=0,green=0,blue=0;if(!saturation)red=green=blue=lightness;else{const q=lightness<.5?lightness*(1+saturation):lightness+saturation-lightness*saturation,p2=2*lightness-q;red=hueToRgb(p2,q,hue+1/3),green=hueToRgb(p2,q,hue),blue=hueToRgb(p2,q,hue-1/3)}return{red:Math.round(red*255),green:Math.round(green*255),blue:Math.round(blue*255),alpha:alpha2}}const mixLinearColor=(from,to,v4)=>{const fromExpo=from*from;return Math.sqrt(Math.max(0,v4*(to*to-fromExpo)+fromExpo))},colorTypes=[hex,rgba,hsla],getColorType=v4=>colorTypes.find(type=>type.test(v4));function asRGBA(color2){const type=getColorType(color2);invariant(!!type,`'${color2}' is not an animatable color. Use the equivalent color code instead.`);let model=type.parse(color2);return type===hsla&&(model=hslaToRgba(model)),model}const mixColor=(from,to)=>{const fromRGBA=asRGBA(from),toRGBA=asRGBA(to),blended={...fromRGBA};return v4=>(blended.red=mixLinearColor(fromRGBA.red,toRGBA.red,v4),blended.green=mixLinearColor(fromRGBA.green,toRGBA.green,v4),blended.blue=mixLinearColor(fromRGBA.blue,toRGBA.blue,v4),blended.alpha=mix(fromRGBA.alpha,toRGBA.alpha,v4),rgba.transform(blended))};function test(v4){var _a2,_b2;return isNaN(v4)&&isString(v4)&&(((_a2=v4.match(floatRegex))===null||_a2===void 0?void 0:_a2.length)||0)+(((_b2=v4.match(colorRegex))===null||_b2===void 0?void 0:_b2.length)||0)>0}const cssVarTokeniser={regex:cssVariableRegex,countKey:"Vars",token:"${v}",parse:noop},colorTokeniser={regex:colorRegex,countKey:"Colors",token:"${c}",parse:color.parse},numberTokeniser={regex:floatRegex,countKey:"Numbers",token:"${n}",parse:number.parse};function tokenise(info,{regex,countKey,token,parse}){const matches=info.tokenised.match(regex);matches&&(info["num"+countKey]=matches.length,info.tokenised=info.tokenised.replace(regex,token),info.values.push(...matches.map(parse)))}function analyseComplexValue(value){const originalValue=value.toString(),info={value:originalValue,tokenised:originalValue,values:[],numVars:0,numColors:0,numNumbers:0};return info.value.includes("var(--")&&tokenise(info,cssVarTokeniser),tokenise(info,colorTokeniser),tokenise(info,numberTokeniser),info}function parseComplexValue(v4){return analyseComplexValue(v4).values}function createTransformer(source){const{values,numColors,numVars,tokenised}=analyseComplexValue(source),numValues=values.length;return v4=>{let output=tokenised;for(let i2=0;i2<numValues;i2++)i2<numVars?output=output.replace(cssVarTokeniser.token,v4[i2]):i2<numVars+numColors?output=output.replace(colorTokeniser.token,color.transform(v4[i2])):output=output.replace(numberTokeniser.token,sanitize(v4[i2]));return output}}const convertNumbersToZero=v4=>typeof v4=="number"?0:v4;function getAnimatableNone$1(v4){const parsed=parseComplexValue(v4);return createTransformer(v4)(parsed.map(convertNumbersToZero))}const complex={test,parse:parseComplexValue,createTransformer,getAnimatableNone:getAnimatableNone$1},mixImmediate=(origin,target)=>p2=>`${p2>0?target:origin}`;function getMixer(origin,target){return typeof origin=="number"?v4=>mix(origin,target,v4):color.test(origin)?mixColor(origin,target):origin.startsWith("var(")?mixImmediate(origin,target):mixComplex(origin,target)}const mixArray=(from,to)=>{const output=[...from],numValues=output.length,blendValue=from.map((fromThis,i2)=>getMixer(fromThis,to[i2]));return v4=>{for(let i2=0;i2<numValues;i2++)output[i2]=blendValue[i2](v4);return output}},mixObject=(origin,target)=>{const output={...origin,...target},blendValue={};for(const key in output)origin[key]!==void 0&&target[key]!==void 0&&(blendValue[key]=getMixer(origin[key],target[key]));return v4=>{for(const key in blendValue)output[key]=blendValue[key](v4);return output}},mixComplex=(origin,target)=>{const template=complex.createTransformer(target),originStats=analyseComplexValue(origin),targetStats=analyseComplexValue(target);return originStats.numVars===targetStats.numVars&&originStats.numColors===targetStats.numColors&&originStats.numNumbers>=targetStats.numNumbers?pipe(mixArray(originStats.values,targetStats.values),template):(warning(!0,`Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`),mixImmediate(origin,target))},progress=(from,to,value)=>{const toFromDifference=to-from;return toFromDifference===0?1:(value-from)/toFromDifference},mixNumber=(from,to)=>p2=>mix(from,to,p2);function detectMixerFactory(v4){return typeof v4=="number"?mixNumber:typeof v4=="string"?color.test(v4)?mixColor:mixComplex:Array.isArray(v4)?mixArray:typeof v4=="object"?mixObject:mixNumber}function createMixers(output,ease2,customMixer){const mixers=[],mixerFactory=customMixer||detectMixerFactory(output[0]),numMixers=output.length-1;for(let i2=0;i2<numMixers;i2++){let mixer=mixerFactory(output[i2],output[i2+1]);if(ease2){const easingFunction=Array.isArray(ease2)?ease2[i2]||noop:ease2;mixer=pipe(easingFunction,mixer)}mixers.push(mixer)}return mixers}function interpolate(input,output,{clamp:isClamp=!0,ease:ease2,mixer}={}){const inputLength=input.length;if(invariant(inputLength===output.length,"Both input and output ranges must be the same length"),inputLength===1)return()=>output[0];input[0]>input[inputLength-1]&&(input=[...input].reverse(),output=[...output].reverse());const mixers=createMixers(output,ease2,mixer),numMixers=mixers.length,interpolator=v4=>{let i2=0;if(numMixers>1)for(;i2<input.length-2&&!(v4<input[i2+1]);i2++);const progressInRange=progress(input[i2],input[i2+1],v4);return mixers[i2](progressInRange)};return isClamp?v4=>interpolator(clamp$1(input[0],input[inputLength-1],v4)):interpolator}function fillOffset(offset,remaining){const min=offset[offset.length-1];for(let i2=1;i2<=remaining;i2++){const offsetProgress=progress(0,remaining,i2);offset.push(mix(min,1,offsetProgress))}}function defaultOffset(arr){const offset=[0];return fillOffset(offset,arr.length-1),offset}function convertOffsetToTimes(offset,duration){return offset.map(o2=>o2*duration)}function defaultEasing(values,easing){return values.map(()=>easing||easeInOut).splice(0,values.length-1)}function keyframes({duration=300,keyframes:keyframeValues,times,ease:ease2="easeInOut"}){const easingFunctions=isEasingArray(ease2)?ease2.map(easingDefinitionToFunction):easingDefinitionToFunction(ease2),state={done:!1,value:keyframeValues[0]},absoluteTimes=convertOffsetToTimes(times&&times.length===keyframeValues.length?times:defaultOffset(keyframeValues),duration),mapTimeToKeyframe=interpolate(absoluteTimes,keyframeValues,{ease:Array.isArray(easingFunctions)?easingFunctions:defaultEasing(keyframeValues,easingFunctions)});return{calculatedDuration:duration,next:t2=>(state.value=mapTimeToKeyframe(t2),state.done=t2>=duration,state)}}function velocityPerSecond(velocity,frameDuration){return frameDuration?velocity*(1e3/frameDuration):0}const velocitySampleDuration=5;function calcGeneratorVelocity(resolveValue,t2,current){const prevT=Math.max(t2-velocitySampleDuration,0);return velocityPerSecond(current-resolveValue(prevT),t2-prevT)}const safeMin=.001,minDuration=.01,maxDuration$1=10,minDamping=.05,maxDamping=1;function findSpring({duration=800,bounce=.25,velocity=0,mass=1}){let envelope,derivative;warning(duration<=secondsToMilliseconds(maxDuration$1),"Spring duration must be 10 seconds or less");let dampingRatio=1-bounce;dampingRatio=clamp$1(minDamping,maxDamping,dampingRatio),duration=clamp$1(minDuration,maxDuration$1,millisecondsToSeconds(duration)),dampingRatio<1?(envelope=undampedFreq2=>{const exponentialDecay=undampedFreq2*dampingRatio,delta=exponentialDecay*duration,a2=exponentialDecay-velocity,b2=calcAngularFreq(undampedFreq2,dampingRatio),c2=Math.exp(-delta);return safeMin-a2/b2*c2},derivative=undampedFreq2=>{const delta=undampedFreq2*dampingRatio*duration,d2=delta*velocity+velocity,e2=Math.pow(dampingRatio,2)*Math.pow(undampedFreq2,2)*duration,f2=Math.exp(-delta),g2=calcAngularFreq(Math.pow(undampedFreq2,2),dampingRatio);return(-envelope(undampedFreq2)+safeMin>0?-1:1)*((d2-e2)*f2)/g2}):(envelope=undampedFreq2=>{const a2=Math.exp(-undampedFreq2*duration),b2=(undampedFreq2-velocity)*duration+1;return-safeMin+a2*b2},derivative=undampedFreq2=>{const a2=Math.exp(-undampedFreq2*duration),b2=(velocity-undampedFreq2)*(duration*duration);return a2*b2});const initialGuess=5/duration,undampedFreq=approximateRoot(envelope,derivative,initialGuess);if(duration=secondsToMilliseconds(duration),isNaN(undampedFreq))return{stiffness:100,damping:10,duration};{const stiffness=Math.pow(undampedFreq,2)*mass;return{stiffness,damping:dampingRatio*2*Math.sqrt(mass*stiffness),duration}}}const rootIterations=12;function approximateRoot(envelope,derivative,initialGuess){let result=initialGuess;for(let i2=1;i2<rootIterations;i2++)result=result-envelope(result)/derivative(result);return result}function calcAngularFreq(undampedFreq,dampingRatio){return undampedFreq*Math.sqrt(1-dampingRatio*dampingRatio)}const durationKeys=["duration","bounce"],physicsKeys=["stiffness","damping","mass"];function isSpringType(options,keys2){return keys2.some(key=>options[key]!==void 0)}function getSpringOptions(options){let springOptions={velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:!1,...options};if(!isSpringType(options,physicsKeys)&&isSpringType(options,durationKeys)){const derived=findSpring(options);springOptions={...springOptions,...derived,velocity:0,mass:1},springOptions.isResolvedFromDuration=!0}return springOptions}function spring({keyframes:keyframes2,restDelta,restSpeed,...options}){const origin=keyframes2[0],target=keyframes2[keyframes2.length-1],state={done:!1,value:origin},{stiffness,damping,mass,velocity,duration,isResolvedFromDuration}=getSpringOptions(options),initialVelocity=velocity?-millisecondsToSeconds(velocity):0,dampingRatio=damping/(2*Math.sqrt(stiffness*mass)),initialDelta=target-origin,undampedAngularFreq=millisecondsToSeconds(Math.sqrt(stiffness/mass)),isGranularScale=Math.abs(initialDelta)<5;restSpeed||(restSpeed=isGranularScale?.01:2),restDelta||(restDelta=isGranularScale?.005:.5);let resolveSpring;if(dampingRatio<1){const angularFreq=calcAngularFreq(undampedAngularFreq,dampingRatio);resolveSpring=t2=>{const envelope=Math.exp(-dampingRatio*undampedAngularFreq*t2);return target-envelope*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)/angularFreq*Math.sin(angularFreq*t2)+initialDelta*Math.cos(angularFreq*t2))}}else if(dampingRatio===1)resolveSpring=t2=>target-Math.exp(-undampedAngularFreq*t2)*(initialDelta+(initialVelocity+undampedAngularFreq*initialDelta)*t2);else{const dampedAngularFreq=undampedAngularFreq*Math.sqrt(dampingRatio*dampingRatio-1);resolveSpring=t2=>{const envelope=Math.exp(-dampingRatio*undampedAngularFreq*t2),freqForT=Math.min(dampedAngularFreq*t2,300);return target-envelope*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)*Math.sinh(freqForT)+dampedAngularFreq*initialDelta*Math.cosh(freqForT))/dampedAngularFreq}}return{calculatedDuration:isResolvedFromDuration&&duration||null,next:t2=>{const current=resolveSpring(t2);if(isResolvedFromDuration)state.done=t2>=duration;else{let currentVelocity=initialVelocity;t2!==0&&(dampingRatio<1?currentVelocity=calcGeneratorVelocity(resolveSpring,t2,current):currentVelocity=0);const isBelowVelocityThreshold=Math.abs(currentVelocity)<=restSpeed,isBelowDisplacementThreshold=Math.abs(target-current)<=restDelta;state.done=isBelowVelocityThreshold&&isBelowDisplacementThreshold}return state.value=state.done?target:current,state}}}function inertia({keyframes:keyframes2,velocity=0,power=.8,timeConstant=325,bounceDamping=10,bounceStiffness=500,modifyTarget,min,max:max2,restDelta=.5,restSpeed}){const origin=keyframes2[0],state={done:!1,value:origin},isOutOfBounds=v4=>min!==void 0&&v4<min||max2!==void 0&&v4>max2,nearestBoundary=v4=>min===void 0?max2:max2===void 0||Math.abs(min-v4)<Math.abs(max2-v4)?min:max2;let amplitude=power*velocity;const ideal=origin+amplitude,target=modifyTarget===void 0?ideal:modifyTarget(ideal);target!==ideal&&(amplitude=target-origin);const calcDelta=t2=>-amplitude*Math.exp(-t2/timeConstant),calcLatest=t2=>target+calcDelta(t2),applyFriction=t2=>{const delta=calcDelta(t2),latest=calcLatest(t2);state.done=Math.abs(delta)<=restDelta,state.value=state.done?target:latest};let timeReachedBoundary,spring$1;const checkCatchBoundary=t2=>{isOutOfBounds(state.value)&&(timeReachedBoundary=t2,spring$1=spring({keyframes:[state.value,nearestBoundary(state.value)],velocity:calcGeneratorVelocity(calcLatest,t2,state.value),damping:bounceDamping,stiffness:bounceStiffness,restDelta,restSpeed}))};return checkCatchBoundary(0),{calculatedDuration:null,next:t2=>{let hasUpdatedFrame=!1;return!spring$1&&timeReachedBoundary===void 0&&(hasUpdatedFrame=!0,applyFriction(t2),checkCatchBoundary(t2)),timeReachedBoundary!==void 0&&t2>timeReachedBoundary?spring$1.next(t2-timeReachedBoundary):(!hasUpdatedFrame&&applyFriction(t2),state)}}}const frameloopDriver=update=>{const passTimestamp=({timestamp})=>update(timestamp);return{start:()=>frame.update(passTimestamp,!0),stop:()=>cancelFrame(passTimestamp),now:()=>frameData.isProcessing?frameData.timestamp:performance.now()}},maxGeneratorDuration=2e4;function calcGeneratorDuration(generator){let duration=0;const timeStep=50;let state=generator.next(duration);for(;!state.done&&duration<maxGeneratorDuration;)duration+=timeStep,state=generator.next(duration);return duration>=maxGeneratorDuration?1/0:duration}const types={decay:inertia,inertia,tween:keyframes,keyframes,spring};function animateValue({autoplay=!0,delay:delay2=0,driver=frameloopDriver,keyframes:keyframes$1,type="keyframes",repeat=0,repeatDelay=0,repeatType="loop",onPlay,onStop,onComplete,onUpdate,...options}){let speed=1,hasStopped=!1,resolveFinishedPromise,currentFinishedPromise;const updateFinishedPromise=()=>{currentFinishedPromise=new Promise(resolve2=>{resolveFinishedPromise=resolve2})};updateFinishedPromise();let animationDriver;const generatorFactory=types[type]||keyframes;let mapNumbersToKeyframes;generatorFactory!==keyframes&&typeof keyframes$1[0]!="number"&&(mapNumbersToKeyframes=interpolate([0,100],keyframes$1,{clamp:!1}),keyframes$1=[0,100]);const generator=generatorFactory({...options,keyframes:keyframes$1});let mirroredGenerator;repeatType==="mirror"&&(mirroredGenerator=generatorFactory({...options,keyframes:[...keyframes$1].reverse(),velocity:-(options.velocity||0)}));let playState="idle",holdTime=null,startTime=null,cancelTime=null;generator.calculatedDuration===null&&repeat&&(generator.calculatedDuration=calcGeneratorDuration(generator));const{calculatedDuration}=generator;let resolvedDuration=1/0,totalDuration=1/0;calculatedDuration!==null&&(resolvedDuration=calculatedDuration+repeatDelay,totalDuration=resolvedDuration*(repeat+1)-repeatDelay);let currentTime=0;const tick=timestamp=>{if(startTime===null)return;speed>0&&(startTime=Math.min(startTime,timestamp)),speed<0&&(startTime=Math.min(timestamp-totalDuration/speed,startTime)),holdTime!==null?currentTime=holdTime:currentTime=Math.round(timestamp-startTime)*speed;const timeWithoutDelay=currentTime-delay2*(speed>=0?1:-1),isInDelayPhase=speed>=0?timeWithoutDelay<0:timeWithoutDelay>totalDuration;currentTime=Math.max(timeWithoutDelay,0),playState==="finished"&&holdTime===null&&(currentTime=totalDuration);let elapsed=currentTime,frameGenerator=generator;if(repeat){const progress2=currentTime/resolvedDuration;let currentIteration=Math.floor(progress2),iterationProgress=progress2%1;!iterationProgress&&progress2>=1&&(iterationProgress=1),iterationProgress===1&&currentIteration--,currentIteration=Math.min(currentIteration,repeat+1);const iterationIsOdd=!!(currentIteration%2);iterationIsOdd&&(repeatType==="reverse"?(iterationProgress=1-iterationProgress,repeatDelay&&(iterationProgress-=repeatDelay/resolvedDuration)):repeatType==="mirror"&&(frameGenerator=mirroredGenerator));let p2=clamp$1(0,1,iterationProgress);currentTime>totalDuration&&(p2=repeatType==="reverse"&&iterationIsOdd?1:0),elapsed=p2*resolvedDuration}const state=isInDelayPhase?{done:!1,value:keyframes$1[0]}:frameGenerator.next(elapsed);mapNumbersToKeyframes&&(state.value=mapNumbersToKeyframes(state.value));let{done}=state;!isInDelayPhase&&calculatedDuration!==null&&(done=speed>=0?currentTime>=totalDuration:currentTime<=0);const isAnimationFinished=holdTime===null&&(playState==="finished"||playState==="running"&&done);return onUpdate&&onUpdate(state.value),isAnimationFinished&&finish(),state},stopAnimationDriver=()=>{animationDriver&&animationDriver.stop(),animationDriver=void 0},cancel=()=>{playState="idle",stopAnimationDriver(),resolveFinishedPromise(),updateFinishedPromise(),startTime=cancelTime=null},finish=()=>{playState="finished",onComplete&&onComplete(),stopAnimationDriver(),resolveFinishedPromise()},play=()=>{if(hasStopped)return;animationDriver||(animationDriver=driver(tick));const now2=animationDriver.now();onPlay&&onPlay(),holdTime!==null?startTime=now2-holdTime:(!startTime||playState==="finished")&&(startTime=now2),playState==="finished"&&updateFinishedPromise(),cancelTime=startTime,holdTime=null,playState="running",animationDriver.start()};autoplay&&play();const controls={then(resolve2,reject){return currentFinishedPromise.then(resolve2,reject)},get time(){return millisecondsToSeconds(currentTime)},set time(newTime){newTime=secondsToMilliseconds(newTime),currentTime=newTime,holdTime!==null||!animationDriver||speed===0?holdTime=newTime:startTime=animationDriver.now()-newTime/speed},get duration(){const duration=generator.calculatedDuration===null?calcGeneratorDuration(generator):generator.calculatedDuration;return millisecondsToSeconds(duration)},get speed(){return speed},set speed(newSpeed){newSpeed===speed||!animationDriver||(speed=newSpeed,controls.time=millisecondsToSeconds(currentTime))},get state(){return playState},play,pause:()=>{playState="paused",holdTime=currentTime},stop:()=>{hasStopped=!0,playState!=="idle"&&(playState="idle",onStop&&onStop(),cancel())},cancel:()=>{cancelTime!==null&&tick(cancelTime),cancel()},complete:()=>{playState="finished"},sample:elapsed=>(startTime=0,tick(elapsed))};return controls}function memo(callback){let result;return()=>(result===void 0&&(result=callback()),result)}const supportsWaapi=memo(()=>Object.hasOwnProperty.call(Element.prototype,"animate")),acceleratedValues=new Set(["opacity","clipPath","filter","transform","backgroundColor"]),sampleDelta=10,maxDuration=2e4,requiresPregeneratedKeyframes=(valueName,options)=>options.type==="spring"||valueName==="backgroundColor"||!isWaapiSupportedEasing(options.ease);function createAcceleratedAnimation(value,valueName,{onUpdate,onComplete,...options}){if(!(supportsWaapi()&&acceleratedValues.has(valueName)&&!options.repeatDelay&&options.repeatType!=="mirror"&&options.damping!==0&&options.type!=="inertia"))return!1;let hasStopped=!1,resolveFinishedPromise,currentFinishedPromise;const updateFinishedPromise=()=>{currentFinishedPromise=new Promise(resolve2=>{resolveFinishedPromise=resolve2})};updateFinishedPromise();let{keyframes:keyframes2,duration=300,ease:ease2,times}=options;if(requiresPregeneratedKeyframes(valueName,options)){const sampleAnimation=animateValue({...options,repeat:0,delay:0});let state={done:!1,value:keyframes2[0]};const pregeneratedKeyframes=[];let t2=0;for(;!state.done&&t2<maxDuration;)state=sampleAnimation.sample(t2),pregeneratedKeyframes.push(state.value),t2+=sampleDelta;times=void 0,keyframes2=pregeneratedKeyframes,duration=t2-sampleDelta,ease2="linear"}const animation=animateStyle(value.owner.current,valueName,keyframes2,{...options,duration,ease:ease2,times});options.syncStart&&(animation.startTime=frameData.isProcessing?frameData.timestamp:document.timeline?document.timeline.currentTime:performance.now());const cancelAnimation=()=>animation.cancel(),safeCancel=()=>{frame.update(cancelAnimation),resolveFinishedPromise(),updateFinishedPromise()};return animation.onfinish=()=>{value.set(getFinalKeyframe(keyframes2,options)),onComplete&&onComplete(),safeCancel()},{then(resolve2,reject){return currentFinishedPromise.then(resolve2,reject)},attachTimeline(timeline){return animation.timeline=timeline,animation.onfinish=null,noop},get time(){return millisecondsToSeconds(animation.currentTime||0)},set time(newTime){animation.currentTime=secondsToMilliseconds(newTime)},get speed(){return animation.playbackRate},set speed(newSpeed){animation.playbackRate=newSpeed},get duration(){return millisecondsToSeconds(duration)},play:()=>{hasStopped||(animation.play(),cancelFrame(cancelAnimation))},pause:()=>animation.pause(),stop:()=>{if(hasStopped=!0,animation.playState==="idle")return;const{currentTime}=animation;if(currentTime){const sampleAnimation=animateValue({...options,autoplay:!1});value.setWithVelocity(sampleAnimation.sample(currentTime-sampleDelta).value,sampleAnimation.sample(currentTime).value,sampleDelta)}safeCancel()},complete:()=>animation.finish(),cancel:safeCancel}}function createInstantAnimation({keyframes:keyframes2,delay:delay2,onUpdate,onComplete}){const setValue=()=>(onUpdate&&onUpdate(keyframes2[keyframes2.length-1]),onComplete&&onComplete(),{time:0,speed:1,duration:0,play:noop,pause:noop,stop:noop,then:resolve2=>(resolve2(),Promise.resolve()),cancel:noop,complete:noop});return delay2?animateValue({keyframes:[0,1],duration:0,delay:delay2,onComplete:setValue}):setValue()}const underDampedSpring={type:"spring",stiffness:500,damping:25,restSpeed:10},criticallyDampedSpring=target=>({type:"spring",stiffness:550,damping:target===0?2*Math.sqrt(550):30,restSpeed:10}),keyframesTransition={type:"keyframes",duration:.8},ease={type:"keyframes",ease:[.25,.1,.35,1],duration:.3},getDefaultTransition=(valueKey,{keyframes:keyframes2})=>keyframes2.length>2?keyframesTransition:transformProps.has(valueKey)?valueKey.startsWith("scale")?criticallyDampedSpring(keyframes2[1]):underDampedSpring:ease,isAnimatable=(key,value)=>key==="zIndex"?!1:!!(typeof value=="number"||Array.isArray(value)||typeof value=="string"&&(complex.test(value)||value==="0")&&!value.startsWith("url(")),maxDefaults=new Set(["brightness","contrast","saturate","opacity"]);function applyDefaultFilter(v4){const[name,value]=v4.slice(0,-1).split("(");if(name==="drop-shadow")return v4;const[number2]=value.match(floatRegex)||[];if(!number2)return v4;const unit=value.replace(number2,"");let defaultValue=maxDefaults.has(name)?1:0;return number2!==value&&(defaultValue*=100),name+"("+defaultValue+unit+")"}const functionRegex=/([a-z-]*)\(.*?\)/g,filter={...complex,getAnimatableNone:v4=>{const functions=v4.match(functionRegex);return functions?functions.map(applyDefaultFilter).join(" "):v4}},defaultValueTypes={...numberValueTypes,color,backgroundColor:color,outlineColor:color,fill:color,stroke:color,borderColor:color,borderTopColor:color,borderRightColor:color,borderBottomColor:color,borderLeftColor:color,filter,WebkitFilter:filter},getDefaultValueType=key=>defaultValueTypes[key];function getAnimatableNone(key,value){let defaultValueType=getDefaultValueType(key);return defaultValueType!==filter&&(defaultValueType=complex),defaultValueType.getAnimatableNone?defaultValueType.getAnimatableNone(value):void 0}const isZeroValueString=v4=>/^0[^.\s]+$/.test(v4);function isNone(value){if(typeof value=="number")return value===0;if(value!==null)return value==="none"||value==="0"||isZeroValueString(value)}function getKeyframes(value,valueName,target,transition){const isTargetAnimatable=isAnimatable(valueName,target);let keyframes2;Array.isArray(target)?keyframes2=[...target]:keyframes2=[null,target];const defaultOrigin=transition.from!==void 0?transition.from:value.get();let animatableTemplateValue;const noneKeyframeIndexes=[];for(let i2=0;i2<keyframes2.length;i2++)keyframes2[i2]===null&&(keyframes2[i2]=i2===0?defaultOrigin:keyframes2[i2-1]),isNone(keyframes2[i2])&&noneKeyframeIndexes.push(i2),typeof keyframes2[i2]=="string"&&keyframes2[i2]!=="none"&&keyframes2[i2]!=="0"&&(animatableTemplateValue=keyframes2[i2]);if(isTargetAnimatable&&noneKeyframeIndexes.length&&animatableTemplateValue)for(let i2=0;i2<noneKeyframeIndexes.length;i2++){const index=noneKeyframeIndexes[i2];keyframes2[index]=getAnimatableNone(valueName,animatableTemplateValue)}return keyframes2}function isTransitionDefined({when,delay:_delay,delayChildren,staggerChildren,staggerDirection,repeat,repeatType,repeatDelay,from,elapsed,...transition}){return!!Object.keys(transition).length}function getValueTransition(transition,key){return transition[key]||transition.default||transition}const animateMotionValue=(valueName,value,target,transition={})=>onComplete=>{const valueTransition=getValueTransition(transition,valueName)||{},delay2=valueTransition.delay||transition.delay||0;let{elapsed=0}=transition;elapsed=elapsed-secondsToMilliseconds(delay2);const keyframes2=getKeyframes(value,valueName,target,valueTransition),originKeyframe=keyframes2[0],targetKeyframe=keyframes2[keyframes2.length-1],isOriginAnimatable=isAnimatable(valueName,originKeyframe),isTargetAnimatable=isAnimatable(valueName,targetKeyframe);warning(isOriginAnimatable===isTargetAnimatable,`You are trying to animate ${valueName} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);let options={keyframes:keyframes2,velocity:value.getVelocity(),ease:"easeOut",...valueTransition,delay:-elapsed,onUpdate:v4=>{value.set(v4),valueTransition.onUpdate&&valueTransition.onUpdate(v4)},onComplete:()=>{onComplete(),valueTransition.onComplete&&valueTransition.onComplete()}};if(isTransitionDefined(valueTransition)||(options={...options,...getDefaultTransition(valueName,options)}),options.duration&&(options.duration=secondsToMilliseconds(options.duration)),options.repeatDelay&&(options.repeatDelay=secondsToMilliseconds(options.repeatDelay)),!isOriginAnimatable||!isTargetAnimatable||instantAnimationState.current||valueTransition.type===!1)return createInstantAnimation(options);if(value.owner&&value.owner.current instanceof HTMLElement&&!value.owner.getProps().onUpdate){const acceleratedAnimation=createAcceleratedAnimation(value,valueName,options);if(acceleratedAnimation)return acceleratedAnimation}return animateValue(options)};function isWillChangeMotionValue(value){return!!(isMotionValue(value)&&value.add)}const isNumericalString=v4=>/^\-?\d*\.?\d+$/.test(v4);function addUniqueItem(arr,item){arr.indexOf(item)===-1&&arr.push(item)}function removeItem(arr,item){const index=arr.indexOf(item);index>-1&&arr.splice(index,1)}class SubscriptionManager{constructor(){this.subscriptions=[]}add(handler){return addUniqueItem(this.subscriptions,handler),()=>removeItem(this.subscriptions,handler)}notify(a2,b2,c2){const numSubscriptions=this.subscriptions.length;if(numSubscriptions)if(numSubscriptions===1)this.subscriptions[0](a2,b2,c2);else for(let i2=0;i2<numSubscriptions;i2++){const handler=this.subscriptions[i2];handler&&handler(a2,b2,c2)}}getSize(){return this.subscriptions.length}clear(){this.subscriptions.length=0}}const warned=new Set;function warnOnce$1(condition,message,element){condition||warned.has(message)||(console.warn(message),element&&console.warn(element),warned.add(message))}const isFloat=value=>!isNaN(parseFloat(value));class MotionValue{constructor(init,options={}){this.version="10.16.5",this.timeDelta=0,this.lastUpdated=0,this.canTrackVelocity=!1,this.events={},this.updateAndNotify=(v4,render=!0)=>{this.prev=this.current,this.current=v4;const{delta,timestamp}=frameData;this.lastUpdated!==timestamp&&(this.timeDelta=delta,this.lastUpdated=timestamp,frame.postRender(this.scheduleVelocityCheck)),this.prev!==this.current&&this.events.change&&this.events.change.notify(this.current),this.events.velocityChange&&this.events.velocityChange.notify(this.getVelocity()),render&&this.events.renderRequest&&this.events.renderRequest.notify(this.current)},this.scheduleVelocityCheck=()=>frame.postRender(this.velocityCheck),this.velocityCheck=({timestamp})=>{timestamp!==this.lastUpdated&&(this.prev=this.current,this.events.velocityChange&&this.events.velocityChange.notify(this.getVelocity()))},this.hasAnimated=!1,this.prev=this.current=init,this.canTrackVelocity=isFloat(this.current),this.owner=options.owner}onChange(subscription2){return warnOnce$1(!1,'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'),this.on("change",subscription2)}on(eventName,callback){this.events[eventName]||(this.events[eventName]=new SubscriptionManager);const unsubscribe=this.events[eventName].add(callback);return eventName==="change"?()=>{unsubscribe(),frame.read(()=>{this.events.change.getSize()||this.stop()})}:unsubscribe}clearListeners(){for(const eventManagers in this.events)this.events[eventManagers].clear()}attach(passiveEffect,stopPassiveEffect){this.passiveEffect=passiveEffect,this.stopPassiveEffect=stopPassiveEffect}set(v4,render=!0){!render||!this.passiveEffect?this.updateAndNotify(v4,render):this.passiveEffect(v4,this.updateAndNotify)}setWithVelocity(prev,current,delta){this.set(current),this.prev=prev,this.timeDelta=delta}jump(v4){this.updateAndNotify(v4),this.prev=v4,this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}get(){return this.current}getPrevious(){return this.prev}getVelocity(){return this.canTrackVelocity?velocityPerSecond(parseFloat(this.current)-parseFloat(this.prev),this.timeDelta):0}start(startAnimation){return this.stop(),new Promise(resolve2=>{this.hasAnimated=!0,this.animation=startAnimation(resolve2),this.events.animationStart&&this.events.animationStart.notify()}).then(()=>{this.events.animationComplete&&this.events.animationComplete.notify(),this.clearAnimation()})}stop(){this.animation&&(this.animation.stop(),this.events.animationCancel&&this.events.animationCancel.notify()),this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.clearListeners(),this.stop(),this.stopPassiveEffect&&this.stopPassiveEffect()}}function motionValue(init,options){return new MotionValue(init,options)}const testValueType=v4=>type=>type.test(v4),auto={test:v4=>v4==="auto",parse:v4=>v4},dimensionValueTypes=[number,px$1,percent,degrees,vw,vh,auto],findDimensionValueType=v4=>dimensionValueTypes.find(testValueType(v4)),valueTypes=[...dimensionValueTypes,color,complex],findValueType=v4=>valueTypes.find(testValueType(v4));function setMotionValue(visualElement,key,value){visualElement.hasValue(key)?visualElement.getValue(key).set(value):visualElement.addValue(key,motionValue(value))}function setTarget(visualElement,definition){const resolved=resolveVariant(visualElement,definition);let{transitionEnd={},transition={},...target}=resolved?visualElement.makeTargetAnimatable(resolved,!1):{};target={...target,...transitionEnd};for(const key in target){const value=resolveFinalValueInKeyframes(target[key]);setMotionValue(visualElement,key,value)}}function checkTargetForNewValues(visualElement,target,origin){var _a2,_b2;const newValueKeys=Object.keys(target).filter(key=>!visualElement.hasValue(key)),numNewValues=newValueKeys.length;if(numNewValues)for(let i2=0;i2<numNewValues;i2++){const key=newValueKeys[i2],targetValue=target[key];let value=null;Array.isArray(targetValue)&&(value=targetValue[0]),value===null&&(value=(_b2=(_a2=origin[key])!==null&&_a2!==void 0?_a2:visualElement.readValue(key))!==null&&_b2!==void 0?_b2:target[key]),value!=null&&(typeof value=="string"&&(isNumericalString(value)||isZeroValueString(value))?value=parseFloat(value):!findValueType(value)&&complex.test(targetValue)&&(value=getAnimatableNone(key,targetValue)),visualElement.addValue(key,motionValue(value,{owner:visualElement})),origin[key]===void 0&&(origin[key]=value),value!==null&&visualElement.setBaseTarget(key,value))}}function getOriginFromTransition(key,transition){return transition?(transition[key]||transition.default||transition).from:void 0}function getOrigin(target,transition,visualElement){const origin={};for(const key in target){const transitionOrigin=getOriginFromTransition(key,transition);if(transitionOrigin!==void 0)origin[key]=transitionOrigin;else{const value=visualElement.getValue(key);value&&(origin[key]=value.get())}}return origin}function shouldBlockAnimation({protectedKeys,needsAnimating},key){const shouldBlock=protectedKeys.hasOwnProperty(key)&&needsAnimating[key]!==!0;return needsAnimating[key]=!1,shouldBlock}function animateTarget(visualElement,definition,{delay:delay2=0,transitionOverride,type}={}){let{transition=visualElement.getDefaultTransition(),transitionEnd,...target}=visualElement.makeTargetAnimatable(definition);const willChange=visualElement.getValue("willChange");transitionOverride&&(transition=transitionOverride);const animations2=[],animationTypeState=type&&visualElement.animationState&&visualElement.animationState.getState()[type];for(const key in target){const value=visualElement.getValue(key),valueTarget=target[key];if(!value||valueTarget===void 0||animationTypeState&&shouldBlockAnimation(animationTypeState,key))continue;const valueTransition={delay:delay2,elapsed:0,...transition};if(window.HandoffAppearAnimations&&!value.hasAnimated){const appearId=visualElement.getProps()[optimizedAppearDataAttribute];appearId&&(valueTransition.elapsed=window.HandoffAppearAnimations(appearId,key,value,frame),valueTransition.syncStart=!0)}value.start(animateMotionValue(key,value,valueTarget,visualElement.shouldReduceMotion&&transformProps.has(key)?{type:!1}:valueTransition));const animation=value.animation;isWillChangeMotionValue(willChange)&&(willChange.add(key),animation.then(()=>willChange.remove(key))),animations2.push(animation)}return transitionEnd&&Promise.all(animations2).then(()=>{transitionEnd&&setTarget(visualElement,transitionEnd)}),animations2}function animateVariant(visualElement,variant,options={}){const resolved=resolveVariant(visualElement,variant,options.custom);let{transition=visualElement.getDefaultTransition()||{}}=resolved||{};options.transitionOverride&&(transition=options.transitionOverride);const getAnimation=resolved?()=>Promise.all(animateTarget(visualElement,resolved,options)):()=>Promise.resolve(),getChildAnimations=visualElement.variantChildren&&visualElement.variantChildren.size?(forwardDelay=0)=>{const{delayChildren=0,staggerChildren,staggerDirection}=transition;return animateChildren(visualElement,variant,delayChildren+forwardDelay,staggerChildren,staggerDirection,options)}:()=>Promise.resolve(),{when}=transition;if(when){const[first,last]=when==="beforeChildren"?[getAnimation,getChildAnimations]:[getChildAnimations,getAnimation];return first().then(()=>last())}else return Promise.all([getAnimation(),getChildAnimations(options.delay)])}function animateChildren(visualElement,variant,delayChildren=0,staggerChildren=0,staggerDirection=1,options){const animations2=[],maxStaggerDuration=(visualElement.variantChildren.size-1)*staggerChildren,generateStaggerDuration=staggerDirection===1?(i2=0)=>i2*staggerChildren:(i2=0)=>maxStaggerDuration-i2*staggerChildren;return Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child,i2)=>{child.notify("AnimationStart",variant),animations2.push(animateVariant(child,variant,{...options,delay:delayChildren+generateStaggerDuration(i2)}).then(()=>child.notify("AnimationComplete",variant)))}),Promise.all(animations2)}function sortByTreeOrder(a2,b2){return a2.sortNodePosition(b2)}function animateVisualElement(visualElement,definition,options={}){visualElement.notify("AnimationStart",definition);let animation;if(Array.isArray(definition)){const animations2=definition.map(variant=>animateVariant(visualElement,variant,options));animation=Promise.all(animations2)}else if(typeof definition=="string")animation=animateVariant(visualElement,definition,options);else{const resolvedDefinition=typeof definition=="function"?resolveVariant(visualElement,definition,options.custom):definition;animation=Promise.all(animateTarget(visualElement,resolvedDefinition,options))}return animation.then(()=>visualElement.notify("AnimationComplete",definition))}const reversePriorityOrder=[...variantPriorityOrder].reverse(),numAnimationTypes=variantPriorityOrder.length;function animateList(visualElement){return animations2=>Promise.all(animations2.map(({animation,options})=>animateVisualElement(visualElement,animation,options)))}function createAnimationState(visualElement){let animate=animateList(visualElement);const state=createState();let isInitialRender=!0;const buildResolvedTypeValues=(acc,definition)=>{const resolved=resolveVariant(visualElement,definition);if(resolved){const{transition,transitionEnd,...target}=resolved;acc={...acc,...target,...transitionEnd}}return acc};function setAnimateFunction(makeAnimator){animate=makeAnimator(visualElement)}function animateChanges(options,changedActiveType){const props=visualElement.getProps(),context2=visualElement.getVariantContext(!0)||{},animations2=[],removedKeys=new Set;let encounteredKeys={},removedVariantIndex=1/0;for(let i2=0;i2<numAnimationTypes;i2++){const type=reversePriorityOrder[i2],typeState=state[type],prop=props[type]!==void 0?props[type]:context2[type],propIsVariant=isVariantLabel(prop),activeDelta=type===changedActiveType?typeState.isActive:null;activeDelta===!1&&(removedVariantIndex=i2);let isInherited=prop===context2[type]&&prop!==props[type]&&propIsVariant;if(isInherited&&isInitialRender&&visualElement.manuallyAnimateOnMount&&(isInherited=!1),typeState.protectedKeys={...encounteredKeys},!typeState.isActive&&activeDelta===null||!prop&&!typeState.prevProp||isAnimationControls(prop)||typeof prop=="boolean")continue;const variantDidChange=checkVariantsDidChange(typeState.prevProp,prop);let shouldAnimateType=variantDidChange||type===changedActiveType&&typeState.isActive&&!isInherited&&propIsVariant||i2>removedVariantIndex&&propIsVariant;const definitionList=Array.isArray(prop)?prop:[prop];let resolvedValues=definitionList.reduce(buildResolvedTypeValues,{});activeDelta===!1&&(resolvedValues={});const{prevResolvedValues={}}=typeState,allKeys={...prevResolvedValues,...resolvedValues},markToAnimate=key=>{shouldAnimateType=!0,removedKeys.delete(key),typeState.needsAnimating[key]=!0};for(const key in allKeys){const next=resolvedValues[key],prev=prevResolvedValues[key];encounteredKeys.hasOwnProperty(key)||(next!==prev?isKeyframesTarget(next)&&isKeyframesTarget(prev)?!shallowCompare(next,prev)||variantDidChange?markToAnimate(key):typeState.protectedKeys[key]=!0:next!==void 0?markToAnimate(key):removedKeys.add(key):next!==void 0&&removedKeys.has(key)?markToAnimate(key):typeState.protectedKeys[key]=!0)}typeState.prevProp=prop,typeState.prevResolvedValues=resolvedValues,typeState.isActive&&(encounteredKeys={...encounteredKeys,...resolvedValues}),isInitialRender&&visualElement.blockInitialAnimation&&(shouldAnimateType=!1),shouldAnimateType&&!isInherited&&animations2.push(...definitionList.map(animation=>({animation,options:{type,...options}})))}if(removedKeys.size){const fallbackAnimation={};removedKeys.forEach(key=>{const fallbackTarget=visualElement.getBaseTarget(key);fallbackTarget!==void 0&&(fallbackAnimation[key]=fallbackTarget)}),animations2.push({animation:fallbackAnimation})}let shouldAnimate=!!animations2.length;return isInitialRender&&props.initial===!1&&!visualElement.manuallyAnimateOnMount&&(shouldAnimate=!1),isInitialRender=!1,shouldAnimate?animate(animations2):Promise.resolve()}function setActive(type,isActive,options){var _a2;if(state[type].isActive===isActive)return Promise.resolve();(_a2=visualElement.variantChildren)===null||_a2===void 0||_a2.forEach(child=>{var _a3;return(_a3=child.animationState)===null||_a3===void 0?void 0:_a3.setActive(type,isActive)}),state[type].isActive=isActive;const animations2=animateChanges(options,type);for(const key in state)state[key].protectedKeys={};return animations2}return{animateChanges,setActive,setAnimateFunction,getState:()=>state}}function checkVariantsDidChange(prev,next){return typeof next=="string"?next!==prev:Array.isArray(next)?!shallowCompare(next,prev):!1}function createTypeState(isActive=!1){return{isActive,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}function createState(){return{animate:createTypeState(!0),whileInView:createTypeState(),whileHover:createTypeState(),whileTap:createTypeState(),whileDrag:createTypeState(),whileFocus:createTypeState(),exit:createTypeState()}}class AnimationFeature extends Feature{constructor(node){super(node),node.animationState||(node.animationState=createAnimationState(node))}updateAnimationControlsSubscription(){const{animate}=this.node.getProps();this.unmount(),isAnimationControls(animate)&&(this.unmount=animate.subscribe(this.node))}mount(){this.updateAnimationControlsSubscription()}update(){const{animate}=this.node.getProps(),{animate:prevAnimate}=this.node.prevProps||{};animate!==prevAnimate&&this.updateAnimationControlsSubscription()}unmount(){}}let id$1=0;class ExitAnimationFeature extends Feature{constructor(){super(...arguments),this.id=id$1++}update(){if(!this.node.presenceContext)return;const{isPresent,onExitComplete,custom}=this.node.presenceContext,{isPresent:prevIsPresent}=this.node.prevPresenceContext||{};if(!this.node.animationState||isPresent===prevIsPresent)return;const exitAnimation=this.node.animationState.setActive("exit",!isPresent,{custom:custom??this.node.getProps().custom});onExitComplete&&!isPresent&&exitAnimation.then(()=>onExitComplete(this.id))}mount(){const{register}=this.node.presenceContext||{};register&&(this.unmount=register(this.id))}unmount(){}}const animations={animation:{Feature:AnimationFeature},exit:{Feature:ExitAnimationFeature}},distance=(a2,b2)=>Math.abs(a2-b2);function distance2D(a2,b2){const xDelta=distance(a2.x,b2.x),yDelta=distance(a2.y,b2.y);return Math.sqrt(xDelta**2+yDelta**2)}class PanSession{constructor(event,handlers,{transformPagePoint}={}){if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.updatePoint=()=>{if(!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const info2=getPanInfo(this.lastMoveEventInfo,this.history),isPanStarted=this.startEvent!==null,isDistancePastThreshold=distance2D(info2.offset,{x:0,y:0})>=3;if(!isPanStarted&&!isDistancePastThreshold)return;const{point:point2}=info2,{timestamp:timestamp2}=frameData;this.history.push({...point2,timestamp:timestamp2});const{onStart,onMove}=this.handlers;isPanStarted||(onStart&&onStart(this.lastMoveEvent,info2),this.startEvent=this.lastMoveEvent),onMove&&onMove(this.lastMoveEvent,info2)},this.handlePointerMove=(event2,info2)=>{this.lastMoveEvent=event2,this.lastMoveEventInfo=transformPoint(info2,this.transformPagePoint),frame.update(this.updatePoint,!0)},this.handlePointerUp=(event2,info2)=>{if(this.end(),!(this.lastMoveEvent&&this.lastMoveEventInfo))return;const{onEnd,onSessionEnd}=this.handlers,panInfo=getPanInfo(event2.type==="pointercancel"?this.lastMoveEventInfo:transformPoint(info2,this.transformPagePoint),this.history);this.startEvent&&onEnd&&onEnd(event2,panInfo),onSessionEnd&&onSessionEnd(event2,panInfo)},!isPrimaryPointer(event))return;this.handlers=handlers,this.transformPagePoint=transformPagePoint;const info=extractEventInfo(event),initialInfo=transformPoint(info,this.transformPagePoint),{point}=initialInfo,{timestamp}=frameData;this.history=[{...point,timestamp}];const{onSessionStart}=handlers;onSessionStart&&onSessionStart(event,getPanInfo(initialInfo,this.history)),this.removeListeners=pipe(addPointerEvent(window,"pointermove",this.handlePointerMove),addPointerEvent(window,"pointerup",this.handlePointerUp),addPointerEvent(window,"pointercancel",this.handlePointerUp))}updateHandlers(handlers){this.handlers=handlers}end(){this.removeListeners&&this.removeListeners(),cancelFrame(this.updatePoint)}}function transformPoint(info,transformPagePoint){return transformPagePoint?{point:transformPagePoint(info.point)}:info}function subtractPoint(a2,b2){return{x:a2.x-b2.x,y:a2.y-b2.y}}function getPanInfo({point},history){return{point,delta:subtractPoint(point,lastDevicePoint(history)),offset:subtractPoint(point,startDevicePoint(history)),velocity:getVelocity(history,.1)}}function startDevicePoint(history){return history[0]}function lastDevicePoint(history){return history[history.length-1]}function getVelocity(history,timeDelta){if(history.length<2)return{x:0,y:0};let i2=history.length-1,timestampedPoint=null;const lastPoint=lastDevicePoint(history);for(;i2>=0&&(timestampedPoint=history[i2],!(lastPoint.timestamp-timestampedPoint.timestamp>secondsToMilliseconds(timeDelta)));)i2--;if(!timestampedPoint)return{x:0,y:0};const time=millisecondsToSeconds(lastPoint.timestamp-timestampedPoint.timestamp);if(time===0)return{x:0,y:0};const currentVelocity={x:(lastPoint.x-timestampedPoint.x)/time,y:(lastPoint.y-timestampedPoint.y)/time};return currentVelocity.x===1/0&&(currentVelocity.x=0),currentVelocity.y===1/0&&(currentVelocity.y=0),currentVelocity}function calcLength(axis){return axis.max-axis.min}function isNear(value,target=0,maxDistance=.01){return Math.abs(value-target)<=maxDistance}function calcAxisDelta(delta,source,target,origin=.5){delta.origin=origin,delta.originPoint=mix(source.min,source.max,delta.origin),delta.scale=calcLength(target)/calcLength(source),(isNear(delta.scale,1,1e-4)||isNaN(delta.scale))&&(delta.scale=1),delta.translate=mix(target.min,target.max,delta.origin)-delta.originPoint,(isNear(delta.translate)||isNaN(delta.translate))&&(delta.translate=0)}function calcBoxDelta(delta,source,target,origin){calcAxisDelta(delta.x,source.x,target.x,origin?origin.originX:void 0),calcAxisDelta(delta.y,source.y,target.y,origin?origin.originY:void 0)}function calcRelativeAxis(target,relative,parent){target.min=parent.min+relative.min,target.max=target.min+calcLength(relative)}function calcRelativeBox(target,relative,parent){calcRelativeAxis(target.x,relative.x,parent.x),calcRelativeAxis(target.y,relative.y,parent.y)}function calcRelativeAxisPosition(target,layout2,parent){target.min=layout2.min-parent.min,target.max=target.min+calcLength(layout2)}function calcRelativePosition(target,layout2,parent){calcRelativeAxisPosition(target.x,layout2.x,parent.x),calcRelativeAxisPosition(target.y,layout2.y,parent.y)}function applyConstraints(point,{min,max:max2},elastic){return min!==void 0&&point<min?point=elastic?mix(min,point,elastic.min):Math.max(point,min):max2!==void 0&&point>max2&&(point=elastic?mix(max2,point,elastic.max):Math.min(point,max2)),point}function calcRelativeAxisConstraints(axis,min,max2){return{min:min!==void 0?axis.min+min:void 0,max:max2!==void 0?axis.max+max2-(axis.max-axis.min):void 0}}function calcRelativeConstraints(layoutBox,{top,left,bottom,right}){return{x:calcRelativeAxisConstraints(layoutBox.x,left,right),y:calcRelativeAxisConstraints(layoutBox.y,top,bottom)}}function calcViewportAxisConstraints(layoutAxis,constraintsAxis){let min=constraintsAxis.min-layoutAxis.min,max2=constraintsAxis.max-layoutAxis.max;return constraintsAxis.max-constraintsAxis.min<layoutAxis.max-layoutAxis.min&&([min,max2]=[max2,min]),{min,max:max2}}function calcViewportConstraints(layoutBox,constraintsBox){return{x:calcViewportAxisConstraints(layoutBox.x,constraintsBox.x),y:calcViewportAxisConstraints(layoutBox.y,constraintsBox.y)}}function calcOrigin(source,target){let origin=.5;const sourceLength=calcLength(source),targetLength=calcLength(target);return targetLength>sourceLength?origin=progress(target.min,target.max-sourceLength,source.min):sourceLength>targetLength&&(origin=progress(source.min,source.max-targetLength,target.min)),clamp$1(0,1,origin)}function rebaseAxisConstraints(layout2,constraints){const relativeConstraints={};return constraints.min!==void 0&&(relativeConstraints.min=constraints.min-layout2.min),constraints.max!==void 0&&(relativeConstraints.max=constraints.max-layout2.min),relativeConstraints}const defaultElastic=.35;function resolveDragElastic(dragElastic=defaultElastic){return dragElastic===!1?dragElastic=0:dragElastic===!0&&(dragElastic=defaultElastic),{x:resolveAxisElastic(dragElastic,"left","right"),y:resolveAxisElastic(dragElastic,"top","bottom")}}function resolveAxisElastic(dragElastic,minLabel,maxLabel){return{min:resolvePointElastic(dragElastic,minLabel),max:resolvePointElastic(dragElastic,maxLabel)}}function resolvePointElastic(dragElastic,label){return typeof dragElastic=="number"?dragElastic:dragElastic[label]||0}const createAxisDelta=()=>({translate:0,scale:1,origin:0,originPoint:0}),createDelta=()=>({x:createAxisDelta(),y:createAxisDelta()}),createAxis=()=>({min:0,max:0}),createBox=()=>({x:createAxis(),y:createAxis()});function eachAxis(callback){return[callback("x"),callback("y")]}function convertBoundingBoxToBox({top,left,right,bottom}){return{x:{min:left,max:right},y:{min:top,max:bottom}}}function convertBoxToBoundingBox({x:x2,y:y2}){return{top:y2.min,right:x2.max,bottom:y2.max,left:x2.min}}function transformBoxPoints(point,transformPoint2){if(!transformPoint2)return point;const topLeft=transformPoint2({x:point.left,y:point.top}),bottomRight=transformPoint2({x:point.right,y:point.bottom});return{top:topLeft.y,left:topLeft.x,bottom:bottomRight.y,right:bottomRight.x}}function isIdentityScale(scale2){return scale2===void 0||scale2===1}function hasScale({scale:scale2,scaleX,scaleY}){return!isIdentityScale(scale2)||!isIdentityScale(scaleX)||!isIdentityScale(scaleY)}function hasTransform(values){return hasScale(values)||has2DTranslate(values)||values.z||values.rotate||values.rotateX||values.rotateY}function has2DTranslate(values){return is2DTranslate(values.x)||is2DTranslate(values.y)}function is2DTranslate(value){return value&&value!=="0%"}function scalePoint(point,scale2,originPoint){const distanceFromOrigin=point-originPoint,scaled=scale2*distanceFromOrigin;return originPoint+scaled}function applyPointDelta(point,translate,scale2,originPoint,boxScale){return boxScale!==void 0&&(point=scalePoint(point,boxScale,originPoint)),scalePoint(point,scale2,originPoint)+translate}function applyAxisDelta(axis,translate=0,scale2=1,originPoint,boxScale){axis.min=applyPointDelta(axis.min,translate,scale2,originPoint,boxScale),axis.max=applyPointDelta(axis.max,translate,scale2,originPoint,boxScale)}function applyBoxDelta(box,{x:x2,y:y2}){applyAxisDelta(box.x,x2.translate,x2.scale,x2.originPoint),applyAxisDelta(box.y,y2.translate,y2.scale,y2.originPoint)}function applyTreeDeltas(box,treeScale,treePath,isSharedTransition=!1){const treeLength=treePath.length;if(!treeLength)return;treeScale.x=treeScale.y=1;let node,delta;for(let i2=0;i2<treeLength;i2++){node=treePath[i2],delta=node.projectionDelta;const instance=node.instance;instance&&instance.style&&instance.style.display==="contents"||(isSharedTransition&&node.options.layoutScroll&&node.scroll&&node!==node.root&&transformBox(box,{x:-node.scroll.offset.x,y:-node.scroll.offset.y}),delta&&(treeScale.x*=delta.x.scale,treeScale.y*=delta.y.scale,applyBoxDelta(box,delta)),isSharedTransition&&hasTransform(node.latestValues)&&transformBox(box,node.latestValues))}treeScale.x=snapToDefault(treeScale.x),treeScale.y=snapToDefault(treeScale.y)}function snapToDefault(scale2){return Number.isInteger(scale2)||scale2>1.0000000000001||scale2<.999999999999?scale2:1}function translateAxis(axis,distance2){axis.min=axis.min+distance2,axis.max=axis.max+distance2}function transformAxis(axis,transforms,[key,scaleKey,originKey]){const axisOrigin=transforms[originKey]!==void 0?transforms[originKey]:.5,originPoint=mix(axis.min,axis.max,axisOrigin);applyAxisDelta(axis,transforms[key],transforms[scaleKey],originPoint,transforms.scale)}const xKeys$1=["x","scaleX","originX"],yKeys$1=["y","scaleY","originY"];function transformBox(box,transform){transformAxis(box.x,transform,xKeys$1),transformAxis(box.y,transform,yKeys$1)}function measureViewportBox(instance,transformPoint2){return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(),transformPoint2))}function measurePageBox(element,rootProjectionNode2,transformPagePoint){const viewportBox=measureViewportBox(element,transformPagePoint),{scroll}=rootProjectionNode2;return scroll&&(translateAxis(viewportBox.x,scroll.offset.x),translateAxis(viewportBox.y,scroll.offset.y)),viewportBox}const elementDragControls=new WeakMap;class VisualElementDragControls{constructor(visualElement){this.openGlobalLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic=createBox(),this.visualElement=visualElement}start(originEvent,{snapToCursor=!1}={}){const{presenceContext}=this.visualElement;if(presenceContext&&presenceContext.isPresent===!1)return;const onSessionStart=event=>{this.stopAnimation(),snapToCursor&&this.snapToCursor(extractEventInfo(event,"page").point)},onStart=(event,info)=>{const{drag:drag2,dragPropagation,onDragStart}=this.getProps();if(drag2&&!dragPropagation&&(this.openGlobalLock&&this.openGlobalLock(),this.openGlobalLock=getGlobalLock(drag2),!this.openGlobalLock))return;this.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&&(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),eachAxis(axis=>{let current=this.getAxisMotionValue(axis).get()||0;if(percent.test(current)){const{projection}=this.visualElement;if(projection&&projection.layout){const measuredAxis=projection.layout.layoutBox[axis];measuredAxis&&(current=calcLength(measuredAxis)*(parseFloat(current)/100))}}this.originPoint[axis]=current}),onDragStart&&frame.update(()=>onDragStart(event,info),!1,!0);const{animationState}=this.visualElement;animationState&&animationState.setActive("whileDrag",!0)},onMove=(event,info)=>{const{dragPropagation,dragDirectionLock,onDirectionLock,onDrag}=this.getProps();if(!dragPropagation&&!this.openGlobalLock)return;const{offset}=info;if(dragDirectionLock&&this.currentDirection===null){this.currentDirection=getCurrentDirection(offset),this.currentDirection!==null&&onDirectionLock&&onDirectionLock(this.currentDirection);return}this.updateAxis("x",info.point,offset),this.updateAxis("y",info.point,offset),this.visualElement.render(),onDrag&&onDrag(event,info)},onSessionEnd=(event,info)=>this.stop(event,info);this.panSession=new PanSession(originEvent,{onSessionStart,onStart,onMove,onSessionEnd},{transformPagePoint:this.visualElement.getTransformPagePoint()})}stop(event,info){const isDragging=this.isDragging;if(this.cancel(),!isDragging)return;const{velocity}=info;this.startAnimation(velocity);const{onDragEnd}=this.getProps();onDragEnd&&frame.update(()=>onDragEnd(event,info))}cancel(){this.isDragging=!1;const{projection,animationState}=this.visualElement;projection&&(projection.isAnimationBlocked=!1),this.panSession&&this.panSession.end(),this.panSession=void 0;const{dragPropagation}=this.getProps();!dragPropagation&&this.openGlobalLock&&(this.openGlobalLock(),this.openGlobalLock=null),animationState&&animationState.setActive("whileDrag",!1)}updateAxis(axis,_point,offset){const{drag:drag2}=this.getProps();if(!offset||!shouldDrag(axis,drag2,this.currentDirection))return;const axisValue=this.getAxisMotionValue(axis);let next=this.originPoint[axis]+offset[axis];this.constraints&&this.constraints[axis]&&(next=applyConstraints(next,this.constraints[axis],this.elastic[axis])),axisValue.set(next)}resolveConstraints(){const{dragConstraints,dragElastic}=this.getProps(),{layout:layout2}=this.visualElement.projection||{},prevConstraints=this.constraints;dragConstraints&&isRefObject$1(dragConstraints)?this.constraints||(this.constraints=this.resolveRefConstraints()):dragConstraints&&layout2?this.constraints=calcRelativeConstraints(layout2.layoutBox,dragConstraints):this.constraints=!1,this.elastic=resolveDragElastic(dragElastic),prevConstraints!==this.constraints&&layout2&&this.constraints&&!this.hasMutatedConstraints&&eachAxis(axis=>{this.getAxisMotionValue(axis)&&(this.constraints[axis]=rebaseAxisConstraints(layout2.layoutBox[axis],this.constraints[axis]))})}resolveRefConstraints(){const{dragConstraints:constraints,onMeasureDragConstraints}=this.getProps();if(!constraints||!isRefObject$1(constraints))return!1;const constraintsElement=constraints.current;invariant(constraintsElement!==null,"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");const{projection}=this.visualElement;if(!projection||!projection.layout)return!1;const constraintsBox=measurePageBox(constraintsElement,projection.root,this.visualElement.getTransformPagePoint());let measuredConstraints=calcViewportConstraints(projection.layout.layoutBox,constraintsBox);if(onMeasureDragConstraints){const userConstraints=onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));this.hasMutatedConstraints=!!userConstraints,userConstraints&&(measuredConstraints=convertBoundingBoxToBox(userConstraints))}return measuredConstraints}startAnimation(velocity){const{drag:drag2,dragMomentum,dragElastic,dragTransition,dragSnapToOrigin,onDragTransitionEnd}=this.getProps(),constraints=this.constraints||{},momentumAnimations=eachAxis(axis=>{if(!shouldDrag(axis,drag2,this.currentDirection))return;let transition=constraints&&constraints[axis]||{};dragSnapToOrigin&&(transition={min:0,max:0});const bounceStiffness=dragElastic?200:1e6,bounceDamping=dragElastic?40:1e7,inertia2={type:"inertia",velocity:dragMomentum?velocity[axis]:0,bounceStiffness,bounceDamping,timeConstant:750,restDelta:1,restSpeed:10,...dragTransition,...transition};return this.startAxisValueAnimation(axis,inertia2)});return Promise.all(momentumAnimations).then(onDragTransitionEnd)}startAxisValueAnimation(axis,transition){const axisValue=this.getAxisMotionValue(axis);return axisValue.start(animateMotionValue(axis,axisValue,0,transition))}stopAnimation(){eachAxis(axis=>this.getAxisMotionValue(axis).stop())}getAxisMotionValue(axis){const dragKey="_drag"+axis.toUpperCase(),props=this.visualElement.getProps(),externalMotionValue=props[dragKey];return externalMotionValue||this.visualElement.getValue(axis,(props.initial?props.initial[axis]:void 0)||0)}snapToCursor(point){eachAxis(axis=>{const{drag:drag2}=this.getProps();if(!shouldDrag(axis,drag2,this.currentDirection))return;const{projection}=this.visualElement,axisValue=this.getAxisMotionValue(axis);if(projection&&projection.layout){const{min,max:max2}=projection.layout.layoutBox[axis];axisValue.set(point[axis]-mix(min,max2,.5))}})}scalePositionWithinConstraints(){if(!this.visualElement.current)return;const{drag:drag2,dragConstraints}=this.getProps(),{projection}=this.visualElement;if(!isRefObject$1(dragConstraints)||!projection||!this.constraints)return;this.stopAnimation();const boxProgress={x:0,y:0};eachAxis(axis=>{const axisValue=this.getAxisMotionValue(axis);if(axisValue){const latest=axisValue.get();boxProgress[axis]=calcOrigin({min:latest,max:latest},this.constraints[axis])}});const{transformTemplate}=this.visualElement.getProps();this.visualElement.current.style.transform=transformTemplate?transformTemplate({},""):"none",projection.root&&projection.root.updateScroll(),projection.updateLayout(),this.resolveConstraints(),eachAxis(axis=>{if(!shouldDrag(axis,drag2,null))return;const axisValue=this.getAxisMotionValue(axis),{min,max:max2}=this.constraints[axis];axisValue.set(mix(min,max2,boxProgress[axis]))})}addListeners(){if(!this.visualElement.current)return;elementDragControls.set(this.visualElement,this);const element=this.visualElement.current,stopPointerListener=addPointerEvent(element,"pointerdown",event=>{const{drag:drag2,dragListener=!0}=this.getProps();drag2&&dragListener&&this.start(event)}),measureDragConstraints=()=>{const{dragConstraints}=this.getProps();isRefObject$1(dragConstraints)&&(this.constraints=this.resolveRefConstraints())},{projection}=this.visualElement,stopMeasureLayoutListener=projection.addEventListener("measure",measureDragConstraints);projection&&!projection.layout&&(projection.root&&projection.root.updateScroll(),projection.updateLayout()),measureDragConstraints();const stopResizeListener=addDomEvent(window,"resize",()=>this.scalePositionWithinConstraints()),stopLayoutUpdateListener=projection.addEventListener("didUpdate",({delta,hasLayoutChanged})=>{this.isDragging&&hasLayoutChanged&&(eachAxis(axis=>{const motionValue2=this.getAxisMotionValue(axis);motionValue2&&(this.originPoint[axis]+=delta[axis].translate,motionValue2.set(motionValue2.get()+delta[axis].translate))}),this.visualElement.render())});return()=>{stopResizeListener(),stopPointerListener(),stopMeasureLayoutListener(),stopLayoutUpdateListener&&stopLayoutUpdateListener()}}getProps(){const props=this.visualElement.getProps(),{drag:drag2=!1,dragDirectionLock=!1,dragPropagation=!1,dragConstraints=!1,dragElastic=defaultElastic,dragMomentum=!0}=props;return{...props,drag:drag2,dragDirectionLock,dragPropagation,dragConstraints,dragElastic,dragMomentum}}}function shouldDrag(direction,drag2,currentDirection){return(drag2===!0||drag2===direction)&&(currentDirection===null||currentDirection===direction)}function getCurrentDirection(offset,lockThreshold=10){let direction=null;return Math.abs(offset.y)>lockThreshold?direction="y":Math.abs(offset.x)>lockThreshold&&(direction="x"),direction}class DragGesture extends Feature{constructor(node){super(node),this.removeGroupControls=noop,this.removeListeners=noop,this.controls=new VisualElementDragControls(node)}mount(){const{dragControls}=this.node.getProps();dragControls&&(this.removeGroupControls=dragControls.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||noop}unmount(){this.removeGroupControls(),this.removeListeners()}}const asyncHandler=handler=>(event,info)=>{handler&&frame.update(()=>handler(event,info))};class PanGesture extends Feature{constructor(){super(...arguments),this.removePointerDownListener=noop}onPointerDown(pointerDownEvent){this.session=new PanSession(pointerDownEvent,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint()})}createPanHandlers(){const{onPanSessionStart,onPanStart,onPan,onPanEnd}=this.node.getProps();return{onSessionStart:asyncHandler(onPanSessionStart),onStart:asyncHandler(onPanStart),onMove:onPan,onEnd:(event,info)=>{delete this.session,onPanEnd&&frame.update(()=>onPanEnd(event,info))}}}mount(){this.removePointerDownListener=addPointerEvent(this.node.current,"pointerdown",event=>this.onPointerDown(event))}update(){this.session&&this.session.updateHandlers(this.createPanHandlers())}unmount(){this.removePointerDownListener(),this.session&&this.session.end()}}function usePresence(){const context2=reactExports.useContext(PresenceContext);if(context2===null)return[!0,null];const{isPresent,onExitComplete,register}=context2,id2=reactExports.useId();return reactExports.useEffect(()=>register(id2),[]),!isPresent&&onExitComplete?[!1,()=>onExitComplete&&onExitComplete(id2)]:[!0]}const globalProjectionState={hasAnimatedSinceResize:!0,hasEverUpdated:!1};function pixelsToPercent(pixels,axis){return axis.max===axis.min?0:pixels/(axis.max-axis.min)*100}const correctBorderRadius={correct:(latest,node)=>{if(!node.target)return latest;if(typeof latest=="string")if(px$1.test(latest))latest=parseFloat(latest);else return latest;const x2=pixelsToPercent(latest,node.target.x),y2=pixelsToPercent(latest,node.target.y);return`${x2}% ${y2}%`}},correctBoxShadow={correct:(latest,{treeScale,projectionDelta})=>{const original=latest,shadow=complex.parse(latest);if(shadow.length>5)return original;const template=complex.createTransformer(latest),offset=typeof shadow[0]!="number"?1:0,xScale=projectionDelta.x.scale*treeScale.x,yScale=projectionDelta.y.scale*treeScale.y;shadow[0+offset]/=xScale,shadow[1+offset]/=yScale;const averageScale=mix(xScale,yScale,.5);return typeof shadow[2+offset]=="number"&&(shadow[2+offset]/=averageScale),typeof shadow[3+offset]=="number"&&(shadow[3+offset]/=averageScale),template(shadow)}};class MeasureLayoutWithContext extends u$1.Component{componentDidMount(){const{visualElement,layoutGroup,switchLayoutGroup,layoutId}=this.props,{projection}=visualElement;addScaleCorrector(defaultScaleCorrectors),projection&&(layoutGroup.group&&layoutGroup.group.add(projection),switchLayoutGroup&&switchLayoutGroup.register&&layoutId&&switchLayoutGroup.register(projection),projection.root.didUpdate(),projection.addEventListener("animationComplete",()=>{this.safeToRemove()}),projection.setOptions({...projection.options,onExitComplete:()=>this.safeToRemove()})),globalProjectionState.hasEverUpdated=!0}getSnapshotBeforeUpdate(prevProps){const{layoutDependency,visualElement,drag:drag2,isPresent}=this.props,projection=visualElement.projection;return projection&&(projection.isPresent=isPresent,drag2||prevProps.layoutDependency!==layoutDependency||layoutDependency===void 0?projection.willUpdate():this.safeToRemove(),prevProps.isPresent!==isPresent&&(isPresent?projection.promote():projection.relegate()||frame.postRender(()=>{const stack=projection.getStack();(!stack||!stack.members.length)&&this.safeToRemove()}))),null}componentDidUpdate(){const{projection}=this.props.visualElement;projection&&(projection.root.didUpdate(),queueMicrotask(()=>{!projection.currentAnimation&&projection.isLead()&&this.safeToRemove()}))}componentWillUnmount(){const{visualElement,layoutGroup,switchLayoutGroup:promoteContext}=this.props,{projection}=visualElement;projection&&(projection.scheduleCheckAfterUnmount(),layoutGroup&&layoutGroup.group&&layoutGroup.group.remove(projection),promoteContext&&promoteContext.deregister&&promoteContext.deregister(projection))}safeToRemove(){const{safeToRemove}=this.props;safeToRemove&&safeToRemove()}render(){return null}}function MeasureLayout(props){const[isPresent,safeToRemove]=usePresence(),layoutGroup=reactExports.useContext(LayoutGroupContext);return u$1.createElement(MeasureLayoutWithContext,{...props,layoutGroup,switchLayoutGroup:reactExports.useContext(SwitchLayoutGroupContext),isPresent,safeToRemove})}const defaultScaleCorrectors={borderRadius:{...correctBorderRadius,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:correctBorderRadius,borderTopRightRadius:correctBorderRadius,borderBottomLeftRadius:correctBorderRadius,borderBottomRightRadius:correctBorderRadius,boxShadow:correctBoxShadow},borders=["TopLeft","TopRight","BottomLeft","BottomRight"],numBorders=borders.length,asNumber=value=>typeof value=="string"?parseFloat(value):value,isPx=value=>typeof value=="number"||px$1.test(value);function mixValues(target,follow,lead,progress2,shouldCrossfadeOpacity,isOnlyMember){shouldCrossfadeOpacity?(target.opacity=mix(0,lead.opacity!==void 0?lead.opacity:1,easeCrossfadeIn(progress2)),target.opacityExit=mix(follow.opacity!==void 0?follow.opacity:1,0,easeCrossfadeOut(progress2))):isOnlyMember&&(target.opacity=mix(follow.opacity!==void 0?follow.opacity:1,lead.opacity!==void 0?lead.opacity:1,progress2));for(let i2=0;i2<numBorders;i2++){const borderLabel=`border${borders[i2]}Radius`;let followRadius=getRadius(follow,borderLabel),leadRadius=getRadius(lead,borderLabel);if(followRadius===void 0&&leadRadius===void 0)continue;followRadius||(followRadius=0),leadRadius||(leadRadius=0),followRadius===0||leadRadius===0||isPx(followRadius)===isPx(leadRadius)?(target[borderLabel]=Math.max(mix(asNumber(followRadius),asNumber(leadRadius),progress2),0),(percent.test(leadRadius)||percent.test(followRadius))&&(target[borderLabel]+="%")):target[borderLabel]=leadRadius}(follow.rotate||lead.rotate)&&(target.rotate=mix(follow.rotate||0,lead.rotate||0,progress2))}function getRadius(values,radiusName){return values[radiusName]!==void 0?values[radiusName]:values.borderRadius}const easeCrossfadeIn=compress(0,.5,circOut),easeCrossfadeOut=compress(.5,.95,noop);function compress(min,max2,easing){return p2=>p2<min?0:p2>max2?1:easing(progress(min,max2,p2))}function copyAxisInto(axis,originAxis){axis.min=originAxis.min,axis.max=originAxis.max}function copyBoxInto(box,originBox){copyAxisInto(box.x,originBox.x),copyAxisInto(box.y,originBox.y)}function removePointDelta(point,translate,scale2,originPoint,boxScale){return point-=translate,point=scalePoint(point,1/scale2,originPoint),boxScale!==void 0&&(point=scalePoint(point,1/boxScale,originPoint)),point}function removeAxisDelta(axis,translate=0,scale2=1,origin=.5,boxScale,originAxis=axis,sourceAxis=axis){if(percent.test(translate)&&(translate=parseFloat(translate),translate=mix(sourceAxis.min,sourceAxis.max,translate/100)-sourceAxis.min),typeof translate!="number")return;let originPoint=mix(originAxis.min,originAxis.max,origin);axis===originAxis&&(originPoint-=translate),axis.min=removePointDelta(axis.min,translate,scale2,originPoint,boxScale),axis.max=removePointDelta(axis.max,translate,scale2,originPoint,boxScale)}function removeAxisTransforms(axis,transforms,[key,scaleKey,originKey],origin,sourceAxis){removeAxisDelta(axis,transforms[key],transforms[scaleKey],transforms[originKey],transforms.scale,origin,sourceAxis)}const xKeys=["x","scaleX","originX"],yKeys=["y","scaleY","originY"];function removeBoxTransforms(box,transforms,originBox,sourceBox){removeAxisTransforms(box.x,transforms,xKeys,originBox?originBox.x:void 0,sourceBox?sourceBox.x:void 0),removeAxisTransforms(box.y,transforms,yKeys,originBox?originBox.y:void 0,sourceBox?sourceBox.y:void 0)}function isAxisDeltaZero(delta){return delta.translate===0&&delta.scale===1}function isDeltaZero(delta){return isAxisDeltaZero(delta.x)&&isAxisDeltaZero(delta.y)}function boxEquals(a2,b2){return a2.x.min===b2.x.min&&a2.x.max===b2.x.max&&a2.y.min===b2.y.min&&a2.y.max===b2.y.max}function boxEqualsRounded(a2,b2){return Math.round(a2.x.min)===Math.round(b2.x.min)&&Math.round(a2.x.max)===Math.round(b2.x.max)&&Math.round(a2.y.min)===Math.round(b2.y.min)&&Math.round(a2.y.max)===Math.round(b2.y.max)}function aspectRatio(box){return calcLength(box.x)/calcLength(box.y)}class NodeStack{constructor(){this.members=[]}add(node){addUniqueItem(this.members,node),node.scheduleRender()}remove(node){if(removeItem(this.members,node),node===this.prevLead&&(this.prevLead=void 0),node===this.lead){const prevLead=this.members[this.members.length-1];prevLead&&this.promote(prevLead)}}relegate(node){const indexOfNode=this.members.findIndex(member=>node===member);if(indexOfNode===0)return!1;let prevLead;for(let i2=indexOfNode;i2>=0;i2--){const member=this.members[i2];if(member.isPresent!==!1){prevLead=member;break}}return prevLead?(this.promote(prevLead),!0):!1}promote(node,preserveFollowOpacity){const prevLead=this.lead;if(node!==prevLead&&(this.prevLead=prevLead,this.lead=node,node.show(),prevLead)){prevLead.instance&&prevLead.scheduleRender(),node.scheduleRender(),node.resumeFrom=prevLead,preserveFollowOpacity&&(node.resumeFrom.preserveOpacity=!0),prevLead.snapshot&&(node.snapshot=prevLead.snapshot,node.snapshot.latestValues=prevLead.animationValues||prevLead.latestValues),node.root&&node.root.isUpdating&&(node.isLayoutDirty=!0);const{crossfade}=node.options;crossfade===!1&&prevLead.hide()}}exitAnimationComplete(){this.members.forEach(node=>{const{options,resumingFrom}=node;options.onExitComplete&&options.onExitComplete(),resumingFrom&&resumingFrom.options.onExitComplete&&resumingFrom.options.onExitComplete()})}scheduleRender(){this.members.forEach(node=>{node.instance&&node.scheduleRender(!1)})}removeLeadSnapshot(){this.lead&&this.lead.snapshot&&(this.lead.snapshot=void 0)}}function buildProjectionTransform(delta,treeScale,latestTransform){let transform="";const xTranslate=delta.x.translate/treeScale.x,yTranslate=delta.y.translate/treeScale.y;if((xTranslate||yTranslate)&&(transform=`translate3d(${xTranslate}px, ${yTranslate}px, 0) `),(treeScale.x!==1||treeScale.y!==1)&&(transform+=`scale(${1/treeScale.x}, ${1/treeScale.y}) `),latestTransform){const{rotate,rotateX,rotateY}=latestTransform;rotate&&(transform+=`rotate(${rotate}deg) `),rotateX&&(transform+=`rotateX(${rotateX}deg) `),rotateY&&(transform+=`rotateY(${rotateY}deg) `)}const elementScaleX=delta.x.scale*treeScale.x,elementScaleY=delta.y.scale*treeScale.y;return(elementScaleX!==1||elementScaleY!==1)&&(transform+=`scale(${elementScaleX}, ${elementScaleY})`),transform||"none"}const compareByDepth=(a2,b2)=>a2.depth-b2.depth;class FlatTree{constructor(){this.children=[],this.isDirty=!1}add(child){addUniqueItem(this.children,child),this.isDirty=!0}remove(child){removeItem(this.children,child),this.isDirty=!0}forEach(callback){this.isDirty&&this.children.sort(compareByDepth),this.isDirty=!1,this.children.forEach(callback)}}function delay(callback,timeout){const start=performance.now(),checkElapsed=({timestamp})=>{const elapsed=timestamp-start;elapsed>=timeout&&(cancelFrame(checkElapsed),callback(elapsed-timeout))};return frame.read(checkElapsed,!0),()=>cancelFrame(checkElapsed)}function record(data){window.MotionDebug&&window.MotionDebug.record(data)}function isSVGElement(element){return element instanceof SVGElement&&element.tagName!=="svg"}function animateSingleValue(value,keyframes2,options){const motionValue$1=isMotionValue(value)?value:motionValue(value);return motionValue$1.start(animateMotionValue("",motionValue$1,keyframes2,options)),motionValue$1.animation}const transformAxes=["","X","Y","Z"],animationTarget=1e3;let id=0;const projectionFrameData={type:"projectionFrame",totalNodes:0,resolvedTargetDeltas:0,recalculatedProjection:0};function createProjectionNode({attachResizeListener,defaultParent,measureScroll,checkIsScrollRoot,resetTransform}){return class{constructor(latestValues={},parent=defaultParent==null?void 0:defaultParent()){this.id=id++,this.animationId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.updateScheduled=!1,this.checkUpdateFailed=()=>{this.isUpdating&&(this.isUpdating=!1,this.clearAllSnapshots())},this.updateProjection=()=>{projectionFrameData.totalNodes=projectionFrameData.resolvedTargetDeltas=projectionFrameData.recalculatedProjection=0,this.nodes.forEach(propagateDirtyNodes),this.nodes.forEach(resolveTargetDelta),this.nodes.forEach(calcProjection),this.nodes.forEach(cleanDirtyNodes),record(projectionFrameData)},this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=latestValues,this.root=parent?parent.root||parent:this,this.path=parent?[...parent.path,parent]:[],this.parent=parent,this.depth=parent?parent.depth+1:0;for(let i2=0;i2<this.path.length;i2++)this.path[i2].shouldResetTransform=!0;this.root===this&&(this.nodes=new FlatTree)}addEventListener(name,handler){return this.eventHandlers.has(name)||this.eventHandlers.set(name,new SubscriptionManager),this.eventHandlers.get(name).add(handler)}notifyListeners(name,...args){const subscriptionManager=this.eventHandlers.get(name);subscriptionManager&&subscriptionManager.notify(...args)}hasListeners(name){return this.eventHandlers.has(name)}mount(instance,isLayoutDirty=this.root.hasTreeAnimated){if(this.instance)return;this.isSVG=isSVGElement(instance),this.instance=instance;const{layoutId,layout:layout2,visualElement}=this.options;if(visualElement&&!visualElement.current&&visualElement.mount(instance),this.root.nodes.add(this),this.parent&&this.parent.children.add(this),isLayoutDirty&&(layout2||layoutId)&&(this.isLayoutDirty=!0),attachResizeListener){let cancelDelay;const resizeUnblockUpdate=()=>this.root.updateBlockedByResize=!1;attachResizeListener(instance,()=>{this.root.updateBlockedByResize=!0,cancelDelay&&cancelDelay(),cancelDelay=delay(resizeUnblockUpdate,250),globalProjectionState.hasAnimatedSinceResize&&(globalProjectionState.hasAnimatedSinceResize=!1,this.nodes.forEach(finishAnimation))})}layoutId&&this.root.registerSharedNode(layoutId,this),this.options.animate!==!1&&visualElement&&(layoutId||layout2)&&this.addEventListener("didUpdate",({delta,hasLayoutChanged,hasRelativeTargetChanged,layout:newLayout})=>{if(this.isTreeAnimationBlocked()){this.target=void 0,this.relativeTarget=void 0;return}const layoutTransition=this.options.transition||visualElement.getDefaultTransition()||defaultLayoutTransition,{onLayoutAnimationStart,onLayoutAnimationComplete}=visualElement.getProps(),targetChanged=!this.targetLayout||!boxEqualsRounded(this.targetLayout,newLayout)||hasRelativeTargetChanged,hasOnlyRelativeTargetChanged=!hasLayoutChanged&&hasRelativeTargetChanged;if(this.options.layoutRoot||this.resumeFrom&&this.resumeFrom.instance||hasOnlyRelativeTargetChanged||hasLayoutChanged&&(targetChanged||!this.currentAnimation)){this.resumeFrom&&(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0),this.setAnimationOrigin(delta,hasOnlyRelativeTargetChanged);const animationOptions={...getValueTransition(layoutTransition,"layout"),onPlay:onLayoutAnimationStart,onComplete:onLayoutAnimationComplete};(visualElement.shouldReduceMotion||this.options.layoutRoot)&&(animationOptions.delay=0,animationOptions.type=!1),this.startAnimation(animationOptions)}else hasLayoutChanged||finishAnimation(this),this.isLead()&&this.options.onExitComplete&&this.options.onExitComplete();this.targetLayout=newLayout})}unmount(){this.options.layoutId&&this.willUpdate(),this.root.nodes.remove(this);const stack=this.getStack();stack&&stack.remove(this),this.parent&&this.parent.children.delete(this),this.instance=void 0,cancelFrame(this.updateProjection)}blockUpdate(){this.updateManuallyBlocked=!0}unblockUpdate(){this.updateManuallyBlocked=!1}isUpdateBlocked(){return this.updateManuallyBlocked||this.updateBlockedByResize}isTreeAnimationBlocked(){return this.isAnimationBlocked||this.parent&&this.parent.isTreeAnimationBlocked()||!1}startUpdate(){this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&&this.nodes.forEach(resetRotation),this.animationId++)}getTransformTemplate(){const{visualElement}=this.options;return visualElement&&visualElement.getProps().transformTemplate}willUpdate(shouldNotifyListeners=!0){if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked()){this.options.onExitComplete&&this.options.onExitComplete();return}if(!this.root.isUpdating&&this.root.startUpdate(),this.isLayoutDirty)return;this.isLayoutDirty=!0;for(let i2=0;i2<this.path.length;i2++){const node=this.path[i2];node.shouldResetTransform=!0,node.updateScroll("snapshot"),node.options.layoutRoot&&node.willUpdate(!1)}const{layoutId,layout:layout2}=this.options;if(layoutId===void 0&&!layout2)return;const transformTemplate=this.getTransformTemplate();this.prevTransformTemplateValue=transformTemplate?transformTemplate(this.latestValues,""):void 0,this.updateSnapshot(),shouldNotifyListeners&&this.notifyListeners("willUpdate")}update(){if(this.updateScheduled=!1,this.isUpdateBlocked()){this.unblockUpdate(),this.clearAllSnapshots(),this.nodes.forEach(clearMeasurements);return}this.isUpdating||this.nodes.forEach(clearIsLayoutDirty),this.isUpdating=!1,this.nodes.forEach(resetTransformStyle),this.nodes.forEach(updateLayout),this.nodes.forEach(notifyLayoutUpdate),this.clearAllSnapshots();const now2=performance.now();frameData.delta=clamp$1(0,1e3/60,now2-frameData.timestamp),frameData.timestamp=now2,frameData.isProcessing=!0,steps.update.process(frameData),steps.preRender.process(frameData),steps.render.process(frameData),frameData.isProcessing=!1}didUpdate(){this.updateScheduled||(this.updateScheduled=!0,queueMicrotask(()=>this.update()))}clearAllSnapshots(){this.nodes.forEach(clearSnapshot),this.sharedNodes.forEach(removeLeadSnapshots)}scheduleUpdateProjection(){frame.preRender(this.updateProjection,!1,!0)}scheduleCheckAfterUnmount(){frame.postRender(()=>{this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()})}updateSnapshot(){this.snapshot||!this.instance||(this.snapshot=this.measure())}updateLayout(){if(!this.instance||(this.updateScroll(),!(this.options.alwaysMeasureLayout&&this.isLead())&&!this.isLayoutDirty))return;if(this.resumeFrom&&!this.resumeFrom.instance)for(let i2=0;i2<this.path.length;i2++)this.path[i2].updateScroll();const prevLayout=this.layout;this.layout=this.measure(!1),this.layoutCorrected=createBox(),this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);const{visualElement}=this.options;visualElement&&visualElement.notify("LayoutMeasure",this.layout.layoutBox,prevLayout?prevLayout.layoutBox:void 0)}updateScroll(phase="measure"){let needsMeasurement=!!(this.options.layoutScroll&&this.instance);this.scroll&&this.scroll.animationId===this.root.animationId&&this.scroll.phase===phase&&(needsMeasurement=!1),needsMeasurement&&(this.scroll={animationId:this.root.animationId,phase,isRoot:checkIsScrollRoot(this.instance),offset:measureScroll(this.instance)})}resetTransform(){if(!resetTransform)return;const isResetRequested=this.isLayoutDirty||this.shouldResetTransform,hasProjection=this.projectionDelta&&!isDeltaZero(this.projectionDelta),transformTemplate=this.getTransformTemplate(),transformTemplateValue=transformTemplate?transformTemplate(this.latestValues,""):void 0,transformTemplateHasChanged=transformTemplateValue!==this.prevTransformTemplateValue;isResetRequested&&(hasProjection||hasTransform(this.latestValues)||transformTemplateHasChanged)&&(resetTransform(this.instance,transformTemplateValue),this.shouldResetTransform=!1,this.scheduleRender())}measure(removeTransform=!0){const pageBox=this.measurePageBox();let layoutBox=this.removeElementScroll(pageBox);return removeTransform&&(layoutBox=this.removeTransform(layoutBox)),roundBox(layoutBox),{animationId:this.root.animationId,measuredBox:pageBox,layoutBox,latestValues:{},source:this.id}}measurePageBox(){const{visualElement}=this.options;if(!visualElement)return createBox();const box=visualElement.measureViewportBox(),{scroll}=this.root;return scroll&&(translateAxis(box.x,scroll.offset.x),translateAxis(box.y,scroll.offset.y)),box}removeElementScroll(box){const boxWithoutScroll=createBox();copyBoxInto(boxWithoutScroll,box);for(let i2=0;i2<this.path.length;i2++){const node=this.path[i2],{scroll,options}=node;if(node!==this.root&&scroll&&options.layoutScroll){if(scroll.isRoot){copyBoxInto(boxWithoutScroll,box);const{scroll:rootScroll}=this.root;rootScroll&&(translateAxis(boxWithoutScroll.x,-rootScroll.offset.x),translateAxis(boxWithoutScroll.y,-rootScroll.offset.y))}translateAxis(boxWithoutScroll.x,scroll.offset.x),translateAxis(boxWithoutScroll.y,scroll.offset.y)}}return boxWithoutScroll}applyTransform(box,transformOnly=!1){const withTransforms=createBox();copyBoxInto(withTransforms,box);for(let i2=0;i2<this.path.length;i2++){const node=this.path[i2];!transformOnly&&node.options.layoutScroll&&node.scroll&&node!==node.root&&transformBox(withTransforms,{x:-node.scroll.offset.x,y:-node.scroll.offset.y}),hasTransform(node.latestValues)&&transformBox(withTransforms,node.latestValues)}return hasTransform(this.latestValues)&&transformBox(withTransforms,this.latestValues),withTransforms}removeTransform(box){const boxWithoutTransform=createBox();copyBoxInto(boxWithoutTransform,box);for(let i2=0;i2<this.path.length;i2++){const node=this.path[i2];if(!node.instance||!hasTransform(node.latestValues))continue;hasScale(node.latestValues)&&node.updateSnapshot();const sourceBox=createBox(),nodeBox=node.measurePageBox();copyBoxInto(sourceBox,nodeBox),removeBoxTransforms(boxWithoutTransform,node.latestValues,node.snapshot?node.snapshot.layoutBox:void 0,sourceBox)}return hasTransform(this.latestValues)&&removeBoxTransforms(boxWithoutTransform,this.latestValues),boxWithoutTransform}setTargetDelta(delta){this.targetDelta=delta,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}setOptions(options){this.options={...this.options,...options,crossfade:options.crossfade!==void 0?options.crossfade:!0}}clearMeasurements(){this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}forceRelativeParentToResolveTarget(){this.relativeParent&&this.relativeParent.resolvedRelativeTargetAt!==frameData.timestamp&&this.relativeParent.resolveTargetDelta(!0)}resolveTargetDelta(forceRecalculation=!1){var _a2;const lead=this.getLead();this.isProjectionDirty||(this.isProjectionDirty=lead.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=lead.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=lead.isSharedProjectionDirty);const isShared=!!this.resumingFrom||this!==lead;if(!(forceRecalculation||isShared&&this.isSharedProjectionDirty||this.isProjectionDirty||!((_a2=this.parent)===null||_a2===void 0)&&_a2.isProjectionDirty||this.attemptToResolveRelativeTarget))return;const{layout:layout2,layoutId}=this.options;if(!(!this.layout||!(layout2||layoutId))){if(this.resolvedRelativeTargetAt=frameData.timestamp,!this.targetDelta&&!this.relativeTarget){const relativeParent=this.getClosestProjectingParent();relativeParent&&relativeParent.layout&&this.animationProgress!==1?(this.relativeParent=relativeParent,this.forceRelativeParentToResolveTarget(),this.relativeTarget=createBox(),this.relativeTargetOrigin=createBox(),calcRelativePosition(this.relativeTargetOrigin,this.layout.layoutBox,relativeParent.layout.layoutBox),copyBoxInto(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}if(!(!this.relativeTarget&&!this.targetDelta)){if(this.target||(this.target=createBox(),this.targetWithTransforms=createBox()),this.relativeTarget&&this.relativeTargetOrigin&&this.relativeParent&&this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),calcRelativeBox(this.target,this.relativeTarget,this.relativeParent.target)):this.targetDelta?(this.resumingFrom?this.target=this.applyTransform(this.layout.layoutBox):copyBoxInto(this.target,this.layout.layoutBox),applyBoxDelta(this.target,this.targetDelta)):copyBoxInto(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget){this.attemptToResolveRelativeTarget=!1;const relativeParent=this.getClosestProjectingParent();relativeParent&&!!relativeParent.resumingFrom==!!this.resumingFrom&&!relativeParent.options.layoutScroll&&relativeParent.target&&this.animationProgress!==1?(this.relativeParent=relativeParent,this.forceRelativeParentToResolveTarget(),this.relativeTarget=createBox(),this.relativeTargetOrigin=createBox(),calcRelativePosition(this.relativeTargetOrigin,this.target,relativeParent.target),copyBoxInto(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}projectionFrameData.resolvedTargetDeltas++}}}getClosestProjectingParent(){if(!(!this.parent||hasScale(this.parent.latestValues)||has2DTranslate(this.parent.latestValues)))return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}isProjecting(){return!!((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&&this.layout)}calcProjection(){var _a2;const lead=this.getLead(),isShared=!!this.resumingFrom||this!==lead;let canSkip=!0;if((this.isProjectionDirty||!((_a2=this.parent)===null||_a2===void 0)&&_a2.isProjectionDirty)&&(canSkip=!1),isShared&&(this.isSharedProjectionDirty||this.isTransformDirty)&&(canSkip=!1),this.resolvedRelativeTargetAt===frameData.timestamp&&(canSkip=!1),canSkip)return;const{layout:layout2,layoutId}=this.options;if(this.isTreeAnimating=!!(this.parent&&this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!(layout2||layoutId))return;copyBoxInto(this.layoutCorrected,this.layout.layoutBox);const prevTreeScaleX=this.treeScale.x,prevTreeScaleY=this.treeScale.y;applyTreeDeltas(this.layoutCorrected,this.treeScale,this.path,isShared),lead.layout&&!lead.target&&(this.treeScale.x!==1||this.treeScale.y!==1)&&(lead.target=lead.layout.layoutBox);const{target}=lead;if(!target){this.projectionTransform&&(this.projectionDelta=createDelta(),this.projectionTransform="none",this.scheduleRender());return}this.projectionDelta||(this.projectionDelta=createDelta(),this.projectionDeltaWithTransform=createDelta());const prevProjectionTransform=this.projectionTransform;calcBoxDelta(this.projectionDelta,this.layoutCorrected,target,this.latestValues),this.projectionTransform=buildProjectionTransform(this.projectionDelta,this.treeScale),(this.projectionTransform!==prevProjectionTransform||this.treeScale.x!==prevTreeScaleX||this.treeScale.y!==prevTreeScaleY)&&(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",target)),projectionFrameData.recalculatedProjection++}hide(){this.isVisible=!1}show(){this.isVisible=!0}scheduleRender(notifyAll=!0){if(this.options.scheduleRender&&this.options.scheduleRender(),notifyAll){const stack=this.getStack();stack&&stack.scheduleRender()}this.resumingFrom&&!this.resumingFrom.instance&&(this.resumingFrom=void 0)}setAnimationOrigin(delta,hasOnlyRelativeTargetChanged=!1){const snapshot=this.snapshot,snapshotLatestValues=snapshot?snapshot.latestValues:{},mixedValues={...this.latestValues},targetDelta=createDelta();(!this.relativeParent||!this.relativeParent.options.layoutRoot)&&(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!hasOnlyRelativeTargetChanged;const relativeLayout=createBox(),snapshotSource=snapshot?snapshot.source:void 0,layoutSource=this.layout?this.layout.source:void 0,isSharedLayoutAnimation=snapshotSource!==layoutSource,stack=this.getStack(),isOnlyMember=!stack||stack.members.length<=1,shouldCrossfadeOpacity=!!(isSharedLayoutAnimation&&!isOnlyMember&&this.options.crossfade===!0&&!this.path.some(hasOpacityCrossfade));this.animationProgress=0;let prevRelativeTarget;this.mixTargetDelta=latest=>{const progress2=latest/1e3;mixAxisDelta(targetDelta.x,delta.x,progress2),mixAxisDelta(targetDelta.y,delta.y,progress2),this.setTargetDelta(targetDelta),this.relativeTarget&&this.relativeTargetOrigin&&this.layout&&this.relativeParent&&this.relativeParent.layout&&(calcRelativePosition(relativeLayout,this.layout.layoutBox,this.relativeParent.layout.layoutBox),mixBox(this.relativeTarget,this.relativeTargetOrigin,relativeLayout,progress2),prevRelativeTarget&&boxEquals(this.relativeTarget,prevRelativeTarget)&&(this.isProjectionDirty=!1),prevRelativeTarget||(prevRelativeTarget=createBox()),copyBoxInto(prevRelativeTarget,this.relativeTarget)),isSharedLayoutAnimation&&(this.animationValues=mixedValues,mixValues(mixedValues,snapshotLatestValues,this.latestValues,progress2,shouldCrossfadeOpacity,isOnlyMember)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=progress2},this.mixTargetDelta(this.options.layoutRoot?1e3:0)}startAnimation(options){this.notifyListeners("animationStart"),this.currentAnimation&&this.currentAnimation.stop(),this.resumingFrom&&this.resumingFrom.currentAnimation&&this.resumingFrom.currentAnimation.stop(),this.pendingAnimation&&(cancelFrame(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=frame.update(()=>{globalProjectionState.hasAnimatedSinceResize=!0,this.currentAnimation=animateSingleValue(0,animationTarget,{...options,onUpdate:latest=>{this.mixTargetDelta(latest),options.onUpdate&&options.onUpdate(latest)},onComplete:()=>{options.onComplete&&options.onComplete(),this.completeAnimation()}}),this.resumingFrom&&(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0})}completeAnimation(){this.resumingFrom&&(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);const stack=this.getStack();stack&&stack.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}finishAnimation(){this.currentAnimation&&(this.mixTargetDelta&&this.mixTargetDelta(animationTarget),this.currentAnimation.stop()),this.completeAnimation()}applyTransformsToTarget(){const lead=this.getLead();let{targetWithTransforms,target,layout:layout2,latestValues}=lead;if(!(!targetWithTransforms||!target||!layout2)){if(this!==lead&&this.layout&&layout2&&shouldAnimatePositionOnly(this.options.animationType,this.layout.layoutBox,layout2.layoutBox)){target=this.target||createBox();const xLength=calcLength(this.layout.layoutBox.x);target.x.min=lead.target.x.min,target.x.max=target.x.min+xLength;const yLength=calcLength(this.layout.layoutBox.y);target.y.min=lead.target.y.min,target.y.max=target.y.min+yLength}copyBoxInto(targetWithTransforms,target),transformBox(targetWithTransforms,latestValues),calcBoxDelta(this.projectionDeltaWithTransform,this.layoutCorrected,targetWithTransforms,latestValues)}}registerSharedNode(layoutId,node){this.sharedNodes.has(layoutId)||this.sharedNodes.set(layoutId,new NodeStack),this.sharedNodes.get(layoutId).add(node);const config=node.options.initialPromotionConfig;node.promote({transition:config?config.transition:void 0,preserveFollowOpacity:config&&config.shouldPreserveFollowOpacity?config.shouldPreserveFollowOpacity(node):void 0})}isLead(){const stack=this.getStack();return stack?stack.lead===this:!0}getLead(){var _a2;const{layoutId}=this.options;return layoutId?((_a2=this.getStack())===null||_a2===void 0?void 0:_a2.lead)||this:this}getPrevLead(){var _a2;const{layoutId}=this.options;return layoutId?(_a2=this.getStack())===null||_a2===void 0?void 0:_a2.prevLead:void 0}getStack(){const{layoutId}=this.options;if(layoutId)return this.root.sharedNodes.get(layoutId)}promote({needsReset,transition,preserveFollowOpacity}={}){const stack=this.getStack();stack&&stack.promote(this,preserveFollowOpacity),needsReset&&(this.projectionDelta=void 0,this.needsReset=!0),transition&&this.setOptions({transition})}relegate(){const stack=this.getStack();return stack?stack.relegate(this):!1}resetRotation(){const{visualElement}=this.options;if(!visualElement)return;let hasRotate=!1;const{latestValues}=visualElement;if((latestValues.rotate||latestValues.rotateX||latestValues.rotateY||latestValues.rotateZ)&&(hasRotate=!0),!hasRotate)return;const resetValues={};for(let i2=0;i2<transformAxes.length;i2++){const key="rotate"+transformAxes[i2];latestValues[key]&&(resetValues[key]=latestValues[key],visualElement.setStaticValue(key,0))}visualElement.render();for(const key in resetValues)visualElement.setStaticValue(key,resetValues[key]);visualElement.scheduleRender()}getProjectionStyles(styleProp={}){var _a2,_b2;const styles={};if(!this.instance||this.isSVG)return styles;if(this.isVisible)styles.visibility="";else return{visibility:"hidden"};const transformTemplate=this.getTransformTemplate();if(this.needsReset)return this.needsReset=!1,styles.opacity="",styles.pointerEvents=resolveMotionValue(styleProp.pointerEvents)||"",styles.transform=transformTemplate?transformTemplate(this.latestValues,""):"none",styles;const lead=this.getLead();if(!this.projectionDelta||!this.layout||!lead.target){const emptyStyles={};return this.options.layoutId&&(emptyStyles.opacity=this.latestValues.opacity!==void 0?this.latestValues.opacity:1,emptyStyles.pointerEvents=resolveMotionValue(styleProp.pointerEvents)||""),this.hasProjected&&!hasTransform(this.latestValues)&&(emptyStyles.transform=transformTemplate?transformTemplate({},""):"none",this.hasProjected=!1),emptyStyles}const valuesToRender=lead.animationValues||lead.latestValues;this.applyTransformsToTarget(),styles.transform=buildProjectionTransform(this.projectionDeltaWithTransform,this.treeScale,valuesToRender),transformTemplate&&(styles.transform=transformTemplate(valuesToRender,styles.transform));const{x:x2,y:y2}=this.projectionDelta;styles.transformOrigin=`${x2.origin*100}% ${y2.origin*100}% 0`,lead.animationValues?styles.opacity=lead===this?(_b2=(_a2=valuesToRender.opacity)!==null&&_a2!==void 0?_a2:this.latestValues.opacity)!==null&&_b2!==void 0?_b2:1:this.preserveOpacity?this.latestValues.opacity:valuesToRender.opacityExit:styles.opacity=lead===this?valuesToRender.opacity!==void 0?valuesToRender.opacity:"":valuesToRender.opacityExit!==void 0?valuesToRender.opacityExit:0;for(const key in scaleCorrectors){if(valuesToRender[key]===void 0)continue;const{correct,applyTo}=scaleCorrectors[key],corrected=styles.transform==="none"?valuesToRender[key]:correct(valuesToRender[key],lead);if(applyTo){const num=applyTo.length;for(let i2=0;i2<num;i2++)styles[applyTo[i2]]=corrected}else styles[key]=corrected}return this.options.layoutId&&(styles.pointerEvents=lead===this?resolveMotionValue(styleProp.pointerEvents)||"":"none"),styles}clearSnapshot(){this.resumeFrom=this.snapshot=void 0}resetTree(){this.root.nodes.forEach(node=>{var _a2;return(_a2=node.currentAnimation)===null||_a2===void 0?void 0:_a2.stop()}),this.root.nodes.forEach(clearMeasurements),this.root.sharedNodes.clear()}}}function updateLayout(node){node.updateLayout()}function notifyLayoutUpdate(node){var _a2;const snapshot=((_a2=node.resumeFrom)===null||_a2===void 0?void 0:_a2.snapshot)||node.snapshot;if(node.isLead()&&node.layout&&snapshot&&node.hasListeners("didUpdate")){const{layoutBox:layout2,measuredBox:measuredLayout}=node.layout,{animationType}=node.options,isShared=snapshot.source!==node.layout.source;animationType==="size"?eachAxis(axis=>{const axisSnapshot=isShared?snapshot.measuredBox[axis]:snapshot.layoutBox[axis],length=calcLength(axisSnapshot);axisSnapshot.min=layout2[axis].min,axisSnapshot.max=axisSnapshot.min+length}):shouldAnimatePositionOnly(animationType,snapshot.layoutBox,layout2)&&eachAxis(axis=>{const axisSnapshot=isShared?snapshot.measuredBox[axis]:snapshot.layoutBox[axis],length=calcLength(layout2[axis]);axisSnapshot.max=axisSnapshot.min+length,node.relativeTarget&&!node.currentAnimation&&(node.isProjectionDirty=!0,node.relativeTarget[axis].max=node.relativeTarget[axis].min+length)});const layoutDelta=createDelta();calcBoxDelta(layoutDelta,layout2,snapshot.layoutBox);const visualDelta=createDelta();isShared?calcBoxDelta(visualDelta,node.applyTransform(measuredLayout,!0),snapshot.measuredBox):calcBoxDelta(visualDelta,layout2,snapshot.layoutBox);const hasLayoutChanged=!isDeltaZero(layoutDelta);let hasRelativeTargetChanged=!1;if(!node.resumeFrom){const relativeParent=node.getClosestProjectingParent();if(relativeParent&&!relativeParent.resumeFrom){const{snapshot:parentSnapshot,layout:parentLayout}=relativeParent;if(parentSnapshot&&parentLayout){const relativeSnapshot=createBox();calcRelativePosition(relativeSnapshot,snapshot.layoutBox,parentSnapshot.layoutBox);const relativeLayout=createBox();calcRelativePosition(relativeLayout,layout2,parentLayout.layoutBox),boxEqualsRounded(relativeSnapshot,relativeLayout)||(hasRelativeTargetChanged=!0),relativeParent.options.layoutRoot&&(node.relativeTarget=relativeLayout,node.relativeTargetOrigin=relativeSnapshot,node.relativeParent=relativeParent)}}}node.notifyListeners("didUpdate",{layout:layout2,snapshot,delta:visualDelta,layoutDelta,hasLayoutChanged,hasRelativeTargetChanged})}else if(node.isLead()){const{onExitComplete}=node.options;onExitComplete&&onExitComplete()}node.options.transition=void 0}function propagateDirtyNodes(node){projectionFrameData.totalNodes++,node.parent&&(node.isProjecting()||(node.isProjectionDirty=node.parent.isProjectionDirty),node.isSharedProjectionDirty||(node.isSharedProjectionDirty=!!(node.isProjectionDirty||node.parent.isProjectionDirty||node.parent.isSharedProjectionDirty)),node.isTransformDirty||(node.isTransformDirty=node.parent.isTransformDirty))}function cleanDirtyNodes(node){node.isProjectionDirty=node.isSharedProjectionDirty=node.isTransformDirty=!1}function clearSnapshot(node){node.clearSnapshot()}function clearMeasurements(node){node.clearMeasurements()}function clearIsLayoutDirty(node){node.isLayoutDirty=!1}function resetTransformStyle(node){const{visualElement}=node.options;visualElement&&visualElement.getProps().onBeforeLayoutMeasure&&visualElement.notify("BeforeLayoutMeasure"),node.resetTransform()}function finishAnimation(node){node.finishAnimation(),node.targetDelta=node.relativeTarget=node.target=void 0,node.isProjectionDirty=!0}function resolveTargetDelta(node){node.resolveTargetDelta()}function calcProjection(node){node.calcProjection()}function resetRotation(node){node.resetRotation()}function removeLeadSnapshots(stack){stack.removeLeadSnapshot()}function mixAxisDelta(output,delta,p2){output.translate=mix(delta.translate,0,p2),output.scale=mix(delta.scale,1,p2),output.origin=delta.origin,output.originPoint=delta.originPoint}function mixAxis(output,from,to,p2){output.min=mix(from.min,to.min,p2),output.max=mix(from.max,to.max,p2)}function mixBox(output,from,to,p2){mixAxis(output.x,from.x,to.x,p2),mixAxis(output.y,from.y,to.y,p2)}function hasOpacityCrossfade(node){return node.animationValues&&node.animationValues.opacityExit!==void 0}const defaultLayoutTransition={duration:.45,ease:[.4,0,.1,1]},userAgentContains=string=>typeof navigator<"u"&&navigator.userAgent.toLowerCase().includes(string),roundPoint=userAgentContains("applewebkit/")&&!userAgentContains("chrome/")?Math.round:noop;function roundAxis(axis){axis.min=roundPoint(axis.min),axis.max=roundPoint(axis.max)}function roundBox(box){roundAxis(box.x),roundAxis(box.y)}function shouldAnimatePositionOnly(animationType,snapshot,layout2){return animationType==="position"||animationType==="preserve-aspect"&&!isNear(aspectRatio(snapshot),aspectRatio(layout2),.2)}const DocumentProjectionNode=createProjectionNode({attachResizeListener:(ref,notify)=>addDomEvent(ref,"resize",notify),measureScroll:()=>({x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop}),checkIsScrollRoot:()=>!0}),rootProjectionNode={current:void 0},HTMLProjectionNode=createProjectionNode({measureScroll:instance=>({x:instance.scrollLeft,y:instance.scrollTop}),defaultParent:()=>{if(!rootProjectionNode.current){const documentNode=new DocumentProjectionNode({});documentNode.mount(window),documentNode.setOptions({layoutScroll:!0}),rootProjectionNode.current=documentNode}return rootProjectionNode.current},resetTransform:(instance,value)=>{instance.style.transform=value!==void 0?value:"none"},checkIsScrollRoot:instance=>window.getComputedStyle(instance).position==="fixed"}),drag={pan:{Feature:PanGesture},drag:{Feature:DragGesture,ProjectionNode:HTMLProjectionNode,MeasureLayout}},splitCSSVariableRegex=/var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;function parseCSSVariable(current){const match=splitCSSVariableRegex.exec(current);if(!match)return[,];const[,token,fallback]=match;return[token,fallback]}const maxDepth=4;function getVariableValue(current,element,depth=1){invariant(depth<=maxDepth,`Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);const[token,fallback]=parseCSSVariable(current);if(!token)return;const resolved=window.getComputedStyle(element).getPropertyValue(token);if(resolved){const trimmed=resolved.trim();return isNumericalString(trimmed)?parseFloat(trimmed):trimmed}else return isCSSVariableToken(fallback)?getVariableValue(fallback,element,depth+1):fallback}function resolveCSSVariables(visualElement,{...target},transitionEnd){const element=visualElement.current;if(!(element instanceof Element))return{target,transitionEnd};transitionEnd&&(transitionEnd={...transitionEnd}),visualElement.values.forEach(value=>{const current=value.get();if(!isCSSVariableToken(current))return;const resolved=getVariableValue(current,element);resolved&&value.set(resolved)});for(const key in target){const current=target[key];if(!isCSSVariableToken(current))continue;const resolved=getVariableValue(current,element);resolved&&(target[key]=resolved,transitionEnd||(transitionEnd={}),transitionEnd[key]===void 0&&(transitionEnd[key]=current))}return{target,transitionEnd}}const positionalKeys=new Set(["width","height","top","left","right","bottom","x","y","translateX","translateY"]),isPositionalKey=key=>positionalKeys.has(key),hasPositionalKey=target=>Object.keys(target).some(isPositionalKey),isNumOrPxType=v4=>v4===number||v4===px$1,getPosFromMatrix=(matrix,pos)=>parseFloat(matrix.split(", ")[pos]),getTranslateFromMatrix=(pos2,pos3)=>(_bbox,{transform})=>{if(transform==="none"||!transform)return 0;const matrix3d=transform.match(/^matrix3d\((.+)\)$/);if(matrix3d)return getPosFromMatrix(matrix3d[1],pos3);{const matrix=transform.match(/^matrix\((.+)\)$/);return matrix?getPosFromMatrix(matrix[1],pos2):0}},transformKeys=new Set(["x","y","z"]),nonTranslationalTransformKeys=transformPropOrder.filter(key=>!transformKeys.has(key));function removeNonTranslationalTransform(visualElement){const removedTransforms=[];return nonTranslationalTransformKeys.forEach(key=>{const value=visualElement.getValue(key);value!==void 0&&(removedTransforms.push([key,value.get()]),value.set(key.startsWith("scale")?1:0))}),removedTransforms.length&&visualElement.render(),removedTransforms}const positionalValues={width:({x:x2},{paddingLeft="0",paddingRight="0"})=>x2.max-x2.min-parseFloat(paddingLeft)-parseFloat(paddingRight),height:({y:y2},{paddingTop="0",paddingBottom="0"})=>y2.max-y2.min-parseFloat(paddingTop)-parseFloat(paddingBottom),top:(_bbox,{top})=>parseFloat(top),left:(_bbox,{left})=>parseFloat(left),bottom:({y:y2},{top})=>parseFloat(top)+(y2.max-y2.min),right:({x:x2},{left})=>parseFloat(left)+(x2.max-x2.min),x:getTranslateFromMatrix(4,13),y:getTranslateFromMatrix(5,14)};positionalValues.translateX=positionalValues.x;positionalValues.translateY=positionalValues.y;const convertChangedValueTypes=(target,visualElement,changedKeys)=>{const originBbox=visualElement.measureViewportBox(),element=visualElement.current,elementComputedStyle=getComputedStyle(element),{display}=elementComputedStyle,origin={};display==="none"&&visualElement.setStaticValue("display",target.display||"block"),changedKeys.forEach(key=>{origin[key]=positionalValues[key](originBbox,elementComputedStyle)}),visualElement.render();const targetBbox=visualElement.measureViewportBox();return changedKeys.forEach(key=>{const value=visualElement.getValue(key);value&&value.jump(origin[key]),target[key]=positionalValues[key](targetBbox,elementComputedStyle)}),target},checkAndConvertChangedValueTypes=(visualElement,target,origin={},transitionEnd={})=>{target={...target},transitionEnd={...transitionEnd};const targetPositionalKeys=Object.keys(target).filter(isPositionalKey);let removedTransformValues=[],hasAttemptedToRemoveTransformValues=!1;const changedValueTypeKeys=[];if(targetPositionalKeys.forEach(key=>{const value=visualElement.getValue(key);if(!visualElement.hasValue(key))return;let from=origin[key],fromType=findDimensionValueType(from);const to=target[key];let toType;if(isKeyframesTarget(to)){const numKeyframes=to.length,fromIndex=to[0]===null?1:0;from=to[fromIndex],fromType=findDimensionValueType(from);for(let i2=fromIndex;i2<numKeyframes&&to[i2]!==null;i2++)toType?invariant(findDimensionValueType(to[i2])===toType,"All keyframes must be of the same type"):(toType=findDimensionValueType(to[i2]),invariant(toType===fromType||isNumOrPxType(fromType)&&isNumOrPxType(toType),"Keyframes must be of the same dimension as the current value"))}else toType=findDimensionValueType(to);if(fromType!==toType)if(isNumOrPxType(fromType)&&isNumOrPxType(toType)){const current=value.get();typeof current=="string"&&value.set(parseFloat(current)),typeof to=="string"?target[key]=parseFloat(to):Array.isArray(to)&&toType===px$1&&(target[key]=to.map(parseFloat))}else fromType!=null&&fromType.transform&&(toType!=null&&toType.transform)&&(from===0||to===0)?from===0?value.set(toType.transform(from)):target[key]=fromType.transform(to):(hasAttemptedToRemoveTransformValues||(removedTransformValues=removeNonTranslationalTransform(visualElement),hasAttemptedToRemoveTransformValues=!0),changedValueTypeKeys.push(key),transitionEnd[key]=transitionEnd[key]!==void 0?transitionEnd[key]:target[key],value.jump(to))}),changedValueTypeKeys.length){const scrollY=changedValueTypeKeys.indexOf("height")>=0?window.pageYOffset:null,convertedTarget=convertChangedValueTypes(target,visualElement,changedValueTypeKeys);return removedTransformValues.length&&removedTransformValues.forEach(([key,value])=>{visualElement.getValue(key).set(value)}),visualElement.render(),isBrowser&&scrollY!==null&&window.scrollTo({top:scrollY}),{target:convertedTarget,transitionEnd}}else return{target,transitionEnd}};function unitConversion(visualElement,target,origin,transitionEnd){return hasPositionalKey(target)?checkAndConvertChangedValueTypes(visualElement,target,origin,transitionEnd):{target,transitionEnd}}const parseDomVariant=(visualElement,target,origin,transitionEnd)=>{const resolved=resolveCSSVariables(visualElement,target,transitionEnd);return target=resolved.target,transitionEnd=resolved.transitionEnd,unitConversion(visualElement,target,origin,transitionEnd)},prefersReducedMotion={current:null},hasReducedMotionListener={current:!1};function initPrefersReducedMotion(){if(hasReducedMotionListener.current=!0,!!isBrowser)if(window.matchMedia){const motionMediaQuery=window.matchMedia("(prefers-reduced-motion)"),setReducedMotionPreferences=()=>prefersReducedMotion.current=motionMediaQuery.matches;motionMediaQuery.addListener(setReducedMotionPreferences),setReducedMotionPreferences()}else prefersReducedMotion.current=!1}function updateMotionValuesFromProps(element,next,prev){const{willChange}=next;for(const key in next){const nextValue=next[key],prevValue=prev[key];if(isMotionValue(nextValue))element.addValue(key,nextValue),isWillChangeMotionValue(willChange)&&willChange.add(key),warnOnce$1(nextValue.version==="10.16.5",`Attempting to mix Framer Motion versions ${nextValue.version} with 10.16.5 may not work as expected.`);else if(isMotionValue(prevValue))element.addValue(key,motionValue(nextValue,{owner:element})),isWillChangeMotionValue(willChange)&&willChange.remove(key);else if(prevValue!==nextValue)if(element.hasValue(key)){const existingValue=element.getValue(key);!existingValue.hasAnimated&&existingValue.set(nextValue)}else{const latestValue=element.getStaticValue(key);element.addValue(key,motionValue(latestValue!==void 0?latestValue:nextValue,{owner:element}))}}for(const key in prev)next[key]===void 0&&element.removeValue(key);return next}const visualElementStore=new WeakMap,featureNames=Object.keys(featureDefinitions),numFeatures=featureNames.length,propEventHandlers=["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"],numVariantProps=variantProps.length;class VisualElement{constructor({parent,props,presenceContext,reducedMotionConfig,visualState},options={}){this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=()=>this.notify("Update",this.latestValues),this.render=()=>{this.current&&(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))},this.scheduleRender=()=>frame.render(this.render,!1,!0);const{latestValues,renderState}=visualState;this.latestValues=latestValues,this.baseTarget={...latestValues},this.initialValues=props.initial?{...latestValues}:{},this.renderState=renderState,this.parent=parent,this.props=props,this.presenceContext=presenceContext,this.depth=parent?parent.depth+1:0,this.reducedMotionConfig=reducedMotionConfig,this.options=options,this.isControllingVariants=isControllingVariants(props),this.isVariantNode=isVariantNode(props),this.isVariantNode&&(this.variantChildren=new Set),this.manuallyAnimateOnMount=!!(parent&&parent.current);const{willChange,...initialMotionValues}=this.scrapeMotionValuesFromProps(props,{});for(const key in initialMotionValues){const value=initialMotionValues[key];latestValues[key]!==void 0&&isMotionValue(value)&&(value.set(latestValues[key],!1),isWillChangeMotionValue(willChange)&&willChange.add(key))}}scrapeMotionValuesFromProps(_props,_prevProps){return{}}mount(instance){this.current=instance,visualElementStore.set(instance,this),this.projection&&!this.projection.instance&&this.projection.mount(instance),this.parent&&this.isVariantNode&&!this.isControllingVariants&&(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((value,key)=>this.bindToMotionValue(key,value)),hasReducedMotionListener.current||initPrefersReducedMotion(),this.shouldReduceMotion=this.reducedMotionConfig==="never"?!1:this.reducedMotionConfig==="always"?!0:prefersReducedMotion.current,warnOnce$1(this.shouldReduceMotion!==!0,"You have Reduced Motion enabled on your device. Animations may not appear as expected."),this.parent&&this.parent.children.add(this),this.update(this.props,this.presenceContext)}unmount(){visualElementStore.delete(this.current),this.projection&&this.projection.unmount(),cancelFrame(this.notifyUpdate),cancelFrame(this.render),this.valueSubscriptions.forEach(remove=>remove()),this.removeFromVariantTree&&this.removeFromVariantTree(),this.parent&&this.parent.children.delete(this);for(const key in this.events)this.events[key].clear();for(const key in this.features)this.features[key].unmount();this.current=null}bindToMotionValue(key,value){const valueIsTransform=transformProps.has(key),removeOnChange=value.on("change",latestValue=>{this.latestValues[key]=latestValue,this.props.onUpdate&&frame.update(this.notifyUpdate,!1,!0),valueIsTransform&&this.projection&&(this.projection.isTransformDirty=!0)}),removeOnRenderRequest=value.on("renderRequest",this.scheduleRender);this.valueSubscriptions.set(key,()=>{removeOnChange(),removeOnRenderRequest()})}sortNodePosition(other){return!this.current||!this.sortInstanceNodePosition||this.type!==other.type?0:this.sortInstanceNodePosition(this.current,other.current)}loadFeatures({children,...renderedProps},isStrict,preloadedFeatures2,initialLayoutGroupConfig){let ProjectionNodeConstructor,MeasureLayout2;if(preloadedFeatures2&&isStrict){const strictMessage="You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";renderedProps.ignoreStrict?warning(!1,strictMessage):invariant(!1,strictMessage)}for(let i2=0;i2<numFeatures;i2++){const name=featureNames[i2],{isEnabled,Feature:FeatureConstructor,ProjectionNode,MeasureLayout:MeasureLayoutComponent}=featureDefinitions[name];ProjectionNode&&(ProjectionNodeConstructor=ProjectionNode),isEnabled(renderedProps)&&(!this.features[name]&&FeatureConstructor&&(this.features[name]=new FeatureConstructor(this)),MeasureLayoutComponent&&(MeasureLayout2=MeasureLayoutComponent))}if(!this.projection&&ProjectionNodeConstructor){this.projection=new ProjectionNodeConstructor(this.latestValues,this.parent&&this.parent.projection);const{layoutId,layout:layout2,drag:drag2,dragConstraints,layoutScroll,layoutRoot}=renderedProps;this.projection.setOptions({layoutId,layout:layout2,alwaysMeasureLayout:!!drag2||dragConstraints&&isRefObject$1(dragConstraints),visualElement:this,scheduleRender:()=>this.scheduleRender(),animationType:typeof layout2=="string"?layout2:"both",initialPromotionConfig:initialLayoutGroupConfig,layoutScroll,layoutRoot})}return MeasureLayout2}updateFeatures(){for(const key in this.features){const feature=this.features[key];feature.isMounted?feature.update():(feature.mount(),feature.isMounted=!0)}}triggerBuild(){this.build(this.renderState,this.latestValues,this.options,this.props)}measureViewportBox(){return this.current?this.measureInstanceViewportBox(this.current,this.props):createBox()}getStaticValue(key){return this.latestValues[key]}setStaticValue(key,value){this.latestValues[key]=value}makeTargetAnimatable(target,canMutate=!0){return this.makeTargetAnimatableFromInstance(target,this.props,canMutate)}update(props,presenceContext){(props.transformTemplate||this.props.transformTemplate)&&this.scheduleRender(),this.prevProps=this.props,this.props=props,this.prevPresenceContext=this.presenceContext,this.presenceContext=presenceContext;for(let i2=0;i2<propEventHandlers.length;i2++){const key=propEventHandlers[i2];this.propEventSubscriptions[key]&&(this.propEventSubscriptions[key](),delete this.propEventSubscriptions[key]);const listener=props["on"+key];listener&&(this.propEventSubscriptions[key]=this.on(key,listener))}this.prevMotionValues=updateMotionValuesFromProps(this,this.scrapeMotionValuesFromProps(props,this.prevProps),this.prevMotionValues),this.handleChildMotionValue&&this.handleChildMotionValue()}getProps(){return this.props}getVariant(name){return this.props.variants?this.props.variants[name]:void 0}getDefaultTransition(){return this.props.transition}getTransformPagePoint(){return this.props.transformPagePoint}getClosestVariantNode(){return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}getVariantContext(startAtParent=!1){if(startAtParent)return this.parent?this.parent.getVariantContext():void 0;if(!this.isControllingVariants){const context3=this.parent?this.parent.getVariantContext()||{}:{};return this.props.initial!==void 0&&(context3.initial=this.props.initial),context3}const context2={};for(let i2=0;i2<numVariantProps;i2++){const name=variantProps[i2],prop=this.props[name];(isVariantLabel(prop)||prop===!1)&&(context2[name]=prop)}return context2}addVariantChild(child){const closestVariantNode=this.getClosestVariantNode();if(closestVariantNode)return closestVariantNode.variantChildren&&closestVariantNode.variantChildren.add(child),()=>closestVariantNode.variantChildren.delete(child)}addValue(key,value){value!==this.values.get(key)&&(this.removeValue(key),this.bindToMotionValue(key,value)),this.values.set(key,value),this.latestValues[key]=value.get()}removeValue(key){this.values.delete(key);const unsubscribe=this.valueSubscriptions.get(key);unsubscribe&&(unsubscribe(),this.valueSubscriptions.delete(key)),delete this.latestValues[key],this.removeValueFromRenderState(key,this.renderState)}hasValue(key){return this.values.has(key)}getValue(key,defaultValue){if(this.props.values&&this.props.values[key])return this.props.values[key];let value=this.values.get(key);return value===void 0&&defaultValue!==void 0&&(value=motionValue(defaultValue,{owner:this}),this.addValue(key,value)),value}readValue(key){var _a2;return this.latestValues[key]!==void 0||!this.current?this.latestValues[key]:(_a2=this.getBaseTargetFromProps(this.props,key))!==null&&_a2!==void 0?_a2:this.readValueFromInstance(this.current,key,this.options)}setBaseTarget(key,value){this.baseTarget[key]=value}getBaseTarget(key){var _a2;const{initial}=this.props,valueFromInitial=typeof initial=="string"||typeof initial=="object"?(_a2=resolveVariantFromProps(this.props,initial))===null||_a2===void 0?void 0:_a2[key]:void 0;if(initial&&valueFromInitial!==void 0)return valueFromInitial;const target=this.getBaseTargetFromProps(this.props,key);return target!==void 0&&!isMotionValue(target)?target:this.initialValues[key]!==void 0&&valueFromInitial===void 0?void 0:this.baseTarget[key]}on(eventName,callback){return this.events[eventName]||(this.events[eventName]=new SubscriptionManager),this.events[eventName].add(callback)}notify(eventName,...args){this.events[eventName]&&this.events[eventName].notify(...args)}}class DOMVisualElement extends VisualElement{sortInstanceNodePosition(a2,b2){return a2.compareDocumentPosition(b2)&2?1:-1}getBaseTargetFromProps(props,key){return props.style?props.style[key]:void 0}removeValueFromRenderState(key,{vars,style}){delete vars[key],delete style[key]}makeTargetAnimatableFromInstance({transition,transitionEnd,...target},{transformValues},isMounted){let origin=getOrigin(target,transition||{},this);if(transformValues&&(transitionEnd&&(transitionEnd=transformValues(transitionEnd)),target&&(target=transformValues(target)),origin&&(origin=transformValues(origin))),isMounted){checkTargetForNewValues(this,target,origin);const parsed=parseDomVariant(this,target,origin,transitionEnd);transitionEnd=parsed.transitionEnd,target=parsed.target}return{transition,transitionEnd,...target}}}function getComputedStyle$1(element){return window.getComputedStyle(element)}class HTMLVisualElement extends DOMVisualElement{readValueFromInstance(instance,key){if(transformProps.has(key)){const defaultType=getDefaultValueType(key);return defaultType&&defaultType.default||0}else{const computedStyle=getComputedStyle$1(instance),value=(isCSSVariableName(key)?computedStyle.getPropertyValue(key):computedStyle[key])||0;return typeof value=="string"?value.trim():value}}measureInstanceViewportBox(instance,{transformPagePoint}){return measureViewportBox(instance,transformPagePoint)}build(renderState,latestValues,options,props){buildHTMLStyles(renderState,latestValues,options,props.transformTemplate)}scrapeMotionValuesFromProps(props,prevProps){return scrapeMotionValuesFromProps$1(props,prevProps)}handleChildMotionValue(){this.childSubscription&&(this.childSubscription(),delete this.childSubscription);const{children}=this.props;isMotionValue(children)&&(this.childSubscription=children.on("change",latest=>{this.current&&(this.current.textContent=`${latest}`)}))}renderInstance(instance,renderState,styleProp,projection){renderHTML(instance,renderState,styleProp,projection)}}class SVGVisualElement extends DOMVisualElement{constructor(){super(...arguments),this.isSVGTag=!1}getBaseTargetFromProps(props,key){return props[key]}readValueFromInstance(instance,key){if(transformProps.has(key)){const defaultType=getDefaultValueType(key);return defaultType&&defaultType.default||0}return key=camelCaseAttributes.has(key)?key:camelToDash(key),instance.getAttribute(key)}measureInstanceViewportBox(){return createBox()}scrapeMotionValuesFromProps(props,prevProps){return scrapeMotionValuesFromProps(props,prevProps)}build(renderState,latestValues,options,props){buildSVGAttrs(renderState,latestValues,options,this.isSVGTag,props.transformTemplate)}renderInstance(instance,renderState,styleProp,projection){renderSVG(instance,renderState,styleProp,projection)}mount(instance){this.isSVGTag=isSVGTag(instance.tagName),super.mount(instance)}}const createDomVisualElement=(Component,options)=>isSVGComponent(Component)?new SVGVisualElement(options,{enableHardwareAcceleration:!1}):new HTMLVisualElement(options,{enableHardwareAcceleration:!0}),layout={layout:{ProjectionNode:HTMLProjectionNode,MeasureLayout}},preloadedFeatures={...animations,...gestureAnimations,...drag,...layout},motion=createMotionProxy((Component,config)=>createDomMotionConfig(Component,config,preloadedFeatures,createDomVisualElement));function useIsMounted(){const isMounted=reactExports.useRef(!1);return useIsomorphicLayoutEffect$2(()=>(isMounted.current=!0,()=>{isMounted.current=!1}),[]),isMounted}function useForceUpdate(){const isMounted=useIsMounted(),[forcedRenderCount,setForcedRenderCount]=reactExports.useState(0),forceRender=reactExports.useCallback(()=>{isMounted.current&&setForcedRenderCount(forcedRenderCount+1)},[forcedRenderCount]);return[reactExports.useCallback(()=>frame.postRender(forceRender),[forceRender]),forcedRenderCount]}class PopChildMeasure extends reactExports.Component{getSnapshotBeforeUpdate(prevProps){const element=this.props.childRef.current;if(element&&prevProps.isPresent&&!this.props.isPresent){const size=this.props.sizeRef.current;size.height=element.offsetHeight||0,size.width=element.offsetWidth||0,size.top=element.offsetTop,size.left=element.offsetLeft}return null}componentDidUpdate(){}render(){return this.props.children}}function PopChild({children,isPresent}){const id2=reactExports.useId(),ref=reactExports.useRef(null),size=reactExports.useRef({width:0,height:0,top:0,left:0});return reactExports.useInsertionEffect(()=>{const{width,height,top,left}=size.current;if(isPresent||!ref.current||!width||!height)return;ref.current.dataset.motionPopId=id2;const style=document.createElement("style");return document.head.appendChild(style),style.sheet&&style.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `),()=>{document.head.removeChild(style)}},[isPresent]),reactExports.createElement(PopChildMeasure,{isPresent,childRef:ref,sizeRef:size},reactExports.cloneElement(children,{ref}))}const PresenceChild=({children,initial,isPresent,onExitComplete,custom,presenceAffectsLayout,mode})=>{const presenceChildren=useConstant(newChildrenMap),id2=reactExports.useId(),context2=reactExports.useMemo(()=>({id:id2,initial,isPresent,custom,onExitComplete:childId=>{presenceChildren.set(childId,!0);for(const isComplete of presenceChildren.values())if(!isComplete)return;onExitComplete&&onExitComplete()},register:childId=>(presenceChildren.set(childId,!1),()=>presenceChildren.delete(childId))}),presenceAffectsLayout?void 0:[isPresent]);return reactExports.useMemo(()=>{presenceChildren.forEach((_2,key)=>presenceChildren.set(key,!1))},[isPresent]),reactExports.useEffect(()=>{!isPresent&&!presenceChildren.size&&onExitComplete&&onExitComplete()},[isPresent]),mode==="popLayout"&&(children=reactExports.createElement(PopChild,{isPresent},children)),reactExports.createElement(PresenceContext.Provider,{value:context2},children)};function newChildrenMap(){return new Map}function useUnmountEffect(callback){return reactExports.useEffect(()=>()=>callback(),[])}const getChildKey=child=>child.key||"";function updateChildLookup(children,allChildren){children.forEach(child=>{const key=getChildKey(child);allChildren.set(key,child)})}function onlyElements(children){const filtered=[];return reactExports.Children.forEach(children,child=>{reactExports.isValidElement(child)&&filtered.push(child)}),filtered}const AnimatePresence=({children,custom,initial=!0,onExitComplete,exitBeforeEnter,presenceAffectsLayout=!0,mode="sync"})=>{invariant(!exitBeforeEnter,"Replace exitBeforeEnter with mode='wait'");const forceRender=reactExports.useContext(LayoutGroupContext).forceRender||useForceUpdate()[0],isMounted=useIsMounted(),filteredChildren=onlyElements(children);let childrenToRender=filteredChildren;const exitingChildren=reactExports.useRef(new Map).current,presentChildren=reactExports.useRef(childrenToRender),allChildren=reactExports.useRef(new Map).current,isInitialRender=reactExports.useRef(!0);if(useIsomorphicLayoutEffect$2(()=>{isInitialRender.current=!1,updateChildLookup(filteredChildren,allChildren),presentChildren.current=childrenToRender}),useUnmountEffect(()=>{isInitialRender.current=!0,allChildren.clear(),exitingChildren.clear()}),isInitialRender.current)return reactExports.createElement(reactExports.Fragment,null,childrenToRender.map(child=>reactExports.createElement(PresenceChild,{key:getChildKey(child),isPresent:!0,initial:initial?void 0:!1,presenceAffectsLayout,mode},child)));childrenToRender=[...childrenToRender];const presentKeys=presentChildren.current.map(getChildKey),targetKeys=filteredChildren.map(getChildKey),numPresent=presentKeys.length;for(let i2=0;i2<numPresent;i2++){const key=presentKeys[i2];targetKeys.indexOf(key)===-1&&!exitingChildren.has(key)&&exitingChildren.set(key,void 0)}return mode==="wait"&&exitingChildren.size&&(childrenToRender=[]),exitingChildren.forEach((component,key)=>{if(targetKeys.indexOf(key)!==-1)return;const child=allChildren.get(key);if(!child)return;const insertionIndex=presentKeys.indexOf(key);let exitingComponent=component;if(!exitingComponent){const onExit=()=>{exitingChildren.delete(key);const leftOverKeys=Array.from(allChildren.keys()).filter(childKey=>!targetKeys.includes(childKey));if(leftOverKeys.forEach(leftOverKey=>allChildren.delete(leftOverKey)),presentChildren.current=filteredChildren.filter(presentChild=>{const presentChildKey=getChildKey(presentChild);return presentChildKey===key||leftOverKeys.includes(presentChildKey)}),!exitingChildren.size){if(isMounted.current===!1)return;forceRender(),onExitComplete&&onExitComplete()}};exitingComponent=reactExports.createElement(PresenceChild,{key:getChildKey(child),isPresent:!1,onExitComplete:onExit,custom,presenceAffectsLayout,mode},child),exitingChildren.set(key,exitingComponent)}childrenToRender.splice(insertionIndex,0,exitingComponent)}),childrenToRender=childrenToRender.map(child=>{const key=child.key;return exitingChildren.has(key)?child:reactExports.createElement(PresenceChild,{key:getChildKey(child),isPresent:!0,presenceAffectsLayout,mode},child)}),mode==="wait"&&childrenToRender.length>1&&console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`),reactExports.createElement(reactExports.Fragment,null,exitingChildren.size?childrenToRender:childrenToRender.map(child=>reactExports.cloneElement(child)))},AnimateChangeInHeight=({children,...rest})=>{const containerRef=reactExports.useRef(null),[height,setHeight]=reactExports.useState(0);return reactExports.useEffect(()=>{if(containerRef.current){const resizeObserver=new ResizeObserver(entries=>{const observedHeight=entries[0].contentRect.height;setHeight(observedHeight)});return resizeObserver.observe(containerRef.current),()=>{resizeObserver.disconnect()}}},[]),jsxDevRuntimeExports.jsxDEV(motion.span,{style:{overflow:"hidden",height},animate:{height},...rest,children:jsxDevRuntimeExports.jsxDEV("div",{ref:containerRef,children},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/AnimateChangeInHeight/index.tsx",lineNumber:29,columnNumber:13},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/AnimateChangeInHeight/index.tsx",lineNumber:28,columnNumber:9},globalThis)};function _extends(){return _extends=Object.assign?Object.assign.bind():function(target){for(var i2=1;i2<arguments.length;i2++){var source=arguments[i2];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends.apply(this,arguments)}/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const REVISION="158",MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},CullFaceNone=0,CullFaceBack=1,CullFaceFront=2,CullFaceFrontBack=3,BasicShadowMap=0,PCFShadowMap=1,PCFSoftShadowMap=2,VSMShadowMap=3,FrontSide=0,BackSide=1,DoubleSide=2,TwoPassDoubleSide=2,NoBlending=0,NormalBlending=1,AdditiveBlending=2,SubtractiveBlending=3,MultiplyBlending=4,CustomBlending=5,AddEquation=100,SubtractEquation=101,ReverseSubtractEquation=102,MinEquation=103,MaxEquation=104,ZeroFactor=200,OneFactor=201,SrcColorFactor=202,OneMinusSrcColorFactor=203,SrcAlphaFactor=204,OneMinusSrcAlphaFactor=205,DstAlphaFactor=206,OneMinusDstAlphaFactor=207,DstColorFactor=208,OneMinusDstColorFactor=209,SrcAlphaSaturateFactor=210,ConstantColorFactor=211,OneMinusConstantColorFactor=212,ConstantAlphaFactor=213,OneMinusConstantAlphaFactor=214,NeverDepth=0,AlwaysDepth=1,LessDepth=2,LessEqualDepth=3,EqualDepth=4,GreaterEqualDepth=5,GreaterDepth=6,NotEqualDepth=7,MultiplyOperation=0,MixOperation=1,AddOperation=2,NoToneMapping=0,LinearToneMapping=1,ReinhardToneMapping=2,CineonToneMapping=3,ACESFilmicToneMapping=4,CustomToneMapping=5,AttachedBindMode="attached",DetachedBindMode="detached",UVMapping=300,CubeReflectionMapping=301,CubeRefractionMapping=302,EquirectangularReflectionMapping=303,EquirectangularRefractionMapping=304,CubeUVReflectionMapping=306,RepeatWrapping=1e3,ClampToEdgeWrapping=1001,MirroredRepeatWrapping=1002,NearestFilter=1003,NearestMipmapNearestFilter=1004,NearestMipMapNearestFilter=1004,NearestMipmapLinearFilter=1005,NearestMipMapLinearFilter=1005,LinearFilter=1006,LinearMipmapNearestFilter=1007,LinearMipMapNearestFilter=1007,LinearMipmapLinearFilter=1008,LinearMipMapLinearFilter=1008,UnsignedByteType=1009,ByteType=1010,ShortType=1011,UnsignedShortType=1012,IntType=1013,UnsignedIntType=1014,FloatType=1015,HalfFloatType=1016,UnsignedShort4444Type=1017,UnsignedShort5551Type=1018,UnsignedInt248Type=1020,AlphaFormat=1021,RGBAFormat=1023,LuminanceFormat=1024,LuminanceAlphaFormat=1025,DepthFormat=1026,DepthStencilFormat=1027,RedFormat=1028,RedIntegerFormat=1029,RGFormat=1030,RGIntegerFormat=1031,RGBAIntegerFormat=1033,RGB_S3TC_DXT1_Format=33776,RGBA_S3TC_DXT1_Format=33777,RGBA_S3TC_DXT3_Format=33778,RGBA_S3TC_DXT5_Format=33779,RGB_PVRTC_4BPPV1_Format=35840,RGB_PVRTC_2BPPV1_Format=35841,RGBA_PVRTC_4BPPV1_Format=35842,RGBA_PVRTC_2BPPV1_Format=35843,RGB_ETC1_Format=36196,RGB_ETC2_Format=37492,RGBA_ETC2_EAC_Format=37496,RGBA_ASTC_4x4_Format=37808,RGBA_ASTC_5x4_Format=37809,RGBA_ASTC_5x5_Format=37810,RGBA_ASTC_6x5_Format=37811,RGBA_ASTC_6x6_Format=37812,RGBA_ASTC_8x5_Format=37813,RGBA_ASTC_8x6_Format=37814,RGBA_ASTC_8x8_Format=37815,RGBA_ASTC_10x5_Format=37816,RGBA_ASTC_10x6_Format=37817,RGBA_ASTC_10x8_Format=37818,RGBA_ASTC_10x10_Format=37819,RGBA_ASTC_12x10_Format=37820,RGBA_ASTC_12x12_Format=37821,RGBA_BPTC_Format=36492,RGB_BPTC_SIGNED_Format=36494,RGB_BPTC_UNSIGNED_Format=36495,RED_RGTC1_Format=36283,SIGNED_RED_RGTC1_Format=36284,RED_GREEN_RGTC2_Format=36285,SIGNED_RED_GREEN_RGTC2_Format=36286,LoopOnce=2200,LoopRepeat=2201,LoopPingPong=2202,InterpolateDiscrete=2300,InterpolateLinear=2301,InterpolateSmooth=2302,ZeroCurvatureEnding=2400,ZeroSlopeEnding=2401,WrapAroundEnding=2402,NormalAnimationBlendMode=2500,AdditiveAnimationBlendMode=2501,TrianglesDrawMode=0,TriangleStripDrawMode=1,TriangleFanDrawMode=2,LinearEncoding=3e3,sRGBEncoding=3001,BasicDepthPacking=3200,RGBADepthPacking=3201,TangentSpaceNormalMap=0,ObjectSpaceNormalMap=1,NoColorSpace="",SRGBColorSpace="srgb",LinearSRGBColorSpace="srgb-linear",DisplayP3ColorSpace="display-p3",LinearDisplayP3ColorSpace="display-p3-linear",LinearTransfer="linear",SRGBTransfer="srgb",Rec709Primaries="rec709",P3Primaries="p3",ZeroStencilOp=0,KeepStencilOp=7680,ReplaceStencilOp=7681,IncrementStencilOp=7682,DecrementStencilOp=7683,IncrementWrapStencilOp=34055,DecrementWrapStencilOp=34056,InvertStencilOp=5386,NeverStencilFunc=512,LessStencilFunc=513,EqualStencilFunc=514,LessEqualStencilFunc=515,GreaterStencilFunc=516,NotEqualStencilFunc=517,GreaterEqualStencilFunc=518,AlwaysStencilFunc=519,NeverCompare=512,LessCompare=513,EqualCompare=514,LessEqualCompare=515,GreaterCompare=516,NotEqualCompare=517,GreaterEqualCompare=518,AlwaysCompare=519,StaticDrawUsage=35044,DynamicDrawUsage=35048,StreamDrawUsage=35040,StaticReadUsage=35045,DynamicReadUsage=35049,StreamReadUsage=35041,StaticCopyUsage=35046,DynamicCopyUsage=35050,StreamCopyUsage=35042,GLSL1="100",GLSL3="300 es",_SRGBAFormat=1035,WebGLCoordinateSystem=2e3,WebGPUCoordinateSystem=2001;class EventDispatcher{addEventListener(type,listener){this._listeners===void 0&&(this._listeners={});const listeners=this._listeners;listeners[type]===void 0&&(listeners[type]=[]),listeners[type].indexOf(listener)===-1&&listeners[type].push(listener)}hasEventListener(type,listener){if(this._listeners===void 0)return!1;const listeners=this._listeners;return listeners[type]!==void 0&&listeners[type].indexOf(listener)!==-1}removeEventListener(type,listener){if(this._listeners===void 0)return;const listenerArray=this._listeners[type];if(listenerArray!==void 0){const index=listenerArray.indexOf(listener);index!==-1&&listenerArray.splice(index,1)}}dispatchEvent(event){if(this._listeners===void 0)return;const listenerArray=this._listeners[event.type];if(listenerArray!==void 0){event.target=this;const array=listenerArray.slice(0);for(let i2=0,l2=array.length;i2<l2;i2++)array[i2].call(this,event);event.target=null}}}const _lut=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let _seed=1234567;const DEG2RAD=Math.PI/180,RAD2DEG=180/Math.PI;function generateUUID(){const d0=Math.random()*4294967295|0,d1=Math.random()*4294967295|0,d2=Math.random()*4294967295|0,d3=Math.random()*4294967295|0;return(_lut[d0&255]+_lut[d0>>8&255]+_lut[d0>>16&255]+_lut[d0>>24&255]+"-"+_lut[d1&255]+_lut[d1>>8&255]+"-"+_lut[d1>>16&15|64]+_lut[d1>>24&255]+"-"+_lut[d2&63|128]+_lut[d2>>8&255]+"-"+_lut[d2>>16&255]+_lut[d2>>24&255]+_lut[d3&255]+_lut[d3>>8&255]+_lut[d3>>16&255]+_lut[d3>>24&255]).toLowerCase()}function clamp(value,min,max2){return Math.max(min,Math.min(max2,value))}function euclideanModulo(n,m2){return(n%m2+m2)%m2}function mapLinear(x2,a1,a2,b1,b2){return b1+(x2-a1)*(b2-b1)/(a2-a1)}function inverseLerp(x2,y2,value){return x2!==y2?(value-x2)/(y2-x2):0}function lerp(x2,y2,t2){return(1-t2)*x2+t2*y2}function damp(x2,y2,lambda,dt){return lerp(x2,y2,1-Math.exp(-lambda*dt))}function pingpong(x2,length=1){return length-Math.abs(euclideanModulo(x2,length*2)-length)}function smoothstep(x2,min,max2){return x2<=min?0:x2>=max2?1:(x2=(x2-min)/(max2-min),x2*x2*(3-2*x2))}function smootherstep(x2,min,max2){return x2<=min?0:x2>=max2?1:(x2=(x2-min)/(max2-min),x2*x2*x2*(x2*(x2*6-15)+10))}function randInt(low,high){return low+Math.floor(Math.random()*(high-low+1))}function randFloat(low,high){return low+Math.random()*(high-low)}function randFloatSpread(range){return range*(.5-Math.random())}function seededRandom(s2){s2!==void 0&&(_seed=s2);let t2=_seed+=1831565813;return t2=Math.imul(t2^t2>>>15,t2|1),t2^=t2+Math.imul(t2^t2>>>7,t2|61),((t2^t2>>>14)>>>0)/4294967296}function degToRad(degrees2){return degrees2*DEG2RAD}function radToDeg(radians){return radians*RAD2DEG}function isPowerOfTwo(value){return(value&value-1)===0&&value!==0}function ceilPowerOfTwo(value){return Math.pow(2,Math.ceil(Math.log(value)/Math.LN2))}function floorPowerOfTwo(value){return Math.pow(2,Math.floor(Math.log(value)/Math.LN2))}function setQuaternionFromProperEuler(q,a2,b2,c2,order){const cos=Math.cos,sin=Math.sin,c22=cos(b2/2),s2=sin(b2/2),c13=cos((a2+c2)/2),s13=sin((a2+c2)/2),c1_3=cos((a2-c2)/2),s1_3=sin((a2-c2)/2),c3_1=cos((c2-a2)/2),s3_1=sin((c2-a2)/2);switch(order){case"XYX":q.set(c22*s13,s2*c1_3,s2*s1_3,c22*c13);break;case"YZY":q.set(s2*s1_3,c22*s13,s2*c1_3,c22*c13);break;case"ZXZ":q.set(s2*c1_3,s2*s1_3,c22*s13,c22*c13);break;case"XZX":q.set(c22*s13,s2*s3_1,s2*c3_1,c22*c13);break;case"YXY":q.set(s2*c3_1,c22*s13,s2*s3_1,c22*c13);break;case"ZYZ":q.set(s2*s3_1,s2*c3_1,c22*s13,c22*c13);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+order)}}function denormalize(value,array){switch(array.constructor){case Float32Array:return value;case Uint32Array:return value/4294967295;case Uint16Array:return value/65535;case Uint8Array:return value/255;case Int32Array:return Math.max(value/2147483647,-1);case Int16Array:return Math.max(value/32767,-1);case Int8Array:return Math.max(value/127,-1);default:throw new Error("Invalid component type.")}}function normalize(value,array){switch(array.constructor){case Float32Array:return value;case Uint32Array:return Math.round(value*4294967295);case Uint16Array:return Math.round(value*65535);case Uint8Array:return Math.round(value*255);case Int32Array:return Math.round(value*2147483647);case Int16Array:return Math.round(value*32767);case Int8Array:return Math.round(value*127);default:throw new Error("Invalid component type.")}}const MathUtils={DEG2RAD,RAD2DEG,generateUUID,clamp,euclideanModulo,mapLinear,inverseLerp,lerp,damp,pingpong,smoothstep,smootherstep,randInt,randFloat,randFloatSpread,seededRandom,degToRad,radToDeg,isPowerOfTwo,ceilPowerOfTwo,floorPowerOfTwo,setQuaternionFromProperEuler,normalize,denormalize};class Vector2{constructor(x2=0,y2=0){Vector2.prototype.isVector2=!0,this.x=x2,this.y=y2}get width(){return this.x}set width(value){this.x=value}get height(){return this.y}set height(value){this.y=value}set(x2,y2){return this.x=x2,this.y=y2,this}setScalar(scalar){return this.x=scalar,this.y=scalar,this}setX(x2){return this.x=x2,this}setY(y2){return this.y=y2,this}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;default:throw new Error("index is out of range: "+index)}return this}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+index)}}clone(){return new this.constructor(this.x,this.y)}copy(v4){return this.x=v4.x,this.y=v4.y,this}add(v4){return this.x+=v4.x,this.y+=v4.y,this}addScalar(s2){return this.x+=s2,this.y+=s2,this}addVectors(a2,b2){return this.x=a2.x+b2.x,this.y=a2.y+b2.y,this}addScaledVector(v4,s2){return this.x+=v4.x*s2,this.y+=v4.y*s2,this}sub(v4){return this.x-=v4.x,this.y-=v4.y,this}subScalar(s2){return this.x-=s2,this.y-=s2,this}subVectors(a2,b2){return this.x=a2.x-b2.x,this.y=a2.y-b2.y,this}multiply(v4){return this.x*=v4.x,this.y*=v4.y,this}multiplyScalar(scalar){return this.x*=scalar,this.y*=scalar,this}divide(v4){return this.x/=v4.x,this.y/=v4.y,this}divideScalar(scalar){return this.multiplyScalar(1/scalar)}applyMatrix3(m2){const x2=this.x,y2=this.y,e2=m2.elements;return this.x=e2[0]*x2+e2[3]*y2+e2[6],this.y=e2[1]*x2+e2[4]*y2+e2[7],this}min(v4){return this.x=Math.min(this.x,v4.x),this.y=Math.min(this.y,v4.y),this}max(v4){return this.x=Math.max(this.x,v4.x),this.y=Math.max(this.y,v4.y),this}clamp(min,max2){return this.x=Math.max(min.x,Math.min(max2.x,this.x)),this.y=Math.max(min.y,Math.min(max2.y,this.y)),this}clampScalar(minVal,maxVal){return this.x=Math.max(minVal,Math.min(maxVal,this.x)),this.y=Math.max(minVal,Math.min(maxVal,this.y)),this}clampLength(min,max2){const length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max2,length)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(v4){return this.x*v4.x+this.y*v4.y}cross(v4){return this.x*v4.y-this.y*v4.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(v4){const denominator=Math.sqrt(this.lengthSq()*v4.lengthSq());if(denominator===0)return Math.PI/2;const theta=this.dot(v4)/denominator;return Math.acos(clamp(theta,-1,1))}distanceTo(v4){return Math.sqrt(this.distanceToSquared(v4))}distanceToSquared(v4){const dx=this.x-v4.x,dy=this.y-v4.y;return dx*dx+dy*dy}manhattanDistanceTo(v4){return Math.abs(this.x-v4.x)+Math.abs(this.y-v4.y)}setLength(length){return this.normalize().multiplyScalar(length)}lerp(v4,alpha2){return this.x+=(v4.x-this.x)*alpha2,this.y+=(v4.y-this.y)*alpha2,this}lerpVectors(v12,v22,alpha2){return this.x=v12.x+(v22.x-v12.x)*alpha2,this.y=v12.y+(v22.y-v12.y)*alpha2,this}equals(v4){return v4.x===this.x&&v4.y===this.y}fromArray(array,offset=0){return this.x=array[offset],this.y=array[offset+1],this}toArray(array=[],offset=0){return array[offset]=this.x,array[offset+1]=this.y,array}fromBufferAttribute(attribute,index){return this.x=attribute.getX(index),this.y=attribute.getY(index),this}rotateAround(center,angle){const c2=Math.cos(angle),s2=Math.sin(angle),x2=this.x-center.x,y2=this.y-center.y;return this.x=x2*c2-y2*s2+center.x,this.y=x2*s2+y2*c2+center.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Matrix3{constructor(n11,n12,n13,n21,n22,n23,n31,n32,n33){Matrix3.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],n11!==void 0&&this.set(n11,n12,n13,n21,n22,n23,n31,n32,n33)}set(n11,n12,n13,n21,n22,n23,n31,n32,n33){const te=this.elements;return te[0]=n11,te[1]=n21,te[2]=n31,te[3]=n12,te[4]=n22,te[5]=n32,te[6]=n13,te[7]=n23,te[8]=n33,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(m2){const te=this.elements,me=m2.elements;return te[0]=me[0],te[1]=me[1],te[2]=me[2],te[3]=me[3],te[4]=me[4],te[5]=me[5],te[6]=me[6],te[7]=me[7],te[8]=me[8],this}extractBasis(xAxis,yAxis,zAxis){return xAxis.setFromMatrix3Column(this,0),yAxis.setFromMatrix3Column(this,1),zAxis.setFromMatrix3Column(this,2),this}setFromMatrix4(m2){const me=m2.elements;return this.set(me[0],me[4],me[8],me[1],me[5],me[9],me[2],me[6],me[10]),this}multiply(m2){return this.multiplyMatrices(this,m2)}premultiply(m2){return this.multiplyMatrices(m2,this)}multiplyMatrices(a2,b2){const ae=a2.elements,be=b2.elements,te=this.elements,a11=ae[0],a12=ae[3],a13=ae[6],a21=ae[1],a22=ae[4],a23=ae[7],a31=ae[2],a32=ae[5],a33=ae[8],b11=be[0],b12=be[3],b13=be[6],b21=be[1],b22=be[4],b23=be[7],b31=be[2],b32=be[5],b33=be[8];return te[0]=a11*b11+a12*b21+a13*b31,te[3]=a11*b12+a12*b22+a13*b32,te[6]=a11*b13+a12*b23+a13*b33,te[1]=a21*b11+a22*b21+a23*b31,te[4]=a21*b12+a22*b22+a23*b32,te[7]=a21*b13+a22*b23+a23*b33,te[2]=a31*b11+a32*b21+a33*b31,te[5]=a31*b12+a32*b22+a33*b32,te[8]=a31*b13+a32*b23+a33*b33,this}multiplyScalar(s2){const te=this.elements;return te[0]*=s2,te[3]*=s2,te[6]*=s2,te[1]*=s2,te[4]*=s2,te[7]*=s2,te[2]*=s2,te[5]*=s2,te[8]*=s2,this}determinant(){const te=this.elements,a2=te[0],b2=te[1],c2=te[2],d2=te[3],e2=te[4],f2=te[5],g2=te[6],h2=te[7],i2=te[8];return a2*e2*i2-a2*f2*h2-b2*d2*i2+b2*f2*g2+c2*d2*h2-c2*e2*g2}invert(){const te=this.elements,n11=te[0],n21=te[1],n31=te[2],n12=te[3],n22=te[4],n32=te[5],n13=te[6],n23=te[7],n33=te[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13,det=n11*t11+n21*t12+n31*t13;if(det===0)return this.set(0,0,0,0,0,0,0,0,0);const detInv=1/det;return te[0]=t11*detInv,te[1]=(n31*n23-n33*n21)*detInv,te[2]=(n32*n21-n31*n22)*detInv,te[3]=t12*detInv,te[4]=(n33*n11-n31*n13)*detInv,te[5]=(n31*n12-n32*n11)*detInv,te[6]=t13*detInv,te[7]=(n21*n13-n23*n11)*detInv,te[8]=(n22*n11-n21*n12)*detInv,this}transpose(){let tmp2;const m2=this.elements;return tmp2=m2[1],m2[1]=m2[3],m2[3]=tmp2,tmp2=m2[2],m2[2]=m2[6],m2[6]=tmp2,tmp2=m2[5],m2[5]=m2[7],m2[7]=tmp2,this}getNormalMatrix(matrix4){return this.setFromMatrix4(matrix4).invert().transpose()}transposeIntoArray(r2){const m2=this.elements;return r2[0]=m2[0],r2[1]=m2[3],r2[2]=m2[6],r2[3]=m2[1],r2[4]=m2[4],r2[5]=m2[7],r2[6]=m2[2],r2[7]=m2[5],r2[8]=m2[8],this}setUvTransform(tx,ty,sx,sy,rotation,cx,cy){const c2=Math.cos(rotation),s2=Math.sin(rotation);return this.set(sx*c2,sx*s2,-sx*(c2*cx+s2*cy)+cx+tx,-sy*s2,sy*c2,-sy*(-s2*cx+c2*cy)+cy+ty,0,0,1),this}scale(sx,sy){return this.premultiply(_m3.makeScale(sx,sy)),this}rotate(theta){return this.premultiply(_m3.makeRotation(-theta)),this}translate(tx,ty){return this.premultiply(_m3.makeTranslation(tx,ty)),this}makeTranslation(x2,y2){return x2.isVector2?this.set(1,0,x2.x,0,1,x2.y,0,0,1):this.set(1,0,x2,0,1,y2,0,0,1),this}makeRotation(theta){const c2=Math.cos(theta),s2=Math.sin(theta);return this.set(c2,-s2,0,s2,c2,0,0,0,1),this}makeScale(x2,y2){return this.set(x2,0,0,0,y2,0,0,0,1),this}equals(matrix){const te=this.elements,me=matrix.elements;for(let i2=0;i2<9;i2++)if(te[i2]!==me[i2])return!1;return!0}fromArray(array,offset=0){for(let i2=0;i2<9;i2++)this.elements[i2]=array[i2+offset];return this}toArray(array=[],offset=0){const te=this.elements;return array[offset]=te[0],array[offset+1]=te[1],array[offset+2]=te[2],array[offset+3]=te[3],array[offset+4]=te[4],array[offset+5]=te[5],array[offset+6]=te[6],array[offset+7]=te[7],array[offset+8]=te[8],array}clone(){return new this.constructor().fromArray(this.elements)}}const _m3=new Matrix3;function arrayNeedsUint32(array){for(let i2=array.length-1;i2>=0;--i2)if(array[i2]>=65535)return!0;return!1}const TYPED_ARRAYS={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function getTypedArray(type,buffer){return new TYPED_ARRAYS[type](buffer)}function createElementNS(name){return document.createElementNS("http://www.w3.org/1999/xhtml",name)}function createCanvasElement(){const canvas=createElementNS("canvas");return canvas.style.display="block",canvas}const _cache={};function warnOnce(message){message in _cache||(_cache[message]=!0,console.warn(message))}const LINEAR_SRGB_TO_LINEAR_DISPLAY_P3=new Matrix3().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),LINEAR_DISPLAY_P3_TO_LINEAR_SRGB=new Matrix3().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),COLOR_SPACES={[LinearSRGBColorSpace]:{transfer:LinearTransfer,primaries:Rec709Primaries,toReference:color2=>color2,fromReference:color2=>color2},[SRGBColorSpace]:{transfer:SRGBTransfer,primaries:Rec709Primaries,toReference:color2=>color2.convertSRGBToLinear(),fromReference:color2=>color2.convertLinearToSRGB()},[LinearDisplayP3ColorSpace]:{transfer:LinearTransfer,primaries:P3Primaries,toReference:color2=>color2.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),fromReference:color2=>color2.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)},[DisplayP3ColorSpace]:{transfer:SRGBTransfer,primaries:P3Primaries,toReference:color2=>color2.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),fromReference:color2=>color2.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()}},SUPPORTED_WORKING_COLOR_SPACES=new Set([LinearSRGBColorSpace,LinearDisplayP3ColorSpace]),ColorManagement={enabled:!0,_workingColorSpace:LinearSRGBColorSpace,get legacyMode(){return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),!this.enabled},set legacyMode(legacyMode){console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),this.enabled=!legacyMode},get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(colorSpace){if(!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace))throw new Error(`Unsupported working color space, "${colorSpace}".`);this._workingColorSpace=colorSpace},convert:function(color2,sourceColorSpace,targetColorSpace){if(this.enabled===!1||sourceColorSpace===targetColorSpace||!sourceColorSpace||!targetColorSpace)return color2;const sourceToReference=COLOR_SPACES[sourceColorSpace].toReference,targetFromReference=COLOR_SPACES[targetColorSpace].fromReference;return targetFromReference(sourceToReference(color2))},fromWorkingColorSpace:function(color2,targetColorSpace){return this.convert(color2,this._workingColorSpace,targetColorSpace)},toWorkingColorSpace:function(color2,sourceColorSpace){return this.convert(color2,sourceColorSpace,this._workingColorSpace)},getPrimaries:function(colorSpace){return COLOR_SPACES[colorSpace].primaries},getTransfer:function(colorSpace){return colorSpace===NoColorSpace?LinearTransfer:COLOR_SPACES[colorSpace].transfer}};function SRGBToLinear(c2){return c2<.04045?c2*.0773993808:Math.pow(c2*.9478672986+.0521327014,2.4)}function LinearToSRGB(c2){return c2<.0031308?c2*12.92:1.055*Math.pow(c2,.41666)-.055}let _canvas;class ImageUtils{static getDataURL(image){if(/^data:/i.test(image.src)||typeof HTMLCanvasElement>"u")return image.src;let canvas;if(image instanceof HTMLCanvasElement)canvas=image;else{_canvas===void 0&&(_canvas=createElementNS("canvas")),_canvas.width=image.width,_canvas.height=image.height;const context2=_canvas.getContext("2d");image instanceof ImageData?context2.putImageData(image,0,0):context2.drawImage(image,0,0,image.width,image.height),canvas=_canvas}return canvas.width>2048||canvas.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",image),canvas.toDataURL("image/jpeg",.6)):canvas.toDataURL("image/png")}static sRGBToLinear(image){if(typeof HTMLImageElement<"u"&&image instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&image instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&image instanceof ImageBitmap){const canvas=createElementNS("canvas");canvas.width=image.width,canvas.height=image.height;const context2=canvas.getContext("2d");context2.drawImage(image,0,0,image.width,image.height);const imageData=context2.getImageData(0,0,image.width,image.height),data=imageData.data;for(let i2=0;i2<data.length;i2++)data[i2]=SRGBToLinear(data[i2]/255)*255;return context2.putImageData(imageData,0,0),canvas}else if(image.data){const data=image.data.slice(0);for(let i2=0;i2<data.length;i2++)data instanceof Uint8Array||data instanceof Uint8ClampedArray?data[i2]=Math.floor(SRGBToLinear(data[i2]/255)*255):data[i2]=SRGBToLinear(data[i2]);return{data,width:image.width,height:image.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),image}}let _sourceId=0;class Source{constructor(data=null){this.isSource=!0,Object.defineProperty(this,"id",{value:_sourceId++}),this.uuid=generateUUID(),this.data=data,this.version=0}set needsUpdate(value){value===!0&&this.version++}toJSON(meta){const isRootObject=meta===void 0||typeof meta=="string";if(!isRootObject&&meta.images[this.uuid]!==void 0)return meta.images[this.uuid];const output={uuid:this.uuid,url:""},data=this.data;if(data!==null){let url;if(Array.isArray(data)){url=[];for(let i2=0,l2=data.length;i2<l2;i2++)data[i2].isDataTexture?url.push(serializeImage(data[i2].image)):url.push(serializeImage(data[i2]))}else url=serializeImage(data);output.url=url}return isRootObject||(meta.images[this.uuid]=output),output}}function serializeImage(image){return typeof HTMLImageElement<"u"&&image instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&image instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&image instanceof ImageBitmap?ImageUtils.getDataURL(image):image.data?{data:Array.from(image.data),width:image.width,height:image.height,type:image.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let _textureId=0;class Texture extends EventDispatcher{constructor(image=Texture.DEFAULT_IMAGE,mapping=Texture.DEFAULT_MAPPING,wrapS=ClampToEdgeWrapping,wrapT=ClampToEdgeWrapping,magFilter=LinearFilter,minFilter=LinearMipmapLinearFilter,format=RGBAFormat,type=UnsignedByteType,anisotropy=Texture.DEFAULT_ANISOTROPY,colorSpace=NoColorSpace){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:_textureId++}),this.uuid=generateUUID(),this.name="",this.source=new Source(image),this.mipmaps=[],this.mapping=mapping,this.channel=0,this.wrapS=wrapS,this.wrapT=wrapT,this.magFilter=magFilter,this.minFilter=minFilter,this.anisotropy=anisotropy,this.format=format,this.internalFormat=null,this.type=type,this.offset=new Vector2(0,0),this.repeat=new Vector2(1,1),this.center=new Vector2(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Matrix3,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,typeof colorSpace=="string"?this.colorSpace=colorSpace:(warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=colorSpace===sRGBEncoding?SRGBColorSpace:NoColorSpace),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(value=null){this.source.data=value}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(source){return this.name=source.name,this.source=source.source,this.mipmaps=source.mipmaps.slice(0),this.mapping=source.mapping,this.channel=source.channel,this.wrapS=source.wrapS,this.wrapT=source.wrapT,this.magFilter=source.magFilter,this.minFilter=source.minFilter,this.anisotropy=source.anisotropy,this.format=source.format,this.internalFormat=source.internalFormat,this.type=source.type,this.offset.copy(source.offset),this.repeat.copy(source.repeat),this.center.copy(source.center),this.rotation=source.rotation,this.matrixAutoUpdate=source.matrixAutoUpdate,this.matrix.copy(source.matrix),this.generateMipmaps=source.generateMipmaps,this.premultiplyAlpha=source.premultiplyAlpha,this.flipY=source.flipY,this.unpackAlignment=source.unpackAlignment,this.colorSpace=source.colorSpace,this.userData=JSON.parse(JSON.stringify(source.userData)),this.needsUpdate=!0,this}toJSON(meta){const isRootObject=meta===void 0||typeof meta=="string";if(!isRootObject&&meta.textures[this.uuid]!==void 0)return meta.textures[this.uuid];const output={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(meta).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(output.userData=this.userData),isRootObject||(meta.textures[this.uuid]=output),output}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(uv){if(this.mapping!==UVMapping)return uv;if(uv.applyMatrix3(this.matrix),uv.x<0||uv.x>1)switch(this.wrapS){case RepeatWrapping:uv.x=uv.x-Math.floor(uv.x);break;case ClampToEdgeWrapping:uv.x=uv.x<0?0:1;break;case MirroredRepeatWrapping:Math.abs(Math.floor(uv.x)%2)===1?uv.x=Math.ceil(uv.x)-uv.x:uv.x=uv.x-Math.floor(uv.x);break}if(uv.y<0||uv.y>1)switch(this.wrapT){case RepeatWrapping:uv.y=uv.y-Math.floor(uv.y);break;case ClampToEdgeWrapping:uv.y=uv.y<0?0:1;break;case MirroredRepeatWrapping:Math.abs(Math.floor(uv.y)%2)===1?uv.y=Math.ceil(uv.y)-uv.y:uv.y=uv.y-Math.floor(uv.y);break}return this.flipY&&(uv.y=1-uv.y),uv}set needsUpdate(value){value===!0&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===SRGBColorSpace?sRGBEncoding:LinearEncoding}set encoding(encoding){warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=encoding===sRGBEncoding?SRGBColorSpace:NoColorSpace}}Texture.DEFAULT_IMAGE=null;Texture.DEFAULT_MAPPING=UVMapping;Texture.DEFAULT_ANISOTROPY=1;class Vector4{constructor(x2=0,y2=0,z=0,w2=1){Vector4.prototype.isVector4=!0,this.x=x2,this.y=y2,this.z=z,this.w=w2}get width(){return this.z}set width(value){this.z=value}get height(){return this.w}set height(value){this.w=value}set(x2,y2,z,w2){return this.x=x2,this.y=y2,this.z=z,this.w=w2,this}setScalar(scalar){return this.x=scalar,this.y=scalar,this.z=scalar,this.w=scalar,this}setX(x2){return this.x=x2,this}setY(y2){return this.y=y2,this}setZ(z){return this.z=z,this}setW(w2){return this.w=w2,this}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw new Error("index is out of range: "+index)}return this}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+index)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(v4){return this.x=v4.x,this.y=v4.y,this.z=v4.z,this.w=v4.w!==void 0?v4.w:1,this}add(v4){return this.x+=v4.x,this.y+=v4.y,this.z+=v4.z,this.w+=v4.w,this}addScalar(s2){return this.x+=s2,this.y+=s2,this.z+=s2,this.w+=s2,this}addVectors(a2,b2){return this.x=a2.x+b2.x,this.y=a2.y+b2.y,this.z=a2.z+b2.z,this.w=a2.w+b2.w,this}addScaledVector(v4,s2){return this.x+=v4.x*s2,this.y+=v4.y*s2,this.z+=v4.z*s2,this.w+=v4.w*s2,this}sub(v4){return this.x-=v4.x,this.y-=v4.y,this.z-=v4.z,this.w-=v4.w,this}subScalar(s2){return this.x-=s2,this.y-=s2,this.z-=s2,this.w-=s2,this}subVectors(a2,b2){return this.x=a2.x-b2.x,this.y=a2.y-b2.y,this.z=a2.z-b2.z,this.w=a2.w-b2.w,this}multiply(v4){return this.x*=v4.x,this.y*=v4.y,this.z*=v4.z,this.w*=v4.w,this}multiplyScalar(scalar){return this.x*=scalar,this.y*=scalar,this.z*=scalar,this.w*=scalar,this}applyMatrix4(m2){const x2=this.x,y2=this.y,z=this.z,w2=this.w,e2=m2.elements;return this.x=e2[0]*x2+e2[4]*y2+e2[8]*z+e2[12]*w2,this.y=e2[1]*x2+e2[5]*y2+e2[9]*z+e2[13]*w2,this.z=e2[2]*x2+e2[6]*y2+e2[10]*z+e2[14]*w2,this.w=e2[3]*x2+e2[7]*y2+e2[11]*z+e2[15]*w2,this}divideScalar(scalar){return this.multiplyScalar(1/scalar)}setAxisAngleFromQuaternion(q){this.w=2*Math.acos(q.w);const s2=Math.sqrt(1-q.w*q.w);return s2<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=q.x/s2,this.y=q.y/s2,this.z=q.z/s2),this}setAxisAngleFromRotationMatrix(m2){let angle,x2,y2,z;const te=m2.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];if(Math.abs(m12-m21)<.01&&Math.abs(m13-m31)<.01&&Math.abs(m23-m32)<.01){if(Math.abs(m12+m21)<.1&&Math.abs(m13+m31)<.1&&Math.abs(m23+m32)<.1&&Math.abs(m11+m22+m33-3)<.1)return this.set(1,0,0,0),this;angle=Math.PI;const xx=(m11+1)/2,yy=(m22+1)/2,zz=(m33+1)/2,xy=(m12+m21)/4,xz=(m13+m31)/4,yz=(m23+m32)/4;return xx>yy&&xx>zz?xx<.01?(x2=0,y2=.707106781,z=.707106781):(x2=Math.sqrt(xx),y2=xy/x2,z=xz/x2):yy>zz?yy<.01?(x2=.707106781,y2=0,z=.707106781):(y2=Math.sqrt(yy),x2=xy/y2,z=yz/y2):zz<.01?(x2=.707106781,y2=.707106781,z=0):(z=Math.sqrt(zz),x2=xz/z,y2=yz/z),this.set(x2,y2,z,angle),this}let s2=Math.sqrt((m32-m23)*(m32-m23)+(m13-m31)*(m13-m31)+(m21-m12)*(m21-m12));return Math.abs(s2)<.001&&(s2=1),this.x=(m32-m23)/s2,this.y=(m13-m31)/s2,this.z=(m21-m12)/s2,this.w=Math.acos((m11+m22+m33-1)/2),this}min(v4){return this.x=Math.min(this.x,v4.x),this.y=Math.min(this.y,v4.y),this.z=Math.min(this.z,v4.z),this.w=Math.min(this.w,v4.w),this}max(v4){return this.x=Math.max(this.x,v4.x),this.y=Math.max(this.y,v4.y),this.z=Math.max(this.z,v4.z),this.w=Math.max(this.w,v4.w),this}clamp(min,max2){return this.x=Math.max(min.x,Math.min(max2.x,this.x)),this.y=Math.max(min.y,Math.min(max2.y,this.y)),this.z=Math.max(min.z,Math.min(max2.z,this.z)),this.w=Math.max(min.w,Math.min(max2.w,this.w)),this}clampScalar(minVal,maxVal){return this.x=Math.max(minVal,Math.min(maxVal,this.x)),this.y=Math.max(minVal,Math.min(maxVal,this.y)),this.z=Math.max(minVal,Math.min(maxVal,this.z)),this.w=Math.max(minVal,Math.min(maxVal,this.w)),this}clampLength(min,max2){const length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max2,length)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(v4){return this.x*v4.x+this.y*v4.y+this.z*v4.z+this.w*v4.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(length){return this.normalize().multiplyScalar(length)}lerp(v4,alpha2){return this.x+=(v4.x-this.x)*alpha2,this.y+=(v4.y-this.y)*alpha2,this.z+=(v4.z-this.z)*alpha2,this.w+=(v4.w-this.w)*alpha2,this}lerpVectors(v12,v22,alpha2){return this.x=v12.x+(v22.x-v12.x)*alpha2,this.y=v12.y+(v22.y-v12.y)*alpha2,this.z=v12.z+(v22.z-v12.z)*alpha2,this.w=v12.w+(v22.w-v12.w)*alpha2,this}equals(v4){return v4.x===this.x&&v4.y===this.y&&v4.z===this.z&&v4.w===this.w}fromArray(array,offset=0){return this.x=array[offset],this.y=array[offset+1],this.z=array[offset+2],this.w=array[offset+3],this}toArray(array=[],offset=0){return array[offset]=this.x,array[offset+1]=this.y,array[offset+2]=this.z,array[offset+3]=this.w,array}fromBufferAttribute(attribute,index){return this.x=attribute.getX(index),this.y=attribute.getY(index),this.z=attribute.getZ(index),this.w=attribute.getW(index),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class RenderTarget extends EventDispatcher{constructor(width=1,height=1,options={}){super(),this.isRenderTarget=!0,this.width=width,this.height=height,this.depth=1,this.scissor=new Vector4(0,0,width,height),this.scissorTest=!1,this.viewport=new Vector4(0,0,width,height);const image={width,height,depth:1};options.encoding!==void 0&&(warnOnce("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),options.colorSpace=options.encoding===sRGBEncoding?SRGBColorSpace:NoColorSpace),options=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:LinearFilter,depthBuffer:!0,stencilBuffer:!1,depthTexture:null,samples:0},options),this.texture=new Texture(image,options.mapping,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=options.generateMipmaps,this.texture.internalFormat=options.internalFormat,this.depthBuffer=options.depthBuffer,this.stencilBuffer=options.stencilBuffer,this.depthTexture=options.depthTexture,this.samples=options.samples}setSize(width,height,depth=1){(this.width!==width||this.height!==height||this.depth!==depth)&&(this.width=width,this.height=height,this.depth=depth,this.texture.image.width=width,this.texture.image.height=height,this.texture.image.depth=depth,this.dispose()),this.viewport.set(0,0,width,height),this.scissor.set(0,0,width,height)}clone(){return new this.constructor().copy(this)}copy(source){this.width=source.width,this.height=source.height,this.depth=source.depth,this.scissor.copy(source.scissor),this.scissorTest=source.scissorTest,this.viewport.copy(source.viewport),this.texture=source.texture.clone(),this.texture.isRenderTargetTexture=!0;const image=Object.assign({},source.texture.image);return this.texture.source=new Source(image),this.depthBuffer=source.depthBuffer,this.stencilBuffer=source.stencilBuffer,source.depthTexture!==null&&(this.depthTexture=source.depthTexture.clone()),this.samples=source.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class WebGLRenderTarget extends RenderTarget{constructor(width=1,height=1,options={}){super(width,height,options),this.isWebGLRenderTarget=!0}}class DataArrayTexture extends Texture{constructor(data=null,width=1,height=1,depth=1){super(null),this.isDataArrayTexture=!0,this.image={data,width,height,depth},this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.wrapR=ClampToEdgeWrapping,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class WebGLArrayRenderTarget extends WebGLRenderTarget{constructor(width=1,height=1,depth=1){super(width,height),this.isWebGLArrayRenderTarget=!0,this.depth=depth,this.texture=new DataArrayTexture(null,width,height,depth),this.texture.isRenderTargetTexture=!0}}class Data3DTexture extends Texture{constructor(data=null,width=1,height=1,depth=1){super(null),this.isData3DTexture=!0,this.image={data,width,height,depth},this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.wrapR=ClampToEdgeWrapping,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class WebGL3DRenderTarget extends WebGLRenderTarget{constructor(width=1,height=1,depth=1){super(width,height),this.isWebGL3DRenderTarget=!0,this.depth=depth,this.texture=new Data3DTexture(null,width,height,depth),this.texture.isRenderTargetTexture=!0}}class WebGLMultipleRenderTargets extends WebGLRenderTarget{constructor(width=1,height=1,count=1,options={}){super(width,height,options),this.isWebGLMultipleRenderTargets=!0;const texture=this.texture;this.texture=[];for(let i2=0;i2<count;i2++)this.texture[i2]=texture.clone(),this.texture[i2].isRenderTargetTexture=!0}setSize(width,height,depth=1){if(this.width!==width||this.height!==height||this.depth!==depth){this.width=width,this.height=height,this.depth=depth;for(let i2=0,il=this.texture.length;i2<il;i2++)this.texture[i2].image.width=width,this.texture[i2].image.height=height,this.texture[i2].image.depth=depth;this.dispose()}this.viewport.set(0,0,width,height),this.scissor.set(0,0,width,height)}copy(source){this.dispose(),this.width=source.width,this.height=source.height,this.depth=source.depth,this.scissor.copy(source.scissor),this.scissorTest=source.scissorTest,this.viewport.copy(source.viewport),this.depthBuffer=source.depthBuffer,this.stencilBuffer=source.stencilBuffer,source.depthTexture!==null&&(this.depthTexture=source.depthTexture.clone()),this.texture.length=0;for(let i2=0,il=source.texture.length;i2<il;i2++)this.texture[i2]=source.texture[i2].clone(),this.texture[i2].isRenderTargetTexture=!0;return this}}class Quaternion{constructor(x2=0,y2=0,z=0,w2=1){this.isQuaternion=!0,this._x=x2,this._y=y2,this._z=z,this._w=w2}static slerpFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t2){let x0=src0[srcOffset0+0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3];const x1=src1[srcOffset1+0],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];if(t2===0){dst[dstOffset+0]=x0,dst[dstOffset+1]=y0,dst[dstOffset+2]=z0,dst[dstOffset+3]=w0;return}if(t2===1){dst[dstOffset+0]=x1,dst[dstOffset+1]=y1,dst[dstOffset+2]=z1,dst[dstOffset+3]=w1;return}if(w0!==w1||x0!==x1||y0!==y1||z0!==z1){let s2=1-t2;const cos=x0*x1+y0*y1+z0*z1+w0*w1,dir=cos>=0?1:-1,sqrSin=1-cos*cos;if(sqrSin>Number.EPSILON){const sin=Math.sqrt(sqrSin),len=Math.atan2(sin,cos*dir);s2=Math.sin(s2*len)/sin,t2=Math.sin(t2*len)/sin}const tDir=t2*dir;if(x0=x0*s2+x1*tDir,y0=y0*s2+y1*tDir,z0=z0*s2+z1*tDir,w0=w0*s2+w1*tDir,s2===1-t2){const f2=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);x0*=f2,y0*=f2,z0*=f2,w0*=f2}}dst[dstOffset]=x0,dst[dstOffset+1]=y0,dst[dstOffset+2]=z0,dst[dstOffset+3]=w0}static multiplyQuaternionsFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1){const x0=src0[srcOffset0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3],x1=src1[srcOffset1],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];return dst[dstOffset]=x0*w1+w0*x1+y0*z1-z0*y1,dst[dstOffset+1]=y0*w1+w0*y1+z0*x1-x0*z1,dst[dstOffset+2]=z0*w1+w0*z1+x0*y1-y0*x1,dst[dstOffset+3]=w0*w1-x0*x1-y0*y1-z0*z1,dst}get x(){return this._x}set x(value){this._x=value,this._onChangeCallback()}get y(){return this._y}set y(value){this._y=value,this._onChangeCallback()}get z(){return this._z}set z(value){this._z=value,this._onChangeCallback()}get w(){return this._w}set w(value){this._w=value,this._onChangeCallback()}set(x2,y2,z,w2){return this._x=x2,this._y=y2,this._z=z,this._w=w2,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(quaternion){return this._x=quaternion.x,this._y=quaternion.y,this._z=quaternion.z,this._w=quaternion.w,this._onChangeCallback(),this}setFromEuler(euler,update){const x2=euler._x,y2=euler._y,z=euler._z,order=euler._order,cos=Math.cos,sin=Math.sin,c1=cos(x2/2),c2=cos(y2/2),c3=cos(z/2),s1=sin(x2/2),s2=sin(y2/2),s3=sin(z/2);switch(order){case"XYZ":this._x=s1*c2*c3+c1*s2*s3,this._y=c1*s2*c3-s1*c2*s3,this._z=c1*c2*s3+s1*s2*c3,this._w=c1*c2*c3-s1*s2*s3;break;case"YXZ":this._x=s1*c2*c3+c1*s2*s3,this._y=c1*s2*c3-s1*c2*s3,this._z=c1*c2*s3-s1*s2*c3,this._w=c1*c2*c3+s1*s2*s3;break;case"ZXY":this._x=s1*c2*c3-c1*s2*s3,this._y=c1*s2*c3+s1*c2*s3,this._z=c1*c2*s3+s1*s2*c3,this._w=c1*c2*c3-s1*s2*s3;break;case"ZYX":this._x=s1*c2*c3-c1*s2*s3,this._y=c1*s2*c3+s1*c2*s3,this._z=c1*c2*s3-s1*s2*c3,this._w=c1*c2*c3+s1*s2*s3;break;case"YZX":this._x=s1*c2*c3+c1*s2*s3,this._y=c1*s2*c3+s1*c2*s3,this._z=c1*c2*s3-s1*s2*c3,this._w=c1*c2*c3-s1*s2*s3;break;case"XZY":this._x=s1*c2*c3-c1*s2*s3,this._y=c1*s2*c3-s1*c2*s3,this._z=c1*c2*s3+s1*s2*c3,this._w=c1*c2*c3+s1*s2*s3;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+order)}return update!==!1&&this._onChangeCallback(),this}setFromAxisAngle(axis,angle){const halfAngle=angle/2,s2=Math.sin(halfAngle);return this._x=axis.x*s2,this._y=axis.y*s2,this._z=axis.z*s2,this._w=Math.cos(halfAngle),this._onChangeCallback(),this}setFromRotationMatrix(m2){const te=m2.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10],trace=m11+m22+m33;if(trace>0){const s2=.5/Math.sqrt(trace+1);this._w=.25/s2,this._x=(m32-m23)*s2,this._y=(m13-m31)*s2,this._z=(m21-m12)*s2}else if(m11>m22&&m11>m33){const s2=2*Math.sqrt(1+m11-m22-m33);this._w=(m32-m23)/s2,this._x=.25*s2,this._y=(m12+m21)/s2,this._z=(m13+m31)/s2}else if(m22>m33){const s2=2*Math.sqrt(1+m22-m11-m33);this._w=(m13-m31)/s2,this._x=(m12+m21)/s2,this._y=.25*s2,this._z=(m23+m32)/s2}else{const s2=2*Math.sqrt(1+m33-m11-m22);this._w=(m21-m12)/s2,this._x=(m13+m31)/s2,this._y=(m23+m32)/s2,this._z=.25*s2}return this._onChangeCallback(),this}setFromUnitVectors(vFrom,vTo){let r2=vFrom.dot(vTo)+1;return r2<Number.EPSILON?(r2=0,Math.abs(vFrom.x)>Math.abs(vFrom.z)?(this._x=-vFrom.y,this._y=vFrom.x,this._z=0,this._w=r2):(this._x=0,this._y=-vFrom.z,this._z=vFrom.y,this._w=r2)):(this._x=vFrom.y*vTo.z-vFrom.z*vTo.y,this._y=vFrom.z*vTo.x-vFrom.x*vTo.z,this._z=vFrom.x*vTo.y-vFrom.y*vTo.x,this._w=r2),this.normalize()}angleTo(q){return 2*Math.acos(Math.abs(clamp(this.dot(q),-1,1)))}rotateTowards(q,step){const angle=this.angleTo(q);if(angle===0)return this;const t2=Math.min(1,step/angle);return this.slerp(q,t2),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(v4){return this._x*v4._x+this._y*v4._y+this._z*v4._z+this._w*v4._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let l2=this.length();return l2===0?(this._x=0,this._y=0,this._z=0,this._w=1):(l2=1/l2,this._x=this._x*l2,this._y=this._y*l2,this._z=this._z*l2,this._w=this._w*l2),this._onChangeCallback(),this}multiply(q){return this.multiplyQuaternions(this,q)}premultiply(q){return this.multiplyQuaternions(q,this)}multiplyQuaternions(a2,b2){const qax=a2._x,qay=a2._y,qaz=a2._z,qaw=a2._w,qbx=b2._x,qby=b2._y,qbz=b2._z,qbw=b2._w;return this._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby,this._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz,this._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx,this._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz,this._onChangeCallback(),this}slerp(qb,t2){if(t2===0)return this;if(t2===1)return this.copy(qb);const x2=this._x,y2=this._y,z=this._z,w2=this._w;let cosHalfTheta=w2*qb._w+x2*qb._x+y2*qb._y+z*qb._z;if(cosHalfTheta<0?(this._w=-qb._w,this._x=-qb._x,this._y=-qb._y,this._z=-qb._z,cosHalfTheta=-cosHalfTheta):this.copy(qb),cosHalfTheta>=1)return this._w=w2,this._x=x2,this._y=y2,this._z=z,this;const sqrSinHalfTheta=1-cosHalfTheta*cosHalfTheta;if(sqrSinHalfTheta<=Number.EPSILON){const s2=1-t2;return this._w=s2*w2+t2*this._w,this._x=s2*x2+t2*this._x,this._y=s2*y2+t2*this._y,this._z=s2*z+t2*this._z,this.normalize(),this._onChangeCallback(),this}const sinHalfTheta=Math.sqrt(sqrSinHalfTheta),halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta),ratioA=Math.sin((1-t2)*halfTheta)/sinHalfTheta,ratioB=Math.sin(t2*halfTheta)/sinHalfTheta;return this._w=w2*ratioA+this._w*ratioB,this._x=x2*ratioA+this._x*ratioB,this._y=y2*ratioA+this._y*ratioB,this._z=z*ratioA+this._z*ratioB,this._onChangeCallback(),this}slerpQuaternions(qa,qb,t2){return this.copy(qa).slerp(qb,t2)}random(){const u1=Math.random(),sqrt1u1=Math.sqrt(1-u1),sqrtu1=Math.sqrt(u1),u2=2*Math.PI*Math.random(),u3=2*Math.PI*Math.random();return this.set(sqrt1u1*Math.cos(u2),sqrtu1*Math.sin(u3),sqrtu1*Math.cos(u3),sqrt1u1*Math.sin(u2))}equals(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w}fromArray(array,offset=0){return this._x=array[offset],this._y=array[offset+1],this._z=array[offset+2],this._w=array[offset+3],this._onChangeCallback(),this}toArray(array=[],offset=0){return array[offset]=this._x,array[offset+1]=this._y,array[offset+2]=this._z,array[offset+3]=this._w,array}fromBufferAttribute(attribute,index){return this._x=attribute.getX(index),this._y=attribute.getY(index),this._z=attribute.getZ(index),this._w=attribute.getW(index),this}toJSON(){return this.toArray()}_onChange(callback){return this._onChangeCallback=callback,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Vector3{constructor(x2=0,y2=0,z=0){Vector3.prototype.isVector3=!0,this.x=x2,this.y=y2,this.z=z}set(x2,y2,z){return z===void 0&&(z=this.z),this.x=x2,this.y=y2,this.z=z,this}setScalar(scalar){return this.x=scalar,this.y=scalar,this.z=scalar,this}setX(x2){return this.x=x2,this}setY(y2){return this.y=y2,this}setZ(z){return this.z=z,this}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;default:throw new Error("index is out of range: "+index)}return this}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+index)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(v4){return this.x=v4.x,this.y=v4.y,this.z=v4.z,this}add(v4){return this.x+=v4.x,this.y+=v4.y,this.z+=v4.z,this}addScalar(s2){return this.x+=s2,this.y+=s2,this.z+=s2,this}addVectors(a2,b2){return this.x=a2.x+b2.x,this.y=a2.y+b2.y,this.z=a2.z+b2.z,this}addScaledVector(v4,s2){return this.x+=v4.x*s2,this.y+=v4.y*s2,this.z+=v4.z*s2,this}sub(v4){return this.x-=v4.x,this.y-=v4.y,this.z-=v4.z,this}subScalar(s2){return this.x-=s2,this.y-=s2,this.z-=s2,this}subVectors(a2,b2){return this.x=a2.x-b2.x,this.y=a2.y-b2.y,this.z=a2.z-b2.z,this}multiply(v4){return this.x*=v4.x,this.y*=v4.y,this.z*=v4.z,this}multiplyScalar(scalar){return this.x*=scalar,this.y*=scalar,this.z*=scalar,this}multiplyVectors(a2,b2){return this.x=a2.x*b2.x,this.y=a2.y*b2.y,this.z=a2.z*b2.z,this}applyEuler(euler){return this.applyQuaternion(_quaternion$4.setFromEuler(euler))}applyAxisAngle(axis,angle){return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis,angle))}applyMatrix3(m2){const x2=this.x,y2=this.y,z=this.z,e2=m2.elements;return this.x=e2[0]*x2+e2[3]*y2+e2[6]*z,this.y=e2[1]*x2+e2[4]*y2+e2[7]*z,this.z=e2[2]*x2+e2[5]*y2+e2[8]*z,this}applyNormalMatrix(m2){return this.applyMatrix3(m2).normalize()}applyMatrix4(m2){const x2=this.x,y2=this.y,z=this.z,e2=m2.elements,w2=1/(e2[3]*x2+e2[7]*y2+e2[11]*z+e2[15]);return this.x=(e2[0]*x2+e2[4]*y2+e2[8]*z+e2[12])*w2,this.y=(e2[1]*x2+e2[5]*y2+e2[9]*z+e2[13])*w2,this.z=(e2[2]*x2+e2[6]*y2+e2[10]*z+e2[14])*w2,this}applyQuaternion(q){const vx=this.x,vy=this.y,vz=this.z,qx=q.x,qy=q.y,qz=q.z,qw=q.w,tx=2*(qy*vz-qz*vy),ty=2*(qz*vx-qx*vz),tz=2*(qx*vy-qy*vx);return this.x=vx+qw*tx+qy*tz-qz*ty,this.y=vy+qw*ty+qz*tx-qx*tz,this.z=vz+qw*tz+qx*ty-qy*tx,this}project(camera){return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix)}unproject(camera){return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld)}transformDirection(m2){const x2=this.x,y2=this.y,z=this.z,e2=m2.elements;return this.x=e2[0]*x2+e2[4]*y2+e2[8]*z,this.y=e2[1]*x2+e2[5]*y2+e2[9]*z,this.z=e2[2]*x2+e2[6]*y2+e2[10]*z,this.normalize()}divide(v4){return this.x/=v4.x,this.y/=v4.y,this.z/=v4.z,this}divideScalar(scalar){return this.multiplyScalar(1/scalar)}min(v4){return this.x=Math.min(this.x,v4.x),this.y=Math.min(this.y,v4.y),this.z=Math.min(this.z,v4.z),this}max(v4){return this.x=Math.max(this.x,v4.x),this.y=Math.max(this.y,v4.y),this.z=Math.max(this.z,v4.z),this}clamp(min,max2){return this.x=Math.max(min.x,Math.min(max2.x,this.x)),this.y=Math.max(min.y,Math.min(max2.y,this.y)),this.z=Math.max(min.z,Math.min(max2.z,this.z)),this}clampScalar(minVal,maxVal){return this.x=Math.max(minVal,Math.min(maxVal,this.x)),this.y=Math.max(minVal,Math.min(maxVal,this.y)),this.z=Math.max(minVal,Math.min(maxVal,this.z)),this}clampLength(min,max2){const length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max2,length)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(v4){return this.x*v4.x+this.y*v4.y+this.z*v4.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(length){return this.normalize().multiplyScalar(length)}lerp(v4,alpha2){return this.x+=(v4.x-this.x)*alpha2,this.y+=(v4.y-this.y)*alpha2,this.z+=(v4.z-this.z)*alpha2,this}lerpVectors(v12,v22,alpha2){return this.x=v12.x+(v22.x-v12.x)*alpha2,this.y=v12.y+(v22.y-v12.y)*alpha2,this.z=v12.z+(v22.z-v12.z)*alpha2,this}cross(v4){return this.crossVectors(this,v4)}crossVectors(a2,b2){const ax=a2.x,ay=a2.y,az=a2.z,bx=b2.x,by=b2.y,bz=b2.z;return this.x=ay*bz-az*by,this.y=az*bx-ax*bz,this.z=ax*by-ay*bx,this}projectOnVector(v4){const denominator=v4.lengthSq();if(denominator===0)return this.set(0,0,0);const scalar=v4.dot(this)/denominator;return this.copy(v4).multiplyScalar(scalar)}projectOnPlane(planeNormal){return _vector$b.copy(this).projectOnVector(planeNormal),this.sub(_vector$b)}reflect(normal){return this.sub(_vector$b.copy(normal).multiplyScalar(2*this.dot(normal)))}angleTo(v4){const denominator=Math.sqrt(this.lengthSq()*v4.lengthSq());if(denominator===0)return Math.PI/2;const theta=this.dot(v4)/denominator;return Math.acos(clamp(theta,-1,1))}distanceTo(v4){return Math.sqrt(this.distanceToSquared(v4))}distanceToSquared(v4){const dx=this.x-v4.x,dy=this.y-v4.y,dz=this.z-v4.z;return dx*dx+dy*dy+dz*dz}manhattanDistanceTo(v4){return Math.abs(this.x-v4.x)+Math.abs(this.y-v4.y)+Math.abs(this.z-v4.z)}setFromSpherical(s2){return this.setFromSphericalCoords(s2.radius,s2.phi,s2.theta)}setFromSphericalCoords(radius,phi,theta){const sinPhiRadius=Math.sin(phi)*radius;return this.x=sinPhiRadius*Math.sin(theta),this.y=Math.cos(phi)*radius,this.z=sinPhiRadius*Math.cos(theta),this}setFromCylindrical(c2){return this.setFromCylindricalCoords(c2.radius,c2.theta,c2.y)}setFromCylindricalCoords(radius,theta,y2){return this.x=radius*Math.sin(theta),this.y=y2,this.z=radius*Math.cos(theta),this}setFromMatrixPosition(m2){const e2=m2.elements;return this.x=e2[12],this.y=e2[13],this.z=e2[14],this}setFromMatrixScale(m2){const sx=this.setFromMatrixColumn(m2,0).length(),sy=this.setFromMatrixColumn(m2,1).length(),sz=this.setFromMatrixColumn(m2,2).length();return this.x=sx,this.y=sy,this.z=sz,this}setFromMatrixColumn(m2,index){return this.fromArray(m2.elements,index*4)}setFromMatrix3Column(m2,index){return this.fromArray(m2.elements,index*3)}setFromEuler(e2){return this.x=e2._x,this.y=e2._y,this.z=e2._z,this}setFromColor(c2){return this.x=c2.r,this.y=c2.g,this.z=c2.b,this}equals(v4){return v4.x===this.x&&v4.y===this.y&&v4.z===this.z}fromArray(array,offset=0){return this.x=array[offset],this.y=array[offset+1],this.z=array[offset+2],this}toArray(array=[],offset=0){return array[offset]=this.x,array[offset+1]=this.y,array[offset+2]=this.z,array}fromBufferAttribute(attribute,index){return this.x=attribute.getX(index),this.y=attribute.getY(index),this.z=attribute.getZ(index),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const u2=(Math.random()-.5)*2,t2=Math.random()*Math.PI*2,f2=Math.sqrt(1-u2**2);return this.x=f2*Math.cos(t2),this.y=f2*Math.sin(t2),this.z=u2,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const _vector$b=new Vector3,_quaternion$4=new Quaternion;class Box3{constructor(min=new Vector3(1/0,1/0,1/0),max2=new Vector3(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=min,this.max=max2}set(min,max2){return this.min.copy(min),this.max.copy(max2),this}setFromArray(array){this.makeEmpty();for(let i2=0,il=array.length;i2<il;i2+=3)this.expandByPoint(_vector$a.fromArray(array,i2));return this}setFromBufferAttribute(attribute){this.makeEmpty();for(let i2=0,il=attribute.count;i2<il;i2++)this.expandByPoint(_vector$a.fromBufferAttribute(attribute,i2));return this}setFromPoints(points){this.makeEmpty();for(let i2=0,il=points.length;i2<il;i2++)this.expandByPoint(points[i2]);return this}setFromCenterAndSize(center,size){const halfSize=_vector$a.copy(size).multiplyScalar(.5);return this.min.copy(center).sub(halfSize),this.max.copy(center).add(halfSize),this}setFromObject(object,precise=!1){return this.makeEmpty(),this.expandByObject(object,precise)}clone(){return new this.constructor().copy(this)}copy(box){return this.min.copy(box.min),this.max.copy(box.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(target){return this.isEmpty()?target.set(0,0,0):target.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(target){return this.isEmpty()?target.set(0,0,0):target.subVectors(this.max,this.min)}expandByPoint(point){return this.min.min(point),this.max.max(point),this}expandByVector(vector){return this.min.sub(vector),this.max.add(vector),this}expandByScalar(scalar){return this.min.addScalar(-scalar),this.max.addScalar(scalar),this}expandByObject(object,precise=!1){object.updateWorldMatrix(!1,!1);const geometry=object.geometry;if(geometry!==void 0){const positionAttribute=geometry.getAttribute("position");if(precise===!0&&positionAttribute!==void 0&&object.isInstancedMesh!==!0)for(let i2=0,l2=positionAttribute.count;i2<l2;i2++)object.isMesh===!0?object.getVertexPosition(i2,_vector$a):_vector$a.fromBufferAttribute(positionAttribute,i2),_vector$a.applyMatrix4(object.matrixWorld),this.expandByPoint(_vector$a);else object.boundingBox!==void 0?(object.boundingBox===null&&object.computeBoundingBox(),_box$3.copy(object.boundingBox)):(geometry.boundingBox===null&&geometry.computeBoundingBox(),_box$3.copy(geometry.boundingBox)),_box$3.applyMatrix4(object.matrixWorld),this.union(_box$3)}const children=object.children;for(let i2=0,l2=children.length;i2<l2;i2++)this.expandByObject(children[i2],precise);return this}containsPoint(point){return!(point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y||point.z<this.min.z||point.z>this.max.z)}containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z}getParameter(point,target){return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(box){return!(box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y||box.max.z<this.min.z||box.min.z>this.max.z)}intersectsSphere(sphere){return this.clampPoint(sphere.center,_vector$a),_vector$a.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius}intersectsPlane(plane){let min,max2;return plane.normal.x>0?(min=plane.normal.x*this.min.x,max2=plane.normal.x*this.max.x):(min=plane.normal.x*this.max.x,max2=plane.normal.x*this.min.x),plane.normal.y>0?(min+=plane.normal.y*this.min.y,max2+=plane.normal.y*this.max.y):(min+=plane.normal.y*this.max.y,max2+=plane.normal.y*this.min.y),plane.normal.z>0?(min+=plane.normal.z*this.min.z,max2+=plane.normal.z*this.max.z):(min+=plane.normal.z*this.max.z,max2+=plane.normal.z*this.min.z),min<=-plane.constant&&max2>=-plane.constant}intersectsTriangle(triangle){if(this.isEmpty())return!1;this.getCenter(_center),_extents.subVectors(this.max,_center),_v0$2.subVectors(triangle.a,_center),_v1$7.subVectors(triangle.b,_center),_v2$4.subVectors(triangle.c,_center),_f0.subVectors(_v1$7,_v0$2),_f1.subVectors(_v2$4,_v1$7),_f2.subVectors(_v0$2,_v2$4);let axes=[0,-_f0.z,_f0.y,0,-_f1.z,_f1.y,0,-_f2.z,_f2.y,_f0.z,0,-_f0.x,_f1.z,0,-_f1.x,_f2.z,0,-_f2.x,-_f0.y,_f0.x,0,-_f1.y,_f1.x,0,-_f2.y,_f2.x,0];return!satForAxes(axes,_v0$2,_v1$7,_v2$4,_extents)||(axes=[1,0,0,0,1,0,0,0,1],!satForAxes(axes,_v0$2,_v1$7,_v2$4,_extents))?!1:(_triangleNormal.crossVectors(_f0,_f1),axes=[_triangleNormal.x,_triangleNormal.y,_triangleNormal.z],satForAxes(axes,_v0$2,_v1$7,_v2$4,_extents))}clampPoint(point,target){return target.copy(point).clamp(this.min,this.max)}distanceToPoint(point){return this.clampPoint(point,_vector$a).distanceTo(point)}getBoundingSphere(target){return this.isEmpty()?target.makeEmpty():(this.getCenter(target.center),target.radius=this.getSize(_vector$a).length()*.5),target}intersect(box){return this.min.max(box.min),this.max.min(box.max),this.isEmpty()&&this.makeEmpty(),this}union(box){return this.min.min(box.min),this.max.max(box.max),this}applyMatrix4(matrix){return this.isEmpty()?this:(_points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix),_points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix),_points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix),_points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix),_points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix),_points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix),_points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix),_points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix),this.setFromPoints(_points),this)}translate(offset){return this.min.add(offset),this.max.add(offset),this}equals(box){return box.min.equals(this.min)&&box.max.equals(this.max)}}const _points=[new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3],_vector$a=new Vector3,_box$3=new Box3,_v0$2=new Vector3,_v1$7=new Vector3,_v2$4=new Vector3,_f0=new Vector3,_f1=new Vector3,_f2=new Vector3,_center=new Vector3,_extents=new Vector3,_triangleNormal=new Vector3,_testAxis=new Vector3;function satForAxes(axes,v0,v12,v22,extents){for(let i2=0,j2=axes.length-3;i2<=j2;i2+=3){_testAxis.fromArray(axes,i2);const r2=extents.x*Math.abs(_testAxis.x)+extents.y*Math.abs(_testAxis.y)+extents.z*Math.abs(_testAxis.z),p0=v0.dot(_testAxis),p1=v12.dot(_testAxis),p2=v22.dot(_testAxis);if(Math.max(-Math.max(p0,p1,p2),Math.min(p0,p1,p2))>r2)return!1}return!0}const _box$2=new Box3,_v1$6=new Vector3,_v2$3=new Vector3;class Sphere{constructor(center=new Vector3,radius=-1){this.center=center,this.radius=radius}set(center,radius){return this.center.copy(center),this.radius=radius,this}setFromPoints(points,optionalCenter){const center=this.center;optionalCenter!==void 0?center.copy(optionalCenter):_box$2.setFromPoints(points).getCenter(center);let maxRadiusSq=0;for(let i2=0,il=points.length;i2<il;i2++)maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[i2]));return this.radius=Math.sqrt(maxRadiusSq),this}copy(sphere){return this.center.copy(sphere.center),this.radius=sphere.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(point){return point.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(point){return point.distanceTo(this.center)-this.radius}intersectsSphere(sphere){const radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum}intersectsBox(box){return box.intersectsSphere(this)}intersectsPlane(plane){return Math.abs(plane.distanceToPoint(this.center))<=this.radius}clampPoint(point,target){const deltaLengthSq=this.center.distanceToSquared(point);return target.copy(point),deltaLengthSq>this.radius*this.radius&&(target.sub(this.center).normalize(),target.multiplyScalar(this.radius).add(this.center)),target}getBoundingBox(target){return this.isEmpty()?(target.makeEmpty(),target):(target.set(this.center,this.center),target.expandByScalar(this.radius),target)}applyMatrix4(matrix){return this.center.applyMatrix4(matrix),this.radius=this.radius*matrix.getMaxScaleOnAxis(),this}translate(offset){return this.center.add(offset),this}expandByPoint(point){if(this.isEmpty())return this.center.copy(point),this.radius=0,this;_v1$6.subVectors(point,this.center);const lengthSq=_v1$6.lengthSq();if(lengthSq>this.radius*this.radius){const length=Math.sqrt(lengthSq),delta=(length-this.radius)*.5;this.center.addScaledVector(_v1$6,delta/length),this.radius+=delta}return this}union(sphere){return sphere.isEmpty()?this:this.isEmpty()?(this.copy(sphere),this):(this.center.equals(sphere.center)===!0?this.radius=Math.max(this.radius,sphere.radius):(_v2$3.subVectors(sphere.center,this.center).setLength(sphere.radius),this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3)),this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3))),this)}equals(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius}clone(){return new this.constructor().copy(this)}}const _vector$9=new Vector3,_segCenter=new Vector3,_segDir=new Vector3,_diff=new Vector3,_edge1=new Vector3,_edge2=new Vector3,_normal$1=new Vector3;class Ray{constructor(origin=new Vector3,direction=new Vector3(0,0,-1)){this.origin=origin,this.direction=direction}set(origin,direction){return this.origin.copy(origin),this.direction.copy(direction),this}copy(ray){return this.origin.copy(ray.origin),this.direction.copy(ray.direction),this}at(t2,target){return target.copy(this.origin).addScaledVector(this.direction,t2)}lookAt(v4){return this.direction.copy(v4).sub(this.origin).normalize(),this}recast(t2){return this.origin.copy(this.at(t2,_vector$9)),this}closestPointToPoint(point,target){target.subVectors(point,this.origin);const directionDistance=target.dot(this.direction);return directionDistance<0?target.copy(this.origin):target.copy(this.origin).addScaledVector(this.direction,directionDistance)}distanceToPoint(point){return Math.sqrt(this.distanceSqToPoint(point))}distanceSqToPoint(point){const directionDistance=_vector$9.subVectors(point,this.origin).dot(this.direction);return directionDistance<0?this.origin.distanceToSquared(point):(_vector$9.copy(this.origin).addScaledVector(this.direction,directionDistance),_vector$9.distanceToSquared(point))}distanceSqToSegment(v0,v12,optionalPointOnRay,optionalPointOnSegment){_segCenter.copy(v0).add(v12).multiplyScalar(.5),_segDir.copy(v12).sub(v0).normalize(),_diff.copy(this.origin).sub(_segCenter);const segExtent=v0.distanceTo(v12)*.5,a01=-this.direction.dot(_segDir),b0=_diff.dot(this.direction),b1=-_diff.dot(_segDir),c2=_diff.lengthSq(),det=Math.abs(1-a01*a01);let s0,s1,sqrDist,extDet;if(det>0)if(s0=a01*b1-b0,s1=a01*b0-b1,extDet=segExtent*det,s0>=0)if(s1>=-extDet)if(s1<=extDet){const invDet=1/det;s0*=invDet,s1*=invDet,sqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c2}else s1=segExtent,s0=Math.max(0,-(a01*s1+b0)),sqrDist=-s0*s0+s1*(s1+2*b1)+c2;else s1=-segExtent,s0=Math.max(0,-(a01*s1+b0)),sqrDist=-s0*s0+s1*(s1+2*b1)+c2;else s1<=-extDet?(s0=Math.max(0,-(-a01*segExtent+b0)),s1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent),sqrDist=-s0*s0+s1*(s1+2*b1)+c2):s1<=extDet?(s0=0,s1=Math.min(Math.max(-segExtent,-b1),segExtent),sqrDist=s1*(s1+2*b1)+c2):(s0=Math.max(0,-(a01*segExtent+b0)),s1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent),sqrDist=-s0*s0+s1*(s1+2*b1)+c2);else s1=a01>0?-segExtent:segExtent,s0=Math.max(0,-(a01*s1+b0)),sqrDist=-s0*s0+s1*(s1+2*b1)+c2;return optionalPointOnRay&&optionalPointOnRay.copy(this.origin).addScaledVector(this.direction,s0),optionalPointOnSegment&&optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir,s1),sqrDist}intersectSphere(sphere,target){_vector$9.subVectors(sphere.center,this.origin);const tca=_vector$9.dot(this.direction),d2=_vector$9.dot(_vector$9)-tca*tca,radius2=sphere.radius*sphere.radius;if(d2>radius2)return null;const thc=Math.sqrt(radius2-d2),t0=tca-thc,t1=tca+thc;return t1<0?null:t0<0?this.at(t1,target):this.at(t0,target)}intersectsSphere(sphere){return this.distanceSqToPoint(sphere.center)<=sphere.radius*sphere.radius}distanceToPlane(plane){const denominator=plane.normal.dot(this.direction);if(denominator===0)return plane.distanceToPoint(this.origin)===0?0:null;const t2=-(this.origin.dot(plane.normal)+plane.constant)/denominator;return t2>=0?t2:null}intersectPlane(plane,target){const t2=this.distanceToPlane(plane);return t2===null?null:this.at(t2,target)}intersectsPlane(plane){const distToPoint=plane.distanceToPoint(this.origin);return distToPoint===0||plane.normal.dot(this.direction)*distToPoint<0}intersectBox(box,target){let tmin,tmax,tymin,tymax,tzmin,tzmax;const invdirx=1/this.direction.x,invdiry=1/this.direction.y,invdirz=1/this.direction.z,origin=this.origin;return invdirx>=0?(tmin=(box.min.x-origin.x)*invdirx,tmax=(box.max.x-origin.x)*invdirx):(tmin=(box.max.x-origin.x)*invdirx,tmax=(box.min.x-origin.x)*invdirx),invdiry>=0?(tymin=(box.min.y-origin.y)*invdiry,tymax=(box.max.y-origin.y)*invdiry):(tymin=(box.max.y-origin.y)*invdiry,tymax=(box.min.y-origin.y)*invdiry),tmin>tymax||tymin>tmax||((tymin>tmin||isNaN(tmin))&&(tmin=tymin),(tymax<tmax||isNaN(tmax))&&(tmax=tymax),invdirz>=0?(tzmin=(box.min.z-origin.z)*invdirz,tzmax=(box.max.z-origin.z)*invdirz):(tzmin=(box.max.z-origin.z)*invdirz,tzmax=(box.min.z-origin.z)*invdirz),tmin>tzmax||tzmin>tmax)||((tzmin>tmin||tmin!==tmin)&&(tmin=tzmin),(tzmax<tmax||tmax!==tmax)&&(tmax=tzmax),tmax<0)?null:this.at(tmin>=0?tmin:tmax,target)}intersectsBox(box){return this.intersectBox(box,_vector$9)!==null}intersectTriangle(a2,b2,c2,backfaceCulling,target){_edge1.subVectors(b2,a2),_edge2.subVectors(c2,a2),_normal$1.crossVectors(_edge1,_edge2);let DdN=this.direction.dot(_normal$1),sign2;if(DdN>0){if(backfaceCulling)return null;sign2=1}else if(DdN<0)sign2=-1,DdN=-DdN;else return null;_diff.subVectors(this.origin,a2);const DdQxE2=sign2*this.direction.dot(_edge2.crossVectors(_diff,_edge2));if(DdQxE2<0)return null;const DdE1xQ=sign2*this.direction.dot(_edge1.cross(_diff));if(DdE1xQ<0||DdQxE2+DdE1xQ>DdN)return null;const QdN=-sign2*_diff.dot(_normal$1);return QdN<0?null:this.at(QdN/DdN,target)}applyMatrix4(matrix4){return this.origin.applyMatrix4(matrix4),this.direction.transformDirection(matrix4),this}equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class Matrix4{constructor(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){Matrix4.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],n11!==void 0&&this.set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44)}set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){const te=this.elements;return te[0]=n11,te[4]=n12,te[8]=n13,te[12]=n14,te[1]=n21,te[5]=n22,te[9]=n23,te[13]=n24,te[2]=n31,te[6]=n32,te[10]=n33,te[14]=n34,te[3]=n41,te[7]=n42,te[11]=n43,te[15]=n44,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Matrix4().fromArray(this.elements)}copy(m2){const te=this.elements,me=m2.elements;return te[0]=me[0],te[1]=me[1],te[2]=me[2],te[3]=me[3],te[4]=me[4],te[5]=me[5],te[6]=me[6],te[7]=me[7],te[8]=me[8],te[9]=me[9],te[10]=me[10],te[11]=me[11],te[12]=me[12],te[13]=me[13],te[14]=me[14],te[15]=me[15],this}copyPosition(m2){const te=this.elements,me=m2.elements;return te[12]=me[12],te[13]=me[13],te[14]=me[14],this}setFromMatrix3(m2){const me=m2.elements;return this.set(me[0],me[3],me[6],0,me[1],me[4],me[7],0,me[2],me[5],me[8],0,0,0,0,1),this}extractBasis(xAxis,yAxis,zAxis){return xAxis.setFromMatrixColumn(this,0),yAxis.setFromMatrixColumn(this,1),zAxis.setFromMatrixColumn(this,2),this}makeBasis(xAxis,yAxis,zAxis){return this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1),this}extractRotation(m2){const te=this.elements,me=m2.elements,scaleX=1/_v1$5.setFromMatrixColumn(m2,0).length(),scaleY=1/_v1$5.setFromMatrixColumn(m2,1).length(),scaleZ=1/_v1$5.setFromMatrixColumn(m2,2).length();return te[0]=me[0]*scaleX,te[1]=me[1]*scaleX,te[2]=me[2]*scaleX,te[3]=0,te[4]=me[4]*scaleY,te[5]=me[5]*scaleY,te[6]=me[6]*scaleY,te[7]=0,te[8]=me[8]*scaleZ,te[9]=me[9]*scaleZ,te[10]=me[10]*scaleZ,te[11]=0,te[12]=0,te[13]=0,te[14]=0,te[15]=1,this}makeRotationFromEuler(euler){const te=this.elements,x2=euler.x,y2=euler.y,z=euler.z,a2=Math.cos(x2),b2=Math.sin(x2),c2=Math.cos(y2),d2=Math.sin(y2),e2=Math.cos(z),f2=Math.sin(z);if(euler.order==="XYZ"){const ae=a2*e2,af=a2*f2,be=b2*e2,bf=b2*f2;te[0]=c2*e2,te[4]=-c2*f2,te[8]=d2,te[1]=af+be*d2,te[5]=ae-bf*d2,te[9]=-b2*c2,te[2]=bf-ae*d2,te[6]=be+af*d2,te[10]=a2*c2}else if(euler.order==="YXZ"){const ce=c2*e2,cf=c2*f2,de=d2*e2,df=d2*f2;te[0]=ce+df*b2,te[4]=de*b2-cf,te[8]=a2*d2,te[1]=a2*f2,te[5]=a2*e2,te[9]=-b2,te[2]=cf*b2-de,te[6]=df+ce*b2,te[10]=a2*c2}else if(euler.order==="ZXY"){const ce=c2*e2,cf=c2*f2,de=d2*e2,df=d2*f2;te[0]=ce-df*b2,te[4]=-a2*f2,te[8]=de+cf*b2,te[1]=cf+de*b2,te[5]=a2*e2,te[9]=df-ce*b2,te[2]=-a2*d2,te[6]=b2,te[10]=a2*c2}else if(euler.order==="ZYX"){const ae=a2*e2,af=a2*f2,be=b2*e2,bf=b2*f2;te[0]=c2*e2,te[4]=be*d2-af,te[8]=ae*d2+bf,te[1]=c2*f2,te[5]=bf*d2+ae,te[9]=af*d2-be,te[2]=-d2,te[6]=b2*c2,te[10]=a2*c2}else if(euler.order==="YZX"){const ac=a2*c2,ad=a2*d2,bc=b2*c2,bd=b2*d2;te[0]=c2*e2,te[4]=bd-ac*f2,te[8]=bc*f2+ad,te[1]=f2,te[5]=a2*e2,te[9]=-b2*e2,te[2]=-d2*e2,te[6]=ad*f2+bc,te[10]=ac-bd*f2}else if(euler.order==="XZY"){const ac=a2*c2,ad=a2*d2,bc=b2*c2,bd=b2*d2;te[0]=c2*e2,te[4]=-f2,te[8]=d2*e2,te[1]=ac*f2+bd,te[5]=a2*e2,te[9]=ad*f2-bc,te[2]=bc*f2-ad,te[6]=b2*e2,te[10]=bd*f2+ac}return te[3]=0,te[7]=0,te[11]=0,te[12]=0,te[13]=0,te[14]=0,te[15]=1,this}makeRotationFromQuaternion(q){return this.compose(_zero,q,_one)}lookAt(eye,target,up){const te=this.elements;return _z.subVectors(eye,target),_z.lengthSq()===0&&(_z.z=1),_z.normalize(),_x.crossVectors(up,_z),_x.lengthSq()===0&&(Math.abs(up.z)===1?_z.x+=1e-4:_z.z+=1e-4,_z.normalize(),_x.crossVectors(up,_z)),_x.normalize(),_y.crossVectors(_z,_x),te[0]=_x.x,te[4]=_y.x,te[8]=_z.x,te[1]=_x.y,te[5]=_y.y,te[9]=_z.y,te[2]=_x.z,te[6]=_y.z,te[10]=_z.z,this}multiply(m2){return this.multiplyMatrices(this,m2)}premultiply(m2){return this.multiplyMatrices(m2,this)}multiplyMatrices(a2,b2){const ae=a2.elements,be=b2.elements,te=this.elements,a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12],a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13],a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14],a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15],b11=be[0],b12=be[4],b13=be[8],b14=be[12],b21=be[1],b22=be[5],b23=be[9],b24=be[13],b31=be[2],b32=be[6],b33=be[10],b34=be[14],b41=be[3],b42=be[7],b43=be[11],b44=be[15];return te[0]=a11*b11+a12*b21+a13*b31+a14*b41,te[4]=a11*b12+a12*b22+a13*b32+a14*b42,te[8]=a11*b13+a12*b23+a13*b33+a14*b43,te[12]=a11*b14+a12*b24+a13*b34+a14*b44,te[1]=a21*b11+a22*b21+a23*b31+a24*b41,te[5]=a21*b12+a22*b22+a23*b32+a24*b42,te[9]=a21*b13+a22*b23+a23*b33+a24*b43,te[13]=a21*b14+a22*b24+a23*b34+a24*b44,te[2]=a31*b11+a32*b21+a33*b31+a34*b41,te[6]=a31*b12+a32*b22+a33*b32+a34*b42,te[10]=a31*b13+a32*b23+a33*b33+a34*b43,te[14]=a31*b14+a32*b24+a33*b34+a34*b44,te[3]=a41*b11+a42*b21+a43*b31+a44*b41,te[7]=a41*b12+a42*b22+a43*b32+a44*b42,te[11]=a41*b13+a42*b23+a43*b33+a44*b43,te[15]=a41*b14+a42*b24+a43*b34+a44*b44,this}multiplyScalar(s2){const te=this.elements;return te[0]*=s2,te[4]*=s2,te[8]*=s2,te[12]*=s2,te[1]*=s2,te[5]*=s2,te[9]*=s2,te[13]*=s2,te[2]*=s2,te[6]*=s2,te[10]*=s2,te[14]*=s2,te[3]*=s2,te[7]*=s2,te[11]*=s2,te[15]*=s2,this}determinant(){const te=this.elements,n11=te[0],n12=te[4],n13=te[8],n14=te[12],n21=te[1],n22=te[5],n23=te[9],n24=te[13],n31=te[2],n32=te[6],n33=te[10],n34=te[14],n41=te[3],n42=te[7],n43=te[11],n44=te[15];return n41*(+n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34)+n42*(+n11*n23*n34-n11*n24*n33+n14*n21*n33-n13*n21*n34+n13*n24*n31-n14*n23*n31)+n43*(+n11*n24*n32-n11*n22*n34-n14*n21*n32+n12*n21*n34+n14*n22*n31-n12*n24*n31)+n44*(-n13*n22*n31-n11*n23*n32+n11*n22*n33+n13*n21*n32-n12*n21*n33+n12*n23*n31)}transpose(){const te=this.elements;let tmp2;return tmp2=te[1],te[1]=te[4],te[4]=tmp2,tmp2=te[2],te[2]=te[8],te[8]=tmp2,tmp2=te[6],te[6]=te[9],te[9]=tmp2,tmp2=te[3],te[3]=te[12],te[12]=tmp2,tmp2=te[7],te[7]=te[13],te[13]=tmp2,tmp2=te[11],te[11]=te[14],te[14]=tmp2,this}setPosition(x2,y2,z){const te=this.elements;return x2.isVector3?(te[12]=x2.x,te[13]=x2.y,te[14]=x2.z):(te[12]=x2,te[13]=y2,te[14]=z),this}invert(){const te=this.elements,n11=te[0],n21=te[1],n31=te[2],n41=te[3],n12=te[4],n22=te[5],n32=te[6],n42=te[7],n13=te[8],n23=te[9],n33=te[10],n43=te[11],n14=te[12],n24=te[13],n34=te[14],n44=te[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34,det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const detInv=1/det;return te[0]=t11*detInv,te[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv,te[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv,te[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv,te[4]=t12*detInv,te[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv,te[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv,te[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv,te[8]=t13*detInv,te[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv,te[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv,te[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv,te[12]=t14*detInv,te[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv,te[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv,te[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv,this}scale(v4){const te=this.elements,x2=v4.x,y2=v4.y,z=v4.z;return te[0]*=x2,te[4]*=y2,te[8]*=z,te[1]*=x2,te[5]*=y2,te[9]*=z,te[2]*=x2,te[6]*=y2,te[10]*=z,te[3]*=x2,te[7]*=y2,te[11]*=z,this}getMaxScaleOnAxis(){const te=this.elements,scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2],scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6],scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq))}makeTranslation(x2,y2,z){return x2.isVector3?this.set(1,0,0,x2.x,0,1,0,x2.y,0,0,1,x2.z,0,0,0,1):this.set(1,0,0,x2,0,1,0,y2,0,0,1,z,0,0,0,1),this}makeRotationX(theta){const c2=Math.cos(theta),s2=Math.sin(theta);return this.set(1,0,0,0,0,c2,-s2,0,0,s2,c2,0,0,0,0,1),this}makeRotationY(theta){const c2=Math.cos(theta),s2=Math.sin(theta);return this.set(c2,0,s2,0,0,1,0,0,-s2,0,c2,0,0,0,0,1),this}makeRotationZ(theta){const c2=Math.cos(theta),s2=Math.sin(theta);return this.set(c2,-s2,0,0,s2,c2,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(axis,angle){const c2=Math.cos(angle),s2=Math.sin(angle),t2=1-c2,x2=axis.x,y2=axis.y,z=axis.z,tx=t2*x2,ty=t2*y2;return this.set(tx*x2+c2,tx*y2-s2*z,tx*z+s2*y2,0,tx*y2+s2*z,ty*y2+c2,ty*z-s2*x2,0,tx*z-s2*y2,ty*z+s2*x2,t2*z*z+c2,0,0,0,0,1),this}makeScale(x2,y2,z){return this.set(x2,0,0,0,0,y2,0,0,0,0,z,0,0,0,0,1),this}makeShear(xy,xz,yx,yz,zx,zy){return this.set(1,yx,zx,0,xy,1,zy,0,xz,yz,1,0,0,0,0,1),this}compose(position,quaternion,scale2){const te=this.elements,x2=quaternion._x,y2=quaternion._y,z=quaternion._z,w2=quaternion._w,x22=x2+x2,y22=y2+y2,z2=z+z,xx=x2*x22,xy=x2*y22,xz=x2*z2,yy=y2*y22,yz=y2*z2,zz=z*z2,wx=w2*x22,wy=w2*y22,wz=w2*z2,sx=scale2.x,sy=scale2.y,sz=scale2.z;return te[0]=(1-(yy+zz))*sx,te[1]=(xy+wz)*sx,te[2]=(xz-wy)*sx,te[3]=0,te[4]=(xy-wz)*sy,te[5]=(1-(xx+zz))*sy,te[6]=(yz+wx)*sy,te[7]=0,te[8]=(xz+wy)*sz,te[9]=(yz-wx)*sz,te[10]=(1-(xx+yy))*sz,te[11]=0,te[12]=position.x,te[13]=position.y,te[14]=position.z,te[15]=1,this}decompose(position,quaternion,scale2){const te=this.elements;let sx=_v1$5.set(te[0],te[1],te[2]).length();const sy=_v1$5.set(te[4],te[5],te[6]).length(),sz=_v1$5.set(te[8],te[9],te[10]).length();this.determinant()<0&&(sx=-sx),position.x=te[12],position.y=te[13],position.z=te[14],_m1$2.copy(this);const invSX=1/sx,invSY=1/sy,invSZ=1/sz;return _m1$2.elements[0]*=invSX,_m1$2.elements[1]*=invSX,_m1$2.elements[2]*=invSX,_m1$2.elements[4]*=invSY,_m1$2.elements[5]*=invSY,_m1$2.elements[6]*=invSY,_m1$2.elements[8]*=invSZ,_m1$2.elements[9]*=invSZ,_m1$2.elements[10]*=invSZ,quaternion.setFromRotationMatrix(_m1$2),scale2.x=sx,scale2.y=sy,scale2.z=sz,this}makePerspective(left,right,top,bottom,near,far,coordinateSystem=WebGLCoordinateSystem){const te=this.elements,x2=2*near/(right-left),y2=2*near/(top-bottom),a2=(right+left)/(right-left),b2=(top+bottom)/(top-bottom);let c2,d2;if(coordinateSystem===WebGLCoordinateSystem)c2=-(far+near)/(far-near),d2=-2*far*near/(far-near);else if(coordinateSystem===WebGPUCoordinateSystem)c2=-far/(far-near),d2=-far*near/(far-near);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+coordinateSystem);return te[0]=x2,te[4]=0,te[8]=a2,te[12]=0,te[1]=0,te[5]=y2,te[9]=b2,te[13]=0,te[2]=0,te[6]=0,te[10]=c2,te[14]=d2,te[3]=0,te[7]=0,te[11]=-1,te[15]=0,this}makeOrthographic(left,right,top,bottom,near,far,coordinateSystem=WebGLCoordinateSystem){const te=this.elements,w2=1/(right-left),h2=1/(top-bottom),p2=1/(far-near),x2=(right+left)*w2,y2=(top+bottom)*h2;let z,zInv;if(coordinateSystem===WebGLCoordinateSystem)z=(far+near)*p2,zInv=-2*p2;else if(coordinateSystem===WebGPUCoordinateSystem)z=near*p2,zInv=-1*p2;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+coordinateSystem);return te[0]=2*w2,te[4]=0,te[8]=0,te[12]=-x2,te[1]=0,te[5]=2*h2,te[9]=0,te[13]=-y2,te[2]=0,te[6]=0,te[10]=zInv,te[14]=-z,te[3]=0,te[7]=0,te[11]=0,te[15]=1,this}equals(matrix){const te=this.elements,me=matrix.elements;for(let i2=0;i2<16;i2++)if(te[i2]!==me[i2])return!1;return!0}fromArray(array,offset=0){for(let i2=0;i2<16;i2++)this.elements[i2]=array[i2+offset];return this}toArray(array=[],offset=0){const te=this.elements;return array[offset]=te[0],array[offset+1]=te[1],array[offset+2]=te[2],array[offset+3]=te[3],array[offset+4]=te[4],array[offset+5]=te[5],array[offset+6]=te[6],array[offset+7]=te[7],array[offset+8]=te[8],array[offset+9]=te[9],array[offset+10]=te[10],array[offset+11]=te[11],array[offset+12]=te[12],array[offset+13]=te[13],array[offset+14]=te[14],array[offset+15]=te[15],array}}const _v1$5=new Vector3,_m1$2=new Matrix4,_zero=new Vector3(0,0,0),_one=new Vector3(1,1,1),_x=new Vector3,_y=new Vector3,_z=new Vector3,_matrix=new Matrix4,_quaternion$3=new Quaternion;class Euler{constructor(x2=0,y2=0,z=0,order=Euler.DEFAULT_ORDER){this.isEuler=!0,this._x=x2,this._y=y2,this._z=z,this._order=order}get x(){return this._x}set x(value){this._x=value,this._onChangeCallback()}get y(){return this._y}set y(value){this._y=value,this._onChangeCallback()}get z(){return this._z}set z(value){this._z=value,this._onChangeCallback()}get order(){return this._order}set order(value){this._order=value,this._onChangeCallback()}set(x2,y2,z,order=this._order){return this._x=x2,this._y=y2,this._z=z,this._order=order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(euler){return this._x=euler._x,this._y=euler._y,this._z=euler._z,this._order=euler._order,this._onChangeCallback(),this}setFromRotationMatrix(m2,order=this._order,update=!0){const te=m2.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];switch(order){case"XYZ":this._y=Math.asin(clamp(m13,-1,1)),Math.abs(m13)<.9999999?(this._x=Math.atan2(-m23,m33),this._z=Math.atan2(-m12,m11)):(this._x=Math.atan2(m32,m22),this._z=0);break;case"YXZ":this._x=Math.asin(-clamp(m23,-1,1)),Math.abs(m23)<.9999999?(this._y=Math.atan2(m13,m33),this._z=Math.atan2(m21,m22)):(this._y=Math.atan2(-m31,m11),this._z=0);break;case"ZXY":this._x=Math.asin(clamp(m32,-1,1)),Math.abs(m32)<.9999999?(this._y=Math.atan2(-m31,m33),this._z=Math.atan2(-m12,m22)):(this._y=0,this._z=Math.atan2(m21,m11));break;case"ZYX":this._y=Math.asin(-clamp(m31,-1,1)),Math.abs(m31)<.9999999?(this._x=Math.atan2(m32,m33),this._z=Math.atan2(m21,m11)):(this._x=0,this._z=Math.atan2(-m12,m22));break;case"YZX":this._z=Math.asin(clamp(m21,-1,1)),Math.abs(m21)<.9999999?(this._x=Math.atan2(-m23,m22),this._y=Math.atan2(-m31,m11)):(this._x=0,this._y=Math.atan2(m13,m33));break;case"XZY":this._z=Math.asin(-clamp(m12,-1,1)),Math.abs(m12)<.9999999?(this._x=Math.atan2(m32,m22),this._y=Math.atan2(m13,m11)):(this._x=Math.atan2(-m23,m33),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+order)}return this._order=order,update===!0&&this._onChangeCallback(),this}setFromQuaternion(q,order,update){return _matrix.makeRotationFromQuaternion(q),this.setFromRotationMatrix(_matrix,order,update)}setFromVector3(v4,order=this._order){return this.set(v4.x,v4.y,v4.z,order)}reorder(newOrder){return _quaternion$3.setFromEuler(this),this.setFromQuaternion(_quaternion$3,newOrder)}equals(euler){return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order}fromArray(array){return this._x=array[0],this._y=array[1],this._z=array[2],array[3]!==void 0&&(this._order=array[3]),this._onChangeCallback(),this}toArray(array=[],offset=0){return array[offset]=this._x,array[offset+1]=this._y,array[offset+2]=this._z,array[offset+3]=this._order,array}_onChange(callback){return this._onChangeCallback=callback,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Euler.DEFAULT_ORDER="XYZ";class Layers{constructor(){this.mask=1}set(channel){this.mask=(1<<channel|0)>>>0}enable(channel){this.mask|=1<<channel|0}enableAll(){this.mask=-1}toggle(channel){this.mask^=1<<channel|0}disable(channel){this.mask&=~(1<<channel|0)}disableAll(){this.mask=0}test(layers){return(this.mask&layers.mask)!==0}isEnabled(channel){return(this.mask&(1<<channel|0))!==0}}let _object3DId=0;const _v1$4=new Vector3,_q1=new Quaternion,_m1$1=new Matrix4,_target=new Vector3,_position$3=new Vector3,_scale$2=new Vector3,_quaternion$2=new Quaternion,_xAxis=new Vector3(1,0,0),_yAxis=new Vector3(0,1,0),_zAxis=new Vector3(0,0,1),_addedEvent={type:"added"},_removedEvent={type:"removed"};class Object3D extends EventDispatcher{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:_object3DId++}),this.uuid=generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Object3D.DEFAULT_UP.clone();const position=new Vector3,rotation=new Euler,quaternion=new Quaternion,scale2=new Vector3(1,1,1);function onRotationChange(){quaternion.setFromEuler(rotation,!1)}function onQuaternionChange(){rotation.setFromQuaternion(quaternion,void 0,!1)}rotation._onChange(onRotationChange),quaternion._onChange(onQuaternionChange),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:position},rotation:{configurable:!0,enumerable:!0,value:rotation},quaternion:{configurable:!0,enumerable:!0,value:quaternion},scale:{configurable:!0,enumerable:!0,value:scale2},modelViewMatrix:{value:new Matrix4},normalMatrix:{value:new Matrix3}}),this.matrix=new Matrix4,this.matrixWorld=new Matrix4,this.matrixAutoUpdate=Object3D.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.layers=new Layers,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(matrix){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(matrix),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(q){return this.quaternion.premultiply(q),this}setRotationFromAxisAngle(axis,angle){this.quaternion.setFromAxisAngle(axis,angle)}setRotationFromEuler(euler){this.quaternion.setFromEuler(euler,!0)}setRotationFromMatrix(m2){this.quaternion.setFromRotationMatrix(m2)}setRotationFromQuaternion(q){this.quaternion.copy(q)}rotateOnAxis(axis,angle){return _q1.setFromAxisAngle(axis,angle),this.quaternion.multiply(_q1),this}rotateOnWorldAxis(axis,angle){return _q1.setFromAxisAngle(axis,angle),this.quaternion.premultiply(_q1),this}rotateX(angle){return this.rotateOnAxis(_xAxis,angle)}rotateY(angle){return this.rotateOnAxis(_yAxis,angle)}rotateZ(angle){return this.rotateOnAxis(_zAxis,angle)}translateOnAxis(axis,distance2){return _v1$4.copy(axis).applyQuaternion(this.quaternion),this.position.add(_v1$4.multiplyScalar(distance2)),this}translateX(distance2){return this.translateOnAxis(_xAxis,distance2)}translateY(distance2){return this.translateOnAxis(_yAxis,distance2)}translateZ(distance2){return this.translateOnAxis(_zAxis,distance2)}localToWorld(vector){return this.updateWorldMatrix(!0,!1),vector.applyMatrix4(this.matrixWorld)}worldToLocal(vector){return this.updateWorldMatrix(!0,!1),vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert())}lookAt(x2,y2,z){x2.isVector3?_target.copy(x2):_target.set(x2,y2,z);const parent=this.parent;this.updateWorldMatrix(!0,!1),_position$3.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?_m1$1.lookAt(_position$3,_target,this.up):_m1$1.lookAt(_target,_position$3,this.up),this.quaternion.setFromRotationMatrix(_m1$1),parent&&(_m1$1.extractRotation(parent.matrixWorld),_q1.setFromRotationMatrix(_m1$1),this.quaternion.premultiply(_q1.invert()))}add(object){if(arguments.length>1){for(let i2=0;i2<arguments.length;i2++)this.add(arguments[i2]);return this}return object===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",object),this):(object&&object.isObject3D?(object.parent!==null&&object.parent.remove(object),object.parent=this,this.children.push(object),object.dispatchEvent(_addedEvent)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",object),this)}remove(object){if(arguments.length>1){for(let i2=0;i2<arguments.length;i2++)this.remove(arguments[i2]);return this}const index=this.children.indexOf(object);return index!==-1&&(object.parent=null,this.children.splice(index,1),object.dispatchEvent(_removedEvent)),this}removeFromParent(){const parent=this.parent;return parent!==null&&parent.remove(this),this}clear(){return this.remove(...this.children)}attach(object){return this.updateWorldMatrix(!0,!1),_m1$1.copy(this.matrixWorld).invert(),object.parent!==null&&(object.parent.updateWorldMatrix(!0,!1),_m1$1.multiply(object.parent.matrixWorld)),object.applyMatrix4(_m1$1),this.add(object),object.updateWorldMatrix(!1,!0),this}getObjectById(id2){return this.getObjectByProperty("id",id2)}getObjectByName(name){return this.getObjectByProperty("name",name)}getObjectByProperty(name,value){if(this[name]===value)return this;for(let i2=0,l2=this.children.length;i2<l2;i2++){const object=this.children[i2].getObjectByProperty(name,value);if(object!==void 0)return object}}getObjectsByProperty(name,value){let result=[];this[name]===value&&result.push(this);for(let i2=0,l2=this.children.length;i2<l2;i2++){const childResult=this.children[i2].getObjectsByProperty(name,value);childResult.length>0&&(result=result.concat(childResult))}return result}getWorldPosition(target){return this.updateWorldMatrix(!0,!1),target.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(target){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$3,target,_scale$2),target}getWorldScale(target){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$3,_quaternion$2,target),target}getWorldDirection(target){this.updateWorldMatrix(!0,!1);const e2=this.matrixWorld.elements;return target.set(e2[8],e2[9],e2[10]).normalize()}raycast(){}traverse(callback){callback(this);const children=this.children;for(let i2=0,l2=children.length;i2<l2;i2++)children[i2].traverse(callback)}traverseVisible(callback){if(this.visible===!1)return;callback(this);const children=this.children;for(let i2=0,l2=children.length;i2<l2;i2++)children[i2].traverseVisible(callback)}traverseAncestors(callback){const parent=this.parent;parent!==null&&(callback(parent),parent.traverseAncestors(callback))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(force){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||force)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,force=!0);const children=this.children;for(let i2=0,l2=children.length;i2<l2;i2++){const child=children[i2];(child.matrixWorldAutoUpdate===!0||force===!0)&&child.updateMatrixWorld(force)}}updateWorldMatrix(updateParents,updateChildren){const parent=this.parent;if(updateParents===!0&&parent!==null&&parent.matrixWorldAutoUpdate===!0&&parent.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),updateChildren===!0){const children=this.children;for(let i2=0,l2=children.length;i2<l2;i2++){const child=children[i2];child.matrixWorldAutoUpdate===!0&&child.updateWorldMatrix(!1,!0)}}}toJSON(meta){const isRootObject=meta===void 0||typeof meta=="string",output={};isRootObject&&(meta={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},output.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const object={};object.uuid=this.uuid,object.type=this.type,this.name!==""&&(object.name=this.name),this.castShadow===!0&&(object.castShadow=!0),this.receiveShadow===!0&&(object.receiveShadow=!0),this.visible===!1&&(object.visible=!1),this.frustumCulled===!1&&(object.frustumCulled=!1),this.renderOrder!==0&&(object.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(object.userData=this.userData),object.layers=this.layers.mask,object.matrix=this.matrix.toArray(),object.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(object.matrixAutoUpdate=!1),this.isInstancedMesh&&(object.type="InstancedMesh",object.count=this.count,object.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(object.instanceColor=this.instanceColor.toJSON()));function serialize(library,element){return library[element.uuid]===void 0&&(library[element.uuid]=element.toJSON(meta)),element.uuid}if(this.isScene)this.background&&(this.background.isColor?object.background=this.background.toJSON():this.background.isTexture&&(object.background=this.background.toJSON(meta).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(object.environment=this.environment.toJSON(meta).uuid);else if(this.isMesh||this.isLine||this.isPoints){object.geometry=serialize(meta.geometries,this.geometry);const parameters=this.geometry.parameters;if(parameters!==void 0&&parameters.shapes!==void 0){const shapes=parameters.shapes;if(Array.isArray(shapes))for(let i2=0,l2=shapes.length;i2<l2;i2++){const shape=shapes[i2];serialize(meta.shapes,shape)}else serialize(meta.shapes,shapes)}}if(this.isSkinnedMesh&&(object.bindMode=this.bindMode,object.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(serialize(meta.skeletons,this.skeleton),object.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const uuids=[];for(let i2=0,l2=this.material.length;i2<l2;i2++)uuids.push(serialize(meta.materials,this.material[i2]));object.material=uuids}else object.material=serialize(meta.materials,this.material);if(this.children.length>0){object.children=[];for(let i2=0;i2<this.children.length;i2++)object.children.push(this.children[i2].toJSON(meta).object)}if(this.animations.length>0){object.animations=[];for(let i2=0;i2<this.animations.length;i2++){const animation=this.animations[i2];object.animations.push(serialize(meta.animations,animation))}}if(isRootObject){const geometries=extractFromCache(meta.geometries),materials=extractFromCache(meta.materials),textures=extractFromCache(meta.textures),images=extractFromCache(meta.images),shapes=extractFromCache(meta.shapes),skeletons=extractFromCache(meta.skeletons),animations2=extractFromCache(meta.animations),nodes=extractFromCache(meta.nodes);geometries.length>0&&(output.geometries=geometries),materials.length>0&&(output.materials=materials),textures.length>0&&(output.textures=textures),images.length>0&&(output.images=images),shapes.length>0&&(output.shapes=shapes),skeletons.length>0&&(output.skeletons=skeletons),animations2.length>0&&(output.animations=animations2),nodes.length>0&&(output.nodes=nodes)}return output.object=object,output;function extractFromCache(cache){const values=[];for(const key in cache){const data=cache[key];delete data.metadata,values.push(data)}return values}}clone(recursive){return new this.constructor().copy(this,recursive)}copy(source,recursive=!0){if(this.name=source.name,this.up.copy(source.up),this.position.copy(source.position),this.rotation.order=source.rotation.order,this.quaternion.copy(source.quaternion),this.scale.copy(source.scale),this.matrix.copy(source.matrix),this.matrixWorld.copy(source.matrixWorld),this.matrixAutoUpdate=source.matrixAutoUpdate,this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=source.matrixWorldAutoUpdate,this.layers.mask=source.layers.mask,this.visible=source.visible,this.castShadow=source.castShadow,this.receiveShadow=source.receiveShadow,this.frustumCulled=source.frustumCulled,this.renderOrder=source.renderOrder,this.animations=source.animations.slice(),this.userData=JSON.parse(JSON.stringify(source.userData)),recursive===!0)for(let i2=0;i2<source.children.length;i2++){const child=source.children[i2];this.add(child.clone())}return this}}Object3D.DEFAULT_UP=new Vector3(0,1,0);Object3D.DEFAULT_MATRIX_AUTO_UPDATE=!0;Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const _v0$1=new Vector3,_v1$3=new Vector3,_v2$2=new Vector3,_v3$1=new Vector3,_vab=new Vector3,_vac=new Vector3,_vbc=new Vector3,_vap=new Vector3,_vbp=new Vector3,_vcp=new Vector3;let warnedGetUV=!1;class Triangle{constructor(a2=new Vector3,b2=new Vector3,c2=new Vector3){this.a=a2,this.b=b2,this.c=c2}static getNormal(a2,b2,c2,target){target.subVectors(c2,b2),_v0$1.subVectors(a2,b2),target.cross(_v0$1);const targetLengthSq=target.lengthSq();return targetLengthSq>0?target.multiplyScalar(1/Math.sqrt(targetLengthSq)):target.set(0,0,0)}static getBarycoord(point,a2,b2,c2,target){_v0$1.subVectors(c2,a2),_v1$3.subVectors(b2,a2),_v2$2.subVectors(point,a2);const dot00=_v0$1.dot(_v0$1),dot01=_v0$1.dot(_v1$3),dot02=_v0$1.dot(_v2$2),dot11=_v1$3.dot(_v1$3),dot12=_v1$3.dot(_v2$2),denom=dot00*dot11-dot01*dot01;if(denom===0)return target.set(-2,-1,-1);const invDenom=1/denom,u2=(dot11*dot02-dot01*dot12)*invDenom,v4=(dot00*dot12-dot01*dot02)*invDenom;return target.set(1-u2-v4,v4,u2)}static containsPoint(point,a2,b2,c2){return this.getBarycoord(point,a2,b2,c2,_v3$1),_v3$1.x>=0&&_v3$1.y>=0&&_v3$1.x+_v3$1.y<=1}static getUV(point,p1,p2,p3,uv1,uv2,uv3,target){return warnedGetUV===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),warnedGetUV=!0),this.getInterpolation(point,p1,p2,p3,uv1,uv2,uv3,target)}static getInterpolation(point,p1,p2,p3,v12,v22,v32,target){return this.getBarycoord(point,p1,p2,p3,_v3$1),target.setScalar(0),target.addScaledVector(v12,_v3$1.x),target.addScaledVector(v22,_v3$1.y),target.addScaledVector(v32,_v3$1.z),target}static isFrontFacing(a2,b2,c2,direction){return _v0$1.subVectors(c2,b2),_v1$3.subVectors(a2,b2),_v0$1.cross(_v1$3).dot(direction)<0}set(a2,b2,c2){return this.a.copy(a2),this.b.copy(b2),this.c.copy(c2),this}setFromPointsAndIndices(points,i0,i1,i2){return this.a.copy(points[i0]),this.b.copy(points[i1]),this.c.copy(points[i2]),this}setFromAttributeAndIndices(attribute,i0,i1,i2){return this.a.fromBufferAttribute(attribute,i0),this.b.fromBufferAttribute(attribute,i1),this.c.fromBufferAttribute(attribute,i2),this}clone(){return new this.constructor().copy(this)}copy(triangle){return this.a.copy(triangle.a),this.b.copy(triangle.b),this.c.copy(triangle.c),this}getArea(){return _v0$1.subVectors(this.c,this.b),_v1$3.subVectors(this.a,this.b),_v0$1.cross(_v1$3).length()*.5}getMidpoint(target){return target.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(target){return Triangle.getNormal(this.a,this.b,this.c,target)}getPlane(target){return target.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(point,target){return Triangle.getBarycoord(point,this.a,this.b,this.c,target)}getUV(point,uv1,uv2,uv3,target){return warnedGetUV===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),warnedGetUV=!0),Triangle.getInterpolation(point,this.a,this.b,this.c,uv1,uv2,uv3,target)}getInterpolation(point,v12,v22,v32,target){return Triangle.getInterpolation(point,this.a,this.b,this.c,v12,v22,v32,target)}containsPoint(point){return Triangle.containsPoint(point,this.a,this.b,this.c)}isFrontFacing(direction){return Triangle.isFrontFacing(this.a,this.b,this.c,direction)}intersectsBox(box){return box.intersectsTriangle(this)}closestPointToPoint(p2,target){const a2=this.a,b2=this.b,c2=this.c;let v4,w2;_vab.subVectors(b2,a2),_vac.subVectors(c2,a2),_vap.subVectors(p2,a2);const d1=_vab.dot(_vap),d2=_vac.dot(_vap);if(d1<=0&&d2<=0)return target.copy(a2);_vbp.subVectors(p2,b2);const d3=_vab.dot(_vbp),d4=_vac.dot(_vbp);if(d3>=0&&d4<=d3)return target.copy(b2);const vc=d1*d4-d3*d2;if(vc<=0&&d1>=0&&d3<=0)return v4=d1/(d1-d3),target.copy(a2).addScaledVector(_vab,v4);_vcp.subVectors(p2,c2);const d5=_vab.dot(_vcp),d6=_vac.dot(_vcp);if(d6>=0&&d5<=d6)return target.copy(c2);const vb=d5*d2-d1*d6;if(vb<=0&&d2>=0&&d6<=0)return w2=d2/(d2-d6),target.copy(a2).addScaledVector(_vac,w2);const va=d3*d6-d5*d4;if(va<=0&&d4-d3>=0&&d5-d6>=0)return _vbc.subVectors(c2,b2),w2=(d4-d3)/(d4-d3+(d5-d6)),target.copy(b2).addScaledVector(_vbc,w2);const denom=1/(va+vb+vc);return v4=vb*denom,w2=vc*denom,target.copy(a2).addScaledVector(_vab,v4).addScaledVector(_vac,w2)}equals(triangle){return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c)}}const _colorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},_hslA={h:0,s:0,l:0},_hslB={h:0,s:0,l:0};function hue2rgb(p2,q,t2){return t2<0&&(t2+=1),t2>1&&(t2-=1),t2<1/6?p2+(q-p2)*6*t2:t2<1/2?q:t2<2/3?p2+(q-p2)*6*(2/3-t2):p2}class Color{constructor(r2,g2,b2){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(r2,g2,b2)}set(r2,g2,b2){if(g2===void 0&&b2===void 0){const value=r2;value&&value.isColor?this.copy(value):typeof value=="number"?this.setHex(value):typeof value=="string"&&this.setStyle(value)}else this.setRGB(r2,g2,b2);return this}setScalar(scalar){return this.r=scalar,this.g=scalar,this.b=scalar,this}setHex(hex2,colorSpace=SRGBColorSpace){return hex2=Math.floor(hex2),this.r=(hex2>>16&255)/255,this.g=(hex2>>8&255)/255,this.b=(hex2&255)/255,ColorManagement.toWorkingColorSpace(this,colorSpace),this}setRGB(r2,g2,b2,colorSpace=ColorManagement.workingColorSpace){return this.r=r2,this.g=g2,this.b=b2,ColorManagement.toWorkingColorSpace(this,colorSpace),this}setHSL(h2,s2,l2,colorSpace=ColorManagement.workingColorSpace){if(h2=euclideanModulo(h2,1),s2=clamp(s2,0,1),l2=clamp(l2,0,1),s2===0)this.r=this.g=this.b=l2;else{const p2=l2<=.5?l2*(1+s2):l2+s2-l2*s2,q=2*l2-p2;this.r=hue2rgb(q,p2,h2+1/3),this.g=hue2rgb(q,p2,h2),this.b=hue2rgb(q,p2,h2-1/3)}return ColorManagement.toWorkingColorSpace(this,colorSpace),this}setStyle(style,colorSpace=SRGBColorSpace){function handleAlpha(string){string!==void 0&&parseFloat(string)<1&&console.warn("THREE.Color: Alpha component of "+style+" will be ignored.")}let m2;if(m2=/^(\w+)\(([^\)]*)\)/.exec(style)){let color2;const name=m2[1],components=m2[2];switch(name){case"rgb":case"rgba":if(color2=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components))return handleAlpha(color2[4]),this.setRGB(Math.min(255,parseInt(color2[1],10))/255,Math.min(255,parseInt(color2[2],10))/255,Math.min(255,parseInt(color2[3],10))/255,colorSpace);if(color2=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components))return handleAlpha(color2[4]),this.setRGB(Math.min(100,parseInt(color2[1],10))/100,Math.min(100,parseInt(color2[2],10))/100,Math.min(100,parseInt(color2[3],10))/100,colorSpace);break;case"hsl":case"hsla":if(color2=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components))return handleAlpha(color2[4]),this.setHSL(parseFloat(color2[1])/360,parseFloat(color2[2])/100,parseFloat(color2[3])/100,colorSpace);break;default:console.warn("THREE.Color: Unknown color model "+style)}}else if(m2=/^\#([A-Fa-f\d]+)$/.exec(style)){const hex2=m2[1],size=hex2.length;if(size===3)return this.setRGB(parseInt(hex2.charAt(0),16)/15,parseInt(hex2.charAt(1),16)/15,parseInt(hex2.charAt(2),16)/15,colorSpace);if(size===6)return this.setHex(parseInt(hex2,16),colorSpace);console.warn("THREE.Color: Invalid hex color "+style)}else if(style&&style.length>0)return this.setColorName(style,colorSpace);return this}setColorName(style,colorSpace=SRGBColorSpace){const hex2=_colorKeywords[style.toLowerCase()];return hex2!==void 0?this.setHex(hex2,colorSpace):console.warn("THREE.Color: Unknown color "+style),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(color2){return this.r=color2.r,this.g=color2.g,this.b=color2.b,this}copySRGBToLinear(color2){return this.r=SRGBToLinear(color2.r),this.g=SRGBToLinear(color2.g),this.b=SRGBToLinear(color2.b),this}copyLinearToSRGB(color2){return this.r=LinearToSRGB(color2.r),this.g=LinearToSRGB(color2.g),this.b=LinearToSRGB(color2.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(colorSpace=SRGBColorSpace){return ColorManagement.fromWorkingColorSpace(_color.copy(this),colorSpace),Math.round(clamp(_color.r*255,0,255))*65536+Math.round(clamp(_color.g*255,0,255))*256+Math.round(clamp(_color.b*255,0,255))}getHexString(colorSpace=SRGBColorSpace){return("000000"+this.getHex(colorSpace).toString(16)).slice(-6)}getHSL(target,colorSpace=ColorManagement.workingColorSpace){ColorManagement.fromWorkingColorSpace(_color.copy(this),colorSpace);const r2=_color.r,g2=_color.g,b2=_color.b,max2=Math.max(r2,g2,b2),min=Math.min(r2,g2,b2);let hue,saturation;const lightness=(min+max2)/2;if(min===max2)hue=0,saturation=0;else{const delta=max2-min;switch(saturation=lightness<=.5?delta/(max2+min):delta/(2-max2-min),max2){case r2:hue=(g2-b2)/delta+(g2<b2?6:0);break;case g2:hue=(b2-r2)/delta+2;break;case b2:hue=(r2-g2)/delta+4;break}hue/=6}return target.h=hue,target.s=saturation,target.l=lightness,target}getRGB(target,colorSpace=ColorManagement.workingColorSpace){return ColorManagement.fromWorkingColorSpace(_color.copy(this),colorSpace),target.r=_color.r,target.g=_color.g,target.b=_color.b,target}getStyle(colorSpace=SRGBColorSpace){ColorManagement.fromWorkingColorSpace(_color.copy(this),colorSpace);const r2=_color.r,g2=_color.g,b2=_color.b;return colorSpace!==SRGBColorSpace?`color(${colorSpace} ${r2.toFixed(3)} ${g2.toFixed(3)} ${b2.toFixed(3)})`:`rgb(${Math.round(r2*255)},${Math.round(g2*255)},${Math.round(b2*255)})`}offsetHSL(h2,s2,l2){return this.getHSL(_hslA),this.setHSL(_hslA.h+h2,_hslA.s+s2,_hslA.l+l2)}add(color2){return this.r+=color2.r,this.g+=color2.g,this.b+=color2.b,this}addColors(color1,color2){return this.r=color1.r+color2.r,this.g=color1.g+color2.g,this.b=color1.b+color2.b,this}addScalar(s2){return this.r+=s2,this.g+=s2,this.b+=s2,this}sub(color2){return this.r=Math.max(0,this.r-color2.r),this.g=Math.max(0,this.g-color2.g),this.b=Math.max(0,this.b-color2.b),this}multiply(color2){return this.r*=color2.r,this.g*=color2.g,this.b*=color2.b,this}multiplyScalar(s2){return this.r*=s2,this.g*=s2,this.b*=s2,this}lerp(color2,alpha2){return this.r+=(color2.r-this.r)*alpha2,this.g+=(color2.g-this.g)*alpha2,this.b+=(color2.b-this.b)*alpha2,this}lerpColors(color1,color2,alpha2){return this.r=color1.r+(color2.r-color1.r)*alpha2,this.g=color1.g+(color2.g-color1.g)*alpha2,this.b=color1.b+(color2.b-color1.b)*alpha2,this}lerpHSL(color2,alpha2){this.getHSL(_hslA),color2.getHSL(_hslB);const h2=lerp(_hslA.h,_hslB.h,alpha2),s2=lerp(_hslA.s,_hslB.s,alpha2),l2=lerp(_hslA.l,_hslB.l,alpha2);return this.setHSL(h2,s2,l2),this}setFromVector3(v4){return this.r=v4.x,this.g=v4.y,this.b=v4.z,this}applyMatrix3(m2){const r2=this.r,g2=this.g,b2=this.b,e2=m2.elements;return this.r=e2[0]*r2+e2[3]*g2+e2[6]*b2,this.g=e2[1]*r2+e2[4]*g2+e2[7]*b2,this.b=e2[2]*r2+e2[5]*g2+e2[8]*b2,this}equals(c2){return c2.r===this.r&&c2.g===this.g&&c2.b===this.b}fromArray(array,offset=0){return this.r=array[offset],this.g=array[offset+1],this.b=array[offset+2],this}toArray(array=[],offset=0){return array[offset]=this.r,array[offset+1]=this.g,array[offset+2]=this.b,array}fromBufferAttribute(attribute,index){return this.r=attribute.getX(index),this.g=attribute.getY(index),this.b=attribute.getZ(index),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const _color=new Color;Color.NAMES=_colorKeywords;let _materialId=0;class Material extends EventDispatcher{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:_materialId++}),this.uuid=generateUUID(),this.name="",this.type="Material",this.blending=NormalBlending,this.side=FrontSide,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=SrcAlphaFactor,this.blendDst=OneMinusSrcAlphaFactor,this.blendEquation=AddEquation,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Color(0,0,0),this.blendAlpha=0,this.depthFunc=LessEqualDepth,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=AlwaysStencilFunc,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=KeepStencilOp,this.stencilZFail=KeepStencilOp,this.stencilZPass=KeepStencilOp,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(value){this._alphaTest>0!=value>0&&this.version++,this._alphaTest=value}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(values){if(values!==void 0)for(const key in values){const newValue=values[key];if(newValue===void 0){console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);continue}const currentValue=this[key];if(currentValue===void 0){console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);continue}currentValue&&currentValue.isColor?currentValue.set(newValue):currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3?currentValue.copy(newValue):this[key]=newValue}}toJSON(meta){const isRootObject=meta===void 0||typeof meta=="string";isRootObject&&(meta={textures:{},images:{}});const data={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};data.uuid=this.uuid,data.type=this.type,this.name!==""&&(data.name=this.name),this.color&&this.color.isColor&&(data.color=this.color.getHex()),this.roughness!==void 0&&(data.roughness=this.roughness),this.metalness!==void 0&&(data.metalness=this.metalness),this.sheen!==void 0&&(data.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(data.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(data.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(data.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(data.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(data.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(data.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(data.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(data.shininess=this.shininess),this.clearcoat!==void 0&&(data.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(data.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(data.clearcoatMap=this.clearcoatMap.toJSON(meta).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(data.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(meta).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(data.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(meta).uuid,data.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(data.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(data.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(data.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(data.iridescenceMap=this.iridescenceMap.toJSON(meta).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(data.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(meta).uuid),this.anisotropy!==void 0&&(data.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(data.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(data.anisotropyMap=this.anisotropyMap.toJSON(meta).uuid),this.map&&this.map.isTexture&&(data.map=this.map.toJSON(meta).uuid),this.matcap&&this.matcap.isTexture&&(data.matcap=this.matcap.toJSON(meta).uuid),this.alphaMap&&this.alphaMap.isTexture&&(data.alphaMap=this.alphaMap.toJSON(meta).uuid),this.lightMap&&this.lightMap.isTexture&&(data.lightMap=this.lightMap.toJSON(meta).uuid,data.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(data.aoMap=this.aoMap.toJSON(meta).uuid,data.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(data.bumpMap=this.bumpMap.toJSON(meta).uuid,data.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(data.normalMap=this.normalMap.toJSON(meta).uuid,data.normalMapType=this.normalMapType,data.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(data.displacementMap=this.displacementMap.toJSON(meta).uuid,data.displacementScale=this.displacementScale,data.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(data.roughnessMap=this.roughnessMap.toJSON(meta).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(data.metalnessMap=this.metalnessMap.toJSON(meta).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(data.emissiveMap=this.emissiveMap.toJSON(meta).uuid),this.specularMap&&this.specularMap.isTexture&&(data.specularMap=this.specularMap.toJSON(meta).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(data.specularIntensityMap=this.specularIntensityMap.toJSON(meta).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(data.specularColorMap=this.specularColorMap.toJSON(meta).uuid),this.envMap&&this.envMap.isTexture&&(data.envMap=this.envMap.toJSON(meta).uuid,this.combine!==void 0&&(data.combine=this.combine)),this.envMapIntensity!==void 0&&(data.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(data.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(data.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(data.gradientMap=this.gradientMap.toJSON(meta).uuid),this.transmission!==void 0&&(data.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(data.transmissionMap=this.transmissionMap.toJSON(meta).uuid),this.thickness!==void 0&&(data.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(data.thicknessMap=this.thicknessMap.toJSON(meta).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(data.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(data.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(data.size=this.size),this.shadowSide!==null&&(data.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(data.sizeAttenuation=this.sizeAttenuation),this.blending!==NormalBlending&&(data.blending=this.blending),this.side!==FrontSide&&(data.side=this.side),this.vertexColors===!0&&(data.vertexColors=!0),this.opacity<1&&(data.opacity=this.opacity),this.transparent===!0&&(data.transparent=!0),this.blendSrc!==SrcAlphaFactor&&(data.blendSrc=this.blendSrc),this.blendDst!==OneMinusSrcAlphaFactor&&(data.blendDst=this.blendDst),this.blendEquation!==AddEquation&&(data.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(data.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(data.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(data.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(data.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(data.blendAlpha=this.blendAlpha),this.depthFunc!==LessEqualDepth&&(data.depthFunc=this.depthFunc),this.depthTest===!1&&(data.depthTest=this.depthTest),this.depthWrite===!1&&(data.depthWrite=this.depthWrite),this.colorWrite===!1&&(data.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(data.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==AlwaysStencilFunc&&(data.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(data.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(data.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==KeepStencilOp&&(data.stencilFail=this.stencilFail),this.stencilZFail!==KeepStencilOp&&(data.stencilZFail=this.stencilZFail),this.stencilZPass!==KeepStencilOp&&(data.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(data.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(data.rotation=this.rotation),this.polygonOffset===!0&&(data.polygonOffset=!0),this.polygonOffsetFactor!==0&&(data.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(data.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(data.linewidth=this.linewidth),this.dashSize!==void 0&&(data.dashSize=this.dashSize),this.gapSize!==void 0&&(data.gapSize=this.gapSize),this.scale!==void 0&&(data.scale=this.scale),this.dithering===!0&&(data.dithering=!0),this.alphaTest>0&&(data.alphaTest=this.alphaTest),this.alphaHash===!0&&(data.alphaHash=!0),this.alphaToCoverage===!0&&(data.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(data.premultipliedAlpha=!0),this.forceSinglePass===!0&&(data.forceSinglePass=!0),this.wireframe===!0&&(data.wireframe=!0),this.wireframeLinewidth>1&&(data.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(data.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(data.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(data.flatShading=!0),this.visible===!1&&(data.visible=!1),this.toneMapped===!1&&(data.toneMapped=!1),this.fog===!1&&(data.fog=!1),Object.keys(this.userData).length>0&&(data.userData=this.userData);function extractFromCache(cache){const values=[];for(const key in cache){const data2=cache[key];delete data2.metadata,values.push(data2)}return values}if(isRootObject){const textures=extractFromCache(meta.textures),images=extractFromCache(meta.images);textures.length>0&&(data.textures=textures),images.length>0&&(data.images=images)}return data}clone(){return new this.constructor().copy(this)}copy(source){this.name=source.name,this.blending=source.blending,this.side=source.side,this.vertexColors=source.vertexColors,this.opacity=source.opacity,this.transparent=source.transparent,this.blendSrc=source.blendSrc,this.blendDst=source.blendDst,this.blendEquation=source.blendEquation,this.blendSrcAlpha=source.blendSrcAlpha,this.blendDstAlpha=source.blendDstAlpha,this.blendEquationAlpha=source.blendEquationAlpha,this.blendColor.copy(source.blendColor),this.blendAlpha=source.blendAlpha,this.depthFunc=source.depthFunc,this.depthTest=source.depthTest,this.depthWrite=source.depthWrite,this.stencilWriteMask=source.stencilWriteMask,this.stencilFunc=source.stencilFunc,this.stencilRef=source.stencilRef,this.stencilFuncMask=source.stencilFuncMask,this.stencilFail=source.stencilFail,this.stencilZFail=source.stencilZFail,this.stencilZPass=source.stencilZPass,this.stencilWrite=source.stencilWrite;const srcPlanes=source.clippingPlanes;let dstPlanes=null;if(srcPlanes!==null){const n=srcPlanes.length;dstPlanes=new Array(n);for(let i2=0;i2!==n;++i2)dstPlanes[i2]=srcPlanes[i2].clone()}return this.clippingPlanes=dstPlanes,this.clipIntersection=source.clipIntersection,this.clipShadows=source.clipShadows,this.shadowSide=source.shadowSide,this.colorWrite=source.colorWrite,this.precision=source.precision,this.polygonOffset=source.polygonOffset,this.polygonOffsetFactor=source.polygonOffsetFactor,this.polygonOffsetUnits=source.polygonOffsetUnits,this.dithering=source.dithering,this.alphaTest=source.alphaTest,this.alphaHash=source.alphaHash,this.alphaToCoverage=source.alphaToCoverage,this.premultipliedAlpha=source.premultipliedAlpha,this.forceSinglePass=source.forceSinglePass,this.visible=source.visible,this.toneMapped=source.toneMapped,this.userData=JSON.parse(JSON.stringify(source.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(value){value===!0&&this.version++}}class MeshBasicMaterial extends Material{constructor(parameters){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.map=source.map,this.lightMap=source.lightMap,this.lightMapIntensity=source.lightMapIntensity,this.aoMap=source.aoMap,this.aoMapIntensity=source.aoMapIntensity,this.specularMap=source.specularMap,this.alphaMap=source.alphaMap,this.envMap=source.envMap,this.combine=source.combine,this.reflectivity=source.reflectivity,this.refractionRatio=source.refractionRatio,this.wireframe=source.wireframe,this.wireframeLinewidth=source.wireframeLinewidth,this.wireframeLinecap=source.wireframeLinecap,this.wireframeLinejoin=source.wireframeLinejoin,this.fog=source.fog,this}}const _tables=_generateTables();function _generateTables(){const buffer=new ArrayBuffer(4),floatView=new Float32Array(buffer),uint32View=new Uint32Array(buffer),baseTable=new Uint32Array(512),shiftTable=new Uint32Array(512);for(let i2=0;i2<256;++i2){const e2=i2-127;e2<-27?(baseTable[i2]=0,baseTable[i2|256]=32768,shiftTable[i2]=24,shiftTable[i2|256]=24):e2<-14?(baseTable[i2]=1024>>-e2-14,baseTable[i2|256]=1024>>-e2-14|32768,shiftTable[i2]=-e2-1,shiftTable[i2|256]=-e2-1):e2<=15?(baseTable[i2]=e2+15<<10,baseTable[i2|256]=e2+15<<10|32768,shiftTable[i2]=13,shiftTable[i2|256]=13):e2<128?(baseTable[i2]=31744,baseTable[i2|256]=64512,shiftTable[i2]=24,shiftTable[i2|256]=24):(baseTable[i2]=31744,baseTable[i2|256]=64512,shiftTable[i2]=13,shiftTable[i2|256]=13)}const mantissaTable=new Uint32Array(2048),exponentTable=new Uint32Array(64),offsetTable=new Uint32Array(64);for(let i2=1;i2<1024;++i2){let m2=i2<<13,e2=0;for(;!(m2&8388608);)m2<<=1,e2-=8388608;m2&=-8388609,e2+=947912704,mantissaTable[i2]=m2|e2}for(let i2=1024;i2<2048;++i2)mantissaTable[i2]=939524096+(i2-1024<<13);for(let i2=1;i2<31;++i2)exponentTable[i2]=i2<<23;exponentTable[31]=1199570944,exponentTable[32]=2147483648;for(let i2=33;i2<63;++i2)exponentTable[i2]=2147483648+(i2-32<<23);exponentTable[63]=3347054592;for(let i2=1;i2<64;++i2)i2!==32&&(offsetTable[i2]=1024);return{floatView,uint32View,baseTable,shiftTable,mantissaTable,exponentTable,offsetTable}}function toHalfFloat(val){Math.abs(val)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),val=clamp(val,-65504,65504),_tables.floatView[0]=val;const f2=_tables.uint32View[0],e2=f2>>23&511;return _tables.baseTable[e2]+((f2&8388607)>>_tables.shiftTable[e2])}function fromHalfFloat(val){const m2=val>>10;return _tables.uint32View[0]=_tables.mantissaTable[_tables.offsetTable[m2]+(val&1023)]+_tables.exponentTable[m2],_tables.floatView[0]}const DataUtils={toHalfFloat,fromHalfFloat},_vector$8=new Vector3,_vector2$1=new Vector2;class BufferAttribute{constructor(array,itemSize,normalized=!1){if(Array.isArray(array))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=array,this.itemSize=itemSize,this.count=array!==void 0?array.length/itemSize:0,this.normalized=normalized,this.usage=StaticDrawUsage,this.updateRange={offset:0,count:-1},this.gpuType=FloatType,this.version=0}onUploadCallback(){}set needsUpdate(value){value===!0&&this.version++}setUsage(value){return this.usage=value,this}copy(source){return this.name=source.name,this.array=new source.array.constructor(source.array),this.itemSize=source.itemSize,this.count=source.count,this.normalized=source.normalized,this.usage=source.usage,this.gpuType=source.gpuType,this}copyAt(index1,attribute,index2){index1*=this.itemSize,index2*=attribute.itemSize;for(let i2=0,l2=this.itemSize;i2<l2;i2++)this.array[index1+i2]=attribute.array[index2+i2];return this}copyArray(array){return this.array.set(array),this}applyMatrix3(m2){if(this.itemSize===2)for(let i2=0,l2=this.count;i2<l2;i2++)_vector2$1.fromBufferAttribute(this,i2),_vector2$1.applyMatrix3(m2),this.setXY(i2,_vector2$1.x,_vector2$1.y);else if(this.itemSize===3)for(let i2=0,l2=this.count;i2<l2;i2++)_vector$8.fromBufferAttribute(this,i2),_vector$8.applyMatrix3(m2),this.setXYZ(i2,_vector$8.x,_vector$8.y,_vector$8.z);return this}applyMatrix4(m2){for(let i2=0,l2=this.count;i2<l2;i2++)_vector$8.fromBufferAttribute(this,i2),_vector$8.applyMatrix4(m2),this.setXYZ(i2,_vector$8.x,_vector$8.y,_vector$8.z);return this}applyNormalMatrix(m2){for(let i2=0,l2=this.count;i2<l2;i2++)_vector$8.fromBufferAttribute(this,i2),_vector$8.applyNormalMatrix(m2),this.setXYZ(i2,_vector$8.x,_vector$8.y,_vector$8.z);return this}transformDirection(m2){for(let i2=0,l2=this.count;i2<l2;i2++)_vector$8.fromBufferAttribute(this,i2),_vector$8.transformDirection(m2),this.setXYZ(i2,_vector$8.x,_vector$8.y,_vector$8.z);return this}set(value,offset=0){return this.array.set(value,offset),this}getComponent(index,component){let value=this.array[index*this.itemSize+component];return this.normalized&&(value=denormalize(value,this.array)),value}setComponent(index,component,value){return this.normalized&&(value=normalize(value,this.array)),this.array[index*this.itemSize+component]=value,this}getX(index){let x2=this.array[index*this.itemSize];return this.normalized&&(x2=denormalize(x2,this.array)),x2}setX(index,x2){return this.normalized&&(x2=normalize(x2,this.array)),this.array[index*this.itemSize]=x2,this}getY(index){let y2=this.array[index*this.itemSize+1];return this.normalized&&(y2=denormalize(y2,this.array)),y2}setY(index,y2){return this.normalized&&(y2=normalize(y2,this.array)),this.array[index*this.itemSize+1]=y2,this}getZ(index){let z=this.array[index*this.itemSize+2];return this.normalized&&(z=denormalize(z,this.array)),z}setZ(index,z){return this.normalized&&(z=normalize(z,this.array)),this.array[index*this.itemSize+2]=z,this}getW(index){let w2=this.array[index*this.itemSize+3];return this.normalized&&(w2=denormalize(w2,this.array)),w2}setW(index,w2){return this.normalized&&(w2=normalize(w2,this.array)),this.array[index*this.itemSize+3]=w2,this}setXY(index,x2,y2){return index*=this.itemSize,this.normalized&&(x2=normalize(x2,this.array),y2=normalize(y2,this.array)),this.array[index+0]=x2,this.array[index+1]=y2,this}setXYZ(index,x2,y2,z){return index*=this.itemSize,this.normalized&&(x2=normalize(x2,this.array),y2=normalize(y2,this.array),z=normalize(z,this.array)),this.array[index+0]=x2,this.array[index+1]=y2,this.array[index+2]=z,this}setXYZW(index,x2,y2,z,w2){return index*=this.itemSize,this.normalized&&(x2=normalize(x2,this.array),y2=normalize(y2,this.array),z=normalize(z,this.array),w2=normalize(w2,this.array)),this.array[index+0]=x2,this.array[index+1]=y2,this.array[index+2]=z,this.array[index+3]=w2,this}onUpload(callback){return this.onUploadCallback=callback,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const data={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(data.name=this.name),this.usage!==StaticDrawUsage&&(data.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(data.updateRange=this.updateRange),data}}class Int8BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Int8Array(array),itemSize,normalized)}}class Uint8BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint8Array(array),itemSize,normalized)}}class Uint8ClampedBufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint8ClampedArray(array),itemSize,normalized)}}class Int16BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Int16Array(array),itemSize,normalized)}}class Uint16BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint16Array(array),itemSize,normalized)}}class Int32BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Int32Array(array),itemSize,normalized)}}class Uint32BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint32Array(array),itemSize,normalized)}}class Float16BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint16Array(array),itemSize,normalized),this.isFloat16BufferAttribute=!0}getX(index){let x2=fromHalfFloat(this.array[index*this.itemSize]);return this.normalized&&(x2=denormalize(x2,this.array)),x2}setX(index,x2){return this.normalized&&(x2=normalize(x2,this.array)),this.array[index*this.itemSize]=toHalfFloat(x2),this}getY(index){let y2=fromHalfFloat(this.array[index*this.itemSize+1]);return this.normalized&&(y2=denormalize(y2,this.array)),y2}setY(index,y2){return this.normalized&&(y2=normalize(y2,this.array)),this.array[index*this.itemSize+1]=toHalfFloat(y2),this}getZ(index){let z=fromHalfFloat(this.array[index*this.itemSize+2]);return this.normalized&&(z=denormalize(z,this.array)),z}setZ(index,z){return this.normalized&&(z=normalize(z,this.array)),this.array[index*this.itemSize+2]=toHalfFloat(z),this}getW(index){let w2=fromHalfFloat(this.array[index*this.itemSize+3]);return this.normalized&&(w2=denormalize(w2,this.array)),w2}setW(index,w2){return this.normalized&&(w2=normalize(w2,this.array)),this.array[index*this.itemSize+3]=toHalfFloat(w2),this}setXY(index,x2,y2){return index*=this.itemSize,this.normalized&&(x2=normalize(x2,this.array),y2=normalize(y2,this.array)),this.array[index+0]=toHalfFloat(x2),this.array[index+1]=toHalfFloat(y2),this}setXYZ(index,x2,y2,z){return index*=this.itemSize,this.normalized&&(x2=normalize(x2,this.array),y2=normalize(y2,this.array),z=normalize(z,this.array)),this.array[index+0]=toHalfFloat(x2),this.array[index+1]=toHalfFloat(y2),this.array[index+2]=toHalfFloat(z),this}setXYZW(index,x2,y2,z,w2){return index*=this.itemSize,this.normalized&&(x2=normalize(x2,this.array),y2=normalize(y2,this.array),z=normalize(z,this.array),w2=normalize(w2,this.array)),this.array[index+0]=toHalfFloat(x2),this.array[index+1]=toHalfFloat(y2),this.array[index+2]=toHalfFloat(z),this.array[index+3]=toHalfFloat(w2),this}}class Float32BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Float32Array(array),itemSize,normalized)}}class Float64BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Float64Array(array),itemSize,normalized)}}let _id$2=0;const _m1=new Matrix4,_obj=new Object3D,_offset=new Vector3,_box$1=new Box3,_boxMorphTargets=new Box3,_vector$7=new Vector3;class BufferGeometry extends EventDispatcher{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:_id$2++}),this.uuid=generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(index){return Array.isArray(index)?this.index=new(arrayNeedsUint32(index)?Uint32BufferAttribute:Uint16BufferAttribute)(index,1):this.index=index,this}getAttribute(name){return this.attributes[name]}setAttribute(name,attribute){return this.attributes[name]=attribute,this}deleteAttribute(name){return delete this.attributes[name],this}hasAttribute(name){return this.attributes[name]!==void 0}addGroup(start,count,materialIndex=0){this.groups.push({start,count,materialIndex})}clearGroups(){this.groups=[]}setDrawRange(start,count){this.drawRange.start=start,this.drawRange.count=count}applyMatrix4(matrix){const position=this.attributes.position;position!==void 0&&(position.applyMatrix4(matrix),position.needsUpdate=!0);const normal=this.attributes.normal;if(normal!==void 0){const normalMatrix=new Matrix3().getNormalMatrix(matrix);normal.applyNormalMatrix(normalMatrix),normal.needsUpdate=!0}const tangent=this.attributes.tangent;return tangent!==void 0&&(tangent.transformDirection(matrix),tangent.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(q){return _m1.makeRotationFromQuaternion(q),this.applyMatrix4(_m1),this}rotateX(angle){return _m1.makeRotationX(angle),this.applyMatrix4(_m1),this}rotateY(angle){return _m1.makeRotationY(angle),this.applyMatrix4(_m1),this}rotateZ(angle){return _m1.makeRotationZ(angle),this.applyMatrix4(_m1),this}translate(x2,y2,z){return _m1.makeTranslation(x2,y2,z),this.applyMatrix4(_m1),this}scale(x2,y2,z){return _m1.makeScale(x2,y2,z),this.applyMatrix4(_m1),this}lookAt(vector){return _obj.lookAt(vector),_obj.updateMatrix(),this.applyMatrix4(_obj.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(_offset).negate(),this.translate(_offset.x,_offset.y,_offset.z),this}setFromPoints(points){const position=[];for(let i2=0,l2=points.length;i2<l2;i2++){const point=points[i2];position.push(point.x,point.y,point.z||0)}return this.setAttribute("position",new Float32BufferAttribute(position,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Box3);const position=this.attributes.position,morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new Vector3(-1/0,-1/0,-1/0),new Vector3(1/0,1/0,1/0));return}if(position!==void 0){if(this.boundingBox.setFromBufferAttribute(position),morphAttributesPosition)for(let i2=0,il=morphAttributesPosition.length;i2<il;i2++){const morphAttribute=morphAttributesPosition[i2];_box$1.setFromBufferAttribute(morphAttribute),this.morphTargetsRelative?(_vector$7.addVectors(this.boundingBox.min,_box$1.min),this.boundingBox.expandByPoint(_vector$7),_vector$7.addVectors(this.boundingBox.max,_box$1.max),this.boundingBox.expandByPoint(_vector$7)):(this.boundingBox.expandByPoint(_box$1.min),this.boundingBox.expandByPoint(_box$1.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Sphere);const position=this.attributes.position,morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new Vector3,1/0);return}if(position){const center=this.boundingSphere.center;if(_box$1.setFromBufferAttribute(position),morphAttributesPosition)for(let i2=0,il=morphAttributesPosition.length;i2<il;i2++){const morphAttribute=morphAttributesPosition[i2];_boxMorphTargets.setFromBufferAttribute(morphAttribute),this.morphTargetsRelative?(_vector$7.addVectors(_box$1.min,_boxMorphTargets.min),_box$1.expandByPoint(_vector$7),_vector$7.addVectors(_box$1.max,_boxMorphTargets.max),_box$1.expandByPoint(_vector$7)):(_box$1.expandByPoint(_boxMorphTargets.min),_box$1.expandByPoint(_boxMorphTargets.max))}_box$1.getCenter(center);let maxRadiusSq=0;for(let i2=0,il=position.count;i2<il;i2++)_vector$7.fromBufferAttribute(position,i2),maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$7));if(morphAttributesPosition)for(let i2=0,il=morphAttributesPosition.length;i2<il;i2++){const morphAttribute=morphAttributesPosition[i2],morphTargetsRelative=this.morphTargetsRelative;for(let j2=0,jl=morphAttribute.count;j2<jl;j2++)_vector$7.fromBufferAttribute(morphAttribute,j2),morphTargetsRelative&&(_offset.fromBufferAttribute(position,j2),_vector$7.add(_offset)),maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$7))}this.boundingSphere.radius=Math.sqrt(maxRadiusSq),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const index=this.index,attributes=this.attributes;if(index===null||attributes.position===void 0||attributes.normal===void 0||attributes.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const indices=index.array,positions=attributes.position.array,normals=attributes.normal.array,uvs=attributes.uv.array,nVertices=positions.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new BufferAttribute(new Float32Array(4*nVertices),4));const tangents=this.getAttribute("tangent").array,tan1=[],tan2=[];for(let i2=0;i2<nVertices;i2++)tan1[i2]=new Vector3,tan2[i2]=new Vector3;const vA=new Vector3,vB=new Vector3,vC=new Vector3,uvA=new Vector2,uvB=new Vector2,uvC=new Vector2,sdir=new Vector3,tdir=new Vector3;function handleTriangle(a2,b2,c2){vA.fromArray(positions,a2*3),vB.fromArray(positions,b2*3),vC.fromArray(positions,c2*3),uvA.fromArray(uvs,a2*2),uvB.fromArray(uvs,b2*2),uvC.fromArray(uvs,c2*2),vB.sub(vA),vC.sub(vA),uvB.sub(uvA),uvC.sub(uvA);const r2=1/(uvB.x*uvC.y-uvC.x*uvB.y);isFinite(r2)&&(sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC,-uvB.y).multiplyScalar(r2),tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB,-uvC.x).multiplyScalar(r2),tan1[a2].add(sdir),tan1[b2].add(sdir),tan1[c2].add(sdir),tan2[a2].add(tdir),tan2[b2].add(tdir),tan2[c2].add(tdir))}let groups=this.groups;groups.length===0&&(groups=[{start:0,count:indices.length}]);for(let i2=0,il=groups.length;i2<il;++i2){const group=groups[i2],start=group.start,count=group.count;for(let j2=start,jl=start+count;j2<jl;j2+=3)handleTriangle(indices[j2+0],indices[j2+1],indices[j2+2])}const tmp2=new Vector3,tmp22=new Vector3,n=new Vector3,n2=new Vector3;function handleVertex(v4){n.fromArray(normals,v4*3),n2.copy(n);const t2=tan1[v4];tmp2.copy(t2),tmp2.sub(n.multiplyScalar(n.dot(t2))).normalize(),tmp22.crossVectors(n2,t2);const w2=tmp22.dot(tan2[v4])<0?-1:1;tangents[v4*4]=tmp2.x,tangents[v4*4+1]=tmp2.y,tangents[v4*4+2]=tmp2.z,tangents[v4*4+3]=w2}for(let i2=0,il=groups.length;i2<il;++i2){const group=groups[i2],start=group.start,count=group.count;for(let j2=start,jl=start+count;j2<jl;j2+=3)handleVertex(indices[j2+0]),handleVertex(indices[j2+1]),handleVertex(indices[j2+2])}}computeVertexNormals(){const index=this.index,positionAttribute=this.getAttribute("position");if(positionAttribute!==void 0){let normalAttribute=this.getAttribute("normal");if(normalAttribute===void 0)normalAttribute=new BufferAttribute(new Float32Array(positionAttribute.count*3),3),this.setAttribute("normal",normalAttribute);else for(let i2=0,il=normalAttribute.count;i2<il;i2++)normalAttribute.setXYZ(i2,0,0,0);const pA=new Vector3,pB=new Vector3,pC=new Vector3,nA=new Vector3,nB=new Vector3,nC=new Vector3,cb=new Vector3,ab=new Vector3;if(index)for(let i2=0,il=index.count;i2<il;i2+=3){const vA=index.getX(i2+0),vB=index.getX(i2+1),vC=index.getX(i2+2);pA.fromBufferAttribute(positionAttribute,vA),pB.fromBufferAttribute(positionAttribute,vB),pC.fromBufferAttribute(positionAttribute,vC),cb.subVectors(pC,pB),ab.subVectors(pA,pB),cb.cross(ab),nA.fromBufferAttribute(normalAttribute,vA),nB.fromBufferAttribute(normalAttribute,vB),nC.fromBufferAttribute(normalAttribute,vC),nA.add(cb),nB.add(cb),nC.add(cb),normalAttribute.setXYZ(vA,nA.x,nA.y,nA.z),normalAttribute.setXYZ(vB,nB.x,nB.y,nB.z),normalAttribute.setXYZ(vC,nC.x,nC.y,nC.z)}else for(let i2=0,il=positionAttribute.count;i2<il;i2+=3)pA.fromBufferAttribute(positionAttribute,i2+0),pB.fromBufferAttribute(positionAttribute,i2+1),pC.fromBufferAttribute(positionAttribute,i2+2),cb.subVectors(pC,pB),ab.subVectors(pA,pB),cb.cross(ab),normalAttribute.setXYZ(i2+0,cb.x,cb.y,cb.z),normalAttribute.setXYZ(i2+1,cb.x,cb.y,cb.z),normalAttribute.setXYZ(i2+2,cb.x,cb.y,cb.z);this.normalizeNormals(),normalAttribute.needsUpdate=!0}}normalizeNormals(){const normals=this.attributes.normal;for(let i2=0,il=normals.count;i2<il;i2++)_vector$7.fromBufferAttribute(normals,i2),_vector$7.normalize(),normals.setXYZ(i2,_vector$7.x,_vector$7.y,_vector$7.z)}toNonIndexed(){function convertBufferAttribute(attribute,indices2){const array=attribute.array,itemSize=attribute.itemSize,normalized=attribute.normalized,array2=new array.constructor(indices2.length*itemSize);let index=0,index2=0;for(let i2=0,l2=indices2.length;i2<l2;i2++){attribute.isInterleavedBufferAttribute?index=indices2[i2]*attribute.data.stride+attribute.offset:index=indices2[i2]*itemSize;for(let j2=0;j2<itemSize;j2++)array2[index2++]=array[index++]}return new BufferAttribute(array2,itemSize,normalized)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const geometry2=new BufferGeometry,indices=this.index.array,attributes=this.attributes;for(const name in attributes){const attribute=attributes[name],newAttribute=convertBufferAttribute(attribute,indices);geometry2.setAttribute(name,newAttribute)}const morphAttributes=this.morphAttributes;for(const name in morphAttributes){const morphArray=[],morphAttribute=morphAttributes[name];for(let i2=0,il=morphAttribute.length;i2<il;i2++){const attribute=morphAttribute[i2],newAttribute=convertBufferAttribute(attribute,indices);morphArray.push(newAttribute)}geometry2.morphAttributes[name]=morphArray}geometry2.morphTargetsRelative=this.morphTargetsRelative;const groups=this.groups;for(let i2=0,l2=groups.length;i2<l2;i2++){const group=groups[i2];geometry2.addGroup(group.start,group.count,group.materialIndex)}return geometry2}toJSON(){const data={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(data.uuid=this.uuid,data.type=this.type,this.name!==""&&(data.name=this.name),Object.keys(this.userData).length>0&&(data.userData=this.userData),this.parameters!==void 0){const parameters=this.parameters;for(const key in parameters)parameters[key]!==void 0&&(data[key]=parameters[key]);return data}data.data={attributes:{}};const index=this.index;index!==null&&(data.data.index={type:index.array.constructor.name,array:Array.prototype.slice.call(index.array)});const attributes=this.attributes;for(const key in attributes){const attribute=attributes[key];data.data.attributes[key]=attribute.toJSON(data.data)}const morphAttributes={};let hasMorphAttributes=!1;for(const key in this.morphAttributes){const attributeArray=this.morphAttributes[key],array=[];for(let i2=0,il=attributeArray.length;i2<il;i2++){const attribute=attributeArray[i2];array.push(attribute.toJSON(data.data))}array.length>0&&(morphAttributes[key]=array,hasMorphAttributes=!0)}hasMorphAttributes&&(data.data.morphAttributes=morphAttributes,data.data.morphTargetsRelative=this.morphTargetsRelative);const groups=this.groups;groups.length>0&&(data.data.groups=JSON.parse(JSON.stringify(groups)));const boundingSphere=this.boundingSphere;return boundingSphere!==null&&(data.data.boundingSphere={center:boundingSphere.center.toArray(),radius:boundingSphere.radius}),data}clone(){return new this.constructor().copy(this)}copy(source){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const data={};this.name=source.name;const index=source.index;index!==null&&this.setIndex(index.clone(data));const attributes=source.attributes;for(const name in attributes){const attribute=attributes[name];this.setAttribute(name,attribute.clone(data))}const morphAttributes=source.morphAttributes;for(const name in morphAttributes){const array=[],morphAttribute=morphAttributes[name];for(let i2=0,l2=morphAttribute.length;i2<l2;i2++)array.push(morphAttribute[i2].clone(data));this.morphAttributes[name]=array}this.morphTargetsRelative=source.morphTargetsRelative;const groups=source.groups;for(let i2=0,l2=groups.length;i2<l2;i2++){const group=groups[i2];this.addGroup(group.start,group.count,group.materialIndex)}const boundingBox=source.boundingBox;boundingBox!==null&&(this.boundingBox=boundingBox.clone());const boundingSphere=source.boundingSphere;return boundingSphere!==null&&(this.boundingSphere=boundingSphere.clone()),this.drawRange.start=source.drawRange.start,this.drawRange.count=source.drawRange.count,this.userData=source.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const _inverseMatrix$3=new Matrix4,_ray$3=new Ray,_sphere$5=new Sphere,_sphereHitAt=new Vector3,_vA$1=new Vector3,_vB$1=new Vector3,_vC$1=new Vector3,_tempA=new Vector3,_morphA=new Vector3,_uvA$1=new Vector2,_uvB$1=new Vector2,_uvC$1=new Vector2,_normalA=new Vector3,_normalB=new Vector3,_normalC=new Vector3,_intersectionPoint=new Vector3,_intersectionPointWorld=new Vector3;class Mesh extends Object3D{constructor(geometry=new BufferGeometry,material=new MeshBasicMaterial){super(),this.isMesh=!0,this.type="Mesh",this.geometry=geometry,this.material=material,this.updateMorphTargets()}copy(source,recursive){return super.copy(source,recursive),source.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=source.morphTargetInfluences.slice()),source.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},source.morphTargetDictionary)),this.material=Array.isArray(source.material)?source.material.slice():source.material,this.geometry=source.geometry,this}updateMorphTargets(){const morphAttributes=this.geometry.morphAttributes,keys2=Object.keys(morphAttributes);if(keys2.length>0){const morphAttribute=morphAttributes[keys2[0]];if(morphAttribute!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let m2=0,ml=morphAttribute.length;m2<ml;m2++){const name=morphAttribute[m2].name||String(m2);this.morphTargetInfluences.push(0),this.morphTargetDictionary[name]=m2}}}}getVertexPosition(index,target){const geometry=this.geometry,position=geometry.attributes.position,morphPosition=geometry.morphAttributes.position,morphTargetsRelative=geometry.morphTargetsRelative;target.fromBufferAttribute(position,index);const morphInfluences=this.morphTargetInfluences;if(morphPosition&&morphInfluences){_morphA.set(0,0,0);for(let i2=0,il=morphPosition.length;i2<il;i2++){const influence=morphInfluences[i2],morphAttribute=morphPosition[i2];influence!==0&&(_tempA.fromBufferAttribute(morphAttribute,index),morphTargetsRelative?_morphA.addScaledVector(_tempA,influence):_morphA.addScaledVector(_tempA.sub(target),influence))}target.add(_morphA)}return target}raycast(raycaster,intersects2){const geometry=this.geometry,material=this.material,matrixWorld=this.matrixWorld;material!==void 0&&(geometry.boundingSphere===null&&geometry.computeBoundingSphere(),_sphere$5.copy(geometry.boundingSphere),_sphere$5.applyMatrix4(matrixWorld),_ray$3.copy(raycaster.ray).recast(raycaster.near),!(_sphere$5.containsPoint(_ray$3.origin)===!1&&(_ray$3.intersectSphere(_sphere$5,_sphereHitAt)===null||_ray$3.origin.distanceToSquared(_sphereHitAt)>(raycaster.far-raycaster.near)**2))&&(_inverseMatrix$3.copy(matrixWorld).invert(),_ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3),!(geometry.boundingBox!==null&&_ray$3.intersectsBox(geometry.boundingBox)===!1)&&this._computeIntersections(raycaster,intersects2,_ray$3)))}_computeIntersections(raycaster,intersects2,rayLocalSpace){let intersection;const geometry=this.geometry,material=this.material,index=geometry.index,position=geometry.attributes.position,uv=geometry.attributes.uv,uv1=geometry.attributes.uv1,normal=geometry.attributes.normal,groups=geometry.groups,drawRange=geometry.drawRange;if(index!==null)if(Array.isArray(material))for(let i2=0,il=groups.length;i2<il;i2++){const group=groups[i2],groupMaterial=material[group.materialIndex],start=Math.max(group.start,drawRange.start),end=Math.min(index.count,Math.min(group.start+group.count,drawRange.start+drawRange.count));for(let j2=start,jl=end;j2<jl;j2+=3){const a2=index.getX(j2),b2=index.getX(j2+1),c2=index.getX(j2+2);intersection=checkGeometryIntersection(this,groupMaterial,raycaster,rayLocalSpace,uv,uv1,normal,a2,b2,c2),intersection&&(intersection.faceIndex=Math.floor(j2/3),intersection.face.materialIndex=group.materialIndex,intersects2.push(intersection))}}else{const start=Math.max(0,drawRange.start),end=Math.min(index.count,drawRange.start+drawRange.count);for(let i2=start,il=end;i2<il;i2+=3){const a2=index.getX(i2),b2=index.getX(i2+1),c2=index.getX(i2+2);intersection=checkGeometryIntersection(this,material,raycaster,rayLocalSpace,uv,uv1,normal,a2,b2,c2),intersection&&(intersection.faceIndex=Math.floor(i2/3),intersects2.push(intersection))}}else if(position!==void 0)if(Array.isArray(material))for(let i2=0,il=groups.length;i2<il;i2++){const group=groups[i2],groupMaterial=material[group.materialIndex],start=Math.max(group.start,drawRange.start),end=Math.min(position.count,Math.min(group.start+group.count,drawRange.start+drawRange.count));for(let j2=start,jl=end;j2<jl;j2+=3){const a2=j2,b2=j2+1,c2=j2+2;intersection=checkGeometryIntersection(this,groupMaterial,raycaster,rayLocalSpace,uv,uv1,normal,a2,b2,c2),intersection&&(intersection.faceIndex=Math.floor(j2/3),intersection.face.materialIndex=group.materialIndex,intersects2.push(intersection))}}else{const start=Math.max(0,drawRange.start),end=Math.min(position.count,drawRange.start+drawRange.count);for(let i2=start,il=end;i2<il;i2+=3){const a2=i2,b2=i2+1,c2=i2+2;intersection=checkGeometryIntersection(this,material,raycaster,rayLocalSpace,uv,uv1,normal,a2,b2,c2),intersection&&(intersection.faceIndex=Math.floor(i2/3),intersects2.push(intersection))}}}}function checkIntersection(object,material,raycaster,ray,pA,pB,pC,point){let intersect;if(material.side===BackSide?intersect=ray.intersectTriangle(pC,pB,pA,!0,point):intersect=ray.intersectTriangle(pA,pB,pC,material.side===FrontSide,point),intersect===null)return null;_intersectionPointWorld.copy(point),_intersectionPointWorld.applyMatrix4(object.matrixWorld);const distance2=raycaster.ray.origin.distanceTo(_intersectionPointWorld);return distance2<raycaster.near||distance2>raycaster.far?null:{distance:distance2,point:_intersectionPointWorld.clone(),object}}function checkGeometryIntersection(object,material,raycaster,ray,uv,uv1,normal,a2,b2,c2){object.getVertexPosition(a2,_vA$1),object.getVertexPosition(b2,_vB$1),object.getVertexPosition(c2,_vC$1);const intersection=checkIntersection(object,material,raycaster,ray,_vA$1,_vB$1,_vC$1,_intersectionPoint);if(intersection){uv&&(_uvA$1.fromBufferAttribute(uv,a2),_uvB$1.fromBufferAttribute(uv,b2),_uvC$1.fromBufferAttribute(uv,c2),intersection.uv=Triangle.getInterpolation(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2)),uv1&&(_uvA$1.fromBufferAttribute(uv1,a2),_uvB$1.fromBufferAttribute(uv1,b2),_uvC$1.fromBufferAttribute(uv1,c2),intersection.uv1=Triangle.getInterpolation(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2),intersection.uv2=intersection.uv1),normal&&(_normalA.fromBufferAttribute(normal,a2),_normalB.fromBufferAttribute(normal,b2),_normalC.fromBufferAttribute(normal,c2),intersection.normal=Triangle.getInterpolation(_intersectionPoint,_vA$1,_vB$1,_vC$1,_normalA,_normalB,_normalC,new Vector3),intersection.normal.dot(ray.direction)>0&&intersection.normal.multiplyScalar(-1));const face={a:a2,b:b2,c:c2,normal:new Vector3,materialIndex:0};Triangle.getNormal(_vA$1,_vB$1,_vC$1,face.normal),intersection.face=face}return intersection}class BoxGeometry extends BufferGeometry{constructor(width=1,height=1,depth=1,widthSegments=1,heightSegments=1,depthSegments=1){super(),this.type="BoxGeometry",this.parameters={width,height,depth,widthSegments,heightSegments,depthSegments};const scope=this;widthSegments=Math.floor(widthSegments),heightSegments=Math.floor(heightSegments),depthSegments=Math.floor(depthSegments);const indices=[],vertices=[],normals=[],uvs=[];let numberOfVertices=0,groupStart=0;buildPlane("z","y","x",-1,-1,depth,height,width,depthSegments,heightSegments,0),buildPlane("z","y","x",1,-1,depth,height,-width,depthSegments,heightSegments,1),buildPlane("x","z","y",1,1,width,depth,height,widthSegments,depthSegments,2),buildPlane("x","z","y",1,-1,width,depth,-height,widthSegments,depthSegments,3),buildPlane("x","y","z",1,-1,width,height,depth,widthSegments,heightSegments,4),buildPlane("x","y","z",-1,-1,width,height,-depth,widthSegments,heightSegments,5),this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2));function buildPlane(u2,v4,w2,udir,vdir,width2,height2,depth2,gridX,gridY,materialIndex){const segmentWidth=width2/gridX,segmentHeight=height2/gridY,widthHalf=width2/2,heightHalf=height2/2,depthHalf=depth2/2,gridX1=gridX+1,gridY1=gridY+1;let vertexCounter=0,groupCount=0;const vector=new Vector3;for(let iy=0;iy<gridY1;iy++){const y2=iy*segmentHeight-heightHalf;for(let ix=0;ix<gridX1;ix++){const x2=ix*segmentWidth-widthHalf;vector[u2]=x2*udir,vector[v4]=y2*vdir,vector[w2]=depthHalf,vertices.push(vector.x,vector.y,vector.z),vector[u2]=0,vector[v4]=0,vector[w2]=depth2>0?1:-1,normals.push(vector.x,vector.y,vector.z),uvs.push(ix/gridX),uvs.push(1-iy/gridY),vertexCounter+=1}}for(let iy=0;iy<gridY;iy++)for(let ix=0;ix<gridX;ix++){const a2=numberOfVertices+ix+gridX1*iy,b2=numberOfVertices+ix+gridX1*(iy+1),c2=numberOfVertices+(ix+1)+gridX1*(iy+1),d2=numberOfVertices+(ix+1)+gridX1*iy;indices.push(a2,b2,d2),indices.push(b2,c2,d2),groupCount+=6}scope.addGroup(groupStart,groupCount,materialIndex),groupStart+=groupCount,numberOfVertices+=vertexCounter}}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new BoxGeometry(data.width,data.height,data.depth,data.widthSegments,data.heightSegments,data.depthSegments)}}function cloneUniforms(src){const dst={};for(const u2 in src){dst[u2]={};for(const p2 in src[u2]){const property=src[u2][p2];property&&(property.isColor||property.isMatrix3||property.isMatrix4||property.isVector2||property.isVector3||property.isVector4||property.isTexture||property.isQuaternion)?property.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),dst[u2][p2]=null):dst[u2][p2]=property.clone():Array.isArray(property)?dst[u2][p2]=property.slice():dst[u2][p2]=property}}return dst}function mergeUniforms(uniforms){const merged={};for(let u2=0;u2<uniforms.length;u2++){const tmp2=cloneUniforms(uniforms[u2]);for(const p2 in tmp2)merged[p2]=tmp2[p2]}return merged}function cloneUniformsGroups(src){const dst=[];for(let u2=0;u2<src.length;u2++)dst.push(src[u2].clone());return dst}function getUnlitUniformColorSpace(renderer){return renderer.getRenderTarget()===null?renderer.outputColorSpace:ColorManagement.workingColorSpace}const UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};var default_vertex=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,default_fragment=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class ShaderMaterial extends Material{constructor(parameters){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=default_vertex,this.fragmentShader=default_fragment,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,parameters!==void 0&&this.setValues(parameters)}copy(source){return super.copy(source),this.fragmentShader=source.fragmentShader,this.vertexShader=source.vertexShader,this.uniforms=cloneUniforms(source.uniforms),this.uniformsGroups=cloneUniformsGroups(source.uniformsGroups),this.defines=Object.assign({},source.defines),this.wireframe=source.wireframe,this.wireframeLinewidth=source.wireframeLinewidth,this.fog=source.fog,this.lights=source.lights,this.clipping=source.clipping,this.extensions=Object.assign({},source.extensions),this.glslVersion=source.glslVersion,this}toJSON(meta){const data=super.toJSON(meta);data.glslVersion=this.glslVersion,data.uniforms={};for(const name in this.uniforms){const value=this.uniforms[name].value;value&&value.isTexture?data.uniforms[name]={type:"t",value:value.toJSON(meta).uuid}:value&&value.isColor?data.uniforms[name]={type:"c",value:value.getHex()}:value&&value.isVector2?data.uniforms[name]={type:"v2",value:value.toArray()}:value&&value.isVector3?data.uniforms[name]={type:"v3",value:value.toArray()}:value&&value.isVector4?data.uniforms[name]={type:"v4",value:value.toArray()}:value&&value.isMatrix3?data.uniforms[name]={type:"m3",value:value.toArray()}:value&&value.isMatrix4?data.uniforms[name]={type:"m4",value:value.toArray()}:data.uniforms[name]={value}}Object.keys(this.defines).length>0&&(data.defines=this.defines),data.vertexShader=this.vertexShader,data.fragmentShader=this.fragmentShader,data.lights=this.lights,data.clipping=this.clipping;const extensions2={};for(const key in this.extensions)this.extensions[key]===!0&&(extensions2[key]=!0);return Object.keys(extensions2).length>0&&(data.extensions=extensions2),data}}class Camera extends Object3D{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Matrix4,this.projectionMatrix=new Matrix4,this.projectionMatrixInverse=new Matrix4,this.coordinateSystem=WebGLCoordinateSystem}copy(source,recursive){return super.copy(source,recursive),this.matrixWorldInverse.copy(source.matrixWorldInverse),this.projectionMatrix.copy(source.projectionMatrix),this.projectionMatrixInverse.copy(source.projectionMatrixInverse),this.coordinateSystem=source.coordinateSystem,this}getWorldDirection(target){return super.getWorldDirection(target).negate()}updateMatrixWorld(force){super.updateMatrixWorld(force),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(updateParents,updateChildren){super.updateWorldMatrix(updateParents,updateChildren),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}let PerspectiveCamera$1=class extends Camera{constructor(fov2=50,aspect2=1,near=.1,far=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=fov2,this.zoom=1,this.near=near,this.far=far,this.focus=10,this.aspect=aspect2,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(source,recursive){return super.copy(source,recursive),this.fov=source.fov,this.zoom=source.zoom,this.near=source.near,this.far=source.far,this.focus=source.focus,this.aspect=source.aspect,this.view=source.view===null?null:Object.assign({},source.view),this.filmGauge=source.filmGauge,this.filmOffset=source.filmOffset,this}setFocalLength(focalLength){const vExtentSlope=.5*this.getFilmHeight()/focalLength;this.fov=RAD2DEG*2*Math.atan(vExtentSlope),this.updateProjectionMatrix()}getFocalLength(){const vExtentSlope=Math.tan(DEG2RAD*.5*this.fov);return .5*this.getFilmHeight()/vExtentSlope}getEffectiveFOV(){return RAD2DEG*2*Math.atan(Math.tan(DEG2RAD*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(fullWidth,fullHeight,x2,y2,width,height){this.aspect=fullWidth/fullHeight,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=fullWidth,this.view.fullHeight=fullHeight,this.view.offsetX=x2,this.view.offsetY=y2,this.view.width=width,this.view.height=height,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const near=this.near;let top=near*Math.tan(DEG2RAD*.5*this.fov)/this.zoom,height=2*top,width=this.aspect*height,left=-.5*width;const view=this.view;if(this.view!==null&&this.view.enabled){const fullWidth=view.fullWidth,fullHeight=view.fullHeight;left+=view.offsetX*width/fullWidth,top-=view.offsetY*height/fullHeight,width*=view.width/fullWidth,height*=view.height/fullHeight}const skew=this.filmOffset;skew!==0&&(left+=near*skew/this.getFilmWidth()),this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(meta){const data=super.toJSON(meta);return data.object.fov=this.fov,data.object.zoom=this.zoom,data.object.near=this.near,data.object.far=this.far,data.object.focus=this.focus,data.object.aspect=this.aspect,this.view!==null&&(data.object.view=Object.assign({},this.view)),data.object.filmGauge=this.filmGauge,data.object.filmOffset=this.filmOffset,data}};const fov=-90,aspect=1;class CubeCamera extends Object3D{constructor(near,far,renderTarget){super(),this.type="CubeCamera",this.renderTarget=renderTarget,this.coordinateSystem=null,this.activeMipmapLevel=0;const cameraPX=new PerspectiveCamera$1(fov,aspect,near,far);cameraPX.layers=this.layers,this.add(cameraPX);const cameraNX=new PerspectiveCamera$1(fov,aspect,near,far);cameraNX.layers=this.layers,this.add(cameraNX);const cameraPY=new PerspectiveCamera$1(fov,aspect,near,far);cameraPY.layers=this.layers,this.add(cameraPY);const cameraNY=new PerspectiveCamera$1(fov,aspect,near,far);cameraNY.layers=this.layers,this.add(cameraNY);const cameraPZ=new PerspectiveCamera$1(fov,aspect,near,far);cameraPZ.layers=this.layers,this.add(cameraPZ);const cameraNZ=new PerspectiveCamera$1(fov,aspect,near,far);cameraNZ.layers=this.layers,this.add(cameraNZ)}updateCoordinateSystem(){const coordinateSystem=this.coordinateSystem,cameras=this.children.concat(),[cameraPX,cameraNX,cameraPY,cameraNY,cameraPZ,cameraNZ]=cameras;for(const camera of cameras)this.remove(camera);if(coordinateSystem===WebGLCoordinateSystem)cameraPX.up.set(0,1,0),cameraPX.lookAt(1,0,0),cameraNX.up.set(0,1,0),cameraNX.lookAt(-1,0,0),cameraPY.up.set(0,0,-1),cameraPY.lookAt(0,1,0),cameraNY.up.set(0,0,1),cameraNY.lookAt(0,-1,0),cameraPZ.up.set(0,1,0),cameraPZ.lookAt(0,0,1),cameraNZ.up.set(0,1,0),cameraNZ.lookAt(0,0,-1);else if(coordinateSystem===WebGPUCoordinateSystem)cameraPX.up.set(0,-1,0),cameraPX.lookAt(-1,0,0),cameraNX.up.set(0,-1,0),cameraNX.lookAt(1,0,0),cameraPY.up.set(0,0,1),cameraPY.lookAt(0,1,0),cameraNY.up.set(0,0,-1),cameraNY.lookAt(0,-1,0),cameraPZ.up.set(0,-1,0),cameraPZ.lookAt(0,0,1),cameraNZ.up.set(0,-1,0),cameraNZ.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+coordinateSystem);for(const camera of cameras)this.add(camera),camera.updateMatrixWorld()}update(renderer,scene2){this.parent===null&&this.updateMatrixWorld();const{renderTarget,activeMipmapLevel}=this;this.coordinateSystem!==renderer.coordinateSystem&&(this.coordinateSystem=renderer.coordinateSystem,this.updateCoordinateSystem());const[cameraPX,cameraNX,cameraPY,cameraNY,cameraPZ,cameraNZ]=this.children,currentRenderTarget=renderer.getRenderTarget(),currentActiveCubeFace=renderer.getActiveCubeFace(),currentActiveMipmapLevel=renderer.getActiveMipmapLevel(),currentXrEnabled=renderer.xr.enabled;renderer.xr.enabled=!1;const generateMipmaps=renderTarget.texture.generateMipmaps;renderTarget.texture.generateMipmaps=!1,renderer.setRenderTarget(renderTarget,0,activeMipmapLevel),renderer.render(scene2,cameraPX),renderer.setRenderTarget(renderTarget,1,activeMipmapLevel),renderer.render(scene2,cameraNX),renderer.setRenderTarget(renderTarget,2,activeMipmapLevel),renderer.render(scene2,cameraPY),renderer.setRenderTarget(renderTarget,3,activeMipmapLevel),renderer.render(scene2,cameraNY),renderer.setRenderTarget(renderTarget,4,activeMipmapLevel),renderer.render(scene2,cameraPZ),renderTarget.texture.generateMipmaps=generateMipmaps,renderer.setRenderTarget(renderTarget,5,activeMipmapLevel),renderer.render(scene2,cameraNZ),renderer.setRenderTarget(currentRenderTarget,currentActiveCubeFace,currentActiveMipmapLevel),renderer.xr.enabled=currentXrEnabled,renderTarget.texture.needsPMREMUpdate=!0}}class CubeTexture extends Texture{constructor(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,colorSpace){images=images!==void 0?images:[],mapping=mapping!==void 0?mapping:CubeReflectionMapping,super(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,colorSpace),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(value){this.image=value}}class WebGLCubeRenderTarget extends WebGLRenderTarget{constructor(size=1,options={}){super(size,size,options),this.isWebGLCubeRenderTarget=!0;const image={width:size,height:size,depth:1},images=[image,image,image,image,image,image];options.encoding!==void 0&&(warnOnce("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),options.colorSpace=options.encoding===sRGBEncoding?SRGBColorSpace:NoColorSpace),this.texture=new CubeTexture(images,options.mapping,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=options.generateMipmaps!==void 0?options.generateMipmaps:!1,this.texture.minFilter=options.minFilter!==void 0?options.minFilter:LinearFilter}fromEquirectangularTexture(renderer,texture){this.texture.type=texture.type,this.texture.colorSpace=texture.colorSpace,this.texture.generateMipmaps=texture.generateMipmaps,this.texture.minFilter=texture.minFilter,this.texture.magFilter=texture.magFilter;const shader={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},geometry=new BoxGeometry(5,5,5),material=new ShaderMaterial({name:"CubemapFromEquirect",uniforms:cloneUniforms(shader.uniforms),vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader,side:BackSide,blending:NoBlending});material.uniforms.tEquirect.value=texture;const mesh=new Mesh(geometry,material),currentMinFilter=texture.minFilter;return texture.minFilter===LinearMipmapLinearFilter&&(texture.minFilter=LinearFilter),new CubeCamera(1,10,this).update(renderer,mesh),texture.minFilter=currentMinFilter,mesh.geometry.dispose(),mesh.material.dispose(),this}clear(renderer,color2,depth,stencil){const currentRenderTarget=renderer.getRenderTarget();for(let i2=0;i2<6;i2++)renderer.setRenderTarget(this,i2),renderer.clear(color2,depth,stencil);renderer.setRenderTarget(currentRenderTarget)}}const _vector1=new Vector3,_vector2=new Vector3,_normalMatrix=new Matrix3;class Plane{constructor(normal=new Vector3(1,0,0),constant=0){this.isPlane=!0,this.normal=normal,this.constant=constant}set(normal,constant){return this.normal.copy(normal),this.constant=constant,this}setComponents(x2,y2,z,w2){return this.normal.set(x2,y2,z),this.constant=w2,this}setFromNormalAndCoplanarPoint(normal,point){return this.normal.copy(normal),this.constant=-point.dot(this.normal),this}setFromCoplanarPoints(a2,b2,c2){const normal=_vector1.subVectors(c2,b2).cross(_vector2.subVectors(a2,b2)).normalize();return this.setFromNormalAndCoplanarPoint(normal,a2),this}copy(plane){return this.normal.copy(plane.normal),this.constant=plane.constant,this}normalize(){const inverseNormalLength=1/this.normal.length();return this.normal.multiplyScalar(inverseNormalLength),this.constant*=inverseNormalLength,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(point){return this.normal.dot(point)+this.constant}distanceToSphere(sphere){return this.distanceToPoint(sphere.center)-sphere.radius}projectPoint(point,target){return target.copy(point).addScaledVector(this.normal,-this.distanceToPoint(point))}intersectLine(line,target){const direction=line.delta(_vector1),denominator=this.normal.dot(direction);if(denominator===0)return this.distanceToPoint(line.start)===0?target.copy(line.start):null;const t2=-(line.start.dot(this.normal)+this.constant)/denominator;return t2<0||t2>1?null:target.copy(line.start).addScaledVector(direction,t2)}intersectsLine(line){const startSign=this.distanceToPoint(line.start),endSign=this.distanceToPoint(line.end);return startSign<0&&endSign>0||endSign<0&&startSign>0}intersectsBox(box){return box.intersectsPlane(this)}intersectsSphere(sphere){return sphere.intersectsPlane(this)}coplanarPoint(target){return target.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(matrix,optionalNormalMatrix){const normalMatrix=optionalNormalMatrix||_normalMatrix.getNormalMatrix(matrix),referencePoint=this.coplanarPoint(_vector1).applyMatrix4(matrix),normal=this.normal.applyMatrix3(normalMatrix).normalize();return this.constant=-referencePoint.dot(normal),this}translate(offset){return this.constant-=offset.dot(this.normal),this}equals(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant}clone(){return new this.constructor().copy(this)}}const _sphere$4=new Sphere,_vector$6=new Vector3;class Frustum{constructor(p0=new Plane,p1=new Plane,p2=new Plane,p3=new Plane,p4=new Plane,p5=new Plane){this.planes=[p0,p1,p2,p3,p4,p5]}set(p0,p1,p2,p3,p4,p5){const planes=this.planes;return planes[0].copy(p0),planes[1].copy(p1),planes[2].copy(p2),planes[3].copy(p3),planes[4].copy(p4),planes[5].copy(p5),this}copy(frustum){const planes=this.planes;for(let i2=0;i2<6;i2++)planes[i2].copy(frustum.planes[i2]);return this}setFromProjectionMatrix(m2,coordinateSystem=WebGLCoordinateSystem){const planes=this.planes,me=m2.elements,me0=me[0],me1=me[1],me2=me[2],me3=me[3],me4=me[4],me5=me[5],me6=me[6],me7=me[7],me8=me[8],me9=me[9],me10=me[10],me11=me[11],me12=me[12],me13=me[13],me14=me[14],me15=me[15];if(planes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize(),planes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize(),planes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize(),planes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize(),planes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize(),coordinateSystem===WebGLCoordinateSystem)planes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();else if(coordinateSystem===WebGPUCoordinateSystem)planes[5].setComponents(me2,me6,me10,me14).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+coordinateSystem);return this}intersectsObject(object){if(object.boundingSphere!==void 0)object.boundingSphere===null&&object.computeBoundingSphere(),_sphere$4.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);else{const geometry=object.geometry;geometry.boundingSphere===null&&geometry.computeBoundingSphere(),_sphere$4.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld)}return this.intersectsSphere(_sphere$4)}intersectsSprite(sprite){return _sphere$4.center.set(0,0,0),_sphere$4.radius=.7071067811865476,_sphere$4.applyMatrix4(sprite.matrixWorld),this.intersectsSphere(_sphere$4)}intersectsSphere(sphere){const planes=this.planes,center=sphere.center,negRadius=-sphere.radius;for(let i2=0;i2<6;i2++)if(planes[i2].distanceToPoint(center)<negRadius)return!1;return!0}intersectsBox(box){const planes=this.planes;for(let i2=0;i2<6;i2++){const plane=planes[i2];if(_vector$6.x=plane.normal.x>0?box.max.x:box.min.x,_vector$6.y=plane.normal.y>0?box.max.y:box.min.y,_vector$6.z=plane.normal.z>0?box.max.z:box.min.z,plane.distanceToPoint(_vector$6)<0)return!1}return!0}containsPoint(point){const planes=this.planes;for(let i2=0;i2<6;i2++)if(planes[i2].distanceToPoint(point)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function WebGLAnimation(){let context2=null,isAnimating=!1,animationLoop=null,requestId=null;function onAnimationFrame(time,frame2){animationLoop(time,frame2),requestId=context2.requestAnimationFrame(onAnimationFrame)}return{start:function(){isAnimating!==!0&&animationLoop!==null&&(requestId=context2.requestAnimationFrame(onAnimationFrame),isAnimating=!0)},stop:function(){context2.cancelAnimationFrame(requestId),isAnimating=!1},setAnimationLoop:function(callback){animationLoop=callback},setContext:function(value){context2=value}}}function WebGLAttributes(gl,capabilities){const isWebGL2=capabilities.isWebGL2,buffers=new WeakMap;function createBuffer(attribute,bufferType){const array=attribute.array,usage=attribute.usage,buffer=gl.createBuffer();gl.bindBuffer(bufferType,buffer),gl.bufferData(bufferType,array,usage),attribute.onUploadCallback();let type;if(array instanceof Float32Array)type=gl.FLOAT;else if(array instanceof Uint16Array)if(attribute.isFloat16BufferAttribute)if(isWebGL2)type=gl.HALF_FLOAT;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else type=gl.UNSIGNED_SHORT;else if(array instanceof Int16Array)type=gl.SHORT;else if(array instanceof Uint32Array)type=gl.UNSIGNED_INT;else if(array instanceof Int32Array)type=gl.INT;else if(array instanceof Int8Array)type=gl.BYTE;else if(array instanceof Uint8Array)type=gl.UNSIGNED_BYTE;else if(array instanceof Uint8ClampedArray)type=gl.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+array);return{buffer,type,bytesPerElement:array.BYTES_PER_ELEMENT,version:attribute.version}}function updateBuffer(buffer,attribute,bufferType){const array=attribute.array,updateRange=attribute.updateRange;gl.bindBuffer(bufferType,buffer),updateRange.count===-1?gl.bufferSubData(bufferType,0,array):(isWebGL2?gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array,updateRange.offset,updateRange.count):gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array.subarray(updateRange.offset,updateRange.offset+updateRange.count)),updateRange.count=-1),attribute.onUploadCallback()}function get(attribute){return attribute.isInterleavedBufferAttribute&&(attribute=attribute.data),buffers.get(attribute)}function remove(attribute){attribute.isInterleavedBufferAttribute&&(attribute=attribute.data);const data=buffers.get(attribute);data&&(gl.deleteBuffer(data.buffer),buffers.delete(attribute))}function update(attribute,bufferType){if(attribute.isGLBufferAttribute){const cached=buffers.get(attribute);(!cached||cached.version<attribute.version)&&buffers.set(attribute,{buffer:attribute.buffer,type:attribute.type,bytesPerElement:attribute.elementSize,version:attribute.version});return}attribute.isInterleavedBufferAttribute&&(attribute=attribute.data);const data=buffers.get(attribute);data===void 0?buffers.set(attribute,createBuffer(attribute,bufferType)):data.version<attribute.version&&(updateBuffer(data.buffer,attribute,bufferType),data.version=attribute.version)}return{get,remove,update}}class PlaneGeometry extends BufferGeometry{constructor(width=1,height=1,widthSegments=1,heightSegments=1){super(),this.type="PlaneGeometry",this.parameters={width,height,widthSegments,heightSegments};const width_half=width/2,height_half=height/2,gridX=Math.floor(widthSegments),gridY=Math.floor(heightSegments),gridX1=gridX+1,gridY1=gridY+1,segment_width=width/gridX,segment_height=height/gridY,indices=[],vertices=[],normals=[],uvs=[];for(let iy=0;iy<gridY1;iy++){const y2=iy*segment_height-height_half;for(let ix=0;ix<gridX1;ix++){const x2=ix*segment_width-width_half;vertices.push(x2,-y2,0),normals.push(0,0,1),uvs.push(ix/gridX),uvs.push(1-iy/gridY)}}for(let iy=0;iy<gridY;iy++)for(let ix=0;ix<gridX;ix++){const a2=ix+gridX1*iy,b2=ix+gridX1*(iy+1),c2=ix+1+gridX1*(iy+1),d2=ix+1+gridX1*iy;indices.push(a2,b2,d2),indices.push(b2,c2,d2)}this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new PlaneGeometry(data.width,data.height,data.widthSegments,data.heightSegments)}}var alphahash_fragment=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,alphahash_pars_fragment=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,alphamap_fragment=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,alphamap_pars_fragment=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,alphatest_fragment=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,alphatest_pars_fragment=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,aomap_fragment=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,aomap_pars_fragment=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,begin_vertex=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,beginnormal_vertex=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,bsdfs=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,iridescence_fragment=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,bumpmap_pars_fragment=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,clipping_planes_fragment=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,clipping_planes_pars_fragment=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,clipping_planes_pars_vertex=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,clipping_planes_vertex=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,color_fragment=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,color_pars_fragment=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,color_pars_vertex=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,color_vertex=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,common=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,cube_uv_reflection_fragment=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,defaultnormal_vertex=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,displacementmap_pars_vertex=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,displacementmap_vertex=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,emissivemap_fragment=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,emissivemap_pars_fragment=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,colorspace_fragment="gl_FragColor = linearToOutputTexel( gl_FragColor );",colorspace_pars_fragment=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,envmap_fragment=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,envmap_common_pars_fragment=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,envmap_pars_fragment=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,envmap_pars_vertex=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,envmap_vertex=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,fog_vertex=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,fog_pars_vertex=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,fog_fragment=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,fog_pars_fragment=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gradientmap_pars_fragment=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,lightmap_fragment=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,lightmap_pars_fragment=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,lights_lambert_fragment=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,lights_lambert_pars_fragment=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,lights_pars_begin=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,envmap_physical_pars_fragment=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,lights_toon_fragment=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,lights_toon_pars_fragment=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,lights_phong_fragment=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,lights_phong_pars_fragment=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,lights_physical_fragment=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,lights_physical_pars_fragment=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,lights_fragment_begin=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,lights_fragment_maps=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,lights_fragment_end=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,logdepthbuf_fragment=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,logdepthbuf_pars_fragment=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,logdepthbuf_pars_vertex=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,logdepthbuf_vertex=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,map_fragment=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,map_pars_fragment=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,map_particle_fragment=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,map_particle_pars_fragment=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,metalnessmap_fragment=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,metalnessmap_pars_fragment=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,morphcolor_vertex=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,morphnormal_vertex=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,morphtarget_pars_vertex=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,morphtarget_vertex=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,normal_fragment_begin=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,normal_fragment_maps=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,normal_pars_fragment=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_pars_vertex=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,normal_vertex=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,normalmap_pars_fragment=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,clearcoat_normal_fragment_begin=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,clearcoat_normal_fragment_maps=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,clearcoat_pars_fragment=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,iridescence_pars_fragment=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,opaque_fragment=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,packing=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,premultiplied_alpha_fragment=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,project_vertex=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,dithering_fragment=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,dithering_pars_fragment=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,roughnessmap_fragment=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,roughnessmap_pars_fragment=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,shadowmap_pars_fragment=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,shadowmap_pars_vertex=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,shadowmap_vertex=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,shadowmask_pars_fragment=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,skinbase_vertex=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,skinning_pars_vertex=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,skinning_vertex=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,skinnormal_vertex=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,specularmap_fragment=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,specularmap_pars_fragment=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,tonemapping_fragment=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,tonemapping_pars_fragment=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,transmission_fragment=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,transmission_pars_fragment=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,uv_pars_fragment=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uv_pars_vertex=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,uv_vertex=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,worldpos_vertex=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const vertex$h=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,fragment$h=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$g=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fragment$g=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$f=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,fragment$f=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$e=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,fragment$e=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,vertex$d=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,fragment$d=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,vertex$c=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,fragment$c=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,vertex$b=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,fragment$b=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vertex$a=`#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,fragment$a=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$9=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$9=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$8=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,fragment$8=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$7=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,fragment$7=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,vertex$6=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$6=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$5=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,fragment$5=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$4=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$4=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,vertex$3=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,fragment$3=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,vertex$2=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,fragment$2=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,vertex$1=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,fragment$1=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,ShaderChunk={alphahash_fragment,alphahash_pars_fragment,alphamap_fragment,alphamap_pars_fragment,alphatest_fragment,alphatest_pars_fragment,aomap_fragment,aomap_pars_fragment,begin_vertex,beginnormal_vertex,bsdfs,iridescence_fragment,bumpmap_pars_fragment,clipping_planes_fragment,clipping_planes_pars_fragment,clipping_planes_pars_vertex,clipping_planes_vertex,color_fragment,color_pars_fragment,color_pars_vertex,color_vertex,common,cube_uv_reflection_fragment,defaultnormal_vertex,displacementmap_pars_vertex,displacementmap_vertex,emissivemap_fragment,emissivemap_pars_fragment,colorspace_fragment,colorspace_pars_fragment,envmap_fragment,envmap_common_pars_fragment,envmap_pars_fragment,envmap_pars_vertex,envmap_physical_pars_fragment,envmap_vertex,fog_vertex,fog_pars_vertex,fog_fragment,fog_pars_fragment,gradientmap_pars_fragment,lightmap_fragment,lightmap_pars_fragment,lights_lambert_fragment,lights_lambert_pars_fragment,lights_pars_begin,lights_toon_fragment,lights_toon_pars_fragment,lights_phong_fragment,lights_phong_pars_fragment,lights_physical_fragment,lights_physical_pars_fragment,lights_fragment_begin,lights_fragment_maps,lights_fragment_end,logdepthbuf_fragment,logdepthbuf_pars_fragment,logdepthbuf_pars_vertex,logdepthbuf_vertex,map_fragment,map_pars_fragment,map_particle_fragment,map_particle_pars_fragment,metalnessmap_fragment,metalnessmap_pars_fragment,morphcolor_vertex,morphnormal_vertex,morphtarget_pars_vertex,morphtarget_vertex,normal_fragment_begin,normal_fragment_maps,normal_pars_fragment,normal_pars_vertex,normal_vertex,normalmap_pars_fragment,clearcoat_normal_fragment_begin,clearcoat_normal_fragment_maps,clearcoat_pars_fragment,iridescence_pars_fragment,opaque_fragment,packing,premultiplied_alpha_fragment,project_vertex,dithering_fragment,dithering_pars_fragment,roughnessmap_fragment,roughnessmap_pars_fragment,shadowmap_pars_fragment,shadowmap_pars_vertex,shadowmap_vertex,shadowmask_pars_fragment,skinbase_vertex,skinning_pars_vertex,skinning_vertex,skinnormal_vertex,specularmap_fragment,specularmap_pars_fragment,tonemapping_fragment,tonemapping_pars_fragment,transmission_fragment,transmission_pars_fragment,uv_pars_fragment,uv_pars_vertex,uv_vertex,worldpos_vertex,background_vert:vertex$h,background_frag:fragment$h,backgroundCube_vert:vertex$g,backgroundCube_frag:fragment$g,cube_vert:vertex$f,cube_frag:fragment$f,depth_vert:vertex$e,depth_frag:fragment$e,distanceRGBA_vert:vertex$d,distanceRGBA_frag:fragment$d,equirect_vert:vertex$c,equirect_frag:fragment$c,linedashed_vert:vertex$b,linedashed_frag:fragment$b,meshbasic_vert:vertex$a,meshbasic_frag:fragment$a,meshlambert_vert:vertex$9,meshlambert_frag:fragment$9,meshmatcap_vert:vertex$8,meshmatcap_frag:fragment$8,meshnormal_vert:vertex$7,meshnormal_frag:fragment$7,meshphong_vert:vertex$6,meshphong_frag:fragment$6,meshphysical_vert:vertex$5,meshphysical_frag:fragment$5,meshtoon_vert:vertex$4,meshtoon_frag:fragment$4,points_vert:vertex$3,points_frag:fragment$3,shadow_vert:vertex$2,shadow_frag:fragment$2,sprite_vert:vertex$1,sprite_frag:fragment$1},UniformsLib={common:{diffuse:{value:new Color(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new Matrix3},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new Matrix3}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new Matrix3}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new Matrix3}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new Matrix3},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new Matrix3},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new Matrix3},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new Matrix3}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new Matrix3}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new Matrix3}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Color(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Color(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0},uvTransform:{value:new Matrix3}},sprite:{diffuse:{value:new Color(16777215)},opacity:{value:1},center:{value:new Vector2(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new Matrix3},alphaMap:{value:null},alphaMapTransform:{value:new Matrix3},alphaTest:{value:0}}},ShaderLib={basic:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)},specular:{value:new Color(1118481)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},toon:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)}}]),vertexShader:ShaderChunk.meshtoon_vert,fragmentShader:ShaderChunk.meshtoon_frag},matcap:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,{matcap:{value:null}}]),vertexShader:ShaderChunk.meshmatcap_vert,fragmentShader:ShaderChunk.meshmatcap_frag},points:{uniforms:mergeUniforms([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1}}]),vertexShader:ShaderChunk.meshnormal_vert,fragmentShader:ShaderChunk.meshnormal_frag},sprite:{uniforms:mergeUniforms([UniformsLib.sprite,UniformsLib.fog]),vertexShader:ShaderChunk.sprite_vert,fragmentShader:ShaderChunk.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:ShaderChunk.background_vert,fragmentShader:ShaderChunk.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:ShaderChunk.backgroundCube_vert,fragmentShader:ShaderChunk.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:new Vector3},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([UniformsLib.lights,UniformsLib.fog,{color:{value:new Color(0)},opacity:{value:1}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:mergeUniforms([ShaderLib.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new Matrix3},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new Matrix3},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new Matrix3},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new Matrix3},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new Matrix3},sheen:{value:0},sheenColor:{value:new Color(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new Matrix3},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new Matrix3},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new Matrix3},transmissionSamplerSize:{value:new Vector2},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new Matrix3},attenuationDistance:{value:0},attenuationColor:{value:new Color(0)},specularColor:{value:new Color(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new Matrix3},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new Matrix3},anisotropyVector:{value:new Vector2},anisotropyMap:{value:null},anisotropyMapTransform:{value:new Matrix3}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};const _rgb={r:0,b:0,g:0};function WebGLBackground(renderer,cubemaps,cubeuvmaps,state,objects,alpha2,premultipliedAlpha){const clearColor=new Color(0);let clearAlpha=alpha2===!0?0:1,planeMesh,boxMesh,currentBackground=null,currentBackgroundVersion=0,currentTonemapping=null;function render(renderList,scene2){let forceClear=!1,background=scene2.isScene===!0?scene2.background:null;background&&background.isTexture&&(background=(scene2.backgroundBlurriness>0?cubeuvmaps:cubemaps).get(background)),background===null?setClear(clearColor,clearAlpha):background&&background.isColor&&(setClear(background,1),forceClear=!0);const environmentBlendMode=renderer.xr.getEnvironmentBlendMode();environmentBlendMode==="additive"?state.buffers.color.setClear(0,0,0,1,premultipliedAlpha):environmentBlendMode==="alpha-blend"&&state.buffers.color.setClear(0,0,0,0,premultipliedAlpha),(renderer.autoClear||forceClear)&&renderer.clear(renderer.autoClearColor,renderer.autoClearDepth,renderer.autoClearStencil),background&&(background.isCubeTexture||background.mapping===CubeUVReflectionMapping)?(boxMesh===void 0&&(boxMesh=new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({name:"BackgroundCubeMaterial",uniforms:cloneUniforms(ShaderLib.backgroundCube.uniforms),vertexShader:ShaderLib.backgroundCube.vertexShader,fragmentShader:ShaderLib.backgroundCube.fragmentShader,side:BackSide,depthTest:!1,depthWrite:!1,fog:!1})),boxMesh.geometry.deleteAttribute("normal"),boxMesh.geometry.deleteAttribute("uv"),boxMesh.onBeforeRender=function(renderer2,scene3,camera){this.matrixWorld.copyPosition(camera.matrixWorld)},Object.defineProperty(boxMesh.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),objects.update(boxMesh)),boxMesh.material.uniforms.envMap.value=background,boxMesh.material.uniforms.flipEnvMap.value=background.isCubeTexture&&background.isRenderTargetTexture===!1?-1:1,boxMesh.material.uniforms.backgroundBlurriness.value=scene2.backgroundBlurriness,boxMesh.material.uniforms.backgroundIntensity.value=scene2.backgroundIntensity,boxMesh.material.toneMapped=ColorManagement.getTransfer(background.colorSpace)!==SRGBTransfer,(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer.toneMapping)&&(boxMesh.material.needsUpdate=!0,currentBackground=background,currentBackgroundVersion=background.version,currentTonemapping=renderer.toneMapping),boxMesh.layers.enableAll(),renderList.unshift(boxMesh,boxMesh.geometry,boxMesh.material,0,0,null)):background&&background.isTexture&&(planeMesh===void 0&&(planeMesh=new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:"BackgroundMaterial",uniforms:cloneUniforms(ShaderLib.background.uniforms),vertexShader:ShaderLib.background.vertexShader,fragmentShader:ShaderLib.background.fragmentShader,side:FrontSide,depthTest:!1,depthWrite:!1,fog:!1})),planeMesh.geometry.deleteAttribute("normal"),Object.defineProperty(planeMesh.material,"map",{get:function(){return this.uniforms.t2D.value}}),objects.update(planeMesh)),planeMesh.material.uniforms.t2D.value=background,planeMesh.material.uniforms.backgroundIntensity.value=scene2.backgroundIntensity,planeMesh.material.toneMapped=ColorManagement.getTransfer(background.colorSpace)!==SRGBTransfer,background.matrixAutoUpdate===!0&&background.updateMatrix(),planeMesh.material.uniforms.uvTransform.value.copy(background.matrix),(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer.toneMapping)&&(planeMesh.material.needsUpdate=!0,currentBackground=background,currentBackgroundVersion=background.version,currentTonemapping=renderer.toneMapping),planeMesh.layers.enableAll(),renderList.unshift(planeMesh,planeMesh.geometry,planeMesh.material,0,0,null))}function setClear(color2,alpha3){color2.getRGB(_rgb,getUnlitUniformColorSpace(renderer)),state.buffers.color.setClear(_rgb.r,_rgb.g,_rgb.b,alpha3,premultipliedAlpha)}return{getClearColor:function(){return clearColor},setClearColor:function(color2,alpha3=1){clearColor.set(color2),clearAlpha=alpha3,setClear(clearColor,clearAlpha)},getClearAlpha:function(){return clearAlpha},setClearAlpha:function(alpha3){clearAlpha=alpha3,setClear(clearColor,clearAlpha)},render}}function WebGLBindingStates(gl,extensions2,attributes,capabilities){const maxVertexAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS),extension=capabilities.isWebGL2?null:extensions2.get("OES_vertex_array_object"),vaoAvailable=capabilities.isWebGL2||extension!==null,bindingStates={},defaultState=createBindingState(null);let currentState=defaultState,forceUpdate=!1;function setup(object,material,program,geometry,index){let updateBuffers=!1;if(vaoAvailable){const state=getBindingState(geometry,program,material);currentState!==state&&(currentState=state,bindVertexArrayObject(currentState.object)),updateBuffers=needsUpdate(object,geometry,program,index),updateBuffers&&saveCache(object,geometry,program,index)}else{const wireframe=material.wireframe===!0;(currentState.geometry!==geometry.id||currentState.program!==program.id||currentState.wireframe!==wireframe)&&(currentState.geometry=geometry.id,currentState.program=program.id,currentState.wireframe=wireframe,updateBuffers=!0)}index!==null&&attributes.update(index,gl.ELEMENT_ARRAY_BUFFER),(updateBuffers||forceUpdate)&&(forceUpdate=!1,setupVertexAttributes(object,material,program,geometry),index!==null&&gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,attributes.get(index).buffer))}function createVertexArrayObject(){return capabilities.isWebGL2?gl.createVertexArray():extension.createVertexArrayOES()}function bindVertexArrayObject(vao){return capabilities.isWebGL2?gl.bindVertexArray(vao):extension.bindVertexArrayOES(vao)}function deleteVertexArrayObject(vao){return capabilities.isWebGL2?gl.deleteVertexArray(vao):extension.deleteVertexArrayOES(vao)}function getBindingState(geometry,program,material){const wireframe=material.wireframe===!0;let programMap=bindingStates[geometry.id];programMap===void 0&&(programMap={},bindingStates[geometry.id]=programMap);let stateMap=programMap[program.id];stateMap===void 0&&(stateMap={},programMap[program.id]=stateMap);let state=stateMap[wireframe];return state===void 0&&(state=createBindingState(createVertexArrayObject()),stateMap[wireframe]=state),state}function createBindingState(vao){const newAttributes=[],enabledAttributes=[],attributeDivisors=[];for(let i2=0;i2<maxVertexAttributes;i2++)newAttributes[i2]=0,enabledAttributes[i2]=0,attributeDivisors[i2]=0;return{geometry:null,program:null,wireframe:!1,newAttributes,enabledAttributes,attributeDivisors,object:vao,attributes:{},index:null}}function needsUpdate(object,geometry,program,index){const cachedAttributes=currentState.attributes,geometryAttributes=geometry.attributes;let attributesNum=0;const programAttributes=program.getAttributes();for(const name in programAttributes)if(programAttributes[name].location>=0){const cachedAttribute=cachedAttributes[name];let geometryAttribute=geometryAttributes[name];if(geometryAttribute===void 0&&(name==="instanceMatrix"&&object.instanceMatrix&&(geometryAttribute=object.instanceMatrix),name==="instanceColor"&&object.instanceColor&&(geometryAttribute=object.instanceColor)),cachedAttribute===void 0||cachedAttribute.attribute!==geometryAttribute||geometryAttribute&&cachedAttribute.data!==geometryAttribute.data)return!0;attributesNum++}return currentState.attributesNum!==attributesNum||currentState.index!==index}function saveCache(object,geometry,program,index){const cache={},attributes2=geometry.attributes;let attributesNum=0;const programAttributes=program.getAttributes();for(const name in programAttributes)if(programAttributes[name].location>=0){let attribute=attributes2[name];attribute===void 0&&(name==="instanceMatrix"&&object.instanceMatrix&&(attribute=object.instanceMatrix),name==="instanceColor"&&object.instanceColor&&(attribute=object.instanceColor));const data={};data.attribute=attribute,attribute&&attribute.data&&(data.data=attribute.data),cache[name]=data,attributesNum++}currentState.attributes=cache,currentState.attributesNum=attributesNum,currentState.index=index}function initAttributes(){const newAttributes=currentState.newAttributes;for(let i2=0,il=newAttributes.length;i2<il;i2++)newAttributes[i2]=0}function enableAttribute(attribute){enableAttributeAndDivisor(attribute,0)}function enableAttributeAndDivisor(attribute,meshPerAttribute){const newAttributes=currentState.newAttributes,enabledAttributes=currentState.enabledAttributes,attributeDivisors=currentState.attributeDivisors;newAttributes[attribute]=1,enabledAttributes[attribute]===0&&(gl.enableVertexAttribArray(attribute),enabledAttributes[attribute]=1),attributeDivisors[attribute]!==meshPerAttribute&&((capabilities.isWebGL2?gl:extensions2.get("ANGLE_instanced_arrays"))[capabilities.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](attribute,meshPerAttribute),attributeDivisors[attribute]=meshPerAttribute)}function disableUnusedAttributes(){const newAttributes=currentState.newAttributes,enabledAttributes=currentState.enabledAttributes;for(let i2=0,il=enabledAttributes.length;i2<il;i2++)enabledAttributes[i2]!==newAttributes[i2]&&(gl.disableVertexAttribArray(i2),enabledAttributes[i2]=0)}function vertexAttribPointer(index,size,type,normalized,stride,offset,integer){integer===!0?gl.vertexAttribIPointer(index,size,type,stride,offset):gl.vertexAttribPointer(index,size,type,normalized,stride,offset)}function setupVertexAttributes(object,material,program,geometry){if(capabilities.isWebGL2===!1&&(object.isInstancedMesh||geometry.isInstancedBufferGeometry)&&extensions2.get("ANGLE_instanced_arrays")===null)return;initAttributes();const geometryAttributes=geometry.attributes,programAttributes=program.getAttributes(),materialDefaultAttributeValues=material.defaultAttributeValues;for(const name in programAttributes){const programAttribute=programAttributes[name];if(programAttribute.location>=0){let geometryAttribute=geometryAttributes[name];if(geometryAttribute===void 0&&(name==="instanceMatrix"&&object.instanceMatrix&&(geometryAttribute=object.instanceMatrix),name==="instanceColor"&&object.instanceColor&&(geometryAttribute=object.instanceColor)),geometryAttribute!==void 0){const normalized=geometryAttribute.normalized,size=geometryAttribute.itemSize,attribute=attributes.get(geometryAttribute);if(attribute===void 0)continue;const buffer=attribute.buffer,type=attribute.type,bytesPerElement=attribute.bytesPerElement,integer=capabilities.isWebGL2===!0&&(type===gl.INT||type===gl.UNSIGNED_INT||geometryAttribute.gpuType===IntType);if(geometryAttribute.isInterleavedBufferAttribute){const data=geometryAttribute.data,stride=data.stride,offset=geometryAttribute.offset;if(data.isInstancedInterleavedBuffer){for(let i2=0;i2<programAttribute.locationSize;i2++)enableAttributeAndDivisor(programAttribute.location+i2,data.meshPerAttribute);object.isInstancedMesh!==!0&&geometry._maxInstanceCount===void 0&&(geometry._maxInstanceCount=data.meshPerAttribute*data.count)}else for(let i2=0;i2<programAttribute.locationSize;i2++)enableAttribute(programAttribute.location+i2);gl.bindBuffer(gl.ARRAY_BUFFER,buffer);for(let i2=0;i2<programAttribute.locationSize;i2++)vertexAttribPointer(programAttribute.location+i2,size/programAttribute.locationSize,type,normalized,stride*bytesPerElement,(offset+size/programAttribute.locationSize*i2)*bytesPerElement,integer)}else{if(geometryAttribute.isInstancedBufferAttribute){for(let i2=0;i2<programAttribute.locationSize;i2++)enableAttributeAndDivisor(programAttribute.location+i2,geometryAttribute.meshPerAttribute);object.isInstancedMesh!==!0&&geometry._maxInstanceCount===void 0&&(geometry._maxInstanceCount=geometryAttribute.meshPerAttribute*geometryAttribute.count)}else for(let i2=0;i2<programAttribute.locationSize;i2++)enableAttribute(programAttribute.location+i2);gl.bindBuffer(gl.ARRAY_BUFFER,buffer);for(let i2=0;i2<programAttribute.locationSize;i2++)vertexAttribPointer(programAttribute.location+i2,size/programAttribute.locationSize,type,normalized,size*bytesPerElement,size/programAttribute.locationSize*i2*bytesPerElement,integer)}}else if(materialDefaultAttributeValues!==void 0){const value=materialDefaultAttributeValues[name];if(value!==void 0)switch(value.length){case 2:gl.vertexAttrib2fv(programAttribute.location,value);break;case 3:gl.vertexAttrib3fv(programAttribute.location,value);break;case 4:gl.vertexAttrib4fv(programAttribute.location,value);break;default:gl.vertexAttrib1fv(programAttribute.location,value)}}}}disableUnusedAttributes()}function dispose2(){reset();for(const geometryId in bindingStates){const programMap=bindingStates[geometryId];for(const programId in programMap){const stateMap=programMap[programId];for(const wireframe in stateMap)deleteVertexArrayObject(stateMap[wireframe].object),delete stateMap[wireframe];delete programMap[programId]}delete bindingStates[geometryId]}}function releaseStatesOfGeometry(geometry){if(bindingStates[geometry.id]===void 0)return;const programMap=bindingStates[geometry.id];for(const programId in programMap){const stateMap=programMap[programId];for(const wireframe in stateMap)deleteVertexArrayObject(stateMap[wireframe].object),delete stateMap[wireframe];delete programMap[programId]}delete bindingStates[geometry.id]}function releaseStatesOfProgram(program){for(const geometryId in bindingStates){const programMap=bindingStates[geometryId];if(programMap[program.id]===void 0)continue;const stateMap=programMap[program.id];for(const wireframe in stateMap)deleteVertexArrayObject(stateMap[wireframe].object),delete stateMap[wireframe];delete programMap[program.id]}}function reset(){resetDefaultState(),forceUpdate=!0,currentState!==defaultState&&(currentState=defaultState,bindVertexArrayObject(currentState.object))}function resetDefaultState(){defaultState.geometry=null,defaultState.program=null,defaultState.wireframe=!1}return{setup,reset,resetDefaultState,dispose:dispose2,releaseStatesOfGeometry,releaseStatesOfProgram,initAttributes,enableAttribute,disableUnusedAttributes}}function WebGLBufferRenderer(gl,extensions2,info,capabilities){const isWebGL2=capabilities.isWebGL2;let mode;function setMode(value){mode=value}function render(start,count){gl.drawArrays(mode,start,count),info.update(count,mode,1)}function renderInstances(start,count,primcount){if(primcount===0)return;let extension,methodName;if(isWebGL2)extension=gl,methodName="drawArraysInstanced";else if(extension=extensions2.get("ANGLE_instanced_arrays"),methodName="drawArraysInstancedANGLE",extension===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}extension[methodName](mode,start,count,primcount),info.update(count,mode,primcount)}this.setMode=setMode,this.render=render,this.renderInstances=renderInstances}function WebGLCapabilities(gl,extensions2,parameters){let maxAnisotropy;function getMaxAnisotropy(){if(maxAnisotropy!==void 0)return maxAnisotropy;if(extensions2.has("EXT_texture_filter_anisotropic")===!0){const extension=extensions2.get("EXT_texture_filter_anisotropic");maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else maxAnisotropy=0;return maxAnisotropy}function getMaxPrecision(precision2){if(precision2==="highp"){if(gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.HIGH_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT).precision>0)return"highp";precision2="mediump"}return precision2==="mediump"&&gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.MEDIUM_FLOAT).precision>0&&gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const isWebGL2=typeof WebGL2RenderingContext<"u"&&gl.constructor.name==="WebGL2RenderingContext";let precision=parameters.precision!==void 0?parameters.precision:"highp";const maxPrecision=getMaxPrecision(precision);maxPrecision!==precision&&(console.warn("THREE.WebGLRenderer:",precision,"not supported, using",maxPrecision,"instead."),precision=maxPrecision);const drawBuffers=isWebGL2||extensions2.has("WEBGL_draw_buffers"),logarithmicDepthBuffer=parameters.logarithmicDepthBuffer===!0,maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),maxVertexTextures=gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),maxTextureSize=gl.getParameter(gl.MAX_TEXTURE_SIZE),maxCubemapSize=gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE),maxAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS),maxVertexUniforms=gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),maxVaryings=gl.getParameter(gl.MAX_VARYING_VECTORS),maxFragmentUniforms=gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),vertexTextures=maxVertexTextures>0,floatFragmentTextures=isWebGL2||extensions2.has("OES_texture_float"),floatVertexTextures=vertexTextures&&floatFragmentTextures,maxSamples=isWebGL2?gl.getParameter(gl.MAX_SAMPLES):0;return{isWebGL2,drawBuffers,getMaxAnisotropy,getMaxPrecision,precision,logarithmicDepthBuffer,maxTextures,maxVertexTextures,maxTextureSize,maxCubemapSize,maxAttributes,maxVertexUniforms,maxVaryings,maxFragmentUniforms,vertexTextures,floatFragmentTextures,floatVertexTextures,maxSamples}}function WebGLClipping(properties){const scope=this;let globalState=null,numGlobalPlanes=0,localClippingEnabled=!1,renderingShadows=!1;const plane=new Plane,viewNormalMatrix=new Matrix3,uniform={value:null,needsUpdate:!1};this.uniform=uniform,this.numPlanes=0,this.numIntersection=0,this.init=function(planes,enableLocalClipping){const enabled=planes.length!==0||enableLocalClipping||numGlobalPlanes!==0||localClippingEnabled;return localClippingEnabled=enableLocalClipping,numGlobalPlanes=planes.length,enabled},this.beginShadows=function(){renderingShadows=!0,projectPlanes(null)},this.endShadows=function(){renderingShadows=!1},this.setGlobalState=function(planes,camera){globalState=projectPlanes(planes,camera,0)},this.setState=function(material,camera,useCache){const planes=material.clippingPlanes,clipIntersection=material.clipIntersection,clipShadows=material.clipShadows,materialProperties=properties.get(material);if(!localClippingEnabled||planes===null||planes.length===0||renderingShadows&&!clipShadows)renderingShadows?projectPlanes(null):resetGlobalState();else{const nGlobal=renderingShadows?0:numGlobalPlanes,lGlobal=nGlobal*4;let dstArray=materialProperties.clippingState||null;uniform.value=dstArray,dstArray=projectPlanes(planes,camera,lGlobal,useCache);for(let i2=0;i2!==lGlobal;++i2)dstArray[i2]=globalState[i2];materialProperties.clippingState=dstArray,this.numIntersection=clipIntersection?this.numPlanes:0,this.numPlanes+=nGlobal}};function resetGlobalState(){uniform.value!==globalState&&(uniform.value=globalState,uniform.needsUpdate=numGlobalPlanes>0),scope.numPlanes=numGlobalPlanes,scope.numIntersection=0}function projectPlanes(planes,camera,dstOffset,skipTransform){const nPlanes=planes!==null?planes.length:0;let dstArray=null;if(nPlanes!==0){if(dstArray=uniform.value,skipTransform!==!0||dstArray===null){const flatSize=dstOffset+nPlanes*4,viewMatrix=camera.matrixWorldInverse;viewNormalMatrix.getNormalMatrix(viewMatrix),(dstArray===null||dstArray.length<flatSize)&&(dstArray=new Float32Array(flatSize));for(let i2=0,i4=dstOffset;i2!==nPlanes;++i2,i4+=4)plane.copy(planes[i2]).applyMatrix4(viewMatrix,viewNormalMatrix),plane.normal.toArray(dstArray,i4),dstArray[i4+3]=plane.constant}uniform.value=dstArray,uniform.needsUpdate=!0}return scope.numPlanes=nPlanes,scope.numIntersection=0,dstArray}}function WebGLCubeMaps(renderer){let cubemaps=new WeakMap;function mapTextureMapping(texture,mapping){return mapping===EquirectangularReflectionMapping?texture.mapping=CubeReflectionMapping:mapping===EquirectangularRefractionMapping&&(texture.mapping=CubeRefractionMapping),texture}function get(texture){if(texture&&texture.isTexture&&texture.isRenderTargetTexture===!1){const mapping=texture.mapping;if(mapping===EquirectangularReflectionMapping||mapping===EquirectangularRefractionMapping)if(cubemaps.has(texture)){const cubemap=cubemaps.get(texture).texture;return mapTextureMapping(cubemap,texture.mapping)}else{const image=texture.image;if(image&&image.height>0){const renderTarget=new WebGLCubeRenderTarget(image.height/2);return renderTarget.fromEquirectangularTexture(renderer,texture),cubemaps.set(texture,renderTarget),texture.addEventListener("dispose",onTextureDispose),mapTextureMapping(renderTarget.texture,texture.mapping)}else return null}}return texture}function onTextureDispose(event){const texture=event.target;texture.removeEventListener("dispose",onTextureDispose);const cubemap=cubemaps.get(texture);cubemap!==void 0&&(cubemaps.delete(texture),cubemap.dispose())}function dispose2(){cubemaps=new WeakMap}return{get,dispose:dispose2}}class OrthographicCamera extends Camera{constructor(left=-1,right=1,top=1,bottom=-1,near=.1,far=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=left,this.right=right,this.top=top,this.bottom=bottom,this.near=near,this.far=far,this.updateProjectionMatrix()}copy(source,recursive){return super.copy(source,recursive),this.left=source.left,this.right=source.right,this.top=source.top,this.bottom=source.bottom,this.near=source.near,this.far=source.far,this.zoom=source.zoom,this.view=source.view===null?null:Object.assign({},source.view),this}setViewOffset(fullWidth,fullHeight,x2,y2,width,height){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=fullWidth,this.view.fullHeight=fullHeight,this.view.offsetX=x2,this.view.offsetY=y2,this.view.width=width,this.view.height=height,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const dx=(this.right-this.left)/(2*this.zoom),dy=(this.top-this.bottom)/(2*this.zoom),cx=(this.right+this.left)/2,cy=(this.top+this.bottom)/2;let left=cx-dx,right=cx+dx,top=cy+dy,bottom=cy-dy;if(this.view!==null&&this.view.enabled){const scaleW=(this.right-this.left)/this.view.fullWidth/this.zoom,scaleH=(this.top-this.bottom)/this.view.fullHeight/this.zoom;left+=scaleW*this.view.offsetX,right=left+scaleW*this.view.width,top-=scaleH*this.view.offsetY,bottom=top-scaleH*this.view.height}this.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(meta){const data=super.toJSON(meta);return data.object.zoom=this.zoom,data.object.left=this.left,data.object.right=this.right,data.object.top=this.top,data.object.bottom=this.bottom,data.object.near=this.near,data.object.far=this.far,this.view!==null&&(data.object.view=Object.assign({},this.view)),data}}const LOD_MIN=4,EXTRA_LOD_SIGMA=[.125,.215,.35,.446,.526,.582],MAX_SAMPLES=20,_flatCamera=new OrthographicCamera,_clearColor=new Color;let _oldTarget=null,_oldActiveCubeFace=0,_oldActiveMipmapLevel=0;const PHI=(1+Math.sqrt(5))/2,INV_PHI=1/PHI,_axisDirections=[new Vector3(1,1,1),new Vector3(-1,1,1),new Vector3(1,1,-1),new Vector3(-1,1,-1),new Vector3(0,PHI,INV_PHI),new Vector3(0,PHI,-INV_PHI),new Vector3(INV_PHI,0,PHI),new Vector3(-INV_PHI,0,PHI),new Vector3(PHI,INV_PHI,0),new Vector3(-PHI,INV_PHI,0)];class PMREMGenerator{constructor(renderer){this._renderer=renderer,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(scene2,sigma=0,near=.1,far=100){_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel(),this._setSize(256);const cubeUVRenderTarget=this._allocateTargets();return cubeUVRenderTarget.depthBuffer=!0,this._sceneToCubeUV(scene2,near,far,cubeUVRenderTarget),sigma>0&&this._blur(cubeUVRenderTarget,0,0,sigma),this._applyPMREM(cubeUVRenderTarget),this._cleanup(cubeUVRenderTarget),cubeUVRenderTarget}fromEquirectangular(equirectangular,renderTarget=null){return this._fromTexture(equirectangular,renderTarget)}fromCubemap(cubemap,renderTarget=null){return this._fromTexture(cubemap,renderTarget)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=_getCubemapMaterial(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=_getEquirectMaterial(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(cubeSize){this._lodMax=Math.floor(Math.log2(cubeSize)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let i2=0;i2<this._lodPlanes.length;i2++)this._lodPlanes[i2].dispose()}_cleanup(outputTarget){this._renderer.setRenderTarget(_oldTarget,_oldActiveCubeFace,_oldActiveMipmapLevel),outputTarget.scissorTest=!1,_setViewport(outputTarget,0,0,outputTarget.width,outputTarget.height)}_fromTexture(texture,renderTarget){texture.mapping===CubeReflectionMapping||texture.mapping===CubeRefractionMapping?this._setSize(texture.image.length===0?16:texture.image[0].width||texture.image[0].image.width):this._setSize(texture.image.width/4),_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel();const cubeUVRenderTarget=renderTarget||this._allocateTargets();return this._textureToCubeUV(texture,cubeUVRenderTarget),this._applyPMREM(cubeUVRenderTarget),this._cleanup(cubeUVRenderTarget),cubeUVRenderTarget}_allocateTargets(){const width=3*Math.max(this._cubeSize,112),height=4*this._cubeSize,params={magFilter:LinearFilter,minFilter:LinearFilter,generateMipmaps:!1,type:HalfFloatType,format:RGBAFormat,colorSpace:LinearSRGBColorSpace,depthBuffer:!1},cubeUVRenderTarget=_createRenderTarget(width,height,params);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==width||this._pingPongRenderTarget.height!==height){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=_createRenderTarget(width,height,params);const{_lodMax}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=_createPlanes(_lodMax)),this._blurMaterial=_getBlurShader(_lodMax,width,height)}return cubeUVRenderTarget}_compileMaterial(material){const tmpMesh=new Mesh(this._lodPlanes[0],material);this._renderer.compile(tmpMesh,_flatCamera)}_sceneToCubeUV(scene2,near,far,cubeUVRenderTarget){const cubeCamera=new PerspectiveCamera$1(90,1,near,far),upSign=[1,-1,1,1,1,1],forwardSign=[1,1,1,-1,-1,-1],renderer=this._renderer,originalAutoClear=renderer.autoClear,toneMapping=renderer.toneMapping;renderer.getClearColor(_clearColor),renderer.toneMapping=NoToneMapping,renderer.autoClear=!1;const backgroundMaterial=new MeshBasicMaterial({name:"PMREM.Background",side:BackSide,depthWrite:!1,depthTest:!1}),backgroundBox=new Mesh(new BoxGeometry,backgroundMaterial);let useSolidColor=!1;const background=scene2.background;background?background.isColor&&(backgroundMaterial.color.copy(background),scene2.background=null,useSolidColor=!0):(backgroundMaterial.color.copy(_clearColor),useSolidColor=!0);for(let i2=0;i2<6;i2++){const col=i2%3;col===0?(cubeCamera.up.set(0,upSign[i2],0),cubeCamera.lookAt(forwardSign[i2],0,0)):col===1?(cubeCamera.up.set(0,0,upSign[i2]),cubeCamera.lookAt(0,forwardSign[i2],0)):(cubeCamera.up.set(0,upSign[i2],0),cubeCamera.lookAt(0,0,forwardSign[i2]));const size=this._cubeSize;_setViewport(cubeUVRenderTarget,col*size,i2>2?size:0,size,size),renderer.setRenderTarget(cubeUVRenderTarget),useSolidColor&&renderer.render(backgroundBox,cubeCamera),renderer.render(scene2,cubeCamera)}backgroundBox.geometry.dispose(),backgroundBox.material.dispose(),renderer.toneMapping=toneMapping,renderer.autoClear=originalAutoClear,scene2.background=background}_textureToCubeUV(texture,cubeUVRenderTarget){const renderer=this._renderer,isCubeTexture=texture.mapping===CubeReflectionMapping||texture.mapping===CubeRefractionMapping;isCubeTexture?(this._cubemapMaterial===null&&(this._cubemapMaterial=_getCubemapMaterial()),this._cubemapMaterial.uniforms.flipEnvMap.value=texture.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=_getEquirectMaterial());const material=isCubeTexture?this._cubemapMaterial:this._equirectMaterial,mesh=new Mesh(this._lodPlanes[0],material),uniforms=material.uniforms;uniforms.envMap.value=texture;const size=this._cubeSize;_setViewport(cubeUVRenderTarget,0,0,3*size,2*size),renderer.setRenderTarget(cubeUVRenderTarget),renderer.render(mesh,_flatCamera)}_applyPMREM(cubeUVRenderTarget){const renderer=this._renderer,autoClear=renderer.autoClear;renderer.autoClear=!1;for(let i2=1;i2<this._lodPlanes.length;i2++){const sigma=Math.sqrt(this._sigmas[i2]*this._sigmas[i2]-this._sigmas[i2-1]*this._sigmas[i2-1]),poleAxis=_axisDirections[(i2-1)%_axisDirections.length];this._blur(cubeUVRenderTarget,i2-1,i2,sigma,poleAxis)}renderer.autoClear=autoClear}_blur(cubeUVRenderTarget,lodIn,lodOut,sigma,poleAxis){const pingPongRenderTarget=this._pingPongRenderTarget;this._halfBlur(cubeUVRenderTarget,pingPongRenderTarget,lodIn,lodOut,sigma,"latitudinal",poleAxis),this._halfBlur(pingPongRenderTarget,cubeUVRenderTarget,lodOut,lodOut,sigma,"longitudinal",poleAxis)}_halfBlur(targetIn,targetOut,lodIn,lodOut,sigmaRadians,direction,poleAxis){const renderer=this._renderer,blurMaterial=this._blurMaterial;direction!=="latitudinal"&&direction!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const STANDARD_DEVIATIONS=3,blurMesh=new Mesh(this._lodPlanes[lodOut],blurMaterial),blurUniforms=blurMaterial.uniforms,pixels=this._sizeLods[lodIn]-1,radiansPerPixel=isFinite(sigmaRadians)?Math.PI/(2*pixels):2*Math.PI/(2*MAX_SAMPLES-1),sigmaPixels=sigmaRadians/radiansPerPixel,samples=isFinite(sigmaRadians)?1+Math.floor(STANDARD_DEVIATIONS*sigmaPixels):MAX_SAMPLES;samples>MAX_SAMPLES&&console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);const weights=[];let sum=0;for(let i2=0;i2<MAX_SAMPLES;++i2){const x3=i2/sigmaPixels,weight=Math.exp(-x3*x3/2);weights.push(weight),i2===0?sum+=weight:i2<samples&&(sum+=2*weight)}for(let i2=0;i2<weights.length;i2++)weights[i2]=weights[i2]/sum;blurUniforms.envMap.value=targetIn.texture,blurUniforms.samples.value=samples,blurUniforms.weights.value=weights,blurUniforms.latitudinal.value=direction==="latitudinal",poleAxis&&(blurUniforms.poleAxis.value=poleAxis);const{_lodMax}=this;blurUniforms.dTheta.value=radiansPerPixel,blurUniforms.mipInt.value=_lodMax-lodIn;const outputSize=this._sizeLods[lodOut],x2=3*outputSize*(lodOut>_lodMax-LOD_MIN?lodOut-_lodMax+LOD_MIN:0),y2=4*(this._cubeSize-outputSize);_setViewport(targetOut,x2,y2,3*outputSize,2*outputSize),renderer.setRenderTarget(targetOut),renderer.render(blurMesh,_flatCamera)}}function _createPlanes(lodMax){const lodPlanes=[],sizeLods=[],sigmas=[];let lod=lodMax;const totalLods=lodMax-LOD_MIN+1+EXTRA_LOD_SIGMA.length;for(let i2=0;i2<totalLods;i2++){const sizeLod=Math.pow(2,lod);sizeLods.push(sizeLod);let sigma=1/sizeLod;i2>lodMax-LOD_MIN?sigma=EXTRA_LOD_SIGMA[i2-lodMax+LOD_MIN-1]:i2===0&&(sigma=0),sigmas.push(sigma);const texelSize=1/(sizeLod-2),min=-texelSize,max2=1+texelSize,uv1=[min,min,max2,min,max2,max2,min,min,max2,max2,min,max2],cubeFaces=6,vertices=6,positionSize=3,uvSize=2,faceIndexSize=1,position=new Float32Array(positionSize*vertices*cubeFaces),uv=new Float32Array(uvSize*vertices*cubeFaces),faceIndex=new Float32Array(faceIndexSize*vertices*cubeFaces);for(let face=0;face<cubeFaces;face++){const x2=face%3*2/3-1,y2=face>2?0:-1,coordinates=[x2,y2,0,x2+2/3,y2,0,x2+2/3,y2+1,0,x2,y2,0,x2+2/3,y2+1,0,x2,y2+1,0];position.set(coordinates,positionSize*vertices*face),uv.set(uv1,uvSize*vertices*face);const fill=[face,face,face,face,face,face];faceIndex.set(fill,faceIndexSize*vertices*face)}const planes=new BufferGeometry;planes.setAttribute("position",new BufferAttribute(position,positionSize)),planes.setAttribute("uv",new BufferAttribute(uv,uvSize)),planes.setAttribute("faceIndex",new BufferAttribute(faceIndex,faceIndexSize)),lodPlanes.push(planes),lod>LOD_MIN&&lod--}return{lodPlanes,sizeLods,sigmas}}function _createRenderTarget(width,height,params){const cubeUVRenderTarget=new WebGLRenderTarget(width,height,params);return cubeUVRenderTarget.texture.mapping=CubeUVReflectionMapping,cubeUVRenderTarget.texture.name="PMREM.cubeUv",cubeUVRenderTarget.scissorTest=!0,cubeUVRenderTarget}function _setViewport(target,x2,y2,width,height){target.viewport.set(x2,y2,width,height),target.scissor.set(x2,y2,width,height)}function _getBlurShader(lodMax,width,height){const weights=new Float32Array(MAX_SAMPLES),poleAxis=new Vector3(0,1,0);return new ShaderMaterial({name:"SphericalGaussianBlur",defines:{n:MAX_SAMPLES,CUBEUV_TEXEL_WIDTH:1/width,CUBEUV_TEXEL_HEIGHT:1/height,CUBEUV_MAX_MIP:`${lodMax}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:weights},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:poleAxis}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getEquirectMaterial(){return new ShaderMaterial({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getCubemapMaterial(){return new ShaderMaterial({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:_getCommonVertexShader(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:NoBlending,depthTest:!1,depthWrite:!1})}function _getCommonVertexShader(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function WebGLCubeUVMaps(renderer){let cubeUVmaps=new WeakMap,pmremGenerator=null;function get(texture){if(texture&&texture.isTexture){const mapping=texture.mapping,isEquirectMap=mapping===EquirectangularReflectionMapping||mapping===EquirectangularRefractionMapping,isCubeMap=mapping===CubeReflectionMapping||mapping===CubeRefractionMapping;if(isEquirectMap||isCubeMap)if(texture.isRenderTargetTexture&&texture.needsPMREMUpdate===!0){texture.needsPMREMUpdate=!1;let renderTarget=cubeUVmaps.get(texture);return pmremGenerator===null&&(pmremGenerator=new PMREMGenerator(renderer)),renderTarget=isEquirectMap?pmremGenerator.fromEquirectangular(texture,renderTarget):pmremGenerator.fromCubemap(texture,renderTarget),cubeUVmaps.set(texture,renderTarget),renderTarget.texture}else{if(cubeUVmaps.has(texture))return cubeUVmaps.get(texture).texture;{const image=texture.image;if(isEquirectMap&&image&&image.height>0||isCubeMap&&image&&isCubeTextureComplete(image)){pmremGenerator===null&&(pmremGenerator=new PMREMGenerator(renderer));const renderTarget=isEquirectMap?pmremGenerator.fromEquirectangular(texture):pmremGenerator.fromCubemap(texture);return cubeUVmaps.set(texture,renderTarget),texture.addEventListener("dispose",onTextureDispose),renderTarget.texture}else return null}}}return texture}function isCubeTextureComplete(image){let count=0;const length=6;for(let i2=0;i2<length;i2++)image[i2]!==void 0&&count++;return count===length}function onTextureDispose(event){const texture=event.target;texture.removeEventListener("dispose",onTextureDispose);const cubemapUV=cubeUVmaps.get(texture);cubemapUV!==void 0&&(cubeUVmaps.delete(texture),cubemapUV.dispose())}function dispose2(){cubeUVmaps=new WeakMap,pmremGenerator!==null&&(pmremGenerator.dispose(),pmremGenerator=null)}return{get,dispose:dispose2}}function WebGLExtensions(gl){const extensions2={};function getExtension(name){if(extensions2[name]!==void 0)return extensions2[name];let extension;switch(name){case"WEBGL_depth_texture":extension=gl.getExtension("WEBGL_depth_texture")||gl.getExtension("MOZ_WEBGL_depth_texture")||gl.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":extension=gl.getExtension("EXT_texture_filter_anisotropic")||gl.getExtension("MOZ_EXT_texture_filter_anisotropic")||gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":extension=gl.getExtension("WEBGL_compressed_texture_s3tc")||gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":extension=gl.getExtension("WEBGL_compressed_texture_pvrtc")||gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:extension=gl.getExtension(name)}return extensions2[name]=extension,extension}return{has:function(name){return getExtension(name)!==null},init:function(capabilities){capabilities.isWebGL2?getExtension("EXT_color_buffer_float"):(getExtension("WEBGL_depth_texture"),getExtension("OES_texture_float"),getExtension("OES_texture_half_float"),getExtension("OES_texture_half_float_linear"),getExtension("OES_standard_derivatives"),getExtension("OES_element_index_uint"),getExtension("OES_vertex_array_object"),getExtension("ANGLE_instanced_arrays")),getExtension("OES_texture_float_linear"),getExtension("EXT_color_buffer_half_float"),getExtension("WEBGL_multisampled_render_to_texture")},get:function(name){const extension=getExtension(name);return extension===null&&console.warn("THREE.WebGLRenderer: "+name+" extension not supported."),extension}}}function WebGLGeometries(gl,attributes,info,bindingStates){const geometries={},wireframeAttributes=new WeakMap;function onGeometryDispose(event){const geometry=event.target;geometry.index!==null&&attributes.remove(geometry.index);for(const name in geometry.attributes)attributes.remove(geometry.attributes[name]);for(const name in geometry.morphAttributes){const array=geometry.morphAttributes[name];for(let i2=0,l2=array.length;i2<l2;i2++)attributes.remove(array[i2])}geometry.removeEventListener("dispose",onGeometryDispose),delete geometries[geometry.id];const attribute=wireframeAttributes.get(geometry);attribute&&(attributes.remove(attribute),wireframeAttributes.delete(geometry)),bindingStates.releaseStatesOfGeometry(geometry),geometry.isInstancedBufferGeometry===!0&&delete geometry._maxInstanceCount,info.memory.geometries--}function get(object,geometry){return geometries[geometry.id]===!0||(geometry.addEventListener("dispose",onGeometryDispose),geometries[geometry.id]=!0,info.memory.geometries++),geometry}function update(geometry){const geometryAttributes=geometry.attributes;for(const name in geometryAttributes)attributes.update(geometryAttributes[name],gl.ARRAY_BUFFER);const morphAttributes=geometry.morphAttributes;for(const name in morphAttributes){const array=morphAttributes[name];for(let i2=0,l2=array.length;i2<l2;i2++)attributes.update(array[i2],gl.ARRAY_BUFFER)}}function updateWireframeAttribute(geometry){const indices=[],geometryIndex=geometry.index,geometryPosition=geometry.attributes.position;let version2=0;if(geometryIndex!==null){const array=geometryIndex.array;version2=geometryIndex.version;for(let i2=0,l2=array.length;i2<l2;i2+=3){const a2=array[i2+0],b2=array[i2+1],c2=array[i2+2];indices.push(a2,b2,b2,c2,c2,a2)}}else if(geometryPosition!==void 0){const array=geometryPosition.array;version2=geometryPosition.version;for(let i2=0,l2=array.length/3-1;i2<l2;i2+=3){const a2=i2+0,b2=i2+1,c2=i2+2;indices.push(a2,b2,b2,c2,c2,a2)}}else return;const attribute=new(arrayNeedsUint32(indices)?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1);attribute.version=version2;const previousAttribute=wireframeAttributes.get(geometry);previousAttribute&&attributes.remove(previousAttribute),wireframeAttributes.set(geometry,attribute)}function getWireframeAttribute(geometry){const currentAttribute=wireframeAttributes.get(geometry);if(currentAttribute){const geometryIndex=geometry.index;geometryIndex!==null&&currentAttribute.version<geometryIndex.version&&updateWireframeAttribute(geometry)}else updateWireframeAttribute(geometry);return wireframeAttributes.get(geometry)}return{get,update,getWireframeAttribute}}function WebGLIndexedBufferRenderer(gl,extensions2,info,capabilities){const isWebGL2=capabilities.isWebGL2;let mode;function setMode(value){mode=value}let type,bytesPerElement;function setIndex(value){type=value.type,bytesPerElement=value.bytesPerElement}function render(start,count){gl.drawElements(mode,count,type,start*bytesPerElement),info.update(count,mode,1)}function renderInstances(start,count,primcount){if(primcount===0)return;let extension,methodName;if(isWebGL2)extension=gl,methodName="drawElementsInstanced";else if(extension=extensions2.get("ANGLE_instanced_arrays"),methodName="drawElementsInstancedANGLE",extension===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}extension[methodName](mode,count,type,start*bytesPerElement,primcount),info.update(count,mode,primcount)}this.setMode=setMode,this.setIndex=setIndex,this.render=render,this.renderInstances=renderInstances}function WebGLInfo(gl){const memory={geometries:0,textures:0},render={frame:0,calls:0,triangles:0,points:0,lines:0};function update(count,mode,instanceCount){switch(render.calls++,mode){case gl.TRIANGLES:render.triangles+=instanceCount*(count/3);break;case gl.LINES:render.lines+=instanceCount*(count/2);break;case gl.LINE_STRIP:render.lines+=instanceCount*(count-1);break;case gl.LINE_LOOP:render.lines+=instanceCount*count;break;case gl.POINTS:render.points+=instanceCount*count;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",mode);break}}function reset(){render.calls=0,render.triangles=0,render.points=0,render.lines=0}return{memory,render,programs:null,autoReset:!0,reset,update}}function numericalSort(a2,b2){return a2[0]-b2[0]}function absNumericalSort(a2,b2){return Math.abs(b2[1])-Math.abs(a2[1])}function WebGLMorphtargets(gl,capabilities,textures){const influencesList={},morphInfluences=new Float32Array(8),morphTextures=new WeakMap,morph=new Vector4,workInfluences=[];for(let i2=0;i2<8;i2++)workInfluences[i2]=[i2,0];function update(object,geometry,program){const objectInfluences=object.morphTargetInfluences;if(capabilities.isWebGL2===!0){const morphAttribute=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color,morphTargetsCount=morphAttribute!==void 0?morphAttribute.length:0;let entry=morphTextures.get(geometry);if(entry===void 0||entry.count!==morphTargetsCount){let disposeTexture2=function(){texture.dispose(),morphTextures.delete(geometry),geometry.removeEventListener("dispose",disposeTexture2)};var disposeTexture=disposeTexture2;entry!==void 0&&entry.texture.dispose();const hasMorphPosition=geometry.morphAttributes.position!==void 0,hasMorphNormals=geometry.morphAttributes.normal!==void 0,hasMorphColors=geometry.morphAttributes.color!==void 0,morphTargets=geometry.morphAttributes.position||[],morphNormals=geometry.morphAttributes.normal||[],morphColors=geometry.morphAttributes.color||[];let vertexDataCount=0;hasMorphPosition===!0&&(vertexDataCount=1),hasMorphNormals===!0&&(vertexDataCount=2),hasMorphColors===!0&&(vertexDataCount=3);let width=geometry.attributes.position.count*vertexDataCount,height=1;width>capabilities.maxTextureSize&&(height=Math.ceil(width/capabilities.maxTextureSize),width=capabilities.maxTextureSize);const buffer=new Float32Array(width*height*4*morphTargetsCount),texture=new DataArrayTexture(buffer,width,height,morphTargetsCount);texture.type=FloatType,texture.needsUpdate=!0;const vertexDataStride=vertexDataCount*4;for(let i2=0;i2<morphTargetsCount;i2++){const morphTarget=morphTargets[i2],morphNormal=morphNormals[i2],morphColor=morphColors[i2],offset=width*height*4*i2;for(let j2=0;j2<morphTarget.count;j2++){const stride=j2*vertexDataStride;hasMorphPosition===!0&&(morph.fromBufferAttribute(morphTarget,j2),buffer[offset+stride+0]=morph.x,buffer[offset+stride+1]=morph.y,buffer[offset+stride+2]=morph.z,buffer[offset+stride+3]=0),hasMorphNormals===!0&&(morph.fromBufferAttribute(morphNormal,j2),buffer[offset+stride+4]=morph.x,buffer[offset+stride+5]=morph.y,buffer[offset+stride+6]=morph.z,buffer[offset+stride+7]=0),hasMorphColors===!0&&(morph.fromBufferAttribute(morphColor,j2),buffer[offset+stride+8]=morph.x,buffer[offset+stride+9]=morph.y,buffer[offset+stride+10]=morph.z,buffer[offset+stride+11]=morphColor.itemSize===4?morph.w:1)}}entry={count:morphTargetsCount,texture,size:new Vector2(width,height)},morphTextures.set(geometry,entry),geometry.addEventListener("dispose",disposeTexture2)}let morphInfluencesSum=0;for(let i2=0;i2<objectInfluences.length;i2++)morphInfluencesSum+=objectInfluences[i2];const morphBaseInfluence=geometry.morphTargetsRelative?1:1-morphInfluencesSum;program.getUniforms().setValue(gl,"morphTargetBaseInfluence",morphBaseInfluence),program.getUniforms().setValue(gl,"morphTargetInfluences",objectInfluences),program.getUniforms().setValue(gl,"morphTargetsTexture",entry.texture,textures),program.getUniforms().setValue(gl,"morphTargetsTextureSize",entry.size)}else{const length=objectInfluences===void 0?0:objectInfluences.length;let influences=influencesList[geometry.id];if(influences===void 0||influences.length!==length){influences=[];for(let i2=0;i2<length;i2++)influences[i2]=[i2,0];influencesList[geometry.id]=influences}for(let i2=0;i2<length;i2++){const influence=influences[i2];influence[0]=i2,influence[1]=objectInfluences[i2]}influences.sort(absNumericalSort);for(let i2=0;i2<8;i2++)i2<length&&influences[i2][1]?(workInfluences[i2][0]=influences[i2][0],workInfluences[i2][1]=influences[i2][1]):(workInfluences[i2][0]=Number.MAX_SAFE_INTEGER,workInfluences[i2][1]=0);workInfluences.sort(numericalSort);const morphTargets=geometry.morphAttributes.position,morphNormals=geometry.morphAttributes.normal;let morphInfluencesSum=0;for(let i2=0;i2<8;i2++){const influence=workInfluences[i2],index=influence[0],value=influence[1];index!==Number.MAX_SAFE_INTEGER&&value?(morphTargets&&geometry.getAttribute("morphTarget"+i2)!==morphTargets[index]&&geometry.setAttribute("morphTarget"+i2,morphTargets[index]),morphNormals&&geometry.getAttribute("morphNormal"+i2)!==morphNormals[index]&&geometry.setAttribute("morphNormal"+i2,morphNormals[index]),morphInfluences[i2]=value,morphInfluencesSum+=value):(morphTargets&&geometry.hasAttribute("morphTarget"+i2)===!0&&geometry.deleteAttribute("morphTarget"+i2),morphNormals&&geometry.hasAttribute("morphNormal"+i2)===!0&&geometry.deleteAttribute("morphNormal"+i2),morphInfluences[i2]=0)}const morphBaseInfluence=geometry.morphTargetsRelative?1:1-morphInfluencesSum;program.getUniforms().setValue(gl,"morphTargetBaseInfluence",morphBaseInfluence),program.getUniforms().setValue(gl,"morphTargetInfluences",morphInfluences)}}return{update}}function WebGLObjects(gl,geometries,attributes,info){let updateMap=new WeakMap;function update(object){const frame2=info.render.frame,geometry=object.geometry,buffergeometry=geometries.get(object,geometry);if(updateMap.get(buffergeometry)!==frame2&&(geometries.update(buffergeometry),updateMap.set(buffergeometry,frame2)),object.isInstancedMesh&&(object.hasEventListener("dispose",onInstancedMeshDispose)===!1&&object.addEventListener("dispose",onInstancedMeshDispose),updateMap.get(object)!==frame2&&(attributes.update(object.instanceMatrix,gl.ARRAY_BUFFER),object.instanceColor!==null&&attributes.update(object.instanceColor,gl.ARRAY_BUFFER),updateMap.set(object,frame2))),object.isSkinnedMesh){const skeleton=object.skeleton;updateMap.get(skeleton)!==frame2&&(skeleton.update(),updateMap.set(skeleton,frame2))}return buffergeometry}function dispose2(){updateMap=new WeakMap}function onInstancedMeshDispose(event){const instancedMesh=event.target;instancedMesh.removeEventListener("dispose",onInstancedMeshDispose),attributes.remove(instancedMesh.instanceMatrix),instancedMesh.instanceColor!==null&&attributes.remove(instancedMesh.instanceColor)}return{update,dispose:dispose2}}const emptyTexture=new Texture,emptyArrayTexture=new DataArrayTexture,empty3dTexture=new Data3DTexture,emptyCubeTexture=new CubeTexture,arrayCacheF32=[],arrayCacheI32=[],mat4array=new Float32Array(16),mat3array=new Float32Array(9),mat2array=new Float32Array(4);function flatten(array,nBlocks,blockSize){const firstElem=array[0];if(firstElem<=0||firstElem>0)return array;const n=nBlocks*blockSize;let r2=arrayCacheF32[n];if(r2===void 0&&(r2=new Float32Array(n),arrayCacheF32[n]=r2),nBlocks!==0){firstElem.toArray(r2,0);for(let i2=1,offset=0;i2!==nBlocks;++i2)offset+=blockSize,array[i2].toArray(r2,offset)}return r2}function arraysEqual(a2,b2){if(a2.length!==b2.length)return!1;for(let i2=0,l2=a2.length;i2<l2;i2++)if(a2[i2]!==b2[i2])return!1;return!0}function copyArray(a2,b2){for(let i2=0,l2=b2.length;i2<l2;i2++)a2[i2]=b2[i2]}function allocTexUnits(textures,n){let r2=arrayCacheI32[n];r2===void 0&&(r2=new Int32Array(n),arrayCacheI32[n]=r2);for(let i2=0;i2!==n;++i2)r2[i2]=textures.allocateTextureUnit();return r2}function setValueV1f(gl,v4){const cache=this.cache;cache[0]!==v4&&(gl.uniform1f(this.addr,v4),cache[0]=v4)}function setValueV2f(gl,v4){const cache=this.cache;if(v4.x!==void 0)(cache[0]!==v4.x||cache[1]!==v4.y)&&(gl.uniform2f(this.addr,v4.x,v4.y),cache[0]=v4.x,cache[1]=v4.y);else{if(arraysEqual(cache,v4))return;gl.uniform2fv(this.addr,v4),copyArray(cache,v4)}}function setValueV3f(gl,v4){const cache=this.cache;if(v4.x!==void 0)(cache[0]!==v4.x||cache[1]!==v4.y||cache[2]!==v4.z)&&(gl.uniform3f(this.addr,v4.x,v4.y,v4.z),cache[0]=v4.x,cache[1]=v4.y,cache[2]=v4.z);else if(v4.r!==void 0)(cache[0]!==v4.r||cache[1]!==v4.g||cache[2]!==v4.b)&&(gl.uniform3f(this.addr,v4.r,v4.g,v4.b),cache[0]=v4.r,cache[1]=v4.g,cache[2]=v4.b);else{if(arraysEqual(cache,v4))return;gl.uniform3fv(this.addr,v4),copyArray(cache,v4)}}function setValueV4f(gl,v4){const cache=this.cache;if(v4.x!==void 0)(cache[0]!==v4.x||cache[1]!==v4.y||cache[2]!==v4.z||cache[3]!==v4.w)&&(gl.uniform4f(this.addr,v4.x,v4.y,v4.z,v4.w),cache[0]=v4.x,cache[1]=v4.y,cache[2]=v4.z,cache[3]=v4.w);else{if(arraysEqual(cache,v4))return;gl.uniform4fv(this.addr,v4),copyArray(cache,v4)}}function setValueM2(gl,v4){const cache=this.cache,elements=v4.elements;if(elements===void 0){if(arraysEqual(cache,v4))return;gl.uniformMatrix2fv(this.addr,!1,v4),copyArray(cache,v4)}else{if(arraysEqual(cache,elements))return;mat2array.set(elements),gl.uniformMatrix2fv(this.addr,!1,mat2array),copyArray(cache,elements)}}function setValueM3(gl,v4){const cache=this.cache,elements=v4.elements;if(elements===void 0){if(arraysEqual(cache,v4))return;gl.uniformMatrix3fv(this.addr,!1,v4),copyArray(cache,v4)}else{if(arraysEqual(cache,elements))return;mat3array.set(elements),gl.uniformMatrix3fv(this.addr,!1,mat3array),copyArray(cache,elements)}}function setValueM4(gl,v4){const cache=this.cache,elements=v4.elements;if(elements===void 0){if(arraysEqual(cache,v4))return;gl.uniformMatrix4fv(this.addr,!1,v4),copyArray(cache,v4)}else{if(arraysEqual(cache,elements))return;mat4array.set(elements),gl.uniformMatrix4fv(this.addr,!1,mat4array),copyArray(cache,elements)}}function setValueV1i(gl,v4){const cache=this.cache;cache[0]!==v4&&(gl.uniform1i(this.addr,v4),cache[0]=v4)}function setValueV2i(gl,v4){const cache=this.cache;if(v4.x!==void 0)(cache[0]!==v4.x||cache[1]!==v4.y)&&(gl.uniform2i(this.addr,v4.x,v4.y),cache[0]=v4.x,cache[1]=v4.y);else{if(arraysEqual(cache,v4))return;gl.uniform2iv(this.addr,v4),copyArray(cache,v4)}}function setValueV3i(gl,v4){const cache=this.cache;if(v4.x!==void 0)(cache[0]!==v4.x||cache[1]!==v4.y||cache[2]!==v4.z)&&(gl.uniform3i(this.addr,v4.x,v4.y,v4.z),cache[0]=v4.x,cache[1]=v4.y,cache[2]=v4.z);else{if(arraysEqual(cache,v4))return;gl.uniform3iv(this.addr,v4),copyArray(cache,v4)}}function setValueV4i(gl,v4){const cache=this.cache;if(v4.x!==void 0)(cache[0]!==v4.x||cache[1]!==v4.y||cache[2]!==v4.z||cache[3]!==v4.w)&&(gl.uniform4i(this.addr,v4.x,v4.y,v4.z,v4.w),cache[0]=v4.x,cache[1]=v4.y,cache[2]=v4.z,cache[3]=v4.w);else{if(arraysEqual(cache,v4))return;gl.uniform4iv(this.addr,v4),copyArray(cache,v4)}}function setValueV1ui(gl,v4){const cache=this.cache;cache[0]!==v4&&(gl.uniform1ui(this.addr,v4),cache[0]=v4)}function setValueV2ui(gl,v4){const cache=this.cache;if(v4.x!==void 0)(cache[0]!==v4.x||cache[1]!==v4.y)&&(gl.uniform2ui(this.addr,v4.x,v4.y),cache[0]=v4.x,cache[1]=v4.y);else{if(arraysEqual(cache,v4))return;gl.uniform2uiv(this.addr,v4),copyArray(cache,v4)}}function setValueV3ui(gl,v4){const cache=this.cache;if(v4.x!==void 0)(cache[0]!==v4.x||cache[1]!==v4.y||cache[2]!==v4.z)&&(gl.uniform3ui(this.addr,v4.x,v4.y,v4.z),cache[0]=v4.x,cache[1]=v4.y,cache[2]=v4.z);else{if(arraysEqual(cache,v4))return;gl.uniform3uiv(this.addr,v4),copyArray(cache,v4)}}function setValueV4ui(gl,v4){const cache=this.cache;if(v4.x!==void 0)(cache[0]!==v4.x||cache[1]!==v4.y||cache[2]!==v4.z||cache[3]!==v4.w)&&(gl.uniform4ui(this.addr,v4.x,v4.y,v4.z,v4.w),cache[0]=v4.x,cache[1]=v4.y,cache[2]=v4.z,cache[3]=v4.w);else{if(arraysEqual(cache,v4))return;gl.uniform4uiv(this.addr,v4),copyArray(cache,v4)}}function setValueT1(gl,v4,textures){const cache=this.cache,unit=textures.allocateTextureUnit();cache[0]!==unit&&(gl.uniform1i(this.addr,unit),cache[0]=unit),textures.setTexture2D(v4||emptyTexture,unit)}function setValueT3D1(gl,v4,textures){const cache=this.cache,unit=textures.allocateTextureUnit();cache[0]!==unit&&(gl.uniform1i(this.addr,unit),cache[0]=unit),textures.setTexture3D(v4||empty3dTexture,unit)}function setValueT6(gl,v4,textures){const cache=this.cache,unit=textures.allocateTextureUnit();cache[0]!==unit&&(gl.uniform1i(this.addr,unit),cache[0]=unit),textures.setTextureCube(v4||emptyCubeTexture,unit)}function setValueT2DArray1(gl,v4,textures){const cache=this.cache,unit=textures.allocateTextureUnit();cache[0]!==unit&&(gl.uniform1i(this.addr,unit),cache[0]=unit),textures.setTexture2DArray(v4||emptyArrayTexture,unit)}function getSingularSetter(type){switch(type){case 5126:return setValueV1f;case 35664:return setValueV2f;case 35665:return setValueV3f;case 35666:return setValueV4f;case 35674:return setValueM2;case 35675:return setValueM3;case 35676:return setValueM4;case 5124:case 35670:return setValueV1i;case 35667:case 35671:return setValueV2i;case 35668:case 35672:return setValueV3i;case 35669:case 35673:return setValueV4i;case 5125:return setValueV1ui;case 36294:return setValueV2ui;case 36295:return setValueV3ui;case 36296:return setValueV4ui;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1;case 35679:case 36299:case 36307:return setValueT3D1;case 35680:case 36300:case 36308:case 36293:return setValueT6;case 36289:case 36303:case 36311:case 36292:return setValueT2DArray1}}function setValueV1fArray(gl,v4){gl.uniform1fv(this.addr,v4)}function setValueV2fArray(gl,v4){const data=flatten(v4,this.size,2);gl.uniform2fv(this.addr,data)}function setValueV3fArray(gl,v4){const data=flatten(v4,this.size,3);gl.uniform3fv(this.addr,data)}function setValueV4fArray(gl,v4){const data=flatten(v4,this.size,4);gl.uniform4fv(this.addr,data)}function setValueM2Array(gl,v4){const data=flatten(v4,this.size,4);gl.uniformMatrix2fv(this.addr,!1,data)}function setValueM3Array(gl,v4){const data=flatten(v4,this.size,9);gl.uniformMatrix3fv(this.addr,!1,data)}function setValueM4Array(gl,v4){const data=flatten(v4,this.size,16);gl.uniformMatrix4fv(this.addr,!1,data)}function setValueV1iArray(gl,v4){gl.uniform1iv(this.addr,v4)}function setValueV2iArray(gl,v4){gl.uniform2iv(this.addr,v4)}function setValueV3iArray(gl,v4){gl.uniform3iv(this.addr,v4)}function setValueV4iArray(gl,v4){gl.uniform4iv(this.addr,v4)}function setValueV1uiArray(gl,v4){gl.uniform1uiv(this.addr,v4)}function setValueV2uiArray(gl,v4){gl.uniform2uiv(this.addr,v4)}function setValueV3uiArray(gl,v4){gl.uniform3uiv(this.addr,v4)}function setValueV4uiArray(gl,v4){gl.uniform4uiv(this.addr,v4)}function setValueT1Array(gl,v4,textures){const cache=this.cache,n=v4.length,units=allocTexUnits(textures,n);arraysEqual(cache,units)||(gl.uniform1iv(this.addr,units),copyArray(cache,units));for(let i2=0;i2!==n;++i2)textures.setTexture2D(v4[i2]||emptyTexture,units[i2])}function setValueT3DArray(gl,v4,textures){const cache=this.cache,n=v4.length,units=allocTexUnits(textures,n);arraysEqual(cache,units)||(gl.uniform1iv(this.addr,units),copyArray(cache,units));for(let i2=0;i2!==n;++i2)textures.setTexture3D(v4[i2]||empty3dTexture,units[i2])}function setValueT6Array(gl,v4,textures){const cache=this.cache,n=v4.length,units=allocTexUnits(textures,n);arraysEqual(cache,units)||(gl.uniform1iv(this.addr,units),copyArray(cache,units));for(let i2=0;i2!==n;++i2)textures.setTextureCube(v4[i2]||emptyCubeTexture,units[i2])}function setValueT2DArrayArray(gl,v4,textures){const cache=this.cache,n=v4.length,units=allocTexUnits(textures,n);arraysEqual(cache,units)||(gl.uniform1iv(this.addr,units),copyArray(cache,units));for(let i2=0;i2!==n;++i2)textures.setTexture2DArray(v4[i2]||emptyArrayTexture,units[i2])}function getPureArraySetter(type){switch(type){case 5126:return setValueV1fArray;case 35664:return setValueV2fArray;case 35665:return setValueV3fArray;case 35666:return setValueV4fArray;case 35674:return setValueM2Array;case 35675:return setValueM3Array;case 35676:return setValueM4Array;case 5124:case 35670:return setValueV1iArray;case 35667:case 35671:return setValueV2iArray;case 35668:case 35672:return setValueV3iArray;case 35669:case 35673:return setValueV4iArray;case 5125:return setValueV1uiArray;case 36294:return setValueV2uiArray;case 36295:return setValueV3uiArray;case 36296:return setValueV4uiArray;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1Array;case 35679:case 36299:case 36307:return setValueT3DArray;case 35680:case 36300:case 36308:case 36293:return setValueT6Array;case 36289:case 36303:case 36311:case 36292:return setValueT2DArrayArray}}class SingleUniform{constructor(id2,activeInfo,addr){this.id=id2,this.addr=addr,this.cache=[],this.setValue=getSingularSetter(activeInfo.type)}}class PureArrayUniform{constructor(id2,activeInfo,addr){this.id=id2,this.addr=addr,this.cache=[],this.size=activeInfo.size,this.setValue=getPureArraySetter(activeInfo.type)}}class StructuredUniform{constructor(id2){this.id=id2,this.seq=[],this.map={}}setValue(gl,value,textures){const seq=this.seq;for(let i2=0,n=seq.length;i2!==n;++i2){const u2=seq[i2];u2.setValue(gl,value[u2.id],textures)}}}const RePathPart=/(\w+)(\])?(\[|\.)?/g;function addUniform(container,uniformObject){container.seq.push(uniformObject),container.map[uniformObject.id]=uniformObject}function parseUniform(activeInfo,addr,container){const path2=activeInfo.name,pathLength=path2.length;for(RePathPart.lastIndex=0;;){const match=RePathPart.exec(path2),matchEnd=RePathPart.lastIndex;let id2=match[1];const idIsIndex=match[2]==="]",subscript=match[3];if(idIsIndex&&(id2=id2|0),subscript===void 0||subscript==="["&&matchEnd+2===pathLength){addUniform(container,subscript===void 0?new SingleUniform(id2,activeInfo,addr):new PureArrayUniform(id2,activeInfo,addr));break}else{let next=container.map[id2];next===void 0&&(next=new StructuredUniform(id2),addUniform(container,next)),container=next}}}class WebGLUniforms{constructor(gl,program){this.seq=[],this.map={};const n=gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);for(let i2=0;i2<n;++i2){const info=gl.getActiveUniform(program,i2),addr=gl.getUniformLocation(program,info.name);parseUniform(info,addr,this)}}setValue(gl,name,value,textures){const u2=this.map[name];u2!==void 0&&u2.setValue(gl,value,textures)}setOptional(gl,object,name){const v4=object[name];v4!==void 0&&this.setValue(gl,name,v4)}static upload(gl,seq,values,textures){for(let i2=0,n=seq.length;i2!==n;++i2){const u2=seq[i2],v4=values[u2.id];v4.needsUpdate!==!1&&u2.setValue(gl,v4.value,textures)}}static seqWithValue(seq,values){const r2=[];for(let i2=0,n=seq.length;i2!==n;++i2){const u2=seq[i2];u2.id in values&&r2.push(u2)}return r2}}function WebGLShader(gl,type,string){const shader=gl.createShader(type);return gl.shaderSource(shader,string),gl.compileShader(shader),shader}const COMPLETION_STATUS_KHR=37297;let programIdCount=0;function handleSource(string,errorLine){const lines=string.split(`
`),lines2=[],from=Math.max(errorLine-6,0),to=Math.min(errorLine+6,lines.length);for(let i2=from;i2<to;i2++){const line=i2+1;lines2.push(`${line===errorLine?">":" "} ${line}: ${lines[i2]}`)}return lines2.join(`
`)}function getEncodingComponents(colorSpace){const workingPrimaries=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),encodingPrimaries=ColorManagement.getPrimaries(colorSpace);let gamutMapping;switch(workingPrimaries===encodingPrimaries?gamutMapping="":workingPrimaries===P3Primaries&&encodingPrimaries===Rec709Primaries?gamutMapping="LinearDisplayP3ToLinearSRGB":workingPrimaries===Rec709Primaries&&encodingPrimaries===P3Primaries&&(gamutMapping="LinearSRGBToLinearDisplayP3"),colorSpace){case LinearSRGBColorSpace:case LinearDisplayP3ColorSpace:return[gamutMapping,"LinearTransferOETF"];case SRGBColorSpace:case DisplayP3ColorSpace:return[gamutMapping,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",colorSpace),[gamutMapping,"LinearTransferOETF"]}}function getShaderErrors(gl,shader,type){const status=gl.getShaderParameter(shader,gl.COMPILE_STATUS),errors=gl.getShaderInfoLog(shader).trim();if(status&&errors==="")return"";const errorMatches=/ERROR: 0:(\d+)/.exec(errors);if(errorMatches){const errorLine=parseInt(errorMatches[1]);return type.toUpperCase()+`

`+errors+`

`+handleSource(gl.getShaderSource(shader),errorLine)}else return errors}function getTexelEncodingFunction(functionName,colorSpace){const components=getEncodingComponents(colorSpace);return`vec4 ${functionName}( vec4 value ) { return ${components[0]}( ${components[1]}( value ) ); }`}function getToneMappingFunction(functionName,toneMapping){let toneMappingName;switch(toneMapping){case LinearToneMapping:toneMappingName="Linear";break;case ReinhardToneMapping:toneMappingName="Reinhard";break;case CineonToneMapping:toneMappingName="OptimizedCineon";break;case ACESFilmicToneMapping:toneMappingName="ACESFilmic";break;case CustomToneMapping:toneMappingName="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",toneMapping),toneMappingName="Linear"}return"vec3 "+functionName+"( vec3 color ) { return "+toneMappingName+"ToneMapping( color ); }"}function generateExtensions(parameters){return[parameters.extensionDerivatives||parameters.envMapCubeUVHeight||parameters.bumpMap||parameters.normalMapTangentSpace||parameters.clearcoatNormalMap||parameters.flatShading||parameters.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(parameters.extensionFragDepth||parameters.logarithmicDepthBuffer)&&parameters.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",parameters.extensionDrawBuffers&&parameters.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(parameters.extensionShaderTextureLOD||parameters.envMap||parameters.transmission)&&parameters.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(filterEmptyLine).join(`
`)}function generateDefines(defines){const chunks=[];for(const name in defines){const value=defines[name];value!==!1&&chunks.push("#define "+name+" "+value)}return chunks.join(`
`)}function fetchAttributeLocations(gl,program){const attributes={},n=gl.getProgramParameter(program,gl.ACTIVE_ATTRIBUTES);for(let i2=0;i2<n;i2++){const info=gl.getActiveAttrib(program,i2),name=info.name;let locationSize=1;info.type===gl.FLOAT_MAT2&&(locationSize=2),info.type===gl.FLOAT_MAT3&&(locationSize=3),info.type===gl.FLOAT_MAT4&&(locationSize=4),attributes[name]={type:info.type,location:gl.getAttribLocation(program,name),locationSize}}return attributes}function filterEmptyLine(string){return string!==""}function replaceLightNums(string,parameters){const numSpotLightCoords=parameters.numSpotLightShadows+parameters.numSpotLightMaps-parameters.numSpotLightShadowsWithMaps;return string.replace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g,parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,parameters.numPointLightShadows)}function replaceClippingPlaneNums(string,parameters){return string.replace(/NUM_CLIPPING_PLANES/g,parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,parameters.numClippingPlanes-parameters.numClipIntersection)}const includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(string){return string.replace(includePattern,includeReplacer)}const shaderChunkMap=new Map([["encodings_fragment","colorspace_fragment"],["encodings_pars_fragment","colorspace_pars_fragment"],["output_fragment","opaque_fragment"]]);function includeReplacer(match,include){let string=ShaderChunk[include];if(string===void 0){const newInclude=shaderChunkMap.get(include);if(newInclude!==void 0)string=ShaderChunk[newInclude],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',include,newInclude);else throw new Error("Can not resolve #include <"+include+">")}return resolveIncludes(string)}const unrollLoopPattern=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function unrollLoops(string){return string.replace(unrollLoopPattern,loopReplacer)}function loopReplacer(match,start,end,snippet){let string="";for(let i2=parseInt(start);i2<parseInt(end);i2++)string+=snippet.replace(/\[\s*i\s*\]/g,"[ "+i2+" ]").replace(/UNROLLED_LOOP_INDEX/g,i2);return string}function generatePrecision(parameters){let precisionstring="precision "+parameters.precision+` float;
precision `+parameters.precision+" int;";return parameters.precision==="highp"?precisionstring+=`
#define HIGH_PRECISION`:parameters.precision==="mediump"?precisionstring+=`
#define MEDIUM_PRECISION`:parameters.precision==="lowp"&&(precisionstring+=`
#define LOW_PRECISION`),precisionstring}function generateShadowMapTypeDefine(parameters){let shadowMapTypeDefine="SHADOWMAP_TYPE_BASIC";return parameters.shadowMapType===PCFShadowMap?shadowMapTypeDefine="SHADOWMAP_TYPE_PCF":parameters.shadowMapType===PCFSoftShadowMap?shadowMapTypeDefine="SHADOWMAP_TYPE_PCF_SOFT":parameters.shadowMapType===VSMShadowMap&&(shadowMapTypeDefine="SHADOWMAP_TYPE_VSM"),shadowMapTypeDefine}function generateEnvMapTypeDefine(parameters){let envMapTypeDefine="ENVMAP_TYPE_CUBE";if(parameters.envMap)switch(parameters.envMapMode){case CubeReflectionMapping:case CubeRefractionMapping:envMapTypeDefine="ENVMAP_TYPE_CUBE";break;case CubeUVReflectionMapping:envMapTypeDefine="ENVMAP_TYPE_CUBE_UV";break}return envMapTypeDefine}function generateEnvMapModeDefine(parameters){let envMapModeDefine="ENVMAP_MODE_REFLECTION";if(parameters.envMap)switch(parameters.envMapMode){case CubeRefractionMapping:envMapModeDefine="ENVMAP_MODE_REFRACTION";break}return envMapModeDefine}function generateEnvMapBlendingDefine(parameters){let envMapBlendingDefine="ENVMAP_BLENDING_NONE";if(parameters.envMap)switch(parameters.combine){case MultiplyOperation:envMapBlendingDefine="ENVMAP_BLENDING_MULTIPLY";break;case MixOperation:envMapBlendingDefine="ENVMAP_BLENDING_MIX";break;case AddOperation:envMapBlendingDefine="ENVMAP_BLENDING_ADD";break}return envMapBlendingDefine}function generateCubeUVSize(parameters){const imageHeight=parameters.envMapCubeUVHeight;if(imageHeight===null)return null;const maxMip=Math.log2(imageHeight)-2,texelHeight=1/imageHeight;return{texelWidth:1/(3*Math.max(Math.pow(2,maxMip),7*16)),texelHeight,maxMip}}function WebGLProgram(renderer,cacheKey,parameters,bindingStates){const gl=renderer.getContext(),defines=parameters.defines;let vertexShader=parameters.vertexShader,fragmentShader=parameters.fragmentShader;const shadowMapTypeDefine=generateShadowMapTypeDefine(parameters),envMapTypeDefine=generateEnvMapTypeDefine(parameters),envMapModeDefine=generateEnvMapModeDefine(parameters),envMapBlendingDefine=generateEnvMapBlendingDefine(parameters),envMapCubeUVSize=generateCubeUVSize(parameters),customExtensions=parameters.isWebGL2?"":generateExtensions(parameters),customDefines=generateDefines(defines),program=gl.createProgram();let prefixVertex,prefixFragment,versionString=parameters.glslVersion?"#version "+parameters.glslVersion+`
`:"";parameters.isRawShaderMaterial?(prefixVertex=["#define SHADER_TYPE "+parameters.shaderType,"#define SHADER_NAME "+parameters.shaderName,customDefines].filter(filterEmptyLine).join(`
`),prefixVertex.length>0&&(prefixVertex+=`
`),prefixFragment=[customExtensions,"#define SHADER_TYPE "+parameters.shaderType,"#define SHADER_NAME "+parameters.shaderName,customDefines].filter(filterEmptyLine).join(`
`),prefixFragment.length>0&&(prefixFragment+=`
`)):(prefixVertex=[generatePrecision(parameters),"#define SHADER_TYPE "+parameters.shaderType,"#define SHADER_NAME "+parameters.shaderName,customDefines,parameters.instancing?"#define USE_INSTANCING":"",parameters.instancingColor?"#define USE_INSTANCING_COLOR":"",parameters.useFog&&parameters.fog?"#define USE_FOG":"",parameters.useFog&&parameters.fogExp2?"#define FOG_EXP2":"",parameters.map?"#define USE_MAP":"",parameters.envMap?"#define USE_ENVMAP":"",parameters.envMap?"#define "+envMapModeDefine:"",parameters.lightMap?"#define USE_LIGHTMAP":"",parameters.aoMap?"#define USE_AOMAP":"",parameters.bumpMap?"#define USE_BUMPMAP":"",parameters.normalMap?"#define USE_NORMALMAP":"",parameters.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",parameters.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",parameters.displacementMap?"#define USE_DISPLACEMENTMAP":"",parameters.emissiveMap?"#define USE_EMISSIVEMAP":"",parameters.anisotropy?"#define USE_ANISOTROPY":"",parameters.anisotropyMap?"#define USE_ANISOTROPYMAP":"",parameters.clearcoatMap?"#define USE_CLEARCOATMAP":"",parameters.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",parameters.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",parameters.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",parameters.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",parameters.specularMap?"#define USE_SPECULARMAP":"",parameters.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",parameters.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",parameters.roughnessMap?"#define USE_ROUGHNESSMAP":"",parameters.metalnessMap?"#define USE_METALNESSMAP":"",parameters.alphaMap?"#define USE_ALPHAMAP":"",parameters.alphaHash?"#define USE_ALPHAHASH":"",parameters.transmission?"#define USE_TRANSMISSION":"",parameters.transmissionMap?"#define USE_TRANSMISSIONMAP":"",parameters.thicknessMap?"#define USE_THICKNESSMAP":"",parameters.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",parameters.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",parameters.mapUv?"#define MAP_UV "+parameters.mapUv:"",parameters.alphaMapUv?"#define ALPHAMAP_UV "+parameters.alphaMapUv:"",parameters.lightMapUv?"#define LIGHTMAP_UV "+parameters.lightMapUv:"",parameters.aoMapUv?"#define AOMAP_UV "+parameters.aoMapUv:"",parameters.emissiveMapUv?"#define EMISSIVEMAP_UV "+parameters.emissiveMapUv:"",parameters.bumpMapUv?"#define BUMPMAP_UV "+parameters.bumpMapUv:"",parameters.normalMapUv?"#define NORMALMAP_UV "+parameters.normalMapUv:"",parameters.displacementMapUv?"#define DISPLACEMENTMAP_UV "+parameters.displacementMapUv:"",parameters.metalnessMapUv?"#define METALNESSMAP_UV "+parameters.metalnessMapUv:"",parameters.roughnessMapUv?"#define ROUGHNESSMAP_UV "+parameters.roughnessMapUv:"",parameters.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+parameters.anisotropyMapUv:"",parameters.clearcoatMapUv?"#define CLEARCOATMAP_UV "+parameters.clearcoatMapUv:"",parameters.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+parameters.clearcoatNormalMapUv:"",parameters.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+parameters.clearcoatRoughnessMapUv:"",parameters.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+parameters.iridescenceMapUv:"",parameters.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+parameters.iridescenceThicknessMapUv:"",parameters.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+parameters.sheenColorMapUv:"",parameters.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+parameters.sheenRoughnessMapUv:"",parameters.specularMapUv?"#define SPECULARMAP_UV "+parameters.specularMapUv:"",parameters.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+parameters.specularColorMapUv:"",parameters.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+parameters.specularIntensityMapUv:"",parameters.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+parameters.transmissionMapUv:"",parameters.thicknessMapUv?"#define THICKNESSMAP_UV "+parameters.thicknessMapUv:"",parameters.vertexTangents&&parameters.flatShading===!1?"#define USE_TANGENT":"",parameters.vertexColors?"#define USE_COLOR":"",parameters.vertexAlphas?"#define USE_COLOR_ALPHA":"",parameters.vertexUv1s?"#define USE_UV1":"",parameters.vertexUv2s?"#define USE_UV2":"",parameters.vertexUv3s?"#define USE_UV3":"",parameters.pointsUvs?"#define USE_POINTS_UV":"",parameters.flatShading?"#define FLAT_SHADED":"",parameters.skinning?"#define USE_SKINNING":"",parameters.morphTargets?"#define USE_MORPHTARGETS":"",parameters.morphNormals&&parameters.flatShading===!1?"#define USE_MORPHNORMALS":"",parameters.morphColors&&parameters.isWebGL2?"#define USE_MORPHCOLORS":"",parameters.morphTargetsCount>0&&parameters.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",parameters.morphTargetsCount>0&&parameters.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+parameters.morphTextureStride:"",parameters.morphTargetsCount>0&&parameters.isWebGL2?"#define MORPHTARGETS_COUNT "+parameters.morphTargetsCount:"",parameters.doubleSided?"#define DOUBLE_SIDED":"",parameters.flipSided?"#define FLIP_SIDED":"",parameters.shadowMapEnabled?"#define USE_SHADOWMAP":"",parameters.shadowMapEnabled?"#define "+shadowMapTypeDefine:"",parameters.sizeAttenuation?"#define USE_SIZEATTENUATION":"",parameters.numLightProbes>0?"#define USE_LIGHT_PROBES":"",parameters.useLegacyLights?"#define LEGACY_LIGHTS":"",parameters.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",parameters.logarithmicDepthBuffer&&parameters.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(filterEmptyLine).join(`
`),prefixFragment=[customExtensions,generatePrecision(parameters),"#define SHADER_TYPE "+parameters.shaderType,"#define SHADER_NAME "+parameters.shaderName,customDefines,parameters.useFog&&parameters.fog?"#define USE_FOG":"",parameters.useFog&&parameters.fogExp2?"#define FOG_EXP2":"",parameters.map?"#define USE_MAP":"",parameters.matcap?"#define USE_MATCAP":"",parameters.envMap?"#define USE_ENVMAP":"",parameters.envMap?"#define "+envMapTypeDefine:"",parameters.envMap?"#define "+envMapModeDefine:"",parameters.envMap?"#define "+envMapBlendingDefine:"",envMapCubeUVSize?"#define CUBEUV_TEXEL_WIDTH "+envMapCubeUVSize.texelWidth:"",envMapCubeUVSize?"#define CUBEUV_TEXEL_HEIGHT "+envMapCubeUVSize.texelHeight:"",envMapCubeUVSize?"#define CUBEUV_MAX_MIP "+envMapCubeUVSize.maxMip+".0":"",parameters.lightMap?"#define USE_LIGHTMAP":"",parameters.aoMap?"#define USE_AOMAP":"",parameters.bumpMap?"#define USE_BUMPMAP":"",parameters.normalMap?"#define USE_NORMALMAP":"",parameters.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",parameters.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",parameters.emissiveMap?"#define USE_EMISSIVEMAP":"",parameters.anisotropy?"#define USE_ANISOTROPY":"",parameters.anisotropyMap?"#define USE_ANISOTROPYMAP":"",parameters.clearcoat?"#define USE_CLEARCOAT":"",parameters.clearcoatMap?"#define USE_CLEARCOATMAP":"",parameters.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",parameters.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",parameters.iridescence?"#define USE_IRIDESCENCE":"",parameters.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",parameters.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",parameters.specularMap?"#define USE_SPECULARMAP":"",parameters.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",parameters.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",parameters.roughnessMap?"#define USE_ROUGHNESSMAP":"",parameters.metalnessMap?"#define USE_METALNESSMAP":"",parameters.alphaMap?"#define USE_ALPHAMAP":"",parameters.alphaTest?"#define USE_ALPHATEST":"",parameters.alphaHash?"#define USE_ALPHAHASH":"",parameters.sheen?"#define USE_SHEEN":"",parameters.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",parameters.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",parameters.transmission?"#define USE_TRANSMISSION":"",parameters.transmissionMap?"#define USE_TRANSMISSIONMAP":"",parameters.thicknessMap?"#define USE_THICKNESSMAP":"",parameters.vertexTangents&&parameters.flatShading===!1?"#define USE_TANGENT":"",parameters.vertexColors||parameters.instancingColor?"#define USE_COLOR":"",parameters.vertexAlphas?"#define USE_COLOR_ALPHA":"",parameters.vertexUv1s?"#define USE_UV1":"",parameters.vertexUv2s?"#define USE_UV2":"",parameters.vertexUv3s?"#define USE_UV3":"",parameters.pointsUvs?"#define USE_POINTS_UV":"",parameters.gradientMap?"#define USE_GRADIENTMAP":"",parameters.flatShading?"#define FLAT_SHADED":"",parameters.doubleSided?"#define DOUBLE_SIDED":"",parameters.flipSided?"#define FLIP_SIDED":"",parameters.shadowMapEnabled?"#define USE_SHADOWMAP":"",parameters.shadowMapEnabled?"#define "+shadowMapTypeDefine:"",parameters.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",parameters.numLightProbes>0?"#define USE_LIGHT_PROBES":"",parameters.useLegacyLights?"#define LEGACY_LIGHTS":"",parameters.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",parameters.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",parameters.logarithmicDepthBuffer&&parameters.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",parameters.toneMapping!==NoToneMapping?"#define TONE_MAPPING":"",parameters.toneMapping!==NoToneMapping?ShaderChunk.tonemapping_pars_fragment:"",parameters.toneMapping!==NoToneMapping?getToneMappingFunction("toneMapping",parameters.toneMapping):"",parameters.dithering?"#define DITHERING":"",parameters.opaque?"#define OPAQUE":"",ShaderChunk.colorspace_pars_fragment,getTexelEncodingFunction("linearToOutputTexel",parameters.outputColorSpace),parameters.useDepthPacking?"#define DEPTH_PACKING "+parameters.depthPacking:"",`
`].filter(filterEmptyLine).join(`
`)),vertexShader=resolveIncludes(vertexShader),vertexShader=replaceLightNums(vertexShader,parameters),vertexShader=replaceClippingPlaneNums(vertexShader,parameters),fragmentShader=resolveIncludes(fragmentShader),fragmentShader=replaceLightNums(fragmentShader,parameters),fragmentShader=replaceClippingPlaneNums(fragmentShader,parameters),vertexShader=unrollLoops(vertexShader),fragmentShader=unrollLoops(fragmentShader),parameters.isWebGL2&&parameters.isRawShaderMaterial!==!0&&(versionString=`#version 300 es
`,prefixVertex=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+prefixVertex,prefixFragment=["precision mediump sampler2DArray;","#define varying in",parameters.glslVersion===GLSL3?"":"layout(location = 0) out highp vec4 pc_fragColor;",parameters.glslVersion===GLSL3?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+prefixFragment);const vertexGlsl=versionString+prefixVertex+vertexShader,fragmentGlsl=versionString+prefixFragment+fragmentShader,glVertexShader=WebGLShader(gl,gl.VERTEX_SHADER,vertexGlsl),glFragmentShader=WebGLShader(gl,gl.FRAGMENT_SHADER,fragmentGlsl);gl.attachShader(program,glVertexShader),gl.attachShader(program,glFragmentShader),parameters.index0AttributeName!==void 0?gl.bindAttribLocation(program,0,parameters.index0AttributeName):parameters.morphTargets===!0&&gl.bindAttribLocation(program,0,"position"),gl.linkProgram(program);function onFirstUse(self2){if(renderer.debug.checkShaderErrors){const programLog=gl.getProgramInfoLog(program).trim(),vertexLog=gl.getShaderInfoLog(glVertexShader).trim(),fragmentLog=gl.getShaderInfoLog(glFragmentShader).trim();let runnable=!0,haveDiagnostics=!0;if(gl.getProgramParameter(program,gl.LINK_STATUS)===!1)if(runnable=!1,typeof renderer.debug.onShaderError=="function")renderer.debug.onShaderError(gl,program,glVertexShader,glFragmentShader);else{const vertexErrors=getShaderErrors(gl,glVertexShader,"vertex"),fragmentErrors=getShaderErrors(gl,glFragmentShader,"fragment");console.error("THREE.WebGLProgram: Shader Error "+gl.getError()+" - VALIDATE_STATUS "+gl.getProgramParameter(program,gl.VALIDATE_STATUS)+`

Program Info Log: `+programLog+`
`+vertexErrors+`
`+fragmentErrors)}else programLog!==""?console.warn("THREE.WebGLProgram: Program Info Log:",programLog):(vertexLog===""||fragmentLog==="")&&(haveDiagnostics=!1);haveDiagnostics&&(self2.diagnostics={runnable,programLog,vertexShader:{log:vertexLog,prefix:prefixVertex},fragmentShader:{log:fragmentLog,prefix:prefixFragment}})}gl.deleteShader(glVertexShader),gl.deleteShader(glFragmentShader),cachedUniforms=new WebGLUniforms(gl,program),cachedAttributes=fetchAttributeLocations(gl,program)}let cachedUniforms;this.getUniforms=function(){return cachedUniforms===void 0&&onFirstUse(this),cachedUniforms};let cachedAttributes;this.getAttributes=function(){return cachedAttributes===void 0&&onFirstUse(this),cachedAttributes};let programReady=parameters.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return programReady===!1&&(programReady=gl.getProgramParameter(program,COMPLETION_STATUS_KHR)),programReady},this.destroy=function(){bindingStates.releaseStatesOfProgram(this),gl.deleteProgram(program),this.program=void 0},this.type=parameters.shaderType,this.name=parameters.shaderName,this.id=programIdCount++,this.cacheKey=cacheKey,this.usedTimes=1,this.program=program,this.vertexShader=glVertexShader,this.fragmentShader=glFragmentShader,this}let _id$1=0;class WebGLShaderCache{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(material){const vertexShader=material.vertexShader,fragmentShader=material.fragmentShader,vertexShaderStage=this._getShaderStage(vertexShader),fragmentShaderStage=this._getShaderStage(fragmentShader),materialShaders=this._getShaderCacheForMaterial(material);return materialShaders.has(vertexShaderStage)===!1&&(materialShaders.add(vertexShaderStage),vertexShaderStage.usedTimes++),materialShaders.has(fragmentShaderStage)===!1&&(materialShaders.add(fragmentShaderStage),fragmentShaderStage.usedTimes++),this}remove(material){const materialShaders=this.materialCache.get(material);for(const shaderStage of materialShaders)shaderStage.usedTimes--,shaderStage.usedTimes===0&&this.shaderCache.delete(shaderStage.code);return this.materialCache.delete(material),this}getVertexShaderID(material){return this._getShaderStage(material.vertexShader).id}getFragmentShaderID(material){return this._getShaderStage(material.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(material){const cache=this.materialCache;let set=cache.get(material);return set===void 0&&(set=new Set,cache.set(material,set)),set}_getShaderStage(code){const cache=this.shaderCache;let stage=cache.get(code);return stage===void 0&&(stage=new WebGLShaderStage(code),cache.set(code,stage)),stage}}class WebGLShaderStage{constructor(code){this.id=_id$1++,this.code=code,this.usedTimes=0}}function WebGLPrograms(renderer,cubemaps,cubeuvmaps,extensions2,capabilities,bindingStates,clipping){const _programLayers=new Layers,_customShaders=new WebGLShaderCache,programs=[],IS_WEBGL2=capabilities.isWebGL2,logarithmicDepthBuffer=capabilities.logarithmicDepthBuffer,SUPPORTS_VERTEX_TEXTURES=capabilities.vertexTextures;let precision=capabilities.precision;const shaderIDs={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function getChannel(value){return value===0?"uv":`uv${value}`}function getParameters(material,lights,shadows,scene2,object){const fog=scene2.fog,geometry=object.geometry,environment=material.isMeshStandardMaterial?scene2.environment:null,envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||environment),envMapCubeUVHeight=envMap&&envMap.mapping===CubeUVReflectionMapping?envMap.image.height:null,shaderID=shaderIDs[material.type];material.precision!==null&&(precision=capabilities.getMaxPrecision(material.precision),precision!==material.precision&&console.warn("THREE.WebGLProgram.getParameters:",material.precision,"not supported, using",precision,"instead."));const morphAttribute=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color,morphTargetsCount=morphAttribute!==void 0?morphAttribute.length:0;let morphTextureStride=0;geometry.morphAttributes.position!==void 0&&(morphTextureStride=1),geometry.morphAttributes.normal!==void 0&&(morphTextureStride=2),geometry.morphAttributes.color!==void 0&&(morphTextureStride=3);let vertexShader,fragmentShader,customVertexShaderID,customFragmentShaderID;if(shaderID){const shader=ShaderLib[shaderID];vertexShader=shader.vertexShader,fragmentShader=shader.fragmentShader}else vertexShader=material.vertexShader,fragmentShader=material.fragmentShader,_customShaders.update(material),customVertexShaderID=_customShaders.getVertexShaderID(material),customFragmentShaderID=_customShaders.getFragmentShaderID(material);const currentRenderTarget=renderer.getRenderTarget(),IS_INSTANCEDMESH=object.isInstancedMesh===!0,HAS_MAP=!!material.map,HAS_MATCAP=!!material.matcap,HAS_ENVMAP=!!envMap,HAS_AOMAP=!!material.aoMap,HAS_LIGHTMAP=!!material.lightMap,HAS_BUMPMAP=!!material.bumpMap,HAS_NORMALMAP=!!material.normalMap,HAS_DISPLACEMENTMAP=!!material.displacementMap,HAS_EMISSIVEMAP=!!material.emissiveMap,HAS_METALNESSMAP=!!material.metalnessMap,HAS_ROUGHNESSMAP=!!material.roughnessMap,HAS_ANISOTROPY=material.anisotropy>0,HAS_CLEARCOAT=material.clearcoat>0,HAS_IRIDESCENCE=material.iridescence>0,HAS_SHEEN=material.sheen>0,HAS_TRANSMISSION=material.transmission>0,HAS_ANISOTROPYMAP=HAS_ANISOTROPY&&!!material.anisotropyMap,HAS_CLEARCOATMAP=HAS_CLEARCOAT&&!!material.clearcoatMap,HAS_CLEARCOAT_NORMALMAP=HAS_CLEARCOAT&&!!material.clearcoatNormalMap,HAS_CLEARCOAT_ROUGHNESSMAP=HAS_CLEARCOAT&&!!material.clearcoatRoughnessMap,HAS_IRIDESCENCEMAP=HAS_IRIDESCENCE&&!!material.iridescenceMap,HAS_IRIDESCENCE_THICKNESSMAP=HAS_IRIDESCENCE&&!!material.iridescenceThicknessMap,HAS_SHEEN_COLORMAP=HAS_SHEEN&&!!material.sheenColorMap,HAS_SHEEN_ROUGHNESSMAP=HAS_SHEEN&&!!material.sheenRoughnessMap,HAS_SPECULARMAP=!!material.specularMap,HAS_SPECULAR_COLORMAP=!!material.specularColorMap,HAS_SPECULAR_INTENSITYMAP=!!material.specularIntensityMap,HAS_TRANSMISSIONMAP=HAS_TRANSMISSION&&!!material.transmissionMap,HAS_THICKNESSMAP=HAS_TRANSMISSION&&!!material.thicknessMap,HAS_GRADIENTMAP=!!material.gradientMap,HAS_ALPHAMAP=!!material.alphaMap,HAS_ALPHATEST=material.alphaTest>0,HAS_ALPHAHASH=!!material.alphaHash,HAS_EXTENSIONS=!!material.extensions,HAS_ATTRIBUTE_UV1=!!geometry.attributes.uv1,HAS_ATTRIBUTE_UV2=!!geometry.attributes.uv2,HAS_ATTRIBUTE_UV3=!!geometry.attributes.uv3;let toneMapping=NoToneMapping;return material.toneMapped&&(currentRenderTarget===null||currentRenderTarget.isXRRenderTarget===!0)&&(toneMapping=renderer.toneMapping),{isWebGL2:IS_WEBGL2,shaderID,shaderType:material.type,shaderName:material.name,vertexShader,fragmentShader,defines:material.defines,customVertexShaderID,customFragmentShaderID,isRawShaderMaterial:material.isRawShaderMaterial===!0,glslVersion:material.glslVersion,precision,instancing:IS_INSTANCEDMESH,instancingColor:IS_INSTANCEDMESH&&object.instanceColor!==null,supportsVertexTextures:SUPPORTS_VERTEX_TEXTURES,outputColorSpace:currentRenderTarget===null?renderer.outputColorSpace:currentRenderTarget.isXRRenderTarget===!0?currentRenderTarget.texture.colorSpace:LinearSRGBColorSpace,map:HAS_MAP,matcap:HAS_MATCAP,envMap:HAS_ENVMAP,envMapMode:HAS_ENVMAP&&envMap.mapping,envMapCubeUVHeight,aoMap:HAS_AOMAP,lightMap:HAS_LIGHTMAP,bumpMap:HAS_BUMPMAP,normalMap:HAS_NORMALMAP,displacementMap:SUPPORTS_VERTEX_TEXTURES&&HAS_DISPLACEMENTMAP,emissiveMap:HAS_EMISSIVEMAP,normalMapObjectSpace:HAS_NORMALMAP&&material.normalMapType===ObjectSpaceNormalMap,normalMapTangentSpace:HAS_NORMALMAP&&material.normalMapType===TangentSpaceNormalMap,metalnessMap:HAS_METALNESSMAP,roughnessMap:HAS_ROUGHNESSMAP,anisotropy:HAS_ANISOTROPY,anisotropyMap:HAS_ANISOTROPYMAP,clearcoat:HAS_CLEARCOAT,clearcoatMap:HAS_CLEARCOATMAP,clearcoatNormalMap:HAS_CLEARCOAT_NORMALMAP,clearcoatRoughnessMap:HAS_CLEARCOAT_ROUGHNESSMAP,iridescence:HAS_IRIDESCENCE,iridescenceMap:HAS_IRIDESCENCEMAP,iridescenceThicknessMap:HAS_IRIDESCENCE_THICKNESSMAP,sheen:HAS_SHEEN,sheenColorMap:HAS_SHEEN_COLORMAP,sheenRoughnessMap:HAS_SHEEN_ROUGHNESSMAP,specularMap:HAS_SPECULARMAP,specularColorMap:HAS_SPECULAR_COLORMAP,specularIntensityMap:HAS_SPECULAR_INTENSITYMAP,transmission:HAS_TRANSMISSION,transmissionMap:HAS_TRANSMISSIONMAP,thicknessMap:HAS_THICKNESSMAP,gradientMap:HAS_GRADIENTMAP,opaque:material.transparent===!1&&material.blending===NormalBlending,alphaMap:HAS_ALPHAMAP,alphaTest:HAS_ALPHATEST,alphaHash:HAS_ALPHAHASH,combine:material.combine,mapUv:HAS_MAP&&getChannel(material.map.channel),aoMapUv:HAS_AOMAP&&getChannel(material.aoMap.channel),lightMapUv:HAS_LIGHTMAP&&getChannel(material.lightMap.channel),bumpMapUv:HAS_BUMPMAP&&getChannel(material.bumpMap.channel),normalMapUv:HAS_NORMALMAP&&getChannel(material.normalMap.channel),displacementMapUv:HAS_DISPLACEMENTMAP&&getChannel(material.displacementMap.channel),emissiveMapUv:HAS_EMISSIVEMAP&&getChannel(material.emissiveMap.channel),metalnessMapUv:HAS_METALNESSMAP&&getChannel(material.metalnessMap.channel),roughnessMapUv:HAS_ROUGHNESSMAP&&getChannel(material.roughnessMap.channel),anisotropyMapUv:HAS_ANISOTROPYMAP&&getChannel(material.anisotropyMap.channel),clearcoatMapUv:HAS_CLEARCOATMAP&&getChannel(material.clearcoatMap.channel),clearcoatNormalMapUv:HAS_CLEARCOAT_NORMALMAP&&getChannel(material.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:HAS_CLEARCOAT_ROUGHNESSMAP&&getChannel(material.clearcoatRoughnessMap.channel),iridescenceMapUv:HAS_IRIDESCENCEMAP&&getChannel(material.iridescenceMap.channel),iridescenceThicknessMapUv:HAS_IRIDESCENCE_THICKNESSMAP&&getChannel(material.iridescenceThicknessMap.channel),sheenColorMapUv:HAS_SHEEN_COLORMAP&&getChannel(material.sheenColorMap.channel),sheenRoughnessMapUv:HAS_SHEEN_ROUGHNESSMAP&&getChannel(material.sheenRoughnessMap.channel),specularMapUv:HAS_SPECULARMAP&&getChannel(material.specularMap.channel),specularColorMapUv:HAS_SPECULAR_COLORMAP&&getChannel(material.specularColorMap.channel),specularIntensityMapUv:HAS_SPECULAR_INTENSITYMAP&&getChannel(material.specularIntensityMap.channel),transmissionMapUv:HAS_TRANSMISSIONMAP&&getChannel(material.transmissionMap.channel),thicknessMapUv:HAS_THICKNESSMAP&&getChannel(material.thicknessMap.channel),alphaMapUv:HAS_ALPHAMAP&&getChannel(material.alphaMap.channel),vertexTangents:!!geometry.attributes.tangent&&(HAS_NORMALMAP||HAS_ANISOTROPY),vertexColors:material.vertexColors,vertexAlphas:material.vertexColors===!0&&!!geometry.attributes.color&&geometry.attributes.color.itemSize===4,vertexUv1s:HAS_ATTRIBUTE_UV1,vertexUv2s:HAS_ATTRIBUTE_UV2,vertexUv3s:HAS_ATTRIBUTE_UV3,pointsUvs:object.isPoints===!0&&!!geometry.attributes.uv&&(HAS_MAP||HAS_ALPHAMAP),fog:!!fog,useFog:material.fog===!0,fogExp2:fog&&fog.isFogExp2,flatShading:material.flatShading===!0,sizeAttenuation:material.sizeAttenuation===!0,logarithmicDepthBuffer,skinning:object.isSkinnedMesh===!0,morphTargets:geometry.morphAttributes.position!==void 0,morphNormals:geometry.morphAttributes.normal!==void 0,morphColors:geometry.morphAttributes.color!==void 0,morphTargetsCount,morphTextureStride,numDirLights:lights.directional.length,numPointLights:lights.point.length,numSpotLights:lights.spot.length,numSpotLightMaps:lights.spotLightMap.length,numRectAreaLights:lights.rectArea.length,numHemiLights:lights.hemi.length,numDirLightShadows:lights.directionalShadowMap.length,numPointLightShadows:lights.pointShadowMap.length,numSpotLightShadows:lights.spotShadowMap.length,numSpotLightShadowsWithMaps:lights.numSpotLightShadowsWithMaps,numLightProbes:lights.numLightProbes,numClippingPlanes:clipping.numPlanes,numClipIntersection:clipping.numIntersection,dithering:material.dithering,shadowMapEnabled:renderer.shadowMap.enabled&&shadows.length>0,shadowMapType:renderer.shadowMap.type,toneMapping,useLegacyLights:renderer._useLegacyLights,decodeVideoTexture:HAS_MAP&&material.map.isVideoTexture===!0&&ColorManagement.getTransfer(material.map.colorSpace)===SRGBTransfer,premultipliedAlpha:material.premultipliedAlpha,doubleSided:material.side===DoubleSide,flipSided:material.side===BackSide,useDepthPacking:material.depthPacking>=0,depthPacking:material.depthPacking||0,index0AttributeName:material.index0AttributeName,extensionDerivatives:HAS_EXTENSIONS&&material.extensions.derivatives===!0,extensionFragDepth:HAS_EXTENSIONS&&material.extensions.fragDepth===!0,extensionDrawBuffers:HAS_EXTENSIONS&&material.extensions.drawBuffers===!0,extensionShaderTextureLOD:HAS_EXTENSIONS&&material.extensions.shaderTextureLOD===!0,rendererExtensionFragDepth:IS_WEBGL2||extensions2.has("EXT_frag_depth"),rendererExtensionDrawBuffers:IS_WEBGL2||extensions2.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:IS_WEBGL2||extensions2.has("EXT_shader_texture_lod"),rendererExtensionParallelShaderCompile:extensions2.has("KHR_parallel_shader_compile"),customProgramCacheKey:material.customProgramCacheKey()}}function getProgramCacheKey(parameters){const array=[];if(parameters.shaderID?array.push(parameters.shaderID):(array.push(parameters.customVertexShaderID),array.push(parameters.customFragmentShaderID)),parameters.defines!==void 0)for(const name in parameters.defines)array.push(name),array.push(parameters.defines[name]);return parameters.isRawShaderMaterial===!1&&(getProgramCacheKeyParameters(array,parameters),getProgramCacheKeyBooleans(array,parameters),array.push(renderer.outputColorSpace)),array.push(parameters.customProgramCacheKey),array.join()}function getProgramCacheKeyParameters(array,parameters){array.push(parameters.precision),array.push(parameters.outputColorSpace),array.push(parameters.envMapMode),array.push(parameters.envMapCubeUVHeight),array.push(parameters.mapUv),array.push(parameters.alphaMapUv),array.push(parameters.lightMapUv),array.push(parameters.aoMapUv),array.push(parameters.bumpMapUv),array.push(parameters.normalMapUv),array.push(parameters.displacementMapUv),array.push(parameters.emissiveMapUv),array.push(parameters.metalnessMapUv),array.push(parameters.roughnessMapUv),array.push(parameters.anisotropyMapUv),array.push(parameters.clearcoatMapUv),array.push(parameters.clearcoatNormalMapUv),array.push(parameters.clearcoatRoughnessMapUv),array.push(parameters.iridescenceMapUv),array.push(parameters.iridescenceThicknessMapUv),array.push(parameters.sheenColorMapUv),array.push(parameters.sheenRoughnessMapUv),array.push(parameters.specularMapUv),array.push(parameters.specularColorMapUv),array.push(parameters.specularIntensityMapUv),array.push(parameters.transmissionMapUv),array.push(parameters.thicknessMapUv),array.push(parameters.combine),array.push(parameters.fogExp2),array.push(parameters.sizeAttenuation),array.push(parameters.morphTargetsCount),array.push(parameters.morphAttributeCount),array.push(parameters.numDirLights),array.push(parameters.numPointLights),array.push(parameters.numSpotLights),array.push(parameters.numSpotLightMaps),array.push(parameters.numHemiLights),array.push(parameters.numRectAreaLights),array.push(parameters.numDirLightShadows),array.push(parameters.numPointLightShadows),array.push(parameters.numSpotLightShadows),array.push(parameters.numSpotLightShadowsWithMaps),array.push(parameters.numLightProbes),array.push(parameters.shadowMapType),array.push(parameters.toneMapping),array.push(parameters.numClippingPlanes),array.push(parameters.numClipIntersection),array.push(parameters.depthPacking)}function getProgramCacheKeyBooleans(array,parameters){_programLayers.disableAll(),parameters.isWebGL2&&_programLayers.enable(0),parameters.supportsVertexTextures&&_programLayers.enable(1),parameters.instancing&&_programLayers.enable(2),parameters.instancingColor&&_programLayers.enable(3),parameters.matcap&&_programLayers.enable(4),parameters.envMap&&_programLayers.enable(5),parameters.normalMapObjectSpace&&_programLayers.enable(6),parameters.normalMapTangentSpace&&_programLayers.enable(7),parameters.clearcoat&&_programLayers.enable(8),parameters.iridescence&&_programLayers.enable(9),parameters.alphaTest&&_programLayers.enable(10),parameters.vertexColors&&_programLayers.enable(11),parameters.vertexAlphas&&_programLayers.enable(12),parameters.vertexUv1s&&_programLayers.enable(13),parameters.vertexUv2s&&_programLayers.enable(14),parameters.vertexUv3s&&_programLayers.enable(15),parameters.vertexTangents&&_programLayers.enable(16),parameters.anisotropy&&_programLayers.enable(17),parameters.alphaHash&&_programLayers.enable(18),array.push(_programLayers.mask),_programLayers.disableAll(),parameters.fog&&_programLayers.enable(0),parameters.useFog&&_programLayers.enable(1),parameters.flatShading&&_programLayers.enable(2),parameters.logarithmicDepthBuffer&&_programLayers.enable(3),parameters.skinning&&_programLayers.enable(4),parameters.morphTargets&&_programLayers.enable(5),parameters.morphNormals&&_programLayers.enable(6),parameters.morphColors&&_programLayers.enable(7),parameters.premultipliedAlpha&&_programLayers.enable(8),parameters.shadowMapEnabled&&_programLayers.enable(9),parameters.useLegacyLights&&_programLayers.enable(10),parameters.doubleSided&&_programLayers.enable(11),parameters.flipSided&&_programLayers.enable(12),parameters.useDepthPacking&&_programLayers.enable(13),parameters.dithering&&_programLayers.enable(14),parameters.transmission&&_programLayers.enable(15),parameters.sheen&&_programLayers.enable(16),parameters.opaque&&_programLayers.enable(17),parameters.pointsUvs&&_programLayers.enable(18),parameters.decodeVideoTexture&&_programLayers.enable(19),array.push(_programLayers.mask)}function getUniforms(material){const shaderID=shaderIDs[material.type];let uniforms;if(shaderID){const shader=ShaderLib[shaderID];uniforms=UniformsUtils.clone(shader.uniforms)}else uniforms=material.uniforms;return uniforms}function acquireProgram(parameters,cacheKey){let program;for(let p2=0,pl=programs.length;p2<pl;p2++){const preexistingProgram=programs[p2];if(preexistingProgram.cacheKey===cacheKey){program=preexistingProgram,++program.usedTimes;break}}return program===void 0&&(program=new WebGLProgram(renderer,cacheKey,parameters,bindingStates),programs.push(program)),program}function releaseProgram(program){if(--program.usedTimes===0){const i2=programs.indexOf(program);programs[i2]=programs[programs.length-1],programs.pop(),program.destroy()}}function releaseShaderCache(material){_customShaders.remove(material)}function dispose2(){_customShaders.dispose()}return{getParameters,getProgramCacheKey,getUniforms,acquireProgram,releaseProgram,releaseShaderCache,programs,dispose:dispose2}}function WebGLProperties(){let properties=new WeakMap;function get(object){let map=properties.get(object);return map===void 0&&(map={},properties.set(object,map)),map}function remove(object){properties.delete(object)}function update(object,key,value){properties.get(object)[key]=value}function dispose2(){properties=new WeakMap}return{get,remove,update,dispose:dispose2}}function painterSortStable(a2,b2){return a2.groupOrder!==b2.groupOrder?a2.groupOrder-b2.groupOrder:a2.renderOrder!==b2.renderOrder?a2.renderOrder-b2.renderOrder:a2.material.id!==b2.material.id?a2.material.id-b2.material.id:a2.z!==b2.z?a2.z-b2.z:a2.id-b2.id}function reversePainterSortStable(a2,b2){return a2.groupOrder!==b2.groupOrder?a2.groupOrder-b2.groupOrder:a2.renderOrder!==b2.renderOrder?a2.renderOrder-b2.renderOrder:a2.z!==b2.z?b2.z-a2.z:a2.id-b2.id}function WebGLRenderList(){const renderItems=[];let renderItemsIndex=0;const opaque=[],transmissive=[],transparent=[];function init(){renderItemsIndex=0,opaque.length=0,transmissive.length=0,transparent.length=0}function getNextRenderItem(object,geometry,material,groupOrder,z,group){let renderItem=renderItems[renderItemsIndex];return renderItem===void 0?(renderItem={id:object.id,object,geometry,material,groupOrder,renderOrder:object.renderOrder,z,group},renderItems[renderItemsIndex]=renderItem):(renderItem.id=object.id,renderItem.object=object,renderItem.geometry=geometry,renderItem.material=material,renderItem.groupOrder=groupOrder,renderItem.renderOrder=object.renderOrder,renderItem.z=z,renderItem.group=group),renderItemsIndex++,renderItem}function push(object,geometry,material,groupOrder,z,group){const renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);material.transmission>0?transmissive.push(renderItem):material.transparent===!0?transparent.push(renderItem):opaque.push(renderItem)}function unshift(object,geometry,material,groupOrder,z,group){const renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);material.transmission>0?transmissive.unshift(renderItem):material.transparent===!0?transparent.unshift(renderItem):opaque.unshift(renderItem)}function sort(customOpaqueSort,customTransparentSort){opaque.length>1&&opaque.sort(customOpaqueSort||painterSortStable),transmissive.length>1&&transmissive.sort(customTransparentSort||reversePainterSortStable),transparent.length>1&&transparent.sort(customTransparentSort||reversePainterSortStable)}function finish(){for(let i2=renderItemsIndex,il=renderItems.length;i2<il;i2++){const renderItem=renderItems[i2];if(renderItem.id===null)break;renderItem.id=null,renderItem.object=null,renderItem.geometry=null,renderItem.material=null,renderItem.group=null}}return{opaque,transmissive,transparent,init,push,unshift,finish,sort}}function WebGLRenderLists(){let lists=new WeakMap;function get(scene2,renderCallDepth){const listArray=lists.get(scene2);let list;return listArray===void 0?(list=new WebGLRenderList,lists.set(scene2,[list])):renderCallDepth>=listArray.length?(list=new WebGLRenderList,listArray.push(list)):list=listArray[renderCallDepth],list}function dispose2(){lists=new WeakMap}return{get,dispose:dispose2}}function UniformsCache(){const lights={};return{get:function(light){if(lights[light.id]!==void 0)return lights[light.id];let uniforms;switch(light.type){case"DirectionalLight":uniforms={direction:new Vector3,color:new Color};break;case"SpotLight":uniforms={position:new Vector3,direction:new Vector3,color:new Color,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":uniforms={position:new Vector3,color:new Color,distance:0,decay:0};break;case"HemisphereLight":uniforms={direction:new Vector3,skyColor:new Color,groundColor:new Color};break;case"RectAreaLight":uniforms={color:new Color,position:new Vector3,halfWidth:new Vector3,halfHeight:new Vector3};break}return lights[light.id]=uniforms,uniforms}}}function ShadowUniformsCache(){const lights={};return{get:function(light){if(lights[light.id]!==void 0)return lights[light.id];let uniforms;switch(light.type){case"DirectionalLight":uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"SpotLight":uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case"PointLight":uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2,shadowCameraNear:1,shadowCameraFar:1e3};break}return lights[light.id]=uniforms,uniforms}}}let nextVersion=0;function shadowCastingAndTexturingLightsFirst(lightA,lightB){return(lightB.castShadow?2:0)-(lightA.castShadow?2:0)+(lightB.map?1:0)-(lightA.map?1:0)}function WebGLLights(extensions2,capabilities){const cache=new UniformsCache,shadowCache=ShadowUniformsCache(),state={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let i2=0;i2<9;i2++)state.probe.push(new Vector3);const vector3=new Vector3,matrix4=new Matrix4,matrix42=new Matrix4;function setup(lights,useLegacyLights){let r2=0,g2=0,b2=0;for(let i2=0;i2<9;i2++)state.probe[i2].set(0,0,0);let directionalLength=0,pointLength=0,spotLength=0,rectAreaLength=0,hemiLength=0,numDirectionalShadows=0,numPointShadows=0,numSpotShadows=0,numSpotMaps=0,numSpotShadowsWithMaps=0,numLightProbes=0;lights.sort(shadowCastingAndTexturingLightsFirst);const scaleFactor=useLegacyLights===!0?Math.PI:1;for(let i2=0,l2=lights.length;i2<l2;i2++){const light=lights[i2],color2=light.color,intensity=light.intensity,distance2=light.distance,shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;if(light.isAmbientLight)r2+=color2.r*intensity*scaleFactor,g2+=color2.g*intensity*scaleFactor,b2+=color2.b*intensity*scaleFactor;else if(light.isLightProbe){for(let j2=0;j2<9;j2++)state.probe[j2].addScaledVector(light.sh.coefficients[j2],intensity);numLightProbes++}else if(light.isDirectionalLight){const uniforms=cache.get(light);if(uniforms.color.copy(light.color).multiplyScalar(light.intensity*scaleFactor),light.castShadow){const shadow=light.shadow,shadowUniforms=shadowCache.get(light);shadowUniforms.shadowBias=shadow.bias,shadowUniforms.shadowNormalBias=shadow.normalBias,shadowUniforms.shadowRadius=shadow.radius,shadowUniforms.shadowMapSize=shadow.mapSize,state.directionalShadow[directionalLength]=shadowUniforms,state.directionalShadowMap[directionalLength]=shadowMap,state.directionalShadowMatrix[directionalLength]=light.shadow.matrix,numDirectionalShadows++}state.directional[directionalLength]=uniforms,directionalLength++}else if(light.isSpotLight){const uniforms=cache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld),uniforms.color.copy(color2).multiplyScalar(intensity*scaleFactor),uniforms.distance=distance2,uniforms.coneCos=Math.cos(light.angle),uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra)),uniforms.decay=light.decay,state.spot[spotLength]=uniforms;const shadow=light.shadow;if(light.map&&(state.spotLightMap[numSpotMaps]=light.map,numSpotMaps++,shadow.updateMatrices(light),light.castShadow&&numSpotShadowsWithMaps++),state.spotLightMatrix[spotLength]=shadow.matrix,light.castShadow){const shadowUniforms=shadowCache.get(light);shadowUniforms.shadowBias=shadow.bias,shadowUniforms.shadowNormalBias=shadow.normalBias,shadowUniforms.shadowRadius=shadow.radius,shadowUniforms.shadowMapSize=shadow.mapSize,state.spotShadow[spotLength]=shadowUniforms,state.spotShadowMap[spotLength]=shadowMap,numSpotShadows++}spotLength++}else if(light.isRectAreaLight){const uniforms=cache.get(light);uniforms.color.copy(color2).multiplyScalar(intensity),uniforms.halfWidth.set(light.width*.5,0,0),uniforms.halfHeight.set(0,light.height*.5,0),state.rectArea[rectAreaLength]=uniforms,rectAreaLength++}else if(light.isPointLight){const uniforms=cache.get(light);if(uniforms.color.copy(light.color).multiplyScalar(light.intensity*scaleFactor),uniforms.distance=light.distance,uniforms.decay=light.decay,light.castShadow){const shadow=light.shadow,shadowUniforms=shadowCache.get(light);shadowUniforms.shadowBias=shadow.bias,shadowUniforms.shadowNormalBias=shadow.normalBias,shadowUniforms.shadowRadius=shadow.radius,shadowUniforms.shadowMapSize=shadow.mapSize,shadowUniforms.shadowCameraNear=shadow.camera.near,shadowUniforms.shadowCameraFar=shadow.camera.far,state.pointShadow[pointLength]=shadowUniforms,state.pointShadowMap[pointLength]=shadowMap,state.pointShadowMatrix[pointLength]=light.shadow.matrix,numPointShadows++}state.point[pointLength]=uniforms,pointLength++}else if(light.isHemisphereLight){const uniforms=cache.get(light);uniforms.skyColor.copy(light.color).multiplyScalar(intensity*scaleFactor),uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity*scaleFactor),state.hemi[hemiLength]=uniforms,hemiLength++}}rectAreaLength>0&&(capabilities.isWebGL2||extensions2.has("OES_texture_float_linear")===!0?(state.rectAreaLTC1=UniformsLib.LTC_FLOAT_1,state.rectAreaLTC2=UniformsLib.LTC_FLOAT_2):extensions2.has("OES_texture_half_float_linear")===!0?(state.rectAreaLTC1=UniformsLib.LTC_HALF_1,state.rectAreaLTC2=UniformsLib.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),state.ambient[0]=r2,state.ambient[1]=g2,state.ambient[2]=b2;const hash=state.hash;(hash.directionalLength!==directionalLength||hash.pointLength!==pointLength||hash.spotLength!==spotLength||hash.rectAreaLength!==rectAreaLength||hash.hemiLength!==hemiLength||hash.numDirectionalShadows!==numDirectionalShadows||hash.numPointShadows!==numPointShadows||hash.numSpotShadows!==numSpotShadows||hash.numSpotMaps!==numSpotMaps||hash.numLightProbes!==numLightProbes)&&(state.directional.length=directionalLength,state.spot.length=spotLength,state.rectArea.length=rectAreaLength,state.point.length=pointLength,state.hemi.length=hemiLength,state.directionalShadow.length=numDirectionalShadows,state.directionalShadowMap.length=numDirectionalShadows,state.pointShadow.length=numPointShadows,state.pointShadowMap.length=numPointShadows,state.spotShadow.length=numSpotShadows,state.spotShadowMap.length=numSpotShadows,state.directionalShadowMatrix.length=numDirectionalShadows,state.pointShadowMatrix.length=numPointShadows,state.spotLightMatrix.length=numSpotShadows+numSpotMaps-numSpotShadowsWithMaps,state.spotLightMap.length=numSpotMaps,state.numSpotLightShadowsWithMaps=numSpotShadowsWithMaps,state.numLightProbes=numLightProbes,hash.directionalLength=directionalLength,hash.pointLength=pointLength,hash.spotLength=spotLength,hash.rectAreaLength=rectAreaLength,hash.hemiLength=hemiLength,hash.numDirectionalShadows=numDirectionalShadows,hash.numPointShadows=numPointShadows,hash.numSpotShadows=numSpotShadows,hash.numSpotMaps=numSpotMaps,hash.numLightProbes=numLightProbes,state.version=nextVersion++)}function setupView(lights,camera){let directionalLength=0,pointLength=0,spotLength=0,rectAreaLength=0,hemiLength=0;const viewMatrix=camera.matrixWorldInverse;for(let i2=0,l2=lights.length;i2<l2;i2++){const light=lights[i2];if(light.isDirectionalLight){const uniforms=state.directional[directionalLength];uniforms.direction.setFromMatrixPosition(light.matrixWorld),vector3.setFromMatrixPosition(light.target.matrixWorld),uniforms.direction.sub(vector3),uniforms.direction.transformDirection(viewMatrix),directionalLength++}else if(light.isSpotLight){const uniforms=state.spot[spotLength];uniforms.position.setFromMatrixPosition(light.matrixWorld),uniforms.position.applyMatrix4(viewMatrix),uniforms.direction.setFromMatrixPosition(light.matrixWorld),vector3.setFromMatrixPosition(light.target.matrixWorld),uniforms.direction.sub(vector3),uniforms.direction.transformDirection(viewMatrix),spotLength++}else if(light.isRectAreaLight){const uniforms=state.rectArea[rectAreaLength];uniforms.position.setFromMatrixPosition(light.matrixWorld),uniforms.position.applyMatrix4(viewMatrix),matrix42.identity(),matrix4.copy(light.matrixWorld),matrix4.premultiply(viewMatrix),matrix42.extractRotation(matrix4),uniforms.halfWidth.set(light.width*.5,0,0),uniforms.halfHeight.set(0,light.height*.5,0),uniforms.halfWidth.applyMatrix4(matrix42),uniforms.halfHeight.applyMatrix4(matrix42),rectAreaLength++}else if(light.isPointLight){const uniforms=state.point[pointLength];uniforms.position.setFromMatrixPosition(light.matrixWorld),uniforms.position.applyMatrix4(viewMatrix),pointLength++}else if(light.isHemisphereLight){const uniforms=state.hemi[hemiLength];uniforms.direction.setFromMatrixPosition(light.matrixWorld),uniforms.direction.transformDirection(viewMatrix),hemiLength++}}}return{setup,setupView,state}}function WebGLRenderState(extensions2,capabilities){const lights=new WebGLLights(extensions2,capabilities),lightsArray=[],shadowsArray=[];function init(){lightsArray.length=0,shadowsArray.length=0}function pushLight(light){lightsArray.push(light)}function pushShadow(shadowLight){shadowsArray.push(shadowLight)}function setupLights(useLegacyLights){lights.setup(lightsArray,useLegacyLights)}function setupLightsView(camera){lights.setupView(lightsArray,camera)}return{init,state:{lightsArray,shadowsArray,lights},setupLights,setupLightsView,pushLight,pushShadow}}function WebGLRenderStates(extensions2,capabilities){let renderStates=new WeakMap;function get(scene2,renderCallDepth=0){const renderStateArray=renderStates.get(scene2);let renderState;return renderStateArray===void 0?(renderState=new WebGLRenderState(extensions2,capabilities),renderStates.set(scene2,[renderState])):renderCallDepth>=renderStateArray.length?(renderState=new WebGLRenderState(extensions2,capabilities),renderStateArray.push(renderState)):renderState=renderStateArray[renderCallDepth],renderState}function dispose2(){renderStates=new WeakMap}return{get,dispose:dispose2}}class MeshDepthMaterial extends Material{constructor(parameters){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=BasicDepthPacking,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(parameters)}copy(source){return super.copy(source),this.depthPacking=source.depthPacking,this.map=source.map,this.alphaMap=source.alphaMap,this.displacementMap=source.displacementMap,this.displacementScale=source.displacementScale,this.displacementBias=source.displacementBias,this.wireframe=source.wireframe,this.wireframeLinewidth=source.wireframeLinewidth,this}}class MeshDistanceMaterial extends Material{constructor(parameters){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(parameters)}copy(source){return super.copy(source),this.map=source.map,this.alphaMap=source.alphaMap,this.displacementMap=source.displacementMap,this.displacementScale=source.displacementScale,this.displacementBias=source.displacementBias,this}}const vertex=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,fragment=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function WebGLShadowMap(_renderer,_objects,_capabilities){let _frustum=new Frustum;const _shadowMapSize=new Vector2,_viewportSize=new Vector2,_viewport=new Vector4,_depthMaterial=new MeshDepthMaterial({depthPacking:RGBADepthPacking}),_distanceMaterial=new MeshDistanceMaterial,_materialCache={},_maxTextureSize=_capabilities.maxTextureSize,shadowSide={[FrontSide]:BackSide,[BackSide]:FrontSide,[DoubleSide]:DoubleSide},shadowMaterialVertical=new ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2},radius:{value:4}},vertexShader:vertex,fragmentShader:fragment}),shadowMaterialHorizontal=shadowMaterialVertical.clone();shadowMaterialHorizontal.defines.HORIZONTAL_PASS=1;const fullScreenTri=new BufferGeometry;fullScreenTri.setAttribute("position",new BufferAttribute(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const fullScreenMesh=new Mesh(fullScreenTri,shadowMaterialVertical),scope=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=PCFShadowMap;let _previousType=this.type;this.render=function(lights,scene2,camera){if(scope.enabled===!1||scope.autoUpdate===!1&&scope.needsUpdate===!1||lights.length===0)return;const currentRenderTarget=_renderer.getRenderTarget(),activeCubeFace=_renderer.getActiveCubeFace(),activeMipmapLevel=_renderer.getActiveMipmapLevel(),_state=_renderer.state;_state.setBlending(NoBlending),_state.buffers.color.setClear(1,1,1,1),_state.buffers.depth.setTest(!0),_state.setScissorTest(!1);const toVSM=_previousType!==VSMShadowMap&&this.type===VSMShadowMap,fromVSM=_previousType===VSMShadowMap&&this.type!==VSMShadowMap;for(let i2=0,il=lights.length;i2<il;i2++){const light=lights[i2],shadow=light.shadow;if(shadow===void 0){console.warn("THREE.WebGLShadowMap:",light,"has no shadow.");continue}if(shadow.autoUpdate===!1&&shadow.needsUpdate===!1)continue;_shadowMapSize.copy(shadow.mapSize);const shadowFrameExtents=shadow.getFrameExtents();if(_shadowMapSize.multiply(shadowFrameExtents),_viewportSize.copy(shadow.mapSize),(_shadowMapSize.x>_maxTextureSize||_shadowMapSize.y>_maxTextureSize)&&(_shadowMapSize.x>_maxTextureSize&&(_viewportSize.x=Math.floor(_maxTextureSize/shadowFrameExtents.x),_shadowMapSize.x=_viewportSize.x*shadowFrameExtents.x,shadow.mapSize.x=_viewportSize.x),_shadowMapSize.y>_maxTextureSize&&(_viewportSize.y=Math.floor(_maxTextureSize/shadowFrameExtents.y),_shadowMapSize.y=_viewportSize.y*shadowFrameExtents.y,shadow.mapSize.y=_viewportSize.y)),shadow.map===null||toVSM===!0||fromVSM===!0){const pars=this.type!==VSMShadowMap?{minFilter:NearestFilter,magFilter:NearestFilter}:{};shadow.map!==null&&shadow.map.dispose(),shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars),shadow.map.texture.name=light.name+".shadowMap",shadow.camera.updateProjectionMatrix()}_renderer.setRenderTarget(shadow.map),_renderer.clear();const viewportCount=shadow.getViewportCount();for(let vp=0;vp<viewportCount;vp++){const viewport=shadow.getViewport(vp);_viewport.set(_viewportSize.x*viewport.x,_viewportSize.y*viewport.y,_viewportSize.x*viewport.z,_viewportSize.y*viewport.w),_state.viewport(_viewport),shadow.updateMatrices(light,vp),_frustum=shadow.getFrustum(),renderObject(scene2,camera,shadow.camera,light,this.type)}shadow.isPointLightShadow!==!0&&this.type===VSMShadowMap&&VSMPass(shadow,camera),shadow.needsUpdate=!1}_previousType=this.type,scope.needsUpdate=!1,_renderer.setRenderTarget(currentRenderTarget,activeCubeFace,activeMipmapLevel)};function VSMPass(shadow,camera){const geometry=_objects.update(fullScreenMesh);shadowMaterialVertical.defines.VSM_SAMPLES!==shadow.blurSamples&&(shadowMaterialVertical.defines.VSM_SAMPLES=shadow.blurSamples,shadowMaterialHorizontal.defines.VSM_SAMPLES=shadow.blurSamples,shadowMaterialVertical.needsUpdate=!0,shadowMaterialHorizontal.needsUpdate=!0),shadow.mapPass===null&&(shadow.mapPass=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y)),shadowMaterialVertical.uniforms.shadow_pass.value=shadow.map.texture,shadowMaterialVertical.uniforms.resolution.value=shadow.mapSize,shadowMaterialVertical.uniforms.radius.value=shadow.radius,_renderer.setRenderTarget(shadow.mapPass),_renderer.clear(),_renderer.renderBufferDirect(camera,null,geometry,shadowMaterialVertical,fullScreenMesh,null),shadowMaterialHorizontal.uniforms.shadow_pass.value=shadow.mapPass.texture,shadowMaterialHorizontal.uniforms.resolution.value=shadow.mapSize,shadowMaterialHorizontal.uniforms.radius.value=shadow.radius,_renderer.setRenderTarget(shadow.map),_renderer.clear(),_renderer.renderBufferDirect(camera,null,geometry,shadowMaterialHorizontal,fullScreenMesh,null)}function getDepthMaterial(object,material,light,type){let result=null;const customMaterial=light.isPointLight===!0?object.customDistanceMaterial:object.customDepthMaterial;if(customMaterial!==void 0)result=customMaterial;else if(result=light.isPointLight===!0?_distanceMaterial:_depthMaterial,_renderer.localClippingEnabled&&material.clipShadows===!0&&Array.isArray(material.clippingPlanes)&&material.clippingPlanes.length!==0||material.displacementMap&&material.displacementScale!==0||material.alphaMap&&material.alphaTest>0||material.map&&material.alphaTest>0){const keyA=result.uuid,keyB=material.uuid;let materialsForVariant=_materialCache[keyA];materialsForVariant===void 0&&(materialsForVariant={},_materialCache[keyA]=materialsForVariant);let cachedMaterial=materialsForVariant[keyB];cachedMaterial===void 0&&(cachedMaterial=result.clone(),materialsForVariant[keyB]=cachedMaterial),result=cachedMaterial}if(result.visible=material.visible,result.wireframe=material.wireframe,type===VSMShadowMap?result.side=material.shadowSide!==null?material.shadowSide:material.side:result.side=material.shadowSide!==null?material.shadowSide:shadowSide[material.side],result.alphaMap=material.alphaMap,result.alphaTest=material.alphaTest,result.map=material.map,result.clipShadows=material.clipShadows,result.clippingPlanes=material.clippingPlanes,result.clipIntersection=material.clipIntersection,result.displacementMap=material.displacementMap,result.displacementScale=material.displacementScale,result.displacementBias=material.displacementBias,result.wireframeLinewidth=material.wireframeLinewidth,result.linewidth=material.linewidth,light.isPointLight===!0&&result.isMeshDistanceMaterial===!0){const materialProperties=_renderer.properties.get(result);materialProperties.light=light}return result}function renderObject(object,camera,shadowCamera,light,type){if(object.visible===!1)return;if(object.layers.test(camera.layers)&&(object.isMesh||object.isLine||object.isPoints)&&(object.castShadow||object.receiveShadow&&type===VSMShadowMap)&&(!object.frustumCulled||_frustum.intersectsObject(object))){object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,object.matrixWorld);const geometry=_objects.update(object),material=object.material;if(Array.isArray(material)){const groups=geometry.groups;for(let k2=0,kl=groups.length;k2<kl;k2++){const group=groups[k2],groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){const depthMaterial=getDepthMaterial(object,groupMaterial,light,type);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,group)}}}else if(material.visible){const depthMaterial=getDepthMaterial(object,material,light,type);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,null)}}const children=object.children;for(let i2=0,l2=children.length;i2<l2;i2++)renderObject(children[i2],camera,shadowCamera,light,type)}}function WebGLState(gl,extensions2,capabilities){const isWebGL2=capabilities.isWebGL2;function ColorBuffer(){let locked=!1;const color2=new Vector4;let currentColorMask=null;const currentColorClear=new Vector4(0,0,0,0);return{setMask:function(colorMask){currentColorMask!==colorMask&&!locked&&(gl.colorMask(colorMask,colorMask,colorMask,colorMask),currentColorMask=colorMask)},setLocked:function(lock){locked=lock},setClear:function(r2,g2,b2,a2,premultipliedAlpha){premultipliedAlpha===!0&&(r2*=a2,g2*=a2,b2*=a2),color2.set(r2,g2,b2,a2),currentColorClear.equals(color2)===!1&&(gl.clearColor(r2,g2,b2,a2),currentColorClear.copy(color2))},reset:function(){locked=!1,currentColorMask=null,currentColorClear.set(-1,0,0,0)}}}function DepthBuffer(){let locked=!1,currentDepthMask=null,currentDepthFunc=null,currentDepthClear=null;return{setTest:function(depthTest){depthTest?enable(gl.DEPTH_TEST):disable(gl.DEPTH_TEST)},setMask:function(depthMask){currentDepthMask!==depthMask&&!locked&&(gl.depthMask(depthMask),currentDepthMask=depthMask)},setFunc:function(depthFunc){if(currentDepthFunc!==depthFunc){switch(depthFunc){case NeverDepth:gl.depthFunc(gl.NEVER);break;case AlwaysDepth:gl.depthFunc(gl.ALWAYS);break;case LessDepth:gl.depthFunc(gl.LESS);break;case LessEqualDepth:gl.depthFunc(gl.LEQUAL);break;case EqualDepth:gl.depthFunc(gl.EQUAL);break;case GreaterEqualDepth:gl.depthFunc(gl.GEQUAL);break;case GreaterDepth:gl.depthFunc(gl.GREATER);break;case NotEqualDepth:gl.depthFunc(gl.NOTEQUAL);break;default:gl.depthFunc(gl.LEQUAL)}currentDepthFunc=depthFunc}},setLocked:function(lock){locked=lock},setClear:function(depth){currentDepthClear!==depth&&(gl.clearDepth(depth),currentDepthClear=depth)},reset:function(){locked=!1,currentDepthMask=null,currentDepthFunc=null,currentDepthClear=null}}}function StencilBuffer(){let locked=!1,currentStencilMask=null,currentStencilFunc=null,currentStencilRef=null,currentStencilFuncMask=null,currentStencilFail=null,currentStencilZFail=null,currentStencilZPass=null,currentStencilClear=null;return{setTest:function(stencilTest){locked||(stencilTest?enable(gl.STENCIL_TEST):disable(gl.STENCIL_TEST))},setMask:function(stencilMask){currentStencilMask!==stencilMask&&!locked&&(gl.stencilMask(stencilMask),currentStencilMask=stencilMask)},setFunc:function(stencilFunc,stencilRef,stencilMask){(currentStencilFunc!==stencilFunc||currentStencilRef!==stencilRef||currentStencilFuncMask!==stencilMask)&&(gl.stencilFunc(stencilFunc,stencilRef,stencilMask),currentStencilFunc=stencilFunc,currentStencilRef=stencilRef,currentStencilFuncMask=stencilMask)},setOp:function(stencilFail,stencilZFail,stencilZPass){(currentStencilFail!==stencilFail||currentStencilZFail!==stencilZFail||currentStencilZPass!==stencilZPass)&&(gl.stencilOp(stencilFail,stencilZFail,stencilZPass),currentStencilFail=stencilFail,currentStencilZFail=stencilZFail,currentStencilZPass=stencilZPass)},setLocked:function(lock){locked=lock},setClear:function(stencil){currentStencilClear!==stencil&&(gl.clearStencil(stencil),currentStencilClear=stencil)},reset:function(){locked=!1,currentStencilMask=null,currentStencilFunc=null,currentStencilRef=null,currentStencilFuncMask=null,currentStencilFail=null,currentStencilZFail=null,currentStencilZPass=null,currentStencilClear=null}}}const colorBuffer=new ColorBuffer,depthBuffer=new DepthBuffer,stencilBuffer=new StencilBuffer,uboBindings=new WeakMap,uboProgramMap=new WeakMap;let enabledCapabilities={},currentBoundFramebuffers={},currentDrawbuffers=new WeakMap,defaultDrawbuffers=[],currentProgram=null,currentBlendingEnabled=!1,currentBlending=null,currentBlendEquation=null,currentBlendSrc=null,currentBlendDst=null,currentBlendEquationAlpha=null,currentBlendSrcAlpha=null,currentBlendDstAlpha=null,currentBlendColor=new Color(0,0,0),currentBlendAlpha=0,currentPremultipledAlpha=!1,currentFlipSided=null,currentCullFace=null,currentLineWidth=null,currentPolygonOffsetFactor=null,currentPolygonOffsetUnits=null;const maxTextures=gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let lineWidthAvailable=!1,version2=0;const glVersion=gl.getParameter(gl.VERSION);glVersion.indexOf("WebGL")!==-1?(version2=parseFloat(/^WebGL (\d)/.exec(glVersion)[1]),lineWidthAvailable=version2>=1):glVersion.indexOf("OpenGL ES")!==-1&&(version2=parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]),lineWidthAvailable=version2>=2);let currentTextureSlot=null,currentBoundTextures={};const scissorParam=gl.getParameter(gl.SCISSOR_BOX),viewportParam=gl.getParameter(gl.VIEWPORT),currentScissor=new Vector4().fromArray(scissorParam),currentViewport=new Vector4().fromArray(viewportParam);function createTexture(type,target,count,dimensions){const data=new Uint8Array(4),texture=gl.createTexture();gl.bindTexture(type,texture),gl.texParameteri(type,gl.TEXTURE_MIN_FILTER,gl.NEAREST),gl.texParameteri(type,gl.TEXTURE_MAG_FILTER,gl.NEAREST);for(let i2=0;i2<count;i2++)isWebGL2&&(type===gl.TEXTURE_3D||type===gl.TEXTURE_2D_ARRAY)?gl.texImage3D(target,0,gl.RGBA,1,1,dimensions,0,gl.RGBA,gl.UNSIGNED_BYTE,data):gl.texImage2D(target+i2,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,data);return texture}const emptyTextures={};emptyTextures[gl.TEXTURE_2D]=createTexture(gl.TEXTURE_2D,gl.TEXTURE_2D,1),emptyTextures[gl.TEXTURE_CUBE_MAP]=createTexture(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_CUBE_MAP_POSITIVE_X,6),isWebGL2&&(emptyTextures[gl.TEXTURE_2D_ARRAY]=createTexture(gl.TEXTURE_2D_ARRAY,gl.TEXTURE_2D_ARRAY,1,1),emptyTextures[gl.TEXTURE_3D]=createTexture(gl.TEXTURE_3D,gl.TEXTURE_3D,1,1)),colorBuffer.setClear(0,0,0,1),depthBuffer.setClear(1),stencilBuffer.setClear(0),enable(gl.DEPTH_TEST),depthBuffer.setFunc(LessEqualDepth),setFlipSided(!1),setCullFace(CullFaceBack),enable(gl.CULL_FACE),setBlending(NoBlending);function enable(id2){enabledCapabilities[id2]!==!0&&(gl.enable(id2),enabledCapabilities[id2]=!0)}function disable(id2){enabledCapabilities[id2]!==!1&&(gl.disable(id2),enabledCapabilities[id2]=!1)}function bindFramebuffer(target,framebuffer){return currentBoundFramebuffers[target]!==framebuffer?(gl.bindFramebuffer(target,framebuffer),currentBoundFramebuffers[target]=framebuffer,isWebGL2&&(target===gl.DRAW_FRAMEBUFFER&&(currentBoundFramebuffers[gl.FRAMEBUFFER]=framebuffer),target===gl.FRAMEBUFFER&&(currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER]=framebuffer)),!0):!1}function drawBuffers(renderTarget,framebuffer){let drawBuffers2=defaultDrawbuffers,needsUpdate=!1;if(renderTarget)if(drawBuffers2=currentDrawbuffers.get(framebuffer),drawBuffers2===void 0&&(drawBuffers2=[],currentDrawbuffers.set(framebuffer,drawBuffers2)),renderTarget.isWebGLMultipleRenderTargets){const textures=renderTarget.texture;if(drawBuffers2.length!==textures.length||drawBuffers2[0]!==gl.COLOR_ATTACHMENT0){for(let i2=0,il=textures.length;i2<il;i2++)drawBuffers2[i2]=gl.COLOR_ATTACHMENT0+i2;drawBuffers2.length=textures.length,needsUpdate=!0}}else drawBuffers2[0]!==gl.COLOR_ATTACHMENT0&&(drawBuffers2[0]=gl.COLOR_ATTACHMENT0,needsUpdate=!0);else drawBuffers2[0]!==gl.BACK&&(drawBuffers2[0]=gl.BACK,needsUpdate=!0);needsUpdate&&(capabilities.isWebGL2?gl.drawBuffers(drawBuffers2):extensions2.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2))}function useProgram(program){return currentProgram!==program?(gl.useProgram(program),currentProgram=program,!0):!1}const equationToGL={[AddEquation]:gl.FUNC_ADD,[SubtractEquation]:gl.FUNC_SUBTRACT,[ReverseSubtractEquation]:gl.FUNC_REVERSE_SUBTRACT};if(isWebGL2)equationToGL[MinEquation]=gl.MIN,equationToGL[MaxEquation]=gl.MAX;else{const extension=extensions2.get("EXT_blend_minmax");extension!==null&&(equationToGL[MinEquation]=extension.MIN_EXT,equationToGL[MaxEquation]=extension.MAX_EXT)}const factorToGL={[ZeroFactor]:gl.ZERO,[OneFactor]:gl.ONE,[SrcColorFactor]:gl.SRC_COLOR,[SrcAlphaFactor]:gl.SRC_ALPHA,[SrcAlphaSaturateFactor]:gl.SRC_ALPHA_SATURATE,[DstColorFactor]:gl.DST_COLOR,[DstAlphaFactor]:gl.DST_ALPHA,[OneMinusSrcColorFactor]:gl.ONE_MINUS_SRC_COLOR,[OneMinusSrcAlphaFactor]:gl.ONE_MINUS_SRC_ALPHA,[OneMinusDstColorFactor]:gl.ONE_MINUS_DST_COLOR,[OneMinusDstAlphaFactor]:gl.ONE_MINUS_DST_ALPHA,[ConstantColorFactor]:gl.CONSTANT_COLOR,[OneMinusConstantColorFactor]:gl.ONE_MINUS_CONSTANT_COLOR,[ConstantAlphaFactor]:gl.CONSTANT_ALPHA,[OneMinusConstantAlphaFactor]:gl.ONE_MINUS_CONSTANT_ALPHA};function setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,blendColor,blendAlpha,premultipliedAlpha){if(blending===NoBlending){currentBlendingEnabled===!0&&(disable(gl.BLEND),currentBlendingEnabled=!1);return}if(currentBlendingEnabled===!1&&(enable(gl.BLEND),currentBlendingEnabled=!0),blending!==CustomBlending){if(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){if((currentBlendEquation!==AddEquation||currentBlendEquationAlpha!==AddEquation)&&(gl.blendEquation(gl.FUNC_ADD),currentBlendEquation=AddEquation,currentBlendEquationAlpha=AddEquation),premultipliedAlpha)switch(blending){case NormalBlending:gl.blendFuncSeparate(gl.ONE,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:gl.blendFunc(gl.ONE,gl.ONE);break;case SubtractiveBlending:gl.blendFuncSeparate(gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ZERO,gl.ONE);break;case MultiplyBlending:gl.blendFuncSeparate(gl.ZERO,gl.SRC_COLOR,gl.ZERO,gl.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",blending);break}else switch(blending){case NormalBlending:gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);break;case AdditiveBlending:gl.blendFunc(gl.SRC_ALPHA,gl.ONE);break;case SubtractiveBlending:gl.blendFuncSeparate(gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ZERO,gl.ONE);break;case MultiplyBlending:gl.blendFunc(gl.ZERO,gl.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",blending);break}currentBlendSrc=null,currentBlendDst=null,currentBlendSrcAlpha=null,currentBlendDstAlpha=null,currentBlendColor.set(0,0,0),currentBlendAlpha=0,currentBlending=blending,currentPremultipledAlpha=premultipliedAlpha}return}blendEquationAlpha=blendEquationAlpha||blendEquation,blendSrcAlpha=blendSrcAlpha||blendSrc,blendDstAlpha=blendDstAlpha||blendDst,(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha)&&(gl.blendEquationSeparate(equationToGL[blendEquation],equationToGL[blendEquationAlpha]),currentBlendEquation=blendEquation,currentBlendEquationAlpha=blendEquationAlpha),(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||blendDstAlpha!==currentBlendDstAlpha)&&(gl.blendFuncSeparate(factorToGL[blendSrc],factorToGL[blendDst],factorToGL[blendSrcAlpha],factorToGL[blendDstAlpha]),currentBlendSrc=blendSrc,currentBlendDst=blendDst,currentBlendSrcAlpha=blendSrcAlpha,currentBlendDstAlpha=blendDstAlpha),(blendColor.equals(currentBlendColor)===!1||blendAlpha!==currentBlendAlpha)&&(gl.blendColor(blendColor.r,blendColor.g,blendColor.b,blendAlpha),currentBlendColor.copy(blendColor),currentBlendAlpha=blendAlpha),currentBlending=blending,currentPremultipledAlpha=!1}function setMaterial(material,frontFaceCW){material.side===DoubleSide?disable(gl.CULL_FACE):enable(gl.CULL_FACE);let flipSided=material.side===BackSide;frontFaceCW&&(flipSided=!flipSided),setFlipSided(flipSided),material.blending===NormalBlending&&material.transparent===!1?setBlending(NoBlending):setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.blendColor,material.blendAlpha,material.premultipliedAlpha),depthBuffer.setFunc(material.depthFunc),depthBuffer.setTest(material.depthTest),depthBuffer.setMask(material.depthWrite),colorBuffer.setMask(material.colorWrite);const stencilWrite=material.stencilWrite;stencilBuffer.setTest(stencilWrite),stencilWrite&&(stencilBuffer.setMask(material.stencilWriteMask),stencilBuffer.setFunc(material.stencilFunc,material.stencilRef,material.stencilFuncMask),stencilBuffer.setOp(material.stencilFail,material.stencilZFail,material.stencilZPass)),setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits),material.alphaToCoverage===!0?enable(gl.SAMPLE_ALPHA_TO_COVERAGE):disable(gl.SAMPLE_ALPHA_TO_COVERAGE)}function setFlipSided(flipSided){currentFlipSided!==flipSided&&(flipSided?gl.frontFace(gl.CW):gl.frontFace(gl.CCW),currentFlipSided=flipSided)}function setCullFace(cullFace){cullFace!==CullFaceNone?(enable(gl.CULL_FACE),cullFace!==currentCullFace&&(cullFace===CullFaceBack?gl.cullFace(gl.BACK):cullFace===CullFaceFront?gl.cullFace(gl.FRONT):gl.cullFace(gl.FRONT_AND_BACK))):disable(gl.CULL_FACE),currentCullFace=cullFace}function setLineWidth(width){width!==currentLineWidth&&(lineWidthAvailable&&gl.lineWidth(width),currentLineWidth=width)}function setPolygonOffset(polygonOffset,factor,units){polygonOffset?(enable(gl.POLYGON_OFFSET_FILL),(currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units)&&(gl.polygonOffset(factor,units),currentPolygonOffsetFactor=factor,currentPolygonOffsetUnits=units)):disable(gl.POLYGON_OFFSET_FILL)}function setScissorTest(scissorTest){scissorTest?enable(gl.SCISSOR_TEST):disable(gl.SCISSOR_TEST)}function activeTexture(webglSlot){webglSlot===void 0&&(webglSlot=gl.TEXTURE0+maxTextures-1),currentTextureSlot!==webglSlot&&(gl.activeTexture(webglSlot),currentTextureSlot=webglSlot)}function bindTexture(webglType,webglTexture,webglSlot){webglSlot===void 0&&(currentTextureSlot===null?webglSlot=gl.TEXTURE0+maxTextures-1:webglSlot=currentTextureSlot);let boundTexture=currentBoundTextures[webglSlot];boundTexture===void 0&&(boundTexture={type:void 0,texture:void 0},currentBoundTextures[webglSlot]=boundTexture),(boundTexture.type!==webglType||boundTexture.texture!==webglTexture)&&(currentTextureSlot!==webglSlot&&(gl.activeTexture(webglSlot),currentTextureSlot=webglSlot),gl.bindTexture(webglType,webglTexture||emptyTextures[webglType]),boundTexture.type=webglType,boundTexture.texture=webglTexture)}function unbindTexture(){const boundTexture=currentBoundTextures[currentTextureSlot];boundTexture!==void 0&&boundTexture.type!==void 0&&(gl.bindTexture(boundTexture.type,null),boundTexture.type=void 0,boundTexture.texture=void 0)}function compressedTexImage2D(){try{gl.compressedTexImage2D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}}function compressedTexImage3D(){try{gl.compressedTexImage3D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}}function texSubImage2D(){try{gl.texSubImage2D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}}function texSubImage3D(){try{gl.texSubImage3D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}}function compressedTexSubImage2D(){try{gl.compressedTexSubImage2D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}}function compressedTexSubImage3D(){try{gl.compressedTexSubImage3D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}}function texStorage2D(){try{gl.texStorage2D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}}function texStorage3D(){try{gl.texStorage3D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}}function texImage2D(){try{gl.texImage2D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}}function texImage3D(){try{gl.texImage3D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}}function scissor(scissor2){currentScissor.equals(scissor2)===!1&&(gl.scissor(scissor2.x,scissor2.y,scissor2.z,scissor2.w),currentScissor.copy(scissor2))}function viewport(viewport2){currentViewport.equals(viewport2)===!1&&(gl.viewport(viewport2.x,viewport2.y,viewport2.z,viewport2.w),currentViewport.copy(viewport2))}function updateUBOMapping(uniformsGroup,program){let mapping=uboProgramMap.get(program);mapping===void 0&&(mapping=new WeakMap,uboProgramMap.set(program,mapping));let blockIndex=mapping.get(uniformsGroup);blockIndex===void 0&&(blockIndex=gl.getUniformBlockIndex(program,uniformsGroup.name),mapping.set(uniformsGroup,blockIndex))}function uniformBlockBinding(uniformsGroup,program){const blockIndex=uboProgramMap.get(program).get(uniformsGroup);uboBindings.get(program)!==blockIndex&&(gl.uniformBlockBinding(program,blockIndex,uniformsGroup.__bindingPointIndex),uboBindings.set(program,blockIndex))}function reset(){gl.disable(gl.BLEND),gl.disable(gl.CULL_FACE),gl.disable(gl.DEPTH_TEST),gl.disable(gl.POLYGON_OFFSET_FILL),gl.disable(gl.SCISSOR_TEST),gl.disable(gl.STENCIL_TEST),gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE),gl.blendEquation(gl.FUNC_ADD),gl.blendFunc(gl.ONE,gl.ZERO),gl.blendFuncSeparate(gl.ONE,gl.ZERO,gl.ONE,gl.ZERO),gl.blendColor(0,0,0,0),gl.colorMask(!0,!0,!0,!0),gl.clearColor(0,0,0,0),gl.depthMask(!0),gl.depthFunc(gl.LESS),gl.clearDepth(1),gl.stencilMask(4294967295),gl.stencilFunc(gl.ALWAYS,0,4294967295),gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP),gl.clearStencil(0),gl.cullFace(gl.BACK),gl.frontFace(gl.CCW),gl.polygonOffset(0,0),gl.activeTexture(gl.TEXTURE0),gl.bindFramebuffer(gl.FRAMEBUFFER,null),isWebGL2===!0&&(gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER,null),gl.bindFramebuffer(gl.READ_FRAMEBUFFER,null)),gl.useProgram(null),gl.lineWidth(1),gl.scissor(0,0,gl.canvas.width,gl.canvas.height),gl.viewport(0,0,gl.canvas.width,gl.canvas.height),enabledCapabilities={},currentTextureSlot=null,currentBoundTextures={},currentBoundFramebuffers={},currentDrawbuffers=new WeakMap,defaultDrawbuffers=[],currentProgram=null,currentBlendingEnabled=!1,currentBlending=null,currentBlendEquation=null,currentBlendSrc=null,currentBlendDst=null,currentBlendEquationAlpha=null,currentBlendSrcAlpha=null,currentBlendDstAlpha=null,currentBlendColor=new Color(0,0,0),currentBlendAlpha=0,currentPremultipledAlpha=!1,currentFlipSided=null,currentCullFace=null,currentLineWidth=null,currentPolygonOffsetFactor=null,currentPolygonOffsetUnits=null,currentScissor.set(0,0,gl.canvas.width,gl.canvas.height),currentViewport.set(0,0,gl.canvas.width,gl.canvas.height),colorBuffer.reset(),depthBuffer.reset(),stencilBuffer.reset()}return{buffers:{color:colorBuffer,depth:depthBuffer,stencil:stencilBuffer},enable,disable,bindFramebuffer,drawBuffers,useProgram,setBlending,setMaterial,setFlipSided,setCullFace,setLineWidth,setPolygonOffset,setScissorTest,activeTexture,bindTexture,unbindTexture,compressedTexImage2D,compressedTexImage3D,texImage2D,texImage3D,updateUBOMapping,uniformBlockBinding,texStorage2D,texStorage3D,texSubImage2D,texSubImage3D,compressedTexSubImage2D,compressedTexSubImage3D,scissor,viewport,reset}}function WebGLTextures(_gl,extensions2,state,properties,capabilities,utils,info){const isWebGL2=capabilities.isWebGL2,maxTextures=capabilities.maxTextures,maxCubemapSize=capabilities.maxCubemapSize,maxTextureSize=capabilities.maxTextureSize,maxSamples=capabilities.maxSamples,multisampledRTTExt=extensions2.has("WEBGL_multisampled_render_to_texture")?extensions2.get("WEBGL_multisampled_render_to_texture"):null,supportsInvalidateFramebuffer=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),_videoTextures=new WeakMap;let _canvas2;const _sources=new WeakMap;let useOffscreenCanvas=!1;try{useOffscreenCanvas=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function createCanvas(width,height){return useOffscreenCanvas?new OffscreenCanvas(width,height):createElementNS("canvas")}function resizeImage(image,needsPowerOfTwo,needsNewCanvas,maxSize){let scale2=1;if((image.width>maxSize||image.height>maxSize)&&(scale2=maxSize/Math.max(image.width,image.height)),scale2<1||needsPowerOfTwo===!0)if(typeof HTMLImageElement<"u"&&image instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&image instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&image instanceof ImageBitmap){const floor=needsPowerOfTwo?floorPowerOfTwo:Math.floor,width=floor(scale2*image.width),height=floor(scale2*image.height);_canvas2===void 0&&(_canvas2=createCanvas(width,height));const canvas=needsNewCanvas?createCanvas(width,height):_canvas2;return canvas.width=width,canvas.height=height,canvas.getContext("2d").drawImage(image,0,0,width,height),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+image.width+"x"+image.height+") to ("+width+"x"+height+")."),canvas}else return"data"in image&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+image.width+"x"+image.height+")."),image;return image}function isPowerOfTwo$1(image){return isPowerOfTwo(image.width)&&isPowerOfTwo(image.height)}function textureNeedsPowerOfTwo(texture){return isWebGL2?!1:texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping||texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter}function textureNeedsGenerateMipmaps(texture,supportsMips){return texture.generateMipmaps&&supportsMips&&texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter}function generateMipmap(target){_gl.generateMipmap(target)}function getInternalFormat(internalFormatName,glFormat,glType,colorSpace,forceLinearTransfer=!1){if(isWebGL2===!1)return glFormat;if(internalFormatName!==null){if(_gl[internalFormatName]!==void 0)return _gl[internalFormatName];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+internalFormatName+"'")}let internalFormat=glFormat;if(glFormat===_gl.RED&&(glType===_gl.FLOAT&&(internalFormat=_gl.R32F),glType===_gl.HALF_FLOAT&&(internalFormat=_gl.R16F),glType===_gl.UNSIGNED_BYTE&&(internalFormat=_gl.R8)),glFormat===_gl.RED_INTEGER&&(glType===_gl.UNSIGNED_BYTE&&(internalFormat=_gl.R8UI),glType===_gl.UNSIGNED_SHORT&&(internalFormat=_gl.R16UI),glType===_gl.UNSIGNED_INT&&(internalFormat=_gl.R32UI),glType===_gl.BYTE&&(internalFormat=_gl.R8I),glType===_gl.SHORT&&(internalFormat=_gl.R16I),glType===_gl.INT&&(internalFormat=_gl.R32I)),glFormat===_gl.RG&&(glType===_gl.FLOAT&&(internalFormat=_gl.RG32F),glType===_gl.HALF_FLOAT&&(internalFormat=_gl.RG16F),glType===_gl.UNSIGNED_BYTE&&(internalFormat=_gl.RG8)),glFormat===_gl.RGBA){const transfer=forceLinearTransfer?LinearTransfer:ColorManagement.getTransfer(colorSpace);glType===_gl.FLOAT&&(internalFormat=_gl.RGBA32F),glType===_gl.HALF_FLOAT&&(internalFormat=_gl.RGBA16F),glType===_gl.UNSIGNED_BYTE&&(internalFormat=transfer===SRGBTransfer?_gl.SRGB8_ALPHA8:_gl.RGBA8),glType===_gl.UNSIGNED_SHORT_4_4_4_4&&(internalFormat=_gl.RGBA4),glType===_gl.UNSIGNED_SHORT_5_5_5_1&&(internalFormat=_gl.RGB5_A1)}return(internalFormat===_gl.R16F||internalFormat===_gl.R32F||internalFormat===_gl.RG16F||internalFormat===_gl.RG32F||internalFormat===_gl.RGBA16F||internalFormat===_gl.RGBA32F)&&extensions2.get("EXT_color_buffer_float"),internalFormat}function getMipLevels(texture,image,supportsMips){return textureNeedsGenerateMipmaps(texture,supportsMips)===!0||texture.isFramebufferTexture&&texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter?Math.log2(Math.max(image.width,image.height))+1:texture.mipmaps!==void 0&&texture.mipmaps.length>0?texture.mipmaps.length:texture.isCompressedTexture&&Array.isArray(texture.image)?image.mipmaps.length:1}function filterFallback(f2){return f2===NearestFilter||f2===NearestMipmapNearestFilter||f2===NearestMipmapLinearFilter?_gl.NEAREST:_gl.LINEAR}function onTextureDispose(event){const texture=event.target;texture.removeEventListener("dispose",onTextureDispose),deallocateTexture(texture),texture.isVideoTexture&&_videoTextures.delete(texture)}function onRenderTargetDispose(event){const renderTarget=event.target;renderTarget.removeEventListener("dispose",onRenderTargetDispose),deallocateRenderTarget(renderTarget)}function deallocateTexture(texture){const textureProperties=properties.get(texture);if(textureProperties.__webglInit===void 0)return;const source=texture.source,webglTextures=_sources.get(source);if(webglTextures){const webglTexture=webglTextures[textureProperties.__cacheKey];webglTexture.usedTimes--,webglTexture.usedTimes===0&&deleteTexture(texture),Object.keys(webglTextures).length===0&&_sources.delete(source)}properties.remove(texture)}function deleteTexture(texture){const textureProperties=properties.get(texture);_gl.deleteTexture(textureProperties.__webglTexture);const source=texture.source,webglTextures=_sources.get(source);delete webglTextures[textureProperties.__cacheKey],info.memory.textures--}function deallocateRenderTarget(renderTarget){const texture=renderTarget.texture,renderTargetProperties=properties.get(renderTarget),textureProperties=properties.get(texture);if(textureProperties.__webglTexture!==void 0&&(_gl.deleteTexture(textureProperties.__webglTexture),info.memory.textures--),renderTarget.depthTexture&&renderTarget.depthTexture.dispose(),renderTarget.isWebGLCubeRenderTarget)for(let i2=0;i2<6;i2++){if(Array.isArray(renderTargetProperties.__webglFramebuffer[i2]))for(let level=0;level<renderTargetProperties.__webglFramebuffer[i2].length;level++)_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2][level]);else _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);renderTargetProperties.__webglDepthbuffer&&_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2])}else{if(Array.isArray(renderTargetProperties.__webglFramebuffer))for(let level=0;level<renderTargetProperties.__webglFramebuffer.length;level++)_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);else _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);if(renderTargetProperties.__webglDepthbuffer&&_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer),renderTargetProperties.__webglMultisampledFramebuffer&&_gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer),renderTargetProperties.__webglColorRenderbuffer)for(let i2=0;i2<renderTargetProperties.__webglColorRenderbuffer.length;i2++)renderTargetProperties.__webglColorRenderbuffer[i2]&&_gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i2]);renderTargetProperties.__webglDepthRenderbuffer&&_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer)}if(renderTarget.isWebGLMultipleRenderTargets)for(let i2=0,il=texture.length;i2<il;i2++){const attachmentProperties=properties.get(texture[i2]);attachmentProperties.__webglTexture&&(_gl.deleteTexture(attachmentProperties.__webglTexture),info.memory.textures--),properties.remove(texture[i2])}properties.remove(texture),properties.remove(renderTarget)}let textureUnits=0;function resetTextureUnits(){textureUnits=0}function allocateTextureUnit(){const textureUnit=textureUnits;return textureUnit>=maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+textureUnit+" texture units while this GPU supports only "+maxTextures),textureUnits+=1,textureUnit}function getTextureCacheKey(texture){const array=[];return array.push(texture.wrapS),array.push(texture.wrapT),array.push(texture.wrapR||0),array.push(texture.magFilter),array.push(texture.minFilter),array.push(texture.anisotropy),array.push(texture.internalFormat),array.push(texture.format),array.push(texture.type),array.push(texture.generateMipmaps),array.push(texture.premultiplyAlpha),array.push(texture.flipY),array.push(texture.unpackAlignment),array.push(texture.colorSpace),array.join()}function setTexture2D(texture,slot){const textureProperties=properties.get(texture);if(texture.isVideoTexture&&updateVideoTexture(texture),texture.isRenderTargetTexture===!1&&texture.version>0&&textureProperties.__version!==texture.version){const image=texture.image;if(image===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(image.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{uploadTexture(textureProperties,texture,slot);return}}state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture,_gl.TEXTURE0+slot)}function setTexture2DArray(texture,slot){const textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return}state.bindTexture(_gl.TEXTURE_2D_ARRAY,textureProperties.__webglTexture,_gl.TEXTURE0+slot)}function setTexture3D(texture,slot){const textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return}state.bindTexture(_gl.TEXTURE_3D,textureProperties.__webglTexture,_gl.TEXTURE0+slot)}function setTextureCube(texture,slot){const textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadCubeTexture(textureProperties,texture,slot);return}state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture,_gl.TEXTURE0+slot)}const wrappingToGL={[RepeatWrapping]:_gl.REPEAT,[ClampToEdgeWrapping]:_gl.CLAMP_TO_EDGE,[MirroredRepeatWrapping]:_gl.MIRRORED_REPEAT},filterToGL={[NearestFilter]:_gl.NEAREST,[NearestMipmapNearestFilter]:_gl.NEAREST_MIPMAP_NEAREST,[NearestMipmapLinearFilter]:_gl.NEAREST_MIPMAP_LINEAR,[LinearFilter]:_gl.LINEAR,[LinearMipmapNearestFilter]:_gl.LINEAR_MIPMAP_NEAREST,[LinearMipmapLinearFilter]:_gl.LINEAR_MIPMAP_LINEAR},compareToGL={[NeverCompare]:_gl.NEVER,[AlwaysCompare]:_gl.ALWAYS,[LessCompare]:_gl.LESS,[LessEqualCompare]:_gl.LEQUAL,[EqualCompare]:_gl.EQUAL,[GreaterEqualCompare]:_gl.GEQUAL,[GreaterCompare]:_gl.GREATER,[NotEqualCompare]:_gl.NOTEQUAL};function setTextureParameters(textureType,texture,supportsMips){if(supportsMips?(_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,wrappingToGL[texture.wrapS]),_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,wrappingToGL[texture.wrapT]),(textureType===_gl.TEXTURE_3D||textureType===_gl.TEXTURE_2D_ARRAY)&&_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_R,wrappingToGL[texture.wrapR]),_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,filterToGL[texture.magFilter]),_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,filterToGL[texture.minFilter])):(_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,_gl.CLAMP_TO_EDGE),_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,_gl.CLAMP_TO_EDGE),(textureType===_gl.TEXTURE_3D||textureType===_gl.TEXTURE_2D_ARRAY)&&_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_R,_gl.CLAMP_TO_EDGE),(texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,filterFallback(texture.magFilter)),_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,filterFallback(texture.minFilter)),texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),texture.compareFunction&&(_gl.texParameteri(textureType,_gl.TEXTURE_COMPARE_MODE,_gl.COMPARE_REF_TO_TEXTURE),_gl.texParameteri(textureType,_gl.TEXTURE_COMPARE_FUNC,compareToGL[texture.compareFunction])),extensions2.has("EXT_texture_filter_anisotropic")===!0){const extension=extensions2.get("EXT_texture_filter_anisotropic");if(texture.magFilter===NearestFilter||texture.minFilter!==NearestMipmapLinearFilter&&texture.minFilter!==LinearMipmapLinearFilter||texture.type===FloatType&&extensions2.has("OES_texture_float_linear")===!1||isWebGL2===!1&&texture.type===HalfFloatType&&extensions2.has("OES_texture_half_float_linear")===!1)return;(texture.anisotropy>1||properties.get(texture).__currentAnisotropy)&&(_gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy())),properties.get(texture).__currentAnisotropy=texture.anisotropy)}}function initTexture(textureProperties,texture){let forceUpload=!1;textureProperties.__webglInit===void 0&&(textureProperties.__webglInit=!0,texture.addEventListener("dispose",onTextureDispose));const source=texture.source;let webglTextures=_sources.get(source);webglTextures===void 0&&(webglTextures={},_sources.set(source,webglTextures));const textureCacheKey=getTextureCacheKey(texture);if(textureCacheKey!==textureProperties.__cacheKey){webglTextures[textureCacheKey]===void 0&&(webglTextures[textureCacheKey]={texture:_gl.createTexture(),usedTimes:0},info.memory.textures++,forceUpload=!0),webglTextures[textureCacheKey].usedTimes++;const webglTexture=webglTextures[textureProperties.__cacheKey];webglTexture!==void 0&&(webglTextures[textureProperties.__cacheKey].usedTimes--,webglTexture.usedTimes===0&&deleteTexture(texture)),textureProperties.__cacheKey=textureCacheKey,textureProperties.__webglTexture=webglTextures[textureCacheKey].texture}return forceUpload}function uploadTexture(textureProperties,texture,slot){let textureType=_gl.TEXTURE_2D;(texture.isDataArrayTexture||texture.isCompressedArrayTexture)&&(textureType=_gl.TEXTURE_2D_ARRAY),texture.isData3DTexture&&(textureType=_gl.TEXTURE_3D);const forceUpload=initTexture(textureProperties,texture),source=texture.source;state.bindTexture(textureType,textureProperties.__webglTexture,_gl.TEXTURE0+slot);const sourceProperties=properties.get(source);if(source.version!==sourceProperties.__version||forceUpload===!0){state.activeTexture(_gl.TEXTURE0+slot);const workingPrimaries=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),texturePrimaries=texture.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(texture.colorSpace),unpackConversion=texture.colorSpace===NoColorSpace||workingPrimaries===texturePrimaries?_gl.NONE:_gl.BROWSER_DEFAULT_WEBGL;_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY),_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.premultiplyAlpha),_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,texture.unpackAlignment),_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,unpackConversion);const needsPowerOfTwo=textureNeedsPowerOfTwo(texture)&&isPowerOfTwo$1(texture.image)===!1;let image=resizeImage(texture.image,needsPowerOfTwo,!1,maxTextureSize);image=verifyColorSpace(texture,image);const supportsMips=isPowerOfTwo$1(image)||isWebGL2,glFormat=utils.convert(texture.format,texture.colorSpace);let glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.colorSpace,texture.isVideoTexture);setTextureParameters(textureType,texture,supportsMips);let mipmap;const mipmaps=texture.mipmaps,useTexStorage=isWebGL2&&texture.isVideoTexture!==!0,allocateMemory=sourceProperties.__version===void 0||forceUpload===!0,levels=getMipLevels(texture,image,supportsMips);if(texture.isDepthTexture)glInternalFormat=_gl.DEPTH_COMPONENT,isWebGL2?texture.type===FloatType?glInternalFormat=_gl.DEPTH_COMPONENT32F:texture.type===UnsignedIntType?glInternalFormat=_gl.DEPTH_COMPONENT24:texture.type===UnsignedInt248Type?glInternalFormat=_gl.DEPTH24_STENCIL8:glInternalFormat=_gl.DEPTH_COMPONENT16:texture.type===FloatType&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),texture.format===DepthFormat&&glInternalFormat===_gl.DEPTH_COMPONENT&&texture.type!==UnsignedShortType&&texture.type!==UnsignedIntType&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),texture.type=UnsignedIntType,glType=utils.convert(texture.type)),texture.format===DepthStencilFormat&&glInternalFormat===_gl.DEPTH_COMPONENT&&(glInternalFormat=_gl.DEPTH_STENCIL,texture.type!==UnsignedInt248Type&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),texture.type=UnsignedInt248Type,glType=utils.convert(texture.type))),allocateMemory&&(useTexStorage?state.texStorage2D(_gl.TEXTURE_2D,1,glInternalFormat,image.width,image.height):state.texImage2D(_gl.TEXTURE_2D,0,glInternalFormat,image.width,image.height,0,glFormat,glType,null));else if(texture.isDataTexture)if(mipmaps.length>0&&supportsMips){useTexStorage&&allocateMemory&&state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,mipmaps[0].width,mipmaps[0].height);for(let i2=0,il=mipmaps.length;i2<il;i2++)mipmap=mipmaps[i2],useTexStorage?state.texSubImage2D(_gl.TEXTURE_2D,i2,0,0,mipmap.width,mipmap.height,glFormat,glType,mipmap.data):state.texImage2D(_gl.TEXTURE_2D,i2,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);texture.generateMipmaps=!1}else useTexStorage?(allocateMemory&&state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,image.width,image.height),state.texSubImage2D(_gl.TEXTURE_2D,0,0,0,image.width,image.height,glFormat,glType,image.data)):state.texImage2D(_gl.TEXTURE_2D,0,glInternalFormat,image.width,image.height,0,glFormat,glType,image.data);else if(texture.isCompressedTexture)if(texture.isCompressedArrayTexture){useTexStorage&&allocateMemory&&state.texStorage3D(_gl.TEXTURE_2D_ARRAY,levels,glInternalFormat,mipmaps[0].width,mipmaps[0].height,image.depth);for(let i2=0,il=mipmaps.length;i2<il;i2++)mipmap=mipmaps[i2],texture.format!==RGBAFormat?glFormat!==null?useTexStorage?state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY,i2,0,0,0,mipmap.width,mipmap.height,image.depth,glFormat,mipmap.data,0,0):state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY,i2,glInternalFormat,mipmap.width,mipmap.height,image.depth,0,mipmap.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):useTexStorage?state.texSubImage3D(_gl.TEXTURE_2D_ARRAY,i2,0,0,0,mipmap.width,mipmap.height,image.depth,glFormat,glType,mipmap.data):state.texImage3D(_gl.TEXTURE_2D_ARRAY,i2,glInternalFormat,mipmap.width,mipmap.height,image.depth,0,glFormat,glType,mipmap.data)}else{useTexStorage&&allocateMemory&&state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,mipmaps[0].width,mipmaps[0].height);for(let i2=0,il=mipmaps.length;i2<il;i2++)mipmap=mipmaps[i2],texture.format!==RGBAFormat?glFormat!==null?useTexStorage?state.compressedTexSubImage2D(_gl.TEXTURE_2D,i2,0,0,mipmap.width,mipmap.height,glFormat,mipmap.data):state.compressedTexImage2D(_gl.TEXTURE_2D,i2,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):useTexStorage?state.texSubImage2D(_gl.TEXTURE_2D,i2,0,0,mipmap.width,mipmap.height,glFormat,glType,mipmap.data):state.texImage2D(_gl.TEXTURE_2D,i2,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data)}else if(texture.isDataArrayTexture)useTexStorage?(allocateMemory&&state.texStorage3D(_gl.TEXTURE_2D_ARRAY,levels,glInternalFormat,image.width,image.height,image.depth),state.texSubImage3D(_gl.TEXTURE_2D_ARRAY,0,0,0,0,image.width,image.height,image.depth,glFormat,glType,image.data)):state.texImage3D(_gl.TEXTURE_2D_ARRAY,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);else if(texture.isData3DTexture)useTexStorage?(allocateMemory&&state.texStorage3D(_gl.TEXTURE_3D,levels,glInternalFormat,image.width,image.height,image.depth),state.texSubImage3D(_gl.TEXTURE_3D,0,0,0,0,image.width,image.height,image.depth,glFormat,glType,image.data)):state.texImage3D(_gl.TEXTURE_3D,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);else if(texture.isFramebufferTexture){if(allocateMemory)if(useTexStorage)state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,image.width,image.height);else{let width=image.width,height=image.height;for(let i2=0;i2<levels;i2++)state.texImage2D(_gl.TEXTURE_2D,i2,glInternalFormat,width,height,0,glFormat,glType,null),width>>=1,height>>=1}}else if(mipmaps.length>0&&supportsMips){useTexStorage&&allocateMemory&&state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,mipmaps[0].width,mipmaps[0].height);for(let i2=0,il=mipmaps.length;i2<il;i2++)mipmap=mipmaps[i2],useTexStorage?state.texSubImage2D(_gl.TEXTURE_2D,i2,0,0,glFormat,glType,mipmap):state.texImage2D(_gl.TEXTURE_2D,i2,glInternalFormat,glFormat,glType,mipmap);texture.generateMipmaps=!1}else useTexStorage?(allocateMemory&&state.texStorage2D(_gl.TEXTURE_2D,levels,glInternalFormat,image.width,image.height),state.texSubImage2D(_gl.TEXTURE_2D,0,0,0,glFormat,glType,image)):state.texImage2D(_gl.TEXTURE_2D,0,glInternalFormat,glFormat,glType,image);textureNeedsGenerateMipmaps(texture,supportsMips)&&generateMipmap(textureType),sourceProperties.__version=source.version,texture.onUpdate&&texture.onUpdate(texture)}textureProperties.__version=texture.version}function uploadCubeTexture(textureProperties,texture,slot){if(texture.image.length!==6)return;const forceUpload=initTexture(textureProperties,texture),source=texture.source;state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture,_gl.TEXTURE0+slot);const sourceProperties=properties.get(source);if(source.version!==sourceProperties.__version||forceUpload===!0){state.activeTexture(_gl.TEXTURE0+slot);const workingPrimaries=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),texturePrimaries=texture.colorSpace===NoColorSpace?null:ColorManagement.getPrimaries(texture.colorSpace),unpackConversion=texture.colorSpace===NoColorSpace||workingPrimaries===texturePrimaries?_gl.NONE:_gl.BROWSER_DEFAULT_WEBGL;_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY),_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.premultiplyAlpha),_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,texture.unpackAlignment),_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,unpackConversion);const isCompressed=texture.isCompressedTexture||texture.image[0].isCompressedTexture,isDataTexture=texture.image[0]&&texture.image[0].isDataTexture,cubeImage=[];for(let i2=0;i2<6;i2++)!isCompressed&&!isDataTexture?cubeImage[i2]=resizeImage(texture.image[i2],!1,!0,maxCubemapSize):cubeImage[i2]=isDataTexture?texture.image[i2].image:texture.image[i2],cubeImage[i2]=verifyColorSpace(texture,cubeImage[i2]);const image=cubeImage[0],supportsMips=isPowerOfTwo$1(image)||isWebGL2,glFormat=utils.convert(texture.format,texture.colorSpace),glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.colorSpace),useTexStorage=isWebGL2&&texture.isVideoTexture!==!0,allocateMemory=sourceProperties.__version===void 0||forceUpload===!0;let levels=getMipLevels(texture,image,supportsMips);setTextureParameters(_gl.TEXTURE_CUBE_MAP,texture,supportsMips);let mipmaps;if(isCompressed){useTexStorage&&allocateMemory&&state.texStorage2D(_gl.TEXTURE_CUBE_MAP,levels,glInternalFormat,image.width,image.height);for(let i2=0;i2<6;i2++){mipmaps=cubeImage[i2].mipmaps;for(let j2=0;j2<mipmaps.length;j2++){const mipmap=mipmaps[j2];texture.format!==RGBAFormat?glFormat!==null?useTexStorage?state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i2,j2,0,0,mipmap.width,mipmap.height,glFormat,mipmap.data):state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i2,j2,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):useTexStorage?state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i2,j2,0,0,mipmap.width,mipmap.height,glFormat,glType,mipmap.data):state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i2,j2,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data)}}}else{mipmaps=texture.mipmaps,useTexStorage&&allocateMemory&&(mipmaps.length>0&&levels++,state.texStorage2D(_gl.TEXTURE_CUBE_MAP,levels,glInternalFormat,cubeImage[0].width,cubeImage[0].height));for(let i2=0;i2<6;i2++)if(isDataTexture){useTexStorage?state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i2,0,0,0,cubeImage[i2].width,cubeImage[i2].height,glFormat,glType,cubeImage[i2].data):state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i2,0,glInternalFormat,cubeImage[i2].width,cubeImage[i2].height,0,glFormat,glType,cubeImage[i2].data);for(let j2=0;j2<mipmaps.length;j2++){const mipmapImage=mipmaps[j2].image[i2].image;useTexStorage?state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i2,j2+1,0,0,mipmapImage.width,mipmapImage.height,glFormat,glType,mipmapImage.data):state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i2,j2+1,glInternalFormat,mipmapImage.width,mipmapImage.height,0,glFormat,glType,mipmapImage.data)}}else{useTexStorage?state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i2,0,0,0,glFormat,glType,cubeImage[i2]):state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i2,0,glInternalFormat,glFormat,glType,cubeImage[i2]);for(let j2=0;j2<mipmaps.length;j2++){const mipmap=mipmaps[j2];useTexStorage?state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i2,j2+1,0,0,glFormat,glType,mipmap.image[i2]):state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i2,j2+1,glInternalFormat,glFormat,glType,mipmap.image[i2])}}}textureNeedsGenerateMipmaps(texture,supportsMips)&&generateMipmap(_gl.TEXTURE_CUBE_MAP),sourceProperties.__version=source.version,texture.onUpdate&&texture.onUpdate(texture)}textureProperties.__version=texture.version}function setupFrameBufferTexture(framebuffer,renderTarget,texture,attachment,textureTarget,level){const glFormat=utils.convert(texture.format,texture.colorSpace),glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.colorSpace);if(!properties.get(renderTarget).__hasExternalTextures){const width=Math.max(1,renderTarget.width>>level),height=Math.max(1,renderTarget.height>>level);textureTarget===_gl.TEXTURE_3D||textureTarget===_gl.TEXTURE_2D_ARRAY?state.texImage3D(textureTarget,level,glInternalFormat,width,height,renderTarget.depth,0,glFormat,glType,null):state.texImage2D(textureTarget,level,glInternalFormat,width,height,0,glFormat,glType,null)}state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer),useMultisampledRTT(renderTarget)?multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER,attachment,textureTarget,properties.get(texture).__webglTexture,0,getRenderTargetSamples(renderTarget)):(textureTarget===_gl.TEXTURE_2D||textureTarget>=_gl.TEXTURE_CUBE_MAP_POSITIVE_X&&textureTarget<=_gl.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&_gl.framebufferTexture2D(_gl.FRAMEBUFFER,attachment,textureTarget,properties.get(texture).__webglTexture,level),state.bindFramebuffer(_gl.FRAMEBUFFER,null)}function setupRenderBufferStorage(renderbuffer,renderTarget,isMultisample){if(_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderbuffer),renderTarget.depthBuffer&&!renderTarget.stencilBuffer){let glInternalFormat=isWebGL2===!0?_gl.DEPTH_COMPONENT24:_gl.DEPTH_COMPONENT16;if(isMultisample||useMultisampledRTT(renderTarget)){const depthTexture=renderTarget.depthTexture;depthTexture&&depthTexture.isDepthTexture&&(depthTexture.type===FloatType?glInternalFormat=_gl.DEPTH_COMPONENT32F:depthTexture.type===UnsignedIntType&&(glInternalFormat=_gl.DEPTH_COMPONENT24));const samples=getRenderTargetSamples(renderTarget);useMultisampledRTT(renderTarget)?multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER,samples,glInternalFormat,renderTarget.width,renderTarget.height):_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,samples,glInternalFormat,renderTarget.width,renderTarget.height)}else _gl.renderbufferStorage(_gl.RENDERBUFFER,glInternalFormat,renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer)}else if(renderTarget.depthBuffer&&renderTarget.stencilBuffer){const samples=getRenderTargetSamples(renderTarget);isMultisample&&useMultisampledRTT(renderTarget)===!1?_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,samples,_gl.DEPTH24_STENCIL8,renderTarget.width,renderTarget.height):useMultisampledRTT(renderTarget)?multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER,samples,_gl.DEPTH24_STENCIL8,renderTarget.width,renderTarget.height):_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.DEPTH_STENCIL,renderTarget.width,renderTarget.height),_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer)}else{const textures=renderTarget.isWebGLMultipleRenderTargets===!0?renderTarget.texture:[renderTarget.texture];for(let i2=0;i2<textures.length;i2++){const texture=textures[i2],glFormat=utils.convert(texture.format,texture.colorSpace),glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.colorSpace),samples=getRenderTargetSamples(renderTarget);isMultisample&&useMultisampledRTT(renderTarget)===!1?_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,samples,glInternalFormat,renderTarget.width,renderTarget.height):useMultisampledRTT(renderTarget)?multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER,samples,glInternalFormat,renderTarget.width,renderTarget.height):_gl.renderbufferStorage(_gl.RENDERBUFFER,glInternalFormat,renderTarget.width,renderTarget.height)}}_gl.bindRenderbuffer(_gl.RENDERBUFFER,null)}function setupDepthTexture(framebuffer,renderTarget){if(renderTarget&&renderTarget.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer),!(renderTarget.depthTexture&&renderTarget.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!properties.get(renderTarget.depthTexture).__webglTexture||renderTarget.depthTexture.image.width!==renderTarget.width||renderTarget.depthTexture.image.height!==renderTarget.height)&&(renderTarget.depthTexture.image.width=renderTarget.width,renderTarget.depthTexture.image.height=renderTarget.height,renderTarget.depthTexture.needsUpdate=!0),setTexture2D(renderTarget.depthTexture,0);const webglDepthTexture=properties.get(renderTarget.depthTexture).__webglTexture,samples=getRenderTargetSamples(renderTarget);if(renderTarget.depthTexture.format===DepthFormat)useMultisampledRTT(renderTarget)?multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0,samples):_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);else if(renderTarget.depthTexture.format===DepthStencilFormat)useMultisampledRTT(renderTarget)?multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0,samples):_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.TEXTURE_2D,webglDepthTexture,0);else throw new Error("Unknown depthTexture format")}function setupDepthRenderbuffer(renderTarget){const renderTargetProperties=properties.get(renderTarget),isCube=renderTarget.isWebGLCubeRenderTarget===!0;if(renderTarget.depthTexture&&!renderTargetProperties.__autoAllocateDepthBuffer){if(isCube)throw new Error("target.depthTexture not supported in Cube render targets");setupDepthTexture(renderTargetProperties.__webglFramebuffer,renderTarget)}else if(isCube){renderTargetProperties.__webglDepthbuffer=[];for(let i2=0;i2<6;i2++)state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer[i2]),renderTargetProperties.__webglDepthbuffer[i2]=_gl.createRenderbuffer(),setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2],renderTarget,!1)}else state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer),renderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer(),setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget,!1);state.bindFramebuffer(_gl.FRAMEBUFFER,null)}function rebindTextures(renderTarget,colorTexture,depthTexture){const renderTargetProperties=properties.get(renderTarget);colorTexture!==void 0&&setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,renderTarget.texture,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D,0),depthTexture!==void 0&&setupDepthRenderbuffer(renderTarget)}function setupRenderTarget(renderTarget){const texture=renderTarget.texture,renderTargetProperties=properties.get(renderTarget),textureProperties=properties.get(texture);renderTarget.addEventListener("dispose",onRenderTargetDispose),renderTarget.isWebGLMultipleRenderTargets!==!0&&(textureProperties.__webglTexture===void 0&&(textureProperties.__webglTexture=_gl.createTexture()),textureProperties.__version=texture.version,info.memory.textures++);const isCube=renderTarget.isWebGLCubeRenderTarget===!0,isMultipleRenderTargets=renderTarget.isWebGLMultipleRenderTargets===!0,supportsMips=isPowerOfTwo$1(renderTarget)||isWebGL2;if(isCube){renderTargetProperties.__webglFramebuffer=[];for(let i2=0;i2<6;i2++)if(isWebGL2&&texture.mipmaps&&texture.mipmaps.length>0){renderTargetProperties.__webglFramebuffer[i2]=[];for(let level=0;level<texture.mipmaps.length;level++)renderTargetProperties.__webglFramebuffer[i2][level]=_gl.createFramebuffer()}else renderTargetProperties.__webglFramebuffer[i2]=_gl.createFramebuffer()}else{if(isWebGL2&&texture.mipmaps&&texture.mipmaps.length>0){renderTargetProperties.__webglFramebuffer=[];for(let level=0;level<texture.mipmaps.length;level++)renderTargetProperties.__webglFramebuffer[level]=_gl.createFramebuffer()}else renderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();if(isMultipleRenderTargets)if(capabilities.drawBuffers){const textures=renderTarget.texture;for(let i2=0,il=textures.length;i2<il;i2++){const attachmentProperties=properties.get(textures[i2]);attachmentProperties.__webglTexture===void 0&&(attachmentProperties.__webglTexture=_gl.createTexture(),info.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(isWebGL2&&renderTarget.samples>0&&useMultisampledRTT(renderTarget)===!1){const textures=isMultipleRenderTargets?texture:[texture];renderTargetProperties.__webglMultisampledFramebuffer=_gl.createFramebuffer(),renderTargetProperties.__webglColorRenderbuffer=[],state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer);for(let i2=0;i2<textures.length;i2++){const texture2=textures[i2];renderTargetProperties.__webglColorRenderbuffer[i2]=_gl.createRenderbuffer(),_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[i2]);const glFormat=utils.convert(texture2.format,texture2.colorSpace),glType=utils.convert(texture2.type),glInternalFormat=getInternalFormat(texture2.internalFormat,glFormat,glType,texture2.colorSpace,renderTarget.isXRRenderTarget===!0),samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,samples,glInternalFormat,renderTarget.width,renderTarget.height),_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i2,_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[i2])}_gl.bindRenderbuffer(_gl.RENDERBUFFER,null),renderTarget.depthBuffer&&(renderTargetProperties.__webglDepthRenderbuffer=_gl.createRenderbuffer(),setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer,renderTarget,!0)),state.bindFramebuffer(_gl.FRAMEBUFFER,null)}}if(isCube){state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture),setTextureParameters(_gl.TEXTURE_CUBE_MAP,texture,supportsMips);for(let i2=0;i2<6;i2++)if(isWebGL2&&texture.mipmaps&&texture.mipmaps.length>0)for(let level=0;level<texture.mipmaps.length;level++)setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2][level],renderTarget,texture,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i2,level);else setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2],renderTarget,texture,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+i2,0);textureNeedsGenerateMipmaps(texture,supportsMips)&&generateMipmap(_gl.TEXTURE_CUBE_MAP),state.unbindTexture()}else if(isMultipleRenderTargets){const textures=renderTarget.texture;for(let i2=0,il=textures.length;i2<il;i2++){const attachment=textures[i2],attachmentProperties=properties.get(attachment);state.bindTexture(_gl.TEXTURE_2D,attachmentProperties.__webglTexture),setTextureParameters(_gl.TEXTURE_2D,attachment,supportsMips),setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,attachment,_gl.COLOR_ATTACHMENT0+i2,_gl.TEXTURE_2D,0),textureNeedsGenerateMipmaps(attachment,supportsMips)&&generateMipmap(_gl.TEXTURE_2D)}state.unbindTexture()}else{let glTextureType=_gl.TEXTURE_2D;if((renderTarget.isWebGL3DRenderTarget||renderTarget.isWebGLArrayRenderTarget)&&(isWebGL2?glTextureType=renderTarget.isWebGL3DRenderTarget?_gl.TEXTURE_3D:_gl.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),state.bindTexture(glTextureType,textureProperties.__webglTexture),setTextureParameters(glTextureType,texture,supportsMips),isWebGL2&&texture.mipmaps&&texture.mipmaps.length>0)for(let level=0;level<texture.mipmaps.length;level++)setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level],renderTarget,texture,_gl.COLOR_ATTACHMENT0,glTextureType,level);else setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,texture,_gl.COLOR_ATTACHMENT0,glTextureType,0);textureNeedsGenerateMipmaps(texture,supportsMips)&&generateMipmap(glTextureType),state.unbindTexture()}renderTarget.depthBuffer&&setupDepthRenderbuffer(renderTarget)}function updateRenderTargetMipmap(renderTarget){const supportsMips=isPowerOfTwo$1(renderTarget)||isWebGL2,textures=renderTarget.isWebGLMultipleRenderTargets===!0?renderTarget.texture:[renderTarget.texture];for(let i2=0,il=textures.length;i2<il;i2++){const texture=textures[i2];if(textureNeedsGenerateMipmaps(texture,supportsMips)){const target=renderTarget.isWebGLCubeRenderTarget?_gl.TEXTURE_CUBE_MAP:_gl.TEXTURE_2D,webglTexture=properties.get(texture).__webglTexture;state.bindTexture(target,webglTexture),generateMipmap(target),state.unbindTexture()}}}function updateMultisampleRenderTarget(renderTarget){if(isWebGL2&&renderTarget.samples>0&&useMultisampledRTT(renderTarget)===!1){const textures=renderTarget.isWebGLMultipleRenderTargets?renderTarget.texture:[renderTarget.texture],width=renderTarget.width,height=renderTarget.height;let mask=_gl.COLOR_BUFFER_BIT;const invalidationArray=[],depthStyle=renderTarget.stencilBuffer?_gl.DEPTH_STENCIL_ATTACHMENT:_gl.DEPTH_ATTACHMENT,renderTargetProperties=properties.get(renderTarget),isMultipleRenderTargets=renderTarget.isWebGLMultipleRenderTargets===!0;if(isMultipleRenderTargets)for(let i2=0;i2<textures.length;i2++)state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer),_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i2,_gl.RENDERBUFFER,null),state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer),_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i2,_gl.TEXTURE_2D,null,0);state.bindFramebuffer(_gl.READ_FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer),state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);for(let i2=0;i2<textures.length;i2++){invalidationArray.push(_gl.COLOR_ATTACHMENT0+i2),renderTarget.depthBuffer&&invalidationArray.push(depthStyle);const ignoreDepthValues=renderTargetProperties.__ignoreDepthValues!==void 0?renderTargetProperties.__ignoreDepthValues:!1;if(ignoreDepthValues===!1&&(renderTarget.depthBuffer&&(mask|=_gl.DEPTH_BUFFER_BIT),renderTarget.stencilBuffer&&(mask|=_gl.STENCIL_BUFFER_BIT)),isMultipleRenderTargets&&_gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[i2]),ignoreDepthValues===!0&&(_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER,[depthStyle]),_gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER,[depthStyle])),isMultipleRenderTargets){const webglTexture=properties.get(textures[i2]).__webglTexture;_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D,webglTexture,0)}_gl.blitFramebuffer(0,0,width,height,0,0,width,height,mask,_gl.NEAREST),supportsInvalidateFramebuffer&&_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER,invalidationArray)}if(state.bindFramebuffer(_gl.READ_FRAMEBUFFER,null),state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,null),isMultipleRenderTargets)for(let i2=0;i2<textures.length;i2++){state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer),_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i2,_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[i2]);const webglTexture=properties.get(textures[i2]).__webglTexture;state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer),_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i2,_gl.TEXTURE_2D,webglTexture,0)}state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer)}}function getRenderTargetSamples(renderTarget){return Math.min(maxSamples,renderTarget.samples)}function useMultisampledRTT(renderTarget){const renderTargetProperties=properties.get(renderTarget);return isWebGL2&&renderTarget.samples>0&&extensions2.has("WEBGL_multisampled_render_to_texture")===!0&&renderTargetProperties.__useRenderToTexture!==!1}function updateVideoTexture(texture){const frame2=info.render.frame;_videoTextures.get(texture)!==frame2&&(_videoTextures.set(texture,frame2),texture.update())}function verifyColorSpace(texture,image){const colorSpace=texture.colorSpace,format=texture.format,type=texture.type;return texture.isCompressedTexture===!0||texture.isVideoTexture===!0||texture.format===_SRGBAFormat||colorSpace!==LinearSRGBColorSpace&&colorSpace!==NoColorSpace&&(ColorManagement.getTransfer(colorSpace)===SRGBTransfer?isWebGL2===!1?extensions2.has("EXT_sRGB")===!0&&format===RGBAFormat?(texture.format=_SRGBAFormat,texture.minFilter=LinearFilter,texture.generateMipmaps=!1):image=ImageUtils.sRGBToLinear(image):(format!==RGBAFormat||type!==UnsignedByteType)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",colorSpace)),image}this.allocateTextureUnit=allocateTextureUnit,this.resetTextureUnits=resetTextureUnits,this.setTexture2D=setTexture2D,this.setTexture2DArray=setTexture2DArray,this.setTexture3D=setTexture3D,this.setTextureCube=setTextureCube,this.rebindTextures=rebindTextures,this.setupRenderTarget=setupRenderTarget,this.updateRenderTargetMipmap=updateRenderTargetMipmap,this.updateMultisampleRenderTarget=updateMultisampleRenderTarget,this.setupDepthRenderbuffer=setupDepthRenderbuffer,this.setupFrameBufferTexture=setupFrameBufferTexture,this.useMultisampledRTT=useMultisampledRTT}function WebGLUtils(gl,extensions2,capabilities){const isWebGL2=capabilities.isWebGL2;function convert(p2,colorSpace=NoColorSpace){let extension;const transfer=ColorManagement.getTransfer(colorSpace);if(p2===UnsignedByteType)return gl.UNSIGNED_BYTE;if(p2===UnsignedShort4444Type)return gl.UNSIGNED_SHORT_4_4_4_4;if(p2===UnsignedShort5551Type)return gl.UNSIGNED_SHORT_5_5_5_1;if(p2===ByteType)return gl.BYTE;if(p2===ShortType)return gl.SHORT;if(p2===UnsignedShortType)return gl.UNSIGNED_SHORT;if(p2===IntType)return gl.INT;if(p2===UnsignedIntType)return gl.UNSIGNED_INT;if(p2===FloatType)return gl.FLOAT;if(p2===HalfFloatType)return isWebGL2?gl.HALF_FLOAT:(extension=extensions2.get("OES_texture_half_float"),extension!==null?extension.HALF_FLOAT_OES:null);if(p2===AlphaFormat)return gl.ALPHA;if(p2===RGBAFormat)return gl.RGBA;if(p2===LuminanceFormat)return gl.LUMINANCE;if(p2===LuminanceAlphaFormat)return gl.LUMINANCE_ALPHA;if(p2===DepthFormat)return gl.DEPTH_COMPONENT;if(p2===DepthStencilFormat)return gl.DEPTH_STENCIL;if(p2===_SRGBAFormat)return extension=extensions2.get("EXT_sRGB"),extension!==null?extension.SRGB_ALPHA_EXT:null;if(p2===RedFormat)return gl.RED;if(p2===RedIntegerFormat)return gl.RED_INTEGER;if(p2===RGFormat)return gl.RG;if(p2===RGIntegerFormat)return gl.RG_INTEGER;if(p2===RGBAIntegerFormat)return gl.RGBA_INTEGER;if(p2===RGB_S3TC_DXT1_Format||p2===RGBA_S3TC_DXT1_Format||p2===RGBA_S3TC_DXT3_Format||p2===RGBA_S3TC_DXT5_Format)if(transfer===SRGBTransfer)if(extension=extensions2.get("WEBGL_compressed_texture_s3tc_srgb"),extension!==null){if(p2===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(p2===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(p2===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(p2===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(extension=extensions2.get("WEBGL_compressed_texture_s3tc"),extension!==null){if(p2===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(p2===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(p2===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(p2===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(p2===RGB_PVRTC_4BPPV1_Format||p2===RGB_PVRTC_2BPPV1_Format||p2===RGBA_PVRTC_4BPPV1_Format||p2===RGBA_PVRTC_2BPPV1_Format)if(extension=extensions2.get("WEBGL_compressed_texture_pvrtc"),extension!==null){if(p2===RGB_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(p2===RGB_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(p2===RGBA_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(p2===RGBA_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(p2===RGB_ETC1_Format)return extension=extensions2.get("WEBGL_compressed_texture_etc1"),extension!==null?extension.COMPRESSED_RGB_ETC1_WEBGL:null;if(p2===RGB_ETC2_Format||p2===RGBA_ETC2_EAC_Format)if(extension=extensions2.get("WEBGL_compressed_texture_etc"),extension!==null){if(p2===RGB_ETC2_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ETC2:extension.COMPRESSED_RGB8_ETC2;if(p2===RGBA_ETC2_EAC_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:extension.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(p2===RGBA_ASTC_4x4_Format||p2===RGBA_ASTC_5x4_Format||p2===RGBA_ASTC_5x5_Format||p2===RGBA_ASTC_6x5_Format||p2===RGBA_ASTC_6x6_Format||p2===RGBA_ASTC_8x5_Format||p2===RGBA_ASTC_8x6_Format||p2===RGBA_ASTC_8x8_Format||p2===RGBA_ASTC_10x5_Format||p2===RGBA_ASTC_10x6_Format||p2===RGBA_ASTC_10x8_Format||p2===RGBA_ASTC_10x10_Format||p2===RGBA_ASTC_12x10_Format||p2===RGBA_ASTC_12x12_Format)if(extension=extensions2.get("WEBGL_compressed_texture_astc"),extension!==null){if(p2===RGBA_ASTC_4x4_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:extension.COMPRESSED_RGBA_ASTC_4x4_KHR;if(p2===RGBA_ASTC_5x4_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:extension.COMPRESSED_RGBA_ASTC_5x4_KHR;if(p2===RGBA_ASTC_5x5_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:extension.COMPRESSED_RGBA_ASTC_5x5_KHR;if(p2===RGBA_ASTC_6x5_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:extension.COMPRESSED_RGBA_ASTC_6x5_KHR;if(p2===RGBA_ASTC_6x6_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:extension.COMPRESSED_RGBA_ASTC_6x6_KHR;if(p2===RGBA_ASTC_8x5_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:extension.COMPRESSED_RGBA_ASTC_8x5_KHR;if(p2===RGBA_ASTC_8x6_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:extension.COMPRESSED_RGBA_ASTC_8x6_KHR;if(p2===RGBA_ASTC_8x8_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:extension.COMPRESSED_RGBA_ASTC_8x8_KHR;if(p2===RGBA_ASTC_10x5_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:extension.COMPRESSED_RGBA_ASTC_10x5_KHR;if(p2===RGBA_ASTC_10x6_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:extension.COMPRESSED_RGBA_ASTC_10x6_KHR;if(p2===RGBA_ASTC_10x8_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:extension.COMPRESSED_RGBA_ASTC_10x8_KHR;if(p2===RGBA_ASTC_10x10_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:extension.COMPRESSED_RGBA_ASTC_10x10_KHR;if(p2===RGBA_ASTC_12x10_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:extension.COMPRESSED_RGBA_ASTC_12x10_KHR;if(p2===RGBA_ASTC_12x12_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:extension.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(p2===RGBA_BPTC_Format||p2===RGB_BPTC_SIGNED_Format||p2===RGB_BPTC_UNSIGNED_Format)if(extension=extensions2.get("EXT_texture_compression_bptc"),extension!==null){if(p2===RGBA_BPTC_Format)return transfer===SRGBTransfer?extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(p2===RGB_BPTC_SIGNED_Format)return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(p2===RGB_BPTC_UNSIGNED_Format)return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(p2===RED_RGTC1_Format||p2===SIGNED_RED_RGTC1_Format||p2===RED_GREEN_RGTC2_Format||p2===SIGNED_RED_GREEN_RGTC2_Format)if(extension=extensions2.get("EXT_texture_compression_rgtc"),extension!==null){if(p2===RGBA_BPTC_Format)return extension.COMPRESSED_RED_RGTC1_EXT;if(p2===SIGNED_RED_RGTC1_Format)return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(p2===RED_GREEN_RGTC2_Format)return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;if(p2===SIGNED_RED_GREEN_RGTC2_Format)return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return p2===UnsignedInt248Type?isWebGL2?gl.UNSIGNED_INT_24_8:(extension=extensions2.get("WEBGL_depth_texture"),extension!==null?extension.UNSIGNED_INT_24_8_WEBGL:null):gl[p2]!==void 0?gl[p2]:null}return{convert}}class ArrayCamera extends PerspectiveCamera$1{constructor(array=[]){super(),this.isArrayCamera=!0,this.cameras=array}}class Group extends Object3D{constructor(){super(),this.isGroup=!0,this.type="Group"}}const _moveEvent={type:"move"};class WebXRController{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Group,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Group,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Vector3,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Vector3),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Group,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Vector3,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Vector3),this._grip}dispatchEvent(event){return this._targetRay!==null&&this._targetRay.dispatchEvent(event),this._grip!==null&&this._grip.dispatchEvent(event),this._hand!==null&&this._hand.dispatchEvent(event),this}connect(inputSource){if(inputSource&&inputSource.hand){const hand=this._hand;if(hand)for(const inputjoint of inputSource.hand.values())this._getHandJoint(hand,inputjoint)}return this.dispatchEvent({type:"connected",data:inputSource}),this}disconnect(inputSource){return this.dispatchEvent({type:"disconnected",data:inputSource}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(inputSource,frame2,referenceSpace){let inputPose=null,gripPose=null,handPose=null;const targetRay=this._targetRay,grip=this._grip,hand=this._hand;if(inputSource&&frame2.session.visibilityState!=="visible-blurred"){if(hand&&inputSource.hand){handPose=!0;for(const inputjoint of inputSource.hand.values()){const jointPose=frame2.getJointPose(inputjoint,referenceSpace),joint=this._getHandJoint(hand,inputjoint);jointPose!==null&&(joint.matrix.fromArray(jointPose.transform.matrix),joint.matrix.decompose(joint.position,joint.rotation,joint.scale),joint.matrixWorldNeedsUpdate=!0,joint.jointRadius=jointPose.radius),joint.visible=jointPose!==null}const indexTip=hand.joints["index-finger-tip"],thumbTip=hand.joints["thumb-tip"],distance2=indexTip.position.distanceTo(thumbTip.position),distanceToPinch=.02,threshold=.005;hand.inputState.pinching&&distance2>distanceToPinch+threshold?(hand.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:inputSource.handedness,target:this})):!hand.inputState.pinching&&distance2<=distanceToPinch-threshold&&(hand.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:inputSource.handedness,target:this}))}else grip!==null&&inputSource.gripSpace&&(gripPose=frame2.getPose(inputSource.gripSpace,referenceSpace),gripPose!==null&&(grip.matrix.fromArray(gripPose.transform.matrix),grip.matrix.decompose(grip.position,grip.rotation,grip.scale),grip.matrixWorldNeedsUpdate=!0,gripPose.linearVelocity?(grip.hasLinearVelocity=!0,grip.linearVelocity.copy(gripPose.linearVelocity)):grip.hasLinearVelocity=!1,gripPose.angularVelocity?(grip.hasAngularVelocity=!0,grip.angularVelocity.copy(gripPose.angularVelocity)):grip.hasAngularVelocity=!1));targetRay!==null&&(inputPose=frame2.getPose(inputSource.targetRaySpace,referenceSpace),inputPose===null&&gripPose!==null&&(inputPose=gripPose),inputPose!==null&&(targetRay.matrix.fromArray(inputPose.transform.matrix),targetRay.matrix.decompose(targetRay.position,targetRay.rotation,targetRay.scale),targetRay.matrixWorldNeedsUpdate=!0,inputPose.linearVelocity?(targetRay.hasLinearVelocity=!0,targetRay.linearVelocity.copy(inputPose.linearVelocity)):targetRay.hasLinearVelocity=!1,inputPose.angularVelocity?(targetRay.hasAngularVelocity=!0,targetRay.angularVelocity.copy(inputPose.angularVelocity)):targetRay.hasAngularVelocity=!1,this.dispatchEvent(_moveEvent)))}return targetRay!==null&&(targetRay.visible=inputPose!==null),grip!==null&&(grip.visible=gripPose!==null),hand!==null&&(hand.visible=handPose!==null),this}_getHandJoint(hand,inputjoint){if(hand.joints[inputjoint.jointName]===void 0){const joint=new Group;joint.matrixAutoUpdate=!1,joint.visible=!1,hand.joints[inputjoint.jointName]=joint,hand.add(joint)}return hand.joints[inputjoint.jointName]}}class DepthTexture extends Texture{constructor(width,height,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,format){if(format=format!==void 0?format:DepthFormat,format!==DepthFormat&&format!==DepthStencilFormat)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");type===void 0&&format===DepthFormat&&(type=UnsignedIntType),type===void 0&&format===DepthStencilFormat&&(type=UnsignedInt248Type),super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy),this.isDepthTexture=!0,this.image={width,height},this.magFilter=magFilter!==void 0?magFilter:NearestFilter,this.minFilter=minFilter!==void 0?minFilter:NearestFilter,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(source){return super.copy(source),this.compareFunction=source.compareFunction,this}toJSON(meta){const data=super.toJSON(meta);return this.compareFunction!==null&&(data.compareFunction=this.compareFunction),data}}class WebXRManager extends EventDispatcher{constructor(renderer,gl){super();const scope=this;let session=null,framebufferScaleFactor=1,referenceSpace=null,referenceSpaceType="local-floor",foveation=1,customReferenceSpace=null,pose=null,glBinding=null,glProjLayer=null,glBaseLayer=null,xrFrame=null;const attributes=gl.getContextAttributes();let initialRenderTarget=null,newRenderTarget=null;const controllers=[],controllerInputSources=[],cameraL=new PerspectiveCamera$1;cameraL.layers.enable(1),cameraL.viewport=new Vector4;const cameraR=new PerspectiveCamera$1;cameraR.layers.enable(2),cameraR.viewport=new Vector4;const cameras=[cameraL,cameraR],cameraXR=new ArrayCamera;cameraXR.layers.enable(1),cameraXR.layers.enable(2);let _currentDepthNear=null,_currentDepthFar=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(index){let controller=controllers[index];return controller===void 0&&(controller=new WebXRController,controllers[index]=controller),controller.getTargetRaySpace()},this.getControllerGrip=function(index){let controller=controllers[index];return controller===void 0&&(controller=new WebXRController,controllers[index]=controller),controller.getGripSpace()},this.getHand=function(index){let controller=controllers[index];return controller===void 0&&(controller=new WebXRController,controllers[index]=controller),controller.getHandSpace()};function onSessionEvent(event){const controllerIndex=controllerInputSources.indexOf(event.inputSource);if(controllerIndex===-1)return;const controller=controllers[controllerIndex];controller!==void 0&&(controller.update(event.inputSource,event.frame,customReferenceSpace||referenceSpace),controller.dispatchEvent({type:event.type,data:event.inputSource}))}function onSessionEnd(){session.removeEventListener("select",onSessionEvent),session.removeEventListener("selectstart",onSessionEvent),session.removeEventListener("selectend",onSessionEvent),session.removeEventListener("squeeze",onSessionEvent),session.removeEventListener("squeezestart",onSessionEvent),session.removeEventListener("squeezeend",onSessionEvent),session.removeEventListener("end",onSessionEnd),session.removeEventListener("inputsourceschange",onInputSourcesChange);for(let i2=0;i2<controllers.length;i2++){const inputSource=controllerInputSources[i2];inputSource!==null&&(controllerInputSources[i2]=null,controllers[i2].disconnect(inputSource))}_currentDepthNear=null,_currentDepthFar=null,renderer.setRenderTarget(initialRenderTarget),glBaseLayer=null,glProjLayer=null,glBinding=null,session=null,newRenderTarget=null,animation.stop(),scope.isPresenting=!1,scope.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(value){framebufferScaleFactor=value,scope.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(value){referenceSpaceType=value,scope.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return customReferenceSpace||referenceSpace},this.setReferenceSpace=function(space){customReferenceSpace=space},this.getBaseLayer=function(){return glProjLayer!==null?glProjLayer:glBaseLayer},this.getBinding=function(){return glBinding},this.getFrame=function(){return xrFrame},this.getSession=function(){return session},this.setSession=async function(value){if(session=value,session!==null){if(initialRenderTarget=renderer.getRenderTarget(),session.addEventListener("select",onSessionEvent),session.addEventListener("selectstart",onSessionEvent),session.addEventListener("selectend",onSessionEvent),session.addEventListener("squeeze",onSessionEvent),session.addEventListener("squeezestart",onSessionEvent),session.addEventListener("squeezeend",onSessionEvent),session.addEventListener("end",onSessionEnd),session.addEventListener("inputsourceschange",onInputSourcesChange),attributes.xrCompatible!==!0&&await gl.makeXRCompatible(),session.renderState.layers===void 0||renderer.capabilities.isWebGL2===!1){const layerInit={antialias:session.renderState.layers===void 0?attributes.antialias:!0,alpha:!0,depth:attributes.depth,stencil:attributes.stencil,framebufferScaleFactor};glBaseLayer=new XRWebGLLayer(session,gl,layerInit),session.updateRenderState({baseLayer:glBaseLayer}),newRenderTarget=new WebGLRenderTarget(glBaseLayer.framebufferWidth,glBaseLayer.framebufferHeight,{format:RGBAFormat,type:UnsignedByteType,colorSpace:renderer.outputColorSpace,stencilBuffer:attributes.stencil})}else{let depthFormat=null,depthType=null,glDepthFormat=null;attributes.depth&&(glDepthFormat=attributes.stencil?gl.DEPTH24_STENCIL8:gl.DEPTH_COMPONENT24,depthFormat=attributes.stencil?DepthStencilFormat:DepthFormat,depthType=attributes.stencil?UnsignedInt248Type:UnsignedIntType);const projectionlayerInit={colorFormat:gl.RGBA8,depthFormat:glDepthFormat,scaleFactor:framebufferScaleFactor};glBinding=new XRWebGLBinding(session,gl),glProjLayer=glBinding.createProjectionLayer(projectionlayerInit),session.updateRenderState({layers:[glProjLayer]}),newRenderTarget=new WebGLRenderTarget(glProjLayer.textureWidth,glProjLayer.textureHeight,{format:RGBAFormat,type:UnsignedByteType,depthTexture:new DepthTexture(glProjLayer.textureWidth,glProjLayer.textureHeight,depthType,void 0,void 0,void 0,void 0,void 0,void 0,depthFormat),stencilBuffer:attributes.stencil,colorSpace:renderer.outputColorSpace,samples:attributes.antialias?4:0});const renderTargetProperties=renderer.properties.get(newRenderTarget);renderTargetProperties.__ignoreDepthValues=glProjLayer.ignoreDepthValues}newRenderTarget.isXRRenderTarget=!0,this.setFoveation(foveation),customReferenceSpace=null,referenceSpace=await session.requestReferenceSpace(referenceSpaceType),animation.setContext(session),animation.start(),scope.isPresenting=!0,scope.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(session!==null)return session.environmentBlendMode};function onInputSourcesChange(event){for(let i2=0;i2<event.removed.length;i2++){const inputSource=event.removed[i2],index=controllerInputSources.indexOf(inputSource);index>=0&&(controllerInputSources[index]=null,controllers[index].disconnect(inputSource))}for(let i2=0;i2<event.added.length;i2++){const inputSource=event.added[i2];let controllerIndex=controllerInputSources.indexOf(inputSource);if(controllerIndex===-1){for(let i3=0;i3<controllers.length;i3++)if(i3>=controllerInputSources.length){controllerInputSources.push(inputSource),controllerIndex=i3;break}else if(controllerInputSources[i3]===null){controllerInputSources[i3]=inputSource,controllerIndex=i3;break}if(controllerIndex===-1)break}const controller=controllers[controllerIndex];controller&&controller.connect(inputSource)}}const cameraLPos=new Vector3,cameraRPos=new Vector3;function setProjectionFromUnion(camera,cameraL2,cameraR2){cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld),cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);const ipd=cameraLPos.distanceTo(cameraRPos),projL=cameraL2.projectionMatrix.elements,projR=cameraR2.projectionMatrix.elements,near=projL[14]/(projL[10]-1),far=projL[14]/(projL[10]+1),topFov=(projL[9]+1)/projL[5],bottomFov=(projL[9]-1)/projL[5],leftFov=(projL[8]-1)/projL[0],rightFov=(projR[8]+1)/projR[0],left=near*leftFov,right=near*rightFov,zOffset=ipd/(-leftFov+rightFov),xOffset=zOffset*-leftFov;cameraL2.matrixWorld.decompose(camera.position,camera.quaternion,camera.scale),camera.translateX(xOffset),camera.translateZ(zOffset),camera.matrixWorld.compose(camera.position,camera.quaternion,camera.scale),camera.matrixWorldInverse.copy(camera.matrixWorld).invert();const near2=near+zOffset,far2=far+zOffset,left2=left-xOffset,right2=right+(ipd-xOffset),top2=topFov*far/far2*near2,bottom2=bottomFov*far/far2*near2;camera.projectionMatrix.makePerspective(left2,right2,top2,bottom2,near2,far2),camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert()}function updateCamera2(camera,parent){parent===null?camera.matrixWorld.copy(camera.matrix):camera.matrixWorld.multiplyMatrices(parent.matrixWorld,camera.matrix),camera.matrixWorldInverse.copy(camera.matrixWorld).invert()}this.updateCamera=function(camera){if(session===null)return;cameraXR.near=cameraR.near=cameraL.near=camera.near,cameraXR.far=cameraR.far=cameraL.far=camera.far,(_currentDepthNear!==cameraXR.near||_currentDepthFar!==cameraXR.far)&&(session.updateRenderState({depthNear:cameraXR.near,depthFar:cameraXR.far}),_currentDepthNear=cameraXR.near,_currentDepthFar=cameraXR.far);const parent=camera.parent,cameras2=cameraXR.cameras;updateCamera2(cameraXR,parent);for(let i2=0;i2<cameras2.length;i2++)updateCamera2(cameras2[i2],parent);cameras2.length===2?setProjectionFromUnion(cameraXR,cameraL,cameraR):cameraXR.projectionMatrix.copy(cameraL.projectionMatrix),updateUserCamera(camera,cameraXR,parent)};function updateUserCamera(camera,cameraXR2,parent){parent===null?camera.matrix.copy(cameraXR2.matrixWorld):(camera.matrix.copy(parent.matrixWorld),camera.matrix.invert(),camera.matrix.multiply(cameraXR2.matrixWorld)),camera.matrix.decompose(camera.position,camera.quaternion,camera.scale),camera.updateMatrixWorld(!0),camera.projectionMatrix.copy(cameraXR2.projectionMatrix),camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse),camera.isPerspectiveCamera&&(camera.fov=RAD2DEG*2*Math.atan(1/camera.projectionMatrix.elements[5]),camera.zoom=1)}this.getCamera=function(){return cameraXR},this.getFoveation=function(){if(!(glProjLayer===null&&glBaseLayer===null))return foveation},this.setFoveation=function(value){foveation=value,glProjLayer!==null&&(glProjLayer.fixedFoveation=value),glBaseLayer!==null&&glBaseLayer.fixedFoveation!==void 0&&(glBaseLayer.fixedFoveation=value)};let onAnimationFrameCallback=null;function onAnimationFrame(time,frame2){if(pose=frame2.getViewerPose(customReferenceSpace||referenceSpace),xrFrame=frame2,pose!==null){const views=pose.views;glBaseLayer!==null&&(renderer.setRenderTargetFramebuffer(newRenderTarget,glBaseLayer.framebuffer),renderer.setRenderTarget(newRenderTarget));let cameraXRNeedsUpdate=!1;views.length!==cameraXR.cameras.length&&(cameraXR.cameras.length=0,cameraXRNeedsUpdate=!0);for(let i2=0;i2<views.length;i2++){const view=views[i2];let viewport=null;if(glBaseLayer!==null)viewport=glBaseLayer.getViewport(view);else{const glSubImage=glBinding.getViewSubImage(glProjLayer,view);viewport=glSubImage.viewport,i2===0&&(renderer.setRenderTargetTextures(newRenderTarget,glSubImage.colorTexture,glProjLayer.ignoreDepthValues?void 0:glSubImage.depthStencilTexture),renderer.setRenderTarget(newRenderTarget))}let camera=cameras[i2];camera===void 0&&(camera=new PerspectiveCamera$1,camera.layers.enable(i2),camera.viewport=new Vector4,cameras[i2]=camera),camera.matrix.fromArray(view.transform.matrix),camera.matrix.decompose(camera.position,camera.quaternion,camera.scale),camera.projectionMatrix.fromArray(view.projectionMatrix),camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert(),camera.viewport.set(viewport.x,viewport.y,viewport.width,viewport.height),i2===0&&(cameraXR.matrix.copy(camera.matrix),cameraXR.matrix.decompose(cameraXR.position,cameraXR.quaternion,cameraXR.scale)),cameraXRNeedsUpdate===!0&&cameraXR.cameras.push(camera)}}for(let i2=0;i2<controllers.length;i2++){const inputSource=controllerInputSources[i2],controller=controllers[i2];inputSource!==null&&controller!==void 0&&controller.update(inputSource,frame2,customReferenceSpace||referenceSpace)}onAnimationFrameCallback&&onAnimationFrameCallback(time,frame2),frame2.detectedPlanes&&scope.dispatchEvent({type:"planesdetected",data:frame2}),xrFrame=null}const animation=new WebGLAnimation;animation.setAnimationLoop(onAnimationFrame),this.setAnimationLoop=function(callback){onAnimationFrameCallback=callback},this.dispose=function(){}}}function WebGLMaterials(renderer,properties){function refreshTransformUniform(map,uniform){map.matrixAutoUpdate===!0&&map.updateMatrix(),uniform.value.copy(map.matrix)}function refreshFogUniforms(uniforms,fog){fog.color.getRGB(uniforms.fogColor.value,getUnlitUniformColorSpace(renderer)),fog.isFog?(uniforms.fogNear.value=fog.near,uniforms.fogFar.value=fog.far):fog.isFogExp2&&(uniforms.fogDensity.value=fog.density)}function refreshMaterialUniforms(uniforms,material,pixelRatio,height,transmissionRenderTarget){material.isMeshBasicMaterial||material.isMeshLambertMaterial?refreshUniformsCommon(uniforms,material):material.isMeshToonMaterial?(refreshUniformsCommon(uniforms,material),refreshUniformsToon(uniforms,material)):material.isMeshPhongMaterial?(refreshUniformsCommon(uniforms,material),refreshUniformsPhong(uniforms,material)):material.isMeshStandardMaterial?(refreshUniformsCommon(uniforms,material),refreshUniformsStandard(uniforms,material),material.isMeshPhysicalMaterial&&refreshUniformsPhysical(uniforms,material,transmissionRenderTarget)):material.isMeshMatcapMaterial?(refreshUniformsCommon(uniforms,material),refreshUniformsMatcap(uniforms,material)):material.isMeshDepthMaterial?refreshUniformsCommon(uniforms,material):material.isMeshDistanceMaterial?(refreshUniformsCommon(uniforms,material),refreshUniformsDistance(uniforms,material)):material.isMeshNormalMaterial?refreshUniformsCommon(uniforms,material):material.isLineBasicMaterial?(refreshUniformsLine(uniforms,material),material.isLineDashedMaterial&&refreshUniformsDash(uniforms,material)):material.isPointsMaterial?refreshUniformsPoints(uniforms,material,pixelRatio,height):material.isSpriteMaterial?refreshUniformsSprites(uniforms,material):material.isShadowMaterial?(uniforms.color.value.copy(material.color),uniforms.opacity.value=material.opacity):material.isShaderMaterial&&(material.uniformsNeedUpdate=!1)}function refreshUniformsCommon(uniforms,material){uniforms.opacity.value=material.opacity,material.color&&uniforms.diffuse.value.copy(material.color),material.emissive&&uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity),material.map&&(uniforms.map.value=material.map,refreshTransformUniform(material.map,uniforms.mapTransform)),material.alphaMap&&(uniforms.alphaMap.value=material.alphaMap,refreshTransformUniform(material.alphaMap,uniforms.alphaMapTransform)),material.bumpMap&&(uniforms.bumpMap.value=material.bumpMap,refreshTransformUniform(material.bumpMap,uniforms.bumpMapTransform),uniforms.bumpScale.value=material.bumpScale,material.side===BackSide&&(uniforms.bumpScale.value*=-1)),material.normalMap&&(uniforms.normalMap.value=material.normalMap,refreshTransformUniform(material.normalMap,uniforms.normalMapTransform),uniforms.normalScale.value.copy(material.normalScale),material.side===BackSide&&uniforms.normalScale.value.negate()),material.displacementMap&&(uniforms.displacementMap.value=material.displacementMap,refreshTransformUniform(material.displacementMap,uniforms.displacementMapTransform),uniforms.displacementScale.value=material.displacementScale,uniforms.displacementBias.value=material.displacementBias),material.emissiveMap&&(uniforms.emissiveMap.value=material.emissiveMap,refreshTransformUniform(material.emissiveMap,uniforms.emissiveMapTransform)),material.specularMap&&(uniforms.specularMap.value=material.specularMap,refreshTransformUniform(material.specularMap,uniforms.specularMapTransform)),material.alphaTest>0&&(uniforms.alphaTest.value=material.alphaTest);const envMap=properties.get(material).envMap;if(envMap&&(uniforms.envMap.value=envMap,uniforms.flipEnvMap.value=envMap.isCubeTexture&&envMap.isRenderTargetTexture===!1?-1:1,uniforms.reflectivity.value=material.reflectivity,uniforms.ior.value=material.ior,uniforms.refractionRatio.value=material.refractionRatio),material.lightMap){uniforms.lightMap.value=material.lightMap;const scaleFactor=renderer._useLegacyLights===!0?Math.PI:1;uniforms.lightMapIntensity.value=material.lightMapIntensity*scaleFactor,refreshTransformUniform(material.lightMap,uniforms.lightMapTransform)}material.aoMap&&(uniforms.aoMap.value=material.aoMap,uniforms.aoMapIntensity.value=material.aoMapIntensity,refreshTransformUniform(material.aoMap,uniforms.aoMapTransform))}function refreshUniformsLine(uniforms,material){uniforms.diffuse.value.copy(material.color),uniforms.opacity.value=material.opacity,material.map&&(uniforms.map.value=material.map,refreshTransformUniform(material.map,uniforms.mapTransform))}function refreshUniformsDash(uniforms,material){uniforms.dashSize.value=material.dashSize,uniforms.totalSize.value=material.dashSize+material.gapSize,uniforms.scale.value=material.scale}function refreshUniformsPoints(uniforms,material,pixelRatio,height){uniforms.diffuse.value.copy(material.color),uniforms.opacity.value=material.opacity,uniforms.size.value=material.size*pixelRatio,uniforms.scale.value=height*.5,material.map&&(uniforms.map.value=material.map,refreshTransformUniform(material.map,uniforms.uvTransform)),material.alphaMap&&(uniforms.alphaMap.value=material.alphaMap,refreshTransformUniform(material.alphaMap,uniforms.alphaMapTransform)),material.alphaTest>0&&(uniforms.alphaTest.value=material.alphaTest)}function refreshUniformsSprites(uniforms,material){uniforms.diffuse.value.copy(material.color),uniforms.opacity.value=material.opacity,uniforms.rotation.value=material.rotation,material.map&&(uniforms.map.value=material.map,refreshTransformUniform(material.map,uniforms.mapTransform)),material.alphaMap&&(uniforms.alphaMap.value=material.alphaMap,refreshTransformUniform(material.alphaMap,uniforms.alphaMapTransform)),material.alphaTest>0&&(uniforms.alphaTest.value=material.alphaTest)}function refreshUniformsPhong(uniforms,material){uniforms.specular.value.copy(material.specular),uniforms.shininess.value=Math.max(material.shininess,1e-4)}function refreshUniformsToon(uniforms,material){material.gradientMap&&(uniforms.gradientMap.value=material.gradientMap)}function refreshUniformsStandard(uniforms,material){uniforms.metalness.value=material.metalness,material.metalnessMap&&(uniforms.metalnessMap.value=material.metalnessMap,refreshTransformUniform(material.metalnessMap,uniforms.metalnessMapTransform)),uniforms.roughness.value=material.roughness,material.roughnessMap&&(uniforms.roughnessMap.value=material.roughnessMap,refreshTransformUniform(material.roughnessMap,uniforms.roughnessMapTransform)),properties.get(material).envMap&&(uniforms.envMapIntensity.value=material.envMapIntensity)}function refreshUniformsPhysical(uniforms,material,transmissionRenderTarget){uniforms.ior.value=material.ior,material.sheen>0&&(uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen),uniforms.sheenRoughness.value=material.sheenRoughness,material.sheenColorMap&&(uniforms.sheenColorMap.value=material.sheenColorMap,refreshTransformUniform(material.sheenColorMap,uniforms.sheenColorMapTransform)),material.sheenRoughnessMap&&(uniforms.sheenRoughnessMap.value=material.sheenRoughnessMap,refreshTransformUniform(material.sheenRoughnessMap,uniforms.sheenRoughnessMapTransform))),material.clearcoat>0&&(uniforms.clearcoat.value=material.clearcoat,uniforms.clearcoatRoughness.value=material.clearcoatRoughness,material.clearcoatMap&&(uniforms.clearcoatMap.value=material.clearcoatMap,refreshTransformUniform(material.clearcoatMap,uniforms.clearcoatMapTransform)),material.clearcoatRoughnessMap&&(uniforms.clearcoatRoughnessMap.value=material.clearcoatRoughnessMap,refreshTransformUniform(material.clearcoatRoughnessMap,uniforms.clearcoatRoughnessMapTransform)),material.clearcoatNormalMap&&(uniforms.clearcoatNormalMap.value=material.clearcoatNormalMap,refreshTransformUniform(material.clearcoatNormalMap,uniforms.clearcoatNormalMapTransform),uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale),material.side===BackSide&&uniforms.clearcoatNormalScale.value.negate())),material.iridescence>0&&(uniforms.iridescence.value=material.iridescence,uniforms.iridescenceIOR.value=material.iridescenceIOR,uniforms.iridescenceThicknessMinimum.value=material.iridescenceThicknessRange[0],uniforms.iridescenceThicknessMaximum.value=material.iridescenceThicknessRange[1],material.iridescenceMap&&(uniforms.iridescenceMap.value=material.iridescenceMap,refreshTransformUniform(material.iridescenceMap,uniforms.iridescenceMapTransform)),material.iridescenceThicknessMap&&(uniforms.iridescenceThicknessMap.value=material.iridescenceThicknessMap,refreshTransformUniform(material.iridescenceThicknessMap,uniforms.iridescenceThicknessMapTransform))),material.transmission>0&&(uniforms.transmission.value=material.transmission,uniforms.transmissionSamplerMap.value=transmissionRenderTarget.texture,uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width,transmissionRenderTarget.height),material.transmissionMap&&(uniforms.transmissionMap.value=material.transmissionMap,refreshTransformUniform(material.transmissionMap,uniforms.transmissionMapTransform)),uniforms.thickness.value=material.thickness,material.thicknessMap&&(uniforms.thicknessMap.value=material.thicknessMap,refreshTransformUniform(material.thicknessMap,uniforms.thicknessMapTransform)),uniforms.attenuationDistance.value=material.attenuationDistance,uniforms.attenuationColor.value.copy(material.attenuationColor)),material.anisotropy>0&&(uniforms.anisotropyVector.value.set(material.anisotropy*Math.cos(material.anisotropyRotation),material.anisotropy*Math.sin(material.anisotropyRotation)),material.anisotropyMap&&(uniforms.anisotropyMap.value=material.anisotropyMap,refreshTransformUniform(material.anisotropyMap,uniforms.anisotropyMapTransform))),uniforms.specularIntensity.value=material.specularIntensity,uniforms.specularColor.value.copy(material.specularColor),material.specularColorMap&&(uniforms.specularColorMap.value=material.specularColorMap,refreshTransformUniform(material.specularColorMap,uniforms.specularColorMapTransform)),material.specularIntensityMap&&(uniforms.specularIntensityMap.value=material.specularIntensityMap,refreshTransformUniform(material.specularIntensityMap,uniforms.specularIntensityMapTransform))}function refreshUniformsMatcap(uniforms,material){material.matcap&&(uniforms.matcap.value=material.matcap)}function refreshUniformsDistance(uniforms,material){const light=properties.get(material).light;uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld),uniforms.nearDistance.value=light.shadow.camera.near,uniforms.farDistance.value=light.shadow.camera.far}return{refreshFogUniforms,refreshMaterialUniforms}}function WebGLUniformsGroups(gl,info,capabilities,state){let buffers={},updateList={},allocatedBindingPoints=[];const maxBindingPoints=capabilities.isWebGL2?gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS):0;function bind(uniformsGroup,program){const webglProgram=program.program;state.uniformBlockBinding(uniformsGroup,webglProgram)}function update(uniformsGroup,program){let buffer=buffers[uniformsGroup.id];buffer===void 0&&(prepareUniformsGroup(uniformsGroup),buffer=createBuffer(uniformsGroup),buffers[uniformsGroup.id]=buffer,uniformsGroup.addEventListener("dispose",onUniformsGroupsDispose));const webglProgram=program.program;state.updateUBOMapping(uniformsGroup,webglProgram);const frame2=info.render.frame;updateList[uniformsGroup.id]!==frame2&&(updateBufferData(uniformsGroup),updateList[uniformsGroup.id]=frame2)}function createBuffer(uniformsGroup){const bindingPointIndex=allocateBindingPointIndex();uniformsGroup.__bindingPointIndex=bindingPointIndex;const buffer=gl.createBuffer(),size=uniformsGroup.__size,usage=uniformsGroup.usage;return gl.bindBuffer(gl.UNIFORM_BUFFER,buffer),gl.bufferData(gl.UNIFORM_BUFFER,size,usage),gl.bindBuffer(gl.UNIFORM_BUFFER,null),gl.bindBufferBase(gl.UNIFORM_BUFFER,bindingPointIndex,buffer),buffer}function allocateBindingPointIndex(){for(let i2=0;i2<maxBindingPoints;i2++)if(allocatedBindingPoints.indexOf(i2)===-1)return allocatedBindingPoints.push(i2),i2;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function updateBufferData(uniformsGroup){const buffer=buffers[uniformsGroup.id],uniforms=uniformsGroup.uniforms,cache=uniformsGroup.__cache;gl.bindBuffer(gl.UNIFORM_BUFFER,buffer);for(let i2=0,il=uniforms.length;i2<il;i2++){const uniform=uniforms[i2];if(hasUniformChanged(uniform,i2,cache)===!0){const offset=uniform.__offset,values=Array.isArray(uniform.value)?uniform.value:[uniform.value];let arrayOffset=0;for(let i3=0;i3<values.length;i3++){const value=values[i3],info2=getUniformSize(value);typeof value=="number"?(uniform.__data[0]=value,gl.bufferSubData(gl.UNIFORM_BUFFER,offset+arrayOffset,uniform.__data)):value.isMatrix3?(uniform.__data[0]=value.elements[0],uniform.__data[1]=value.elements[1],uniform.__data[2]=value.elements[2],uniform.__data[3]=value.elements[0],uniform.__data[4]=value.elements[3],uniform.__data[5]=value.elements[4],uniform.__data[6]=value.elements[5],uniform.__data[7]=value.elements[0],uniform.__data[8]=value.elements[6],uniform.__data[9]=value.elements[7],uniform.__data[10]=value.elements[8],uniform.__data[11]=value.elements[0]):(value.toArray(uniform.__data,arrayOffset),arrayOffset+=info2.storage/Float32Array.BYTES_PER_ELEMENT)}gl.bufferSubData(gl.UNIFORM_BUFFER,offset,uniform.__data)}}gl.bindBuffer(gl.UNIFORM_BUFFER,null)}function hasUniformChanged(uniform,index,cache){const value=uniform.value;if(cache[index]===void 0){if(typeof value=="number")cache[index]=value;else{const values=Array.isArray(value)?value:[value],tempValues=[];for(let i2=0;i2<values.length;i2++)tempValues.push(values[i2].clone());cache[index]=tempValues}return!0}else if(typeof value=="number"){if(cache[index]!==value)return cache[index]=value,!0}else{const cachedObjects=Array.isArray(cache[index])?cache[index]:[cache[index]],values=Array.isArray(value)?value:[value];for(let i2=0;i2<cachedObjects.length;i2++){const cachedObject=cachedObjects[i2];if(cachedObject.equals(values[i2])===!1)return cachedObject.copy(values[i2]),!0}}return!1}function prepareUniformsGroup(uniformsGroup){const uniforms=uniformsGroup.uniforms;let offset=0;const chunkSize=16;let chunkOffset=0;for(let i2=0,l2=uniforms.length;i2<l2;i2++){const uniform=uniforms[i2],infos={boundary:0,storage:0},values=Array.isArray(uniform.value)?uniform.value:[uniform.value];for(let j2=0,jl=values.length;j2<jl;j2++){const value=values[j2],info2=getUniformSize(value);infos.boundary+=info2.boundary,infos.storage+=info2.storage}if(uniform.__data=new Float32Array(infos.storage/Float32Array.BYTES_PER_ELEMENT),uniform.__offset=offset,i2>0){chunkOffset=offset%chunkSize;const remainingSizeInChunk=chunkSize-chunkOffset;chunkOffset!==0&&remainingSizeInChunk-infos.boundary<0&&(offset+=chunkSize-chunkOffset,uniform.__offset=offset)}offset+=infos.storage}return chunkOffset=offset%chunkSize,chunkOffset>0&&(offset+=chunkSize-chunkOffset),uniformsGroup.__size=offset,uniformsGroup.__cache={},this}function getUniformSize(value){const info2={boundary:0,storage:0};return typeof value=="number"?(info2.boundary=4,info2.storage=4):value.isVector2?(info2.boundary=8,info2.storage=8):value.isVector3||value.isColor?(info2.boundary=16,info2.storage=12):value.isVector4?(info2.boundary=16,info2.storage=16):value.isMatrix3?(info2.boundary=48,info2.storage=48):value.isMatrix4?(info2.boundary=64,info2.storage=64):value.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",value),info2}function onUniformsGroupsDispose(event){const uniformsGroup=event.target;uniformsGroup.removeEventListener("dispose",onUniformsGroupsDispose);const index=allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);allocatedBindingPoints.splice(index,1),gl.deleteBuffer(buffers[uniformsGroup.id]),delete buffers[uniformsGroup.id],delete updateList[uniformsGroup.id]}function dispose2(){for(const id2 in buffers)gl.deleteBuffer(buffers[id2]);allocatedBindingPoints=[],buffers={},updateList={}}return{bind,update,dispose:dispose2}}class WebGLRenderer{constructor(parameters={}){const{canvas=createCanvasElement(),context:context2=null,depth=!0,stencil=!0,alpha:alpha2=!1,antialias=!1,premultipliedAlpha=!0,preserveDrawingBuffer=!1,powerPreference="default",failIfMajorPerformanceCaveat=!1}=parameters;this.isWebGLRenderer=!0;let _alpha;context2!==null?_alpha=context2.getContextAttributes().alpha:_alpha=alpha2;const uintClearColor=new Uint32Array(4),intClearColor=new Int32Array(4);let currentRenderList=null,currentRenderState=null;const renderListStack=[],renderStateStack=[];this.domElement=canvas,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=SRGBColorSpace,this._useLegacyLights=!1,this.toneMapping=NoToneMapping,this.toneMappingExposure=1;const _this=this;let _isContextLost=!1,_currentActiveCubeFace=0,_currentActiveMipmapLevel=0,_currentRenderTarget=null,_currentMaterialId=-1,_currentCamera=null;const _currentViewport=new Vector4,_currentScissor=new Vector4;let _currentScissorTest=null;const _currentClearColor=new Color(0);let _currentClearAlpha=0,_width=canvas.width,_height=canvas.height,_pixelRatio=1,_opaqueSort=null,_transparentSort=null;const _viewport=new Vector4(0,0,_width,_height),_scissor=new Vector4(0,0,_width,_height);let _scissorTest=!1;const _frustum=new Frustum;let _clippingEnabled=!1,_localClippingEnabled=!1,_transmissionRenderTarget=null;const _projScreenMatrix2=new Matrix4,_vector22=new Vector2,_vector32=new Vector3,_emptyScene={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function getTargetPixelRatio(){return _currentRenderTarget===null?_pixelRatio:1}let _gl=context2;function getContext(contextNames,contextAttributes){for(let i2=0;i2<contextNames.length;i2++){const contextName=contextNames[i2],context3=canvas.getContext(contextName,contextAttributes);if(context3!==null)return context3}return null}try{const contextAttributes={alpha:!0,depth,stencil,antialias,premultipliedAlpha,preserveDrawingBuffer,powerPreference,failIfMajorPerformanceCaveat};if("setAttribute"in canvas&&canvas.setAttribute("data-engine",`three.js r${REVISION}`),canvas.addEventListener("webglcontextlost",onContextLost,!1),canvas.addEventListener("webglcontextrestored",onContextRestore,!1),canvas.addEventListener("webglcontextcreationerror",onContextCreationError,!1),_gl===null){const contextNames=["webgl2","webgl","experimental-webgl"];if(_this.isWebGL1Renderer===!0&&contextNames.shift(),_gl=getContext(contextNames,contextAttributes),_gl===null)throw getContext(contextNames)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}typeof WebGLRenderingContext<"u"&&_gl instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),_gl.getShaderPrecisionFormat===void 0&&(_gl.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(error){throw console.error("THREE.WebGLRenderer: "+error.message),error}let extensions2,capabilities,state,info,properties,textures,cubemaps,cubeuvmaps,attributes,geometries,objects,programCache,materials,renderLists,renderStates,clipping,shadowMap,background,morphtargets,bufferRenderer,indexedBufferRenderer,utils,bindingStates,uniformsGroups;function initGLContext(){extensions2=new WebGLExtensions(_gl),capabilities=new WebGLCapabilities(_gl,extensions2,parameters),extensions2.init(capabilities),utils=new WebGLUtils(_gl,extensions2,capabilities),state=new WebGLState(_gl,extensions2,capabilities),info=new WebGLInfo(_gl),properties=new WebGLProperties,textures=new WebGLTextures(_gl,extensions2,state,properties,capabilities,utils,info),cubemaps=new WebGLCubeMaps(_this),cubeuvmaps=new WebGLCubeUVMaps(_this),attributes=new WebGLAttributes(_gl,capabilities),bindingStates=new WebGLBindingStates(_gl,extensions2,attributes,capabilities),geometries=new WebGLGeometries(_gl,attributes,info,bindingStates),objects=new WebGLObjects(_gl,geometries,attributes,info),morphtargets=new WebGLMorphtargets(_gl,capabilities,textures),clipping=new WebGLClipping(properties),programCache=new WebGLPrograms(_this,cubemaps,cubeuvmaps,extensions2,capabilities,bindingStates,clipping),materials=new WebGLMaterials(_this,properties),renderLists=new WebGLRenderLists,renderStates=new WebGLRenderStates(extensions2,capabilities),background=new WebGLBackground(_this,cubemaps,cubeuvmaps,state,objects,_alpha,premultipliedAlpha),shadowMap=new WebGLShadowMap(_this,objects,capabilities),uniformsGroups=new WebGLUniformsGroups(_gl,info,capabilities,state),bufferRenderer=new WebGLBufferRenderer(_gl,extensions2,info,capabilities),indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions2,info,capabilities),info.programs=programCache.programs,_this.capabilities=capabilities,_this.extensions=extensions2,_this.properties=properties,_this.renderLists=renderLists,_this.shadowMap=shadowMap,_this.state=state,_this.info=info}initGLContext();const xr=new WebXRManager(_this,_gl);this.xr=xr,this.getContext=function(){return _gl},this.getContextAttributes=function(){return _gl.getContextAttributes()},this.forceContextLoss=function(){const extension=extensions2.get("WEBGL_lose_context");extension&&extension.loseContext()},this.forceContextRestore=function(){const extension=extensions2.get("WEBGL_lose_context");extension&&extension.restoreContext()},this.getPixelRatio=function(){return _pixelRatio},this.setPixelRatio=function(value){value!==void 0&&(_pixelRatio=value,this.setSize(_width,_height,!1))},this.getSize=function(target){return target.set(_width,_height)},this.setSize=function(width,height,updateStyle=!0){if(xr.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}_width=width,_height=height,canvas.width=Math.floor(width*_pixelRatio),canvas.height=Math.floor(height*_pixelRatio),updateStyle===!0&&(canvas.style.width=width+"px",canvas.style.height=height+"px"),this.setViewport(0,0,width,height)},this.getDrawingBufferSize=function(target){return target.set(_width*_pixelRatio,_height*_pixelRatio).floor()},this.setDrawingBufferSize=function(width,height,pixelRatio){_width=width,_height=height,_pixelRatio=pixelRatio,canvas.width=Math.floor(width*pixelRatio),canvas.height=Math.floor(height*pixelRatio),this.setViewport(0,0,width,height)},this.getCurrentViewport=function(target){return target.copy(_currentViewport)},this.getViewport=function(target){return target.copy(_viewport)},this.setViewport=function(x2,y2,width,height){x2.isVector4?_viewport.set(x2.x,x2.y,x2.z,x2.w):_viewport.set(x2,y2,width,height),state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor())},this.getScissor=function(target){return target.copy(_scissor)},this.setScissor=function(x2,y2,width,height){x2.isVector4?_scissor.set(x2.x,x2.y,x2.z,x2.w):_scissor.set(x2,y2,width,height),state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor())},this.getScissorTest=function(){return _scissorTest},this.setScissorTest=function(boolean){state.setScissorTest(_scissorTest=boolean)},this.setOpaqueSort=function(method){_opaqueSort=method},this.setTransparentSort=function(method){_transparentSort=method},this.getClearColor=function(target){return target.copy(background.getClearColor())},this.setClearColor=function(){background.setClearColor.apply(background,arguments)},this.getClearAlpha=function(){return background.getClearAlpha()},this.setClearAlpha=function(){background.setClearAlpha.apply(background,arguments)},this.clear=function(color2=!0,depth2=!0,stencil2=!0){let bits2=0;if(color2){let isIntegerFormat=!1;if(_currentRenderTarget!==null){const targetFormat=_currentRenderTarget.texture.format;isIntegerFormat=targetFormat===RGBAIntegerFormat||targetFormat===RGIntegerFormat||targetFormat===RedIntegerFormat}if(isIntegerFormat){const targetType=_currentRenderTarget.texture.type,isUnsignedType=targetType===UnsignedByteType||targetType===UnsignedIntType||targetType===UnsignedShortType||targetType===UnsignedInt248Type||targetType===UnsignedShort4444Type||targetType===UnsignedShort5551Type,clearColor=background.getClearColor(),a2=background.getClearAlpha(),r2=clearColor.r,g2=clearColor.g,b2=clearColor.b;isUnsignedType?(uintClearColor[0]=r2,uintClearColor[1]=g2,uintClearColor[2]=b2,uintClearColor[3]=a2,_gl.clearBufferuiv(_gl.COLOR,0,uintClearColor)):(intClearColor[0]=r2,intClearColor[1]=g2,intClearColor[2]=b2,intClearColor[3]=a2,_gl.clearBufferiv(_gl.COLOR,0,intClearColor))}else bits2|=_gl.COLOR_BUFFER_BIT}depth2&&(bits2|=_gl.DEPTH_BUFFER_BIT),stencil2&&(bits2|=_gl.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),_gl.clear(bits2)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){canvas.removeEventListener("webglcontextlost",onContextLost,!1),canvas.removeEventListener("webglcontextrestored",onContextRestore,!1),canvas.removeEventListener("webglcontextcreationerror",onContextCreationError,!1),renderLists.dispose(),renderStates.dispose(),properties.dispose(),cubemaps.dispose(),cubeuvmaps.dispose(),objects.dispose(),bindingStates.dispose(),uniformsGroups.dispose(),programCache.dispose(),xr.dispose(),xr.removeEventListener("sessionstart",onXRSessionStart),xr.removeEventListener("sessionend",onXRSessionEnd),_transmissionRenderTarget&&(_transmissionRenderTarget.dispose(),_transmissionRenderTarget=null),animation.stop()};function onContextLost(event){event.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),_isContextLost=!0}function onContextRestore(){console.log("THREE.WebGLRenderer: Context Restored."),_isContextLost=!1;const infoAutoReset=info.autoReset,shadowMapEnabled=shadowMap.enabled,shadowMapAutoUpdate=shadowMap.autoUpdate,shadowMapNeedsUpdate=shadowMap.needsUpdate,shadowMapType=shadowMap.type;initGLContext(),info.autoReset=infoAutoReset,shadowMap.enabled=shadowMapEnabled,shadowMap.autoUpdate=shadowMapAutoUpdate,shadowMap.needsUpdate=shadowMapNeedsUpdate,shadowMap.type=shadowMapType}function onContextCreationError(event){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",event.statusMessage)}function onMaterialDispose(event){const material=event.target;material.removeEventListener("dispose",onMaterialDispose),deallocateMaterial(material)}function deallocateMaterial(material){releaseMaterialProgramReferences(material),properties.remove(material)}function releaseMaterialProgramReferences(material){const programs=properties.get(material).programs;programs!==void 0&&(programs.forEach(function(program){programCache.releaseProgram(program)}),material.isShaderMaterial&&programCache.releaseShaderCache(material))}this.renderBufferDirect=function(camera,scene2,geometry,material,object,group){scene2===null&&(scene2=_emptyScene);const frontFaceCW=object.isMesh&&object.matrixWorld.determinant()<0,program=setProgram(camera,scene2,geometry,material,object);state.setMaterial(material,frontFaceCW);let index=geometry.index,rangeFactor=1;if(material.wireframe===!0){if(index=geometries.getWireframeAttribute(geometry),index===void 0)return;rangeFactor=2}const drawRange=geometry.drawRange,position=geometry.attributes.position;let drawStart=drawRange.start*rangeFactor,drawEnd=(drawRange.start+drawRange.count)*rangeFactor;group!==null&&(drawStart=Math.max(drawStart,group.start*rangeFactor),drawEnd=Math.min(drawEnd,(group.start+group.count)*rangeFactor)),index!==null?(drawStart=Math.max(drawStart,0),drawEnd=Math.min(drawEnd,index.count)):position!=null&&(drawStart=Math.max(drawStart,0),drawEnd=Math.min(drawEnd,position.count));const drawCount=drawEnd-drawStart;if(drawCount<0||drawCount===1/0)return;bindingStates.setup(object,material,program,geometry,index);let attribute,renderer=bufferRenderer;if(index!==null&&(attribute=attributes.get(index),renderer=indexedBufferRenderer,renderer.setIndex(attribute)),object.isMesh)material.wireframe===!0?(state.setLineWidth(material.wireframeLinewidth*getTargetPixelRatio()),renderer.setMode(_gl.LINES)):renderer.setMode(_gl.TRIANGLES);else if(object.isLine){let lineWidth=material.linewidth;lineWidth===void 0&&(lineWidth=1),state.setLineWidth(lineWidth*getTargetPixelRatio()),object.isLineSegments?renderer.setMode(_gl.LINES):object.isLineLoop?renderer.setMode(_gl.LINE_LOOP):renderer.setMode(_gl.LINE_STRIP)}else object.isPoints?renderer.setMode(_gl.POINTS):object.isSprite&&renderer.setMode(_gl.TRIANGLES);if(object.isInstancedMesh)renderer.renderInstances(drawStart,drawCount,object.count);else if(geometry.isInstancedBufferGeometry){const maxInstanceCount=geometry._maxInstanceCount!==void 0?geometry._maxInstanceCount:1/0,instanceCount=Math.min(geometry.instanceCount,maxInstanceCount);renderer.renderInstances(drawStart,drawCount,instanceCount)}else renderer.render(drawStart,drawCount)};function prepareMaterial(material,scene2,object){material.transparent===!0&&material.side===DoubleSide&&material.forceSinglePass===!1?(material.side=BackSide,material.needsUpdate=!0,getProgram(material,scene2,object),material.side=FrontSide,material.needsUpdate=!0,getProgram(material,scene2,object),material.side=DoubleSide):getProgram(material,scene2,object)}this.compile=function(scene2,camera,targetScene=null){targetScene===null&&(targetScene=scene2),currentRenderState=renderStates.get(targetScene),currentRenderState.init(),renderStateStack.push(currentRenderState),targetScene.traverseVisible(function(object){object.isLight&&object.layers.test(camera.layers)&&(currentRenderState.pushLight(object),object.castShadow&&currentRenderState.pushShadow(object))}),scene2!==targetScene&&scene2.traverseVisible(function(object){object.isLight&&object.layers.test(camera.layers)&&(currentRenderState.pushLight(object),object.castShadow&&currentRenderState.pushShadow(object))}),currentRenderState.setupLights(_this._useLegacyLights);const materials2=new Set;return scene2.traverse(function(object){const material=object.material;if(material)if(Array.isArray(material))for(let i2=0;i2<material.length;i2++){const material2=material[i2];prepareMaterial(material2,targetScene,object),materials2.add(material2)}else prepareMaterial(material,targetScene,object),materials2.add(material)}),renderStateStack.pop(),currentRenderState=null,materials2},this.compileAsync=function(scene2,camera,targetScene=null){const materials2=this.compile(scene2,camera,targetScene);return new Promise(resolve2=>{function checkMaterialsReady(){if(materials2.forEach(function(material){properties.get(material).currentProgram.isReady()&&materials2.delete(material)}),materials2.size===0){resolve2(scene2);return}setTimeout(checkMaterialsReady,10)}extensions2.get("KHR_parallel_shader_compile")!==null?checkMaterialsReady():setTimeout(checkMaterialsReady,10)})};let onAnimationFrameCallback=null;function onAnimationFrame(time){onAnimationFrameCallback&&onAnimationFrameCallback(time)}function onXRSessionStart(){animation.stop()}function onXRSessionEnd(){animation.start()}const animation=new WebGLAnimation;animation.setAnimationLoop(onAnimationFrame),typeof self<"u"&&animation.setContext(self),this.setAnimationLoop=function(callback){onAnimationFrameCallback=callback,xr.setAnimationLoop(callback),callback===null?animation.stop():animation.start()},xr.addEventListener("sessionstart",onXRSessionStart),xr.addEventListener("sessionend",onXRSessionEnd),this.render=function(scene2,camera){if(camera!==void 0&&camera.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(_isContextLost===!0)return;scene2.matrixWorldAutoUpdate===!0&&scene2.updateMatrixWorld(),camera.parent===null&&camera.matrixWorldAutoUpdate===!0&&camera.updateMatrixWorld(),xr.enabled===!0&&xr.isPresenting===!0&&(xr.cameraAutoUpdate===!0&&xr.updateCamera(camera),camera=xr.getCamera()),scene2.isScene===!0&&scene2.onBeforeRender(_this,scene2,camera,_currentRenderTarget),currentRenderState=renderStates.get(scene2,renderStateStack.length),currentRenderState.init(),renderStateStack.push(currentRenderState),_projScreenMatrix2.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse),_frustum.setFromProjectionMatrix(_projScreenMatrix2),_localClippingEnabled=this.localClippingEnabled,_clippingEnabled=clipping.init(this.clippingPlanes,_localClippingEnabled),currentRenderList=renderLists.get(scene2,renderListStack.length),currentRenderList.init(),renderListStack.push(currentRenderList),projectObject(scene2,camera,0,_this.sortObjects),currentRenderList.finish(),_this.sortObjects===!0&&currentRenderList.sort(_opaqueSort,_transparentSort),this.info.render.frame++,_clippingEnabled===!0&&clipping.beginShadows();const shadowsArray=currentRenderState.state.shadowsArray;if(shadowMap.render(shadowsArray,scene2,camera),_clippingEnabled===!0&&clipping.endShadows(),this.info.autoReset===!0&&this.info.reset(),background.render(currentRenderList,scene2),currentRenderState.setupLights(_this._useLegacyLights),camera.isArrayCamera){const cameras=camera.cameras;for(let i2=0,l2=cameras.length;i2<l2;i2++){const camera2=cameras[i2];renderScene(currentRenderList,scene2,camera2,camera2.viewport)}}else renderScene(currentRenderList,scene2,camera);_currentRenderTarget!==null&&(textures.updateMultisampleRenderTarget(_currentRenderTarget),textures.updateRenderTargetMipmap(_currentRenderTarget)),scene2.isScene===!0&&scene2.onAfterRender(_this,scene2,camera),bindingStates.resetDefaultState(),_currentMaterialId=-1,_currentCamera=null,renderStateStack.pop(),renderStateStack.length>0?currentRenderState=renderStateStack[renderStateStack.length-1]:currentRenderState=null,renderListStack.pop(),renderListStack.length>0?currentRenderList=renderListStack[renderListStack.length-1]:currentRenderList=null};function projectObject(object,camera,groupOrder,sortObjects){if(object.visible===!1)return;if(object.layers.test(camera.layers)){if(object.isGroup)groupOrder=object.renderOrder;else if(object.isLOD)object.autoUpdate===!0&&object.update(camera);else if(object.isLight)currentRenderState.pushLight(object),object.castShadow&&currentRenderState.pushShadow(object);else if(object.isSprite){if(!object.frustumCulled||_frustum.intersectsSprite(object)){sortObjects&&_vector32.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);const geometry=objects.update(object),material=object.material;material.visible&&currentRenderList.push(object,geometry,material,groupOrder,_vector32.z,null)}}else if((object.isMesh||object.isLine||object.isPoints)&&(!object.frustumCulled||_frustum.intersectsObject(object))){const geometry=objects.update(object),material=object.material;if(sortObjects&&(object.boundingSphere!==void 0?(object.boundingSphere===null&&object.computeBoundingSphere(),_vector32.copy(object.boundingSphere.center)):(geometry.boundingSphere===null&&geometry.computeBoundingSphere(),_vector32.copy(geometry.boundingSphere.center)),_vector32.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix2)),Array.isArray(material)){const groups=geometry.groups;for(let i2=0,l2=groups.length;i2<l2;i2++){const group=groups[i2],groupMaterial=material[group.materialIndex];groupMaterial&&groupMaterial.visible&&currentRenderList.push(object,geometry,groupMaterial,groupOrder,_vector32.z,group)}}else material.visible&&currentRenderList.push(object,geometry,material,groupOrder,_vector32.z,null)}}const children=object.children;for(let i2=0,l2=children.length;i2<l2;i2++)projectObject(children[i2],camera,groupOrder,sortObjects)}function renderScene(currentRenderList2,scene2,camera,viewport){const opaqueObjects=currentRenderList2.opaque,transmissiveObjects=currentRenderList2.transmissive,transparentObjects=currentRenderList2.transparent;currentRenderState.setupLightsView(camera),_clippingEnabled===!0&&clipping.setGlobalState(_this.clippingPlanes,camera),transmissiveObjects.length>0&&renderTransmissionPass(opaqueObjects,transmissiveObjects,scene2,camera),viewport&&state.viewport(_currentViewport.copy(viewport)),opaqueObjects.length>0&&renderObjects(opaqueObjects,scene2,camera),transmissiveObjects.length>0&&renderObjects(transmissiveObjects,scene2,camera),transparentObjects.length>0&&renderObjects(transparentObjects,scene2,camera),state.buffers.depth.setTest(!0),state.buffers.depth.setMask(!0),state.buffers.color.setMask(!0),state.setPolygonOffset(!1)}function renderTransmissionPass(opaqueObjects,transmissiveObjects,scene2,camera){if((scene2.isScene===!0?scene2.overrideMaterial:null)!==null)return;const isWebGL2=capabilities.isWebGL2;_transmissionRenderTarget===null&&(_transmissionRenderTarget=new WebGLRenderTarget(1,1,{generateMipmaps:!0,type:extensions2.has("EXT_color_buffer_half_float")?HalfFloatType:UnsignedByteType,minFilter:LinearMipmapLinearFilter,samples:isWebGL2?4:0})),_this.getDrawingBufferSize(_vector22),isWebGL2?_transmissionRenderTarget.setSize(_vector22.x,_vector22.y):_transmissionRenderTarget.setSize(floorPowerOfTwo(_vector22.x),floorPowerOfTwo(_vector22.y));const currentRenderTarget=_this.getRenderTarget();_this.setRenderTarget(_transmissionRenderTarget),_this.getClearColor(_currentClearColor),_currentClearAlpha=_this.getClearAlpha(),_currentClearAlpha<1&&_this.setClearColor(16777215,.5),_this.clear();const currentToneMapping=_this.toneMapping;_this.toneMapping=NoToneMapping,renderObjects(opaqueObjects,scene2,camera),textures.updateMultisampleRenderTarget(_transmissionRenderTarget),textures.updateRenderTargetMipmap(_transmissionRenderTarget);let renderTargetNeedsUpdate=!1;for(let i2=0,l2=transmissiveObjects.length;i2<l2;i2++){const renderItem=transmissiveObjects[i2],object=renderItem.object,geometry=renderItem.geometry,material=renderItem.material,group=renderItem.group;if(material.side===DoubleSide&&object.layers.test(camera.layers)){const currentSide=material.side;material.side=BackSide,material.needsUpdate=!0,renderObject(object,scene2,camera,geometry,material,group),material.side=currentSide,material.needsUpdate=!0,renderTargetNeedsUpdate=!0}}renderTargetNeedsUpdate===!0&&(textures.updateMultisampleRenderTarget(_transmissionRenderTarget),textures.updateRenderTargetMipmap(_transmissionRenderTarget)),_this.setRenderTarget(currentRenderTarget),_this.setClearColor(_currentClearColor,_currentClearAlpha),_this.toneMapping=currentToneMapping}function renderObjects(renderList,scene2,camera){const overrideMaterial=scene2.isScene===!0?scene2.overrideMaterial:null;for(let i2=0,l2=renderList.length;i2<l2;i2++){const renderItem=renderList[i2],object=renderItem.object,geometry=renderItem.geometry,material=overrideMaterial===null?renderItem.material:overrideMaterial,group=renderItem.group;object.layers.test(camera.layers)&&renderObject(object,scene2,camera,geometry,material,group)}}function renderObject(object,scene2,camera,geometry,material,group){object.onBeforeRender(_this,scene2,camera,geometry,material,group),object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld),object.normalMatrix.getNormalMatrix(object.modelViewMatrix),material.onBeforeRender(_this,scene2,camera,geometry,object,group),material.transparent===!0&&material.side===DoubleSide&&material.forceSinglePass===!1?(material.side=BackSide,material.needsUpdate=!0,_this.renderBufferDirect(camera,scene2,geometry,material,object,group),material.side=FrontSide,material.needsUpdate=!0,_this.renderBufferDirect(camera,scene2,geometry,material,object,group),material.side=DoubleSide):_this.renderBufferDirect(camera,scene2,geometry,material,object,group),object.onAfterRender(_this,scene2,camera,geometry,material,group)}function getProgram(material,scene2,object){scene2.isScene!==!0&&(scene2=_emptyScene);const materialProperties=properties.get(material),lights=currentRenderState.state.lights,shadowsArray=currentRenderState.state.shadowsArray,lightsStateVersion=lights.state.version,parameters2=programCache.getParameters(material,lights.state,shadowsArray,scene2,object),programCacheKey=programCache.getProgramCacheKey(parameters2);let programs=materialProperties.programs;materialProperties.environment=material.isMeshStandardMaterial?scene2.environment:null,materialProperties.fog=scene2.fog,materialProperties.envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||materialProperties.environment),programs===void 0&&(material.addEventListener("dispose",onMaterialDispose),programs=new Map,materialProperties.programs=programs);let program=programs.get(programCacheKey);if(program!==void 0){if(materialProperties.currentProgram===program&&materialProperties.lightsStateVersion===lightsStateVersion)return updateCommonMaterialProperties(material,parameters2),program}else parameters2.uniforms=programCache.getUniforms(material),material.onBuild(object,parameters2,_this),material.onBeforeCompile(parameters2,_this),program=programCache.acquireProgram(parameters2,programCacheKey),programs.set(programCacheKey,program),materialProperties.uniforms=parameters2.uniforms;const uniforms=materialProperties.uniforms;return(!material.isShaderMaterial&&!material.isRawShaderMaterial||material.clipping===!0)&&(uniforms.clippingPlanes=clipping.uniform),updateCommonMaterialProperties(material,parameters2),materialProperties.needsLights=materialNeedsLights(material),materialProperties.lightsStateVersion=lightsStateVersion,materialProperties.needsLights&&(uniforms.ambientLightColor.value=lights.state.ambient,uniforms.lightProbe.value=lights.state.probe,uniforms.directionalLights.value=lights.state.directional,uniforms.directionalLightShadows.value=lights.state.directionalShadow,uniforms.spotLights.value=lights.state.spot,uniforms.spotLightShadows.value=lights.state.spotShadow,uniforms.rectAreaLights.value=lights.state.rectArea,uniforms.ltc_1.value=lights.state.rectAreaLTC1,uniforms.ltc_2.value=lights.state.rectAreaLTC2,uniforms.pointLights.value=lights.state.point,uniforms.pointLightShadows.value=lights.state.pointShadow,uniforms.hemisphereLights.value=lights.state.hemi,uniforms.directionalShadowMap.value=lights.state.directionalShadowMap,uniforms.directionalShadowMatrix.value=lights.state.directionalShadowMatrix,uniforms.spotShadowMap.value=lights.state.spotShadowMap,uniforms.spotLightMatrix.value=lights.state.spotLightMatrix,uniforms.spotLightMap.value=lights.state.spotLightMap,uniforms.pointShadowMap.value=lights.state.pointShadowMap,uniforms.pointShadowMatrix.value=lights.state.pointShadowMatrix),materialProperties.currentProgram=program,materialProperties.uniformsList=null,program}function getUniformList(materialProperties){if(materialProperties.uniformsList===null){const progUniforms=materialProperties.currentProgram.getUniforms();materialProperties.uniformsList=WebGLUniforms.seqWithValue(progUniforms.seq,materialProperties.uniforms)}return materialProperties.uniformsList}function updateCommonMaterialProperties(material,parameters2){const materialProperties=properties.get(material);materialProperties.outputColorSpace=parameters2.outputColorSpace,materialProperties.instancing=parameters2.instancing,materialProperties.instancingColor=parameters2.instancingColor,materialProperties.skinning=parameters2.skinning,materialProperties.morphTargets=parameters2.morphTargets,materialProperties.morphNormals=parameters2.morphNormals,materialProperties.morphColors=parameters2.morphColors,materialProperties.morphTargetsCount=parameters2.morphTargetsCount,materialProperties.numClippingPlanes=parameters2.numClippingPlanes,materialProperties.numIntersection=parameters2.numClipIntersection,materialProperties.vertexAlphas=parameters2.vertexAlphas,materialProperties.vertexTangents=parameters2.vertexTangents,materialProperties.toneMapping=parameters2.toneMapping}function setProgram(camera,scene2,geometry,material,object){scene2.isScene!==!0&&(scene2=_emptyScene),textures.resetTextureUnits();const fog=scene2.fog,environment=material.isMeshStandardMaterial?scene2.environment:null,colorSpace=_currentRenderTarget===null?_this.outputColorSpace:_currentRenderTarget.isXRRenderTarget===!0?_currentRenderTarget.texture.colorSpace:LinearSRGBColorSpace,envMap=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||environment),vertexAlphas=material.vertexColors===!0&&!!geometry.attributes.color&&geometry.attributes.color.itemSize===4,vertexTangents=!!geometry.attributes.tangent&&(!!material.normalMap||material.anisotropy>0),morphTargets=!!geometry.morphAttributes.position,morphNormals=!!geometry.morphAttributes.normal,morphColors=!!geometry.morphAttributes.color;let toneMapping=NoToneMapping;material.toneMapped&&(_currentRenderTarget===null||_currentRenderTarget.isXRRenderTarget===!0)&&(toneMapping=_this.toneMapping);const morphAttribute=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color,morphTargetsCount=morphAttribute!==void 0?morphAttribute.length:0,materialProperties=properties.get(material),lights=currentRenderState.state.lights;if(_clippingEnabled===!0&&(_localClippingEnabled===!0||camera!==_currentCamera)){const useCache=camera===_currentCamera&&material.id===_currentMaterialId;clipping.setState(material,camera,useCache)}let needsProgramChange=!1;material.version===materialProperties.__version?(materialProperties.needsLights&&materialProperties.lightsStateVersion!==lights.state.version||materialProperties.outputColorSpace!==colorSpace||object.isInstancedMesh&&materialProperties.instancing===!1||!object.isInstancedMesh&&materialProperties.instancing===!0||object.isSkinnedMesh&&materialProperties.skinning===!1||!object.isSkinnedMesh&&materialProperties.skinning===!0||object.isInstancedMesh&&materialProperties.instancingColor===!0&&object.instanceColor===null||object.isInstancedMesh&&materialProperties.instancingColor===!1&&object.instanceColor!==null||materialProperties.envMap!==envMap||material.fog===!0&&materialProperties.fog!==fog||materialProperties.numClippingPlanes!==void 0&&(materialProperties.numClippingPlanes!==clipping.numPlanes||materialProperties.numIntersection!==clipping.numIntersection)||materialProperties.vertexAlphas!==vertexAlphas||materialProperties.vertexTangents!==vertexTangents||materialProperties.morphTargets!==morphTargets||materialProperties.morphNormals!==morphNormals||materialProperties.morphColors!==morphColors||materialProperties.toneMapping!==toneMapping||capabilities.isWebGL2===!0&&materialProperties.morphTargetsCount!==morphTargetsCount)&&(needsProgramChange=!0):(needsProgramChange=!0,materialProperties.__version=material.version);let program=materialProperties.currentProgram;needsProgramChange===!0&&(program=getProgram(material,scene2,object));let refreshProgram=!1,refreshMaterial=!1,refreshLights=!1;const p_uniforms=program.getUniforms(),m_uniforms=materialProperties.uniforms;if(state.useProgram(program.program)&&(refreshProgram=!0,refreshMaterial=!0,refreshLights=!0),material.id!==_currentMaterialId&&(_currentMaterialId=material.id,refreshMaterial=!0),refreshProgram||_currentCamera!==camera){p_uniforms.setValue(_gl,"projectionMatrix",camera.projectionMatrix),p_uniforms.setValue(_gl,"viewMatrix",camera.matrixWorldInverse);const uCamPos=p_uniforms.map.cameraPosition;uCamPos!==void 0&&uCamPos.setValue(_gl,_vector32.setFromMatrixPosition(camera.matrixWorld)),capabilities.logarithmicDepthBuffer&&p_uniforms.setValue(_gl,"logDepthBufFC",2/(Math.log(camera.far+1)/Math.LN2)),(material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial)&&p_uniforms.setValue(_gl,"isOrthographic",camera.isOrthographicCamera===!0),_currentCamera!==camera&&(_currentCamera=camera,refreshMaterial=!0,refreshLights=!0)}if(object.isSkinnedMesh){p_uniforms.setOptional(_gl,object,"bindMatrix"),p_uniforms.setOptional(_gl,object,"bindMatrixInverse");const skeleton=object.skeleton;skeleton&&(capabilities.floatVertexTextures?(skeleton.boneTexture===null&&skeleton.computeBoneTexture(),p_uniforms.setValue(_gl,"boneTexture",skeleton.boneTexture,textures),p_uniforms.setValue(_gl,"boneTextureSize",skeleton.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const morphAttributes=geometry.morphAttributes;if((morphAttributes.position!==void 0||morphAttributes.normal!==void 0||morphAttributes.color!==void 0&&capabilities.isWebGL2===!0)&&morphtargets.update(object,geometry,program),(refreshMaterial||materialProperties.receiveShadow!==object.receiveShadow)&&(materialProperties.receiveShadow=object.receiveShadow,p_uniforms.setValue(_gl,"receiveShadow",object.receiveShadow)),material.isMeshGouraudMaterial&&material.envMap!==null&&(m_uniforms.envMap.value=envMap,m_uniforms.flipEnvMap.value=envMap.isCubeTexture&&envMap.isRenderTargetTexture===!1?-1:1),refreshMaterial&&(p_uniforms.setValue(_gl,"toneMappingExposure",_this.toneMappingExposure),materialProperties.needsLights&&markUniformsLightsNeedsUpdate(m_uniforms,refreshLights),fog&&material.fog===!0&&materials.refreshFogUniforms(m_uniforms,fog),materials.refreshMaterialUniforms(m_uniforms,material,_pixelRatio,_height,_transmissionRenderTarget),WebGLUniforms.upload(_gl,getUniformList(materialProperties),m_uniforms,textures)),material.isShaderMaterial&&material.uniformsNeedUpdate===!0&&(WebGLUniforms.upload(_gl,getUniformList(materialProperties),m_uniforms,textures),material.uniformsNeedUpdate=!1),material.isSpriteMaterial&&p_uniforms.setValue(_gl,"center",object.center),p_uniforms.setValue(_gl,"modelViewMatrix",object.modelViewMatrix),p_uniforms.setValue(_gl,"normalMatrix",object.normalMatrix),p_uniforms.setValue(_gl,"modelMatrix",object.matrixWorld),material.isShaderMaterial||material.isRawShaderMaterial){const groups=material.uniformsGroups;for(let i2=0,l2=groups.length;i2<l2;i2++)if(capabilities.isWebGL2){const group=groups[i2];uniformsGroups.update(group,program),uniformsGroups.bind(group,program)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return program}function markUniformsLightsNeedsUpdate(uniforms,value){uniforms.ambientLightColor.needsUpdate=value,uniforms.lightProbe.needsUpdate=value,uniforms.directionalLights.needsUpdate=value,uniforms.directionalLightShadows.needsUpdate=value,uniforms.pointLights.needsUpdate=value,uniforms.pointLightShadows.needsUpdate=value,uniforms.spotLights.needsUpdate=value,uniforms.spotLightShadows.needsUpdate=value,uniforms.rectAreaLights.needsUpdate=value,uniforms.hemisphereLights.needsUpdate=value}function materialNeedsLights(material){return material.isMeshLambertMaterial||material.isMeshToonMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.isShadowMaterial||material.isShaderMaterial&&material.lights===!0}this.getActiveCubeFace=function(){return _currentActiveCubeFace},this.getActiveMipmapLevel=function(){return _currentActiveMipmapLevel},this.getRenderTarget=function(){return _currentRenderTarget},this.setRenderTargetTextures=function(renderTarget,colorTexture,depthTexture){properties.get(renderTarget.texture).__webglTexture=colorTexture,properties.get(renderTarget.depthTexture).__webglTexture=depthTexture;const renderTargetProperties=properties.get(renderTarget);renderTargetProperties.__hasExternalTextures=!0,renderTargetProperties.__hasExternalTextures&&(renderTargetProperties.__autoAllocateDepthBuffer=depthTexture===void 0,renderTargetProperties.__autoAllocateDepthBuffer||extensions2.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),renderTargetProperties.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(renderTarget,defaultFramebuffer){const renderTargetProperties=properties.get(renderTarget);renderTargetProperties.__webglFramebuffer=defaultFramebuffer,renderTargetProperties.__useDefaultFramebuffer=defaultFramebuffer===void 0},this.setRenderTarget=function(renderTarget,activeCubeFace=0,activeMipmapLevel=0){_currentRenderTarget=renderTarget,_currentActiveCubeFace=activeCubeFace,_currentActiveMipmapLevel=activeMipmapLevel;let useDefaultFramebuffer=!0,framebuffer=null,isCube=!1,isRenderTarget3D=!1;if(renderTarget){const renderTargetProperties=properties.get(renderTarget);renderTargetProperties.__useDefaultFramebuffer!==void 0?(state.bindFramebuffer(_gl.FRAMEBUFFER,null),useDefaultFramebuffer=!1):renderTargetProperties.__webglFramebuffer===void 0?textures.setupRenderTarget(renderTarget):renderTargetProperties.__hasExternalTextures&&textures.rebindTextures(renderTarget,properties.get(renderTarget.texture).__webglTexture,properties.get(renderTarget.depthTexture).__webglTexture);const texture=renderTarget.texture;(texture.isData3DTexture||texture.isDataArrayTexture||texture.isCompressedArrayTexture)&&(isRenderTarget3D=!0);const __webglFramebuffer=properties.get(renderTarget).__webglFramebuffer;renderTarget.isWebGLCubeRenderTarget?(Array.isArray(__webglFramebuffer[activeCubeFace])?framebuffer=__webglFramebuffer[activeCubeFace][activeMipmapLevel]:framebuffer=__webglFramebuffer[activeCubeFace],isCube=!0):capabilities.isWebGL2&&renderTarget.samples>0&&textures.useMultisampledRTT(renderTarget)===!1?framebuffer=properties.get(renderTarget).__webglMultisampledFramebuffer:Array.isArray(__webglFramebuffer)?framebuffer=__webglFramebuffer[activeMipmapLevel]:framebuffer=__webglFramebuffer,_currentViewport.copy(renderTarget.viewport),_currentScissor.copy(renderTarget.scissor),_currentScissorTest=renderTarget.scissorTest}else _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor(),_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor(),_currentScissorTest=_scissorTest;if(state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer)&&capabilities.drawBuffers&&useDefaultFramebuffer&&state.drawBuffers(renderTarget,framebuffer),state.viewport(_currentViewport),state.scissor(_currentScissor),state.setScissorTest(_currentScissorTest),isCube){const textureProperties=properties.get(renderTarget.texture);_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+activeCubeFace,textureProperties.__webglTexture,activeMipmapLevel)}else if(isRenderTarget3D){const textureProperties=properties.get(renderTarget.texture),layer=activeCubeFace||0;_gl.framebufferTextureLayer(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,textureProperties.__webglTexture,activeMipmapLevel||0,layer)}_currentMaterialId=-1},this.readRenderTargetPixels=function(renderTarget,x2,y2,width,height,buffer,activeCubeFaceIndex){if(!(renderTarget&&renderTarget.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let framebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget&&activeCubeFaceIndex!==void 0&&(framebuffer=framebuffer[activeCubeFaceIndex]),framebuffer){state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);try{const texture=renderTarget.texture,textureFormat=texture.format,textureType=texture.type;if(textureFormat!==RGBAFormat&&utils.convert(textureFormat)!==_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const halfFloatSupportedByExt=textureType===HalfFloatType&&(extensions2.has("EXT_color_buffer_half_float")||capabilities.isWebGL2&&extensions2.has("EXT_color_buffer_float"));if(textureType!==UnsignedByteType&&utils.convert(textureType)!==_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE)&&!(textureType===FloatType&&(capabilities.isWebGL2||extensions2.has("OES_texture_float")||extensions2.has("WEBGL_color_buffer_float")))&&!halfFloatSupportedByExt){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}x2>=0&&x2<=renderTarget.width-width&&y2>=0&&y2<=renderTarget.height-height&&_gl.readPixels(x2,y2,width,height,utils.convert(textureFormat),utils.convert(textureType),buffer)}finally{const framebuffer2=_currentRenderTarget!==null?properties.get(_currentRenderTarget).__webglFramebuffer:null;state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer2)}}},this.copyFramebufferToTexture=function(position,texture,level=0){const levelScale=Math.pow(2,-level),width=Math.floor(texture.image.width*levelScale),height=Math.floor(texture.image.height*levelScale);textures.setTexture2D(texture,0),_gl.copyTexSubImage2D(_gl.TEXTURE_2D,level,0,0,position.x,position.y,width,height),state.unbindTexture()},this.copyTextureToTexture=function(position,srcTexture,dstTexture,level=0){const width=srcTexture.image.width,height=srcTexture.image.height,glFormat=utils.convert(dstTexture.format),glType=utils.convert(dstTexture.type);textures.setTexture2D(dstTexture,0),_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,dstTexture.flipY),_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,dstTexture.premultiplyAlpha),_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,dstTexture.unpackAlignment),srcTexture.isDataTexture?_gl.texSubImage2D(_gl.TEXTURE_2D,level,position.x,position.y,width,height,glFormat,glType,srcTexture.image.data):srcTexture.isCompressedTexture?_gl.compressedTexSubImage2D(_gl.TEXTURE_2D,level,position.x,position.y,srcTexture.mipmaps[0].width,srcTexture.mipmaps[0].height,glFormat,srcTexture.mipmaps[0].data):_gl.texSubImage2D(_gl.TEXTURE_2D,level,position.x,position.y,glFormat,glType,srcTexture.image),level===0&&dstTexture.generateMipmaps&&_gl.generateMipmap(_gl.TEXTURE_2D),state.unbindTexture()},this.copyTextureToTexture3D=function(sourceBox,position,srcTexture,dstTexture,level=0){if(_this.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const width=sourceBox.max.x-sourceBox.min.x+1,height=sourceBox.max.y-sourceBox.min.y+1,depth2=sourceBox.max.z-sourceBox.min.z+1,glFormat=utils.convert(dstTexture.format),glType=utils.convert(dstTexture.type);let glTarget;if(dstTexture.isData3DTexture)textures.setTexture3D(dstTexture,0),glTarget=_gl.TEXTURE_3D;else if(dstTexture.isDataArrayTexture)textures.setTexture2DArray(dstTexture,0),glTarget=_gl.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,dstTexture.flipY),_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,dstTexture.premultiplyAlpha),_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,dstTexture.unpackAlignment);const unpackRowLen=_gl.getParameter(_gl.UNPACK_ROW_LENGTH),unpackImageHeight=_gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT),unpackSkipPixels=_gl.getParameter(_gl.UNPACK_SKIP_PIXELS),unpackSkipRows=_gl.getParameter(_gl.UNPACK_SKIP_ROWS),unpackSkipImages=_gl.getParameter(_gl.UNPACK_SKIP_IMAGES),image=srcTexture.isCompressedTexture?srcTexture.mipmaps[0]:srcTexture.image;_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH,image.width),_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT,image.height),_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS,sourceBox.min.x),_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS,sourceBox.min.y),_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES,sourceBox.min.z),srcTexture.isDataTexture||srcTexture.isData3DTexture?_gl.texSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth2,glFormat,glType,image.data):srcTexture.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),_gl.compressedTexSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth2,glFormat,image.data)):_gl.texSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth2,glFormat,glType,image),_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH,unpackRowLen),_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT,unpackImageHeight),_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS,unpackSkipPixels),_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS,unpackSkipRows),_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES,unpackSkipImages),level===0&&dstTexture.generateMipmaps&&_gl.generateMipmap(glTarget),state.unbindTexture()},this.initTexture=function(texture){texture.isCubeTexture?textures.setTextureCube(texture,0):texture.isData3DTexture?textures.setTexture3D(texture,0):texture.isDataArrayTexture||texture.isCompressedArrayTexture?textures.setTexture2DArray(texture,0):textures.setTexture2D(texture,0),state.unbindTexture()},this.resetState=function(){_currentActiveCubeFace=0,_currentActiveMipmapLevel=0,_currentRenderTarget=null,state.reset(),bindingStates.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return WebGLCoordinateSystem}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(colorSpace){this._outputColorSpace=colorSpace;const gl=this.getContext();gl.drawingBufferColorSpace=colorSpace===DisplayP3ColorSpace?"display-p3":"srgb",gl.unpackColorSpace=ColorManagement.workingColorSpace===LinearDisplayP3ColorSpace?"display-p3":"srgb"}get physicallyCorrectLights(){return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),!this.useLegacyLights}set physicallyCorrectLights(value){console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),this.useLegacyLights=!value}get outputEncoding(){return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace===SRGBColorSpace?sRGBEncoding:LinearEncoding}set outputEncoding(encoding){console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace=encoding===sRGBEncoding?SRGBColorSpace:LinearSRGBColorSpace}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(value){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=value}}class WebGL1Renderer extends WebGLRenderer{}WebGL1Renderer.prototype.isWebGL1Renderer=!0;class FogExp2{constructor(color2,density=25e-5){this.isFogExp2=!0,this.name="",this.color=new Color(color2),this.density=density}clone(){return new FogExp2(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class Fog{constructor(color2,near=1,far=1e3){this.isFog=!0,this.name="",this.color=new Color(color2),this.near=near,this.far=far}clone(){return new Fog(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}let Scene$1=class extends Object3D{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(source,recursive){return super.copy(source,recursive),source.background!==null&&(this.background=source.background.clone()),source.environment!==null&&(this.environment=source.environment.clone()),source.fog!==null&&(this.fog=source.fog.clone()),this.backgroundBlurriness=source.backgroundBlurriness,this.backgroundIntensity=source.backgroundIntensity,source.overrideMaterial!==null&&(this.overrideMaterial=source.overrideMaterial.clone()),this.matrixAutoUpdate=source.matrixAutoUpdate,this}toJSON(meta){const data=super.toJSON(meta);return this.fog!==null&&(data.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(data.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(data.object.backgroundIntensity=this.backgroundIntensity),data}};class InterleavedBuffer{constructor(array,stride){this.isInterleavedBuffer=!0,this.array=array,this.stride=stride,this.count=array!==void 0?array.length/stride:0,this.usage=StaticDrawUsage,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=generateUUID()}onUploadCallback(){}set needsUpdate(value){value===!0&&this.version++}setUsage(value){return this.usage=value,this}copy(source){return this.array=new source.array.constructor(source.array),this.count=source.count,this.stride=source.stride,this.usage=source.usage,this}copyAt(index1,attribute,index2){index1*=this.stride,index2*=attribute.stride;for(let i2=0,l2=this.stride;i2<l2;i2++)this.array[index1+i2]=attribute.array[index2+i2];return this}set(value,offset=0){return this.array.set(value,offset),this}clone(data){data.arrayBuffers===void 0&&(data.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=generateUUID()),data.arrayBuffers[this.array.buffer._uuid]===void 0&&(data.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const array=new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]),ib=new this.constructor(array,this.stride);return ib.setUsage(this.usage),ib}onUpload(callback){return this.onUploadCallback=callback,this}toJSON(data){return data.arrayBuffers===void 0&&(data.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=generateUUID()),data.arrayBuffers[this.array.buffer._uuid]===void 0&&(data.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const _vector$5=new Vector3;class InterleavedBufferAttribute{constructor(interleavedBuffer,itemSize,offset,normalized=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=interleavedBuffer,this.itemSize=itemSize,this.offset=offset,this.normalized=normalized}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(value){this.data.needsUpdate=value}applyMatrix4(m2){for(let i2=0,l2=this.data.count;i2<l2;i2++)_vector$5.fromBufferAttribute(this,i2),_vector$5.applyMatrix4(m2),this.setXYZ(i2,_vector$5.x,_vector$5.y,_vector$5.z);return this}applyNormalMatrix(m2){for(let i2=0,l2=this.count;i2<l2;i2++)_vector$5.fromBufferAttribute(this,i2),_vector$5.applyNormalMatrix(m2),this.setXYZ(i2,_vector$5.x,_vector$5.y,_vector$5.z);return this}transformDirection(m2){for(let i2=0,l2=this.count;i2<l2;i2++)_vector$5.fromBufferAttribute(this,i2),_vector$5.transformDirection(m2),this.setXYZ(i2,_vector$5.x,_vector$5.y,_vector$5.z);return this}setX(index,x2){return this.normalized&&(x2=normalize(x2,this.array)),this.data.array[index*this.data.stride+this.offset]=x2,this}setY(index,y2){return this.normalized&&(y2=normalize(y2,this.array)),this.data.array[index*this.data.stride+this.offset+1]=y2,this}setZ(index,z){return this.normalized&&(z=normalize(z,this.array)),this.data.array[index*this.data.stride+this.offset+2]=z,this}setW(index,w2){return this.normalized&&(w2=normalize(w2,this.array)),this.data.array[index*this.data.stride+this.offset+3]=w2,this}getX(index){let x2=this.data.array[index*this.data.stride+this.offset];return this.normalized&&(x2=denormalize(x2,this.array)),x2}getY(index){let y2=this.data.array[index*this.data.stride+this.offset+1];return this.normalized&&(y2=denormalize(y2,this.array)),y2}getZ(index){let z=this.data.array[index*this.data.stride+this.offset+2];return this.normalized&&(z=denormalize(z,this.array)),z}getW(index){let w2=this.data.array[index*this.data.stride+this.offset+3];return this.normalized&&(w2=denormalize(w2,this.array)),w2}setXY(index,x2,y2){return index=index*this.data.stride+this.offset,this.normalized&&(x2=normalize(x2,this.array),y2=normalize(y2,this.array)),this.data.array[index+0]=x2,this.data.array[index+1]=y2,this}setXYZ(index,x2,y2,z){return index=index*this.data.stride+this.offset,this.normalized&&(x2=normalize(x2,this.array),y2=normalize(y2,this.array),z=normalize(z,this.array)),this.data.array[index+0]=x2,this.data.array[index+1]=y2,this.data.array[index+2]=z,this}setXYZW(index,x2,y2,z,w2){return index=index*this.data.stride+this.offset,this.normalized&&(x2=normalize(x2,this.array),y2=normalize(y2,this.array),z=normalize(z,this.array),w2=normalize(w2,this.array)),this.data.array[index+0]=x2,this.data.array[index+1]=y2,this.data.array[index+2]=z,this.data.array[index+3]=w2,this}clone(data){if(data===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const array=[];for(let i2=0;i2<this.count;i2++){const index=i2*this.data.stride+this.offset;for(let j2=0;j2<this.itemSize;j2++)array.push(this.data.array[index+j2])}return new BufferAttribute(new this.array.constructor(array),this.itemSize,this.normalized)}else return data.interleavedBuffers===void 0&&(data.interleavedBuffers={}),data.interleavedBuffers[this.data.uuid]===void 0&&(data.interleavedBuffers[this.data.uuid]=this.data.clone(data)),new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(data){if(data===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const array=[];for(let i2=0;i2<this.count;i2++){const index=i2*this.data.stride+this.offset;for(let j2=0;j2<this.itemSize;j2++)array.push(this.data.array[index+j2])}return{itemSize:this.itemSize,type:this.array.constructor.name,array,normalized:this.normalized}}else return data.interleavedBuffers===void 0&&(data.interleavedBuffers={}),data.interleavedBuffers[this.data.uuid]===void 0&&(data.interleavedBuffers[this.data.uuid]=this.data.toJSON(data)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class SpriteMaterial extends Material{constructor(parameters){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.map=source.map,this.alphaMap=source.alphaMap,this.rotation=source.rotation,this.sizeAttenuation=source.sizeAttenuation,this.fog=source.fog,this}}let _geometry;const _intersectPoint=new Vector3,_worldScale=new Vector3,_mvPosition=new Vector3,_alignedPosition=new Vector2,_rotatedPosition=new Vector2,_viewWorldMatrix=new Matrix4,_vA=new Vector3,_vB=new Vector3,_vC=new Vector3,_uvA=new Vector2,_uvB=new Vector2,_uvC=new Vector2;class Sprite extends Object3D{constructor(material=new SpriteMaterial){if(super(),this.isSprite=!0,this.type="Sprite",_geometry===void 0){_geometry=new BufferGeometry;const float32Array=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),interleavedBuffer=new InterleavedBuffer(float32Array,5);_geometry.setIndex([0,1,2,0,2,3]),_geometry.setAttribute("position",new InterleavedBufferAttribute(interleavedBuffer,3,0,!1)),_geometry.setAttribute("uv",new InterleavedBufferAttribute(interleavedBuffer,2,3,!1))}this.geometry=_geometry,this.material=material,this.center=new Vector2(.5,.5)}raycast(raycaster,intersects2){raycaster.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),_worldScale.setFromMatrixScale(this.matrixWorld),_viewWorldMatrix.copy(raycaster.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse,this.matrixWorld),_mvPosition.setFromMatrixPosition(this.modelViewMatrix),raycaster.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&_worldScale.multiplyScalar(-_mvPosition.z);const rotation=this.material.rotation;let sin,cos;rotation!==0&&(cos=Math.cos(rotation),sin=Math.sin(rotation));const center=this.center;transformVertex(_vA.set(-.5,-.5,0),_mvPosition,center,_worldScale,sin,cos),transformVertex(_vB.set(.5,-.5,0),_mvPosition,center,_worldScale,sin,cos),transformVertex(_vC.set(.5,.5,0),_mvPosition,center,_worldScale,sin,cos),_uvA.set(0,0),_uvB.set(1,0),_uvC.set(1,1);let intersect=raycaster.ray.intersectTriangle(_vA,_vB,_vC,!1,_intersectPoint);if(intersect===null&&(transformVertex(_vB.set(-.5,.5,0),_mvPosition,center,_worldScale,sin,cos),_uvB.set(0,1),intersect=raycaster.ray.intersectTriangle(_vA,_vC,_vB,!1,_intersectPoint),intersect===null))return;const distance2=raycaster.ray.origin.distanceTo(_intersectPoint);distance2<raycaster.near||distance2>raycaster.far||intersects2.push({distance:distance2,point:_intersectPoint.clone(),uv:Triangle.getInterpolation(_intersectPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new Vector2),face:null,object:this})}copy(source,recursive){return super.copy(source,recursive),source.center!==void 0&&this.center.copy(source.center),this.material=source.material,this}}function transformVertex(vertexPosition,mvPosition,center,scale2,sin,cos){_alignedPosition.subVectors(vertexPosition,center).addScalar(.5).multiply(scale2),sin!==void 0?(_rotatedPosition.x=cos*_alignedPosition.x-sin*_alignedPosition.y,_rotatedPosition.y=sin*_alignedPosition.x+cos*_alignedPosition.y):_rotatedPosition.copy(_alignedPosition),vertexPosition.copy(mvPosition),vertexPosition.x+=_rotatedPosition.x,vertexPosition.y+=_rotatedPosition.y,vertexPosition.applyMatrix4(_viewWorldMatrix)}const _v1$2=new Vector3,_v2$1=new Vector3;class LOD extends Object3D{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(source){super.copy(source,!1);const levels=source.levels;for(let i2=0,l2=levels.length;i2<l2;i2++){const level=levels[i2];this.addLevel(level.object.clone(),level.distance,level.hysteresis)}return this.autoUpdate=source.autoUpdate,this}addLevel(object,distance2=0,hysteresis=0){distance2=Math.abs(distance2);const levels=this.levels;let l2;for(l2=0;l2<levels.length&&!(distance2<levels[l2].distance);l2++);return levels.splice(l2,0,{distance:distance2,hysteresis,object}),this.add(object),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(distance2){const levels=this.levels;if(levels.length>0){let i2,l2;for(i2=1,l2=levels.length;i2<l2;i2++){let levelDistance=levels[i2].distance;if(levels[i2].object.visible&&(levelDistance-=levelDistance*levels[i2].hysteresis),distance2<levelDistance)break}return levels[i2-1].object}return null}raycast(raycaster,intersects2){if(this.levels.length>0){_v1$2.setFromMatrixPosition(this.matrixWorld);const distance2=raycaster.ray.origin.distanceTo(_v1$2);this.getObjectForDistance(distance2).raycast(raycaster,intersects2)}}update(camera){const levels=this.levels;if(levels.length>1){_v1$2.setFromMatrixPosition(camera.matrixWorld),_v2$1.setFromMatrixPosition(this.matrixWorld);const distance2=_v1$2.distanceTo(_v2$1)/camera.zoom;levels[0].object.visible=!0;let i2,l2;for(i2=1,l2=levels.length;i2<l2;i2++){let levelDistance=levels[i2].distance;if(levels[i2].object.visible&&(levelDistance-=levelDistance*levels[i2].hysteresis),distance2>=levelDistance)levels[i2-1].object.visible=!1,levels[i2].object.visible=!0;else break}for(this._currentLevel=i2-1;i2<l2;i2++)levels[i2].object.visible=!1}}toJSON(meta){const data=super.toJSON(meta);this.autoUpdate===!1&&(data.object.autoUpdate=!1),data.object.levels=[];const levels=this.levels;for(let i2=0,l2=levels.length;i2<l2;i2++){const level=levels[i2];data.object.levels.push({object:level.object.uuid,distance:level.distance,hysteresis:level.hysteresis})}return data}}const _basePosition=new Vector3,_skinIndex=new Vector4,_skinWeight=new Vector4,_vector3=new Vector3,_matrix4=new Matrix4,_vertex=new Vector3,_sphere$3=new Sphere,_inverseMatrix$2=new Matrix4,_ray$2=new Ray;class SkinnedMesh extends Mesh{constructor(geometry,material){super(geometry,material),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=AttachedBindMode,this.bindMatrix=new Matrix4,this.bindMatrixInverse=new Matrix4,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const geometry=this.geometry;this.boundingBox===null&&(this.boundingBox=new Box3),this.boundingBox.makeEmpty();const positionAttribute=geometry.getAttribute("position");for(let i2=0;i2<positionAttribute.count;i2++)this.getVertexPosition(i2,_vertex),this.boundingBox.expandByPoint(_vertex)}computeBoundingSphere(){const geometry=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Sphere),this.boundingSphere.makeEmpty();const positionAttribute=geometry.getAttribute("position");for(let i2=0;i2<positionAttribute.count;i2++)this.getVertexPosition(i2,_vertex),this.boundingSphere.expandByPoint(_vertex)}copy(source,recursive){return super.copy(source,recursive),this.bindMode=source.bindMode,this.bindMatrix.copy(source.bindMatrix),this.bindMatrixInverse.copy(source.bindMatrixInverse),this.skeleton=source.skeleton,source.boundingBox!==null&&(this.boundingBox=source.boundingBox.clone()),source.boundingSphere!==null&&(this.boundingSphere=source.boundingSphere.clone()),this}raycast(raycaster,intersects2){const material=this.material,matrixWorld=this.matrixWorld;material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),_sphere$3.copy(this.boundingSphere),_sphere$3.applyMatrix4(matrixWorld),raycaster.ray.intersectsSphere(_sphere$3)!==!1&&(_inverseMatrix$2.copy(matrixWorld).invert(),_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2),!(this.boundingBox!==null&&_ray$2.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(raycaster,intersects2,_ray$2)))}getVertexPosition(index,target){return super.getVertexPosition(index,target),this.applyBoneTransform(index,target),target}bind(skeleton,bindMatrix){this.skeleton=skeleton,bindMatrix===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),bindMatrix=this.matrixWorld),this.bindMatrix.copy(bindMatrix),this.bindMatrixInverse.copy(bindMatrix).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const vector=new Vector4,skinWeight=this.geometry.attributes.skinWeight;for(let i2=0,l2=skinWeight.count;i2<l2;i2++){vector.fromBufferAttribute(skinWeight,i2);const scale2=1/vector.manhattanLength();scale2!==1/0?vector.multiplyScalar(scale2):vector.set(1,0,0,0),skinWeight.setXYZW(i2,vector.x,vector.y,vector.z,vector.w)}}updateMatrixWorld(force){super.updateMatrixWorld(force),this.bindMode===AttachedBindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===DetachedBindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(index,vector){const skeleton=this.skeleton,geometry=this.geometry;_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex,index),_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight,index),_basePosition.copy(vector).applyMatrix4(this.bindMatrix),vector.set(0,0,0);for(let i2=0;i2<4;i2++){const weight=_skinWeight.getComponent(i2);if(weight!==0){const boneIndex=_skinIndex.getComponent(i2);_matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld,skeleton.boneInverses[boneIndex]),vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4),weight)}}return vector.applyMatrix4(this.bindMatrixInverse)}boneTransform(index,vector){return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),this.applyBoneTransform(index,vector)}}class Bone extends Object3D{constructor(){super(),this.isBone=!0,this.type="Bone"}}class DataTexture extends Texture{constructor(data=null,width=1,height=1,format,type,mapping,wrapS,wrapT,magFilter=NearestFilter,minFilter=NearestFilter,anisotropy,colorSpace){super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,colorSpace),this.isDataTexture=!0,this.image={data,width,height},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const _offsetMatrix=new Matrix4,_identityMatrix$1=new Matrix4;class Skeleton{constructor(bones=[],boneInverses=[]){this.uuid=generateUUID(),this.bones=bones.slice(0),this.boneInverses=boneInverses,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.init()}init(){const bones=this.bones,boneInverses=this.boneInverses;if(this.boneMatrices=new Float32Array(bones.length*16),boneInverses.length===0)this.calculateInverses();else if(bones.length!==boneInverses.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let i2=0,il=this.bones.length;i2<il;i2++)this.boneInverses.push(new Matrix4)}}calculateInverses(){this.boneInverses.length=0;for(let i2=0,il=this.bones.length;i2<il;i2++){const inverse=new Matrix4;this.bones[i2]&&inverse.copy(this.bones[i2].matrixWorld).invert(),this.boneInverses.push(inverse)}}pose(){for(let i2=0,il=this.bones.length;i2<il;i2++){const bone=this.bones[i2];bone&&bone.matrixWorld.copy(this.boneInverses[i2]).invert()}for(let i2=0,il=this.bones.length;i2<il;i2++){const bone=this.bones[i2];bone&&(bone.parent&&bone.parent.isBone?(bone.matrix.copy(bone.parent.matrixWorld).invert(),bone.matrix.multiply(bone.matrixWorld)):bone.matrix.copy(bone.matrixWorld),bone.matrix.decompose(bone.position,bone.quaternion,bone.scale))}}update(){const bones=this.bones,boneInverses=this.boneInverses,boneMatrices=this.boneMatrices,boneTexture=this.boneTexture;for(let i2=0,il=bones.length;i2<il;i2++){const matrix=bones[i2]?bones[i2].matrixWorld:_identityMatrix$1;_offsetMatrix.multiplyMatrices(matrix,boneInverses[i2]),_offsetMatrix.toArray(boneMatrices,i2*16)}boneTexture!==null&&(boneTexture.needsUpdate=!0)}clone(){return new Skeleton(this.bones,this.boneInverses)}computeBoneTexture(){let size=Math.sqrt(this.bones.length*4);size=ceilPowerOfTwo(size),size=Math.max(size,4);const boneMatrices=new Float32Array(size*size*4);boneMatrices.set(this.boneMatrices);const boneTexture=new DataTexture(boneMatrices,size,size,RGBAFormat,FloatType);return boneTexture.needsUpdate=!0,this.boneMatrices=boneMatrices,this.boneTexture=boneTexture,this.boneTextureSize=size,this}getBoneByName(name){for(let i2=0,il=this.bones.length;i2<il;i2++){const bone=this.bones[i2];if(bone.name===name)return bone}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(json,bones){this.uuid=json.uuid;for(let i2=0,l2=json.bones.length;i2<l2;i2++){const uuid=json.bones[i2];let bone=bones[uuid];bone===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",uuid),bone=new Bone),this.bones.push(bone),this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i2]))}return this.init(),this}toJSON(){const data={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};data.uuid=this.uuid;const bones=this.bones,boneInverses=this.boneInverses;for(let i2=0,l2=bones.length;i2<l2;i2++){const bone=bones[i2];data.bones.push(bone.uuid);const boneInverse=boneInverses[i2];data.boneInverses.push(boneInverse.toArray())}return data}}class InstancedBufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized,meshPerAttribute=1){super(array,itemSize,normalized),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=meshPerAttribute}copy(source){return super.copy(source),this.meshPerAttribute=source.meshPerAttribute,this}toJSON(){const data=super.toJSON();return data.meshPerAttribute=this.meshPerAttribute,data.isInstancedBufferAttribute=!0,data}}const _instanceLocalMatrix=new Matrix4,_instanceWorldMatrix=new Matrix4,_instanceIntersects=[],_box3=new Box3,_identity=new Matrix4,_mesh=new Mesh,_sphere$2=new Sphere;class InstancedMesh extends Mesh{constructor(geometry,material,count){super(geometry,material),this.isInstancedMesh=!0,this.instanceMatrix=new InstancedBufferAttribute(new Float32Array(count*16),16),this.instanceColor=null,this.count=count,this.boundingBox=null,this.boundingSphere=null;for(let i2=0;i2<count;i2++)this.setMatrixAt(i2,_identity)}computeBoundingBox(){const geometry=this.geometry,count=this.count;this.boundingBox===null&&(this.boundingBox=new Box3),geometry.boundingBox===null&&geometry.computeBoundingBox(),this.boundingBox.makeEmpty();for(let i2=0;i2<count;i2++)this.getMatrixAt(i2,_instanceLocalMatrix),_box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix),this.boundingBox.union(_box3)}computeBoundingSphere(){const geometry=this.geometry,count=this.count;this.boundingSphere===null&&(this.boundingSphere=new Sphere),geometry.boundingSphere===null&&geometry.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let i2=0;i2<count;i2++)this.getMatrixAt(i2,_instanceLocalMatrix),_sphere$2.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix),this.boundingSphere.union(_sphere$2)}copy(source,recursive){return super.copy(source,recursive),this.instanceMatrix.copy(source.instanceMatrix),source.instanceColor!==null&&(this.instanceColor=source.instanceColor.clone()),this.count=source.count,source.boundingBox!==null&&(this.boundingBox=source.boundingBox.clone()),source.boundingSphere!==null&&(this.boundingSphere=source.boundingSphere.clone()),this}getColorAt(index,color2){color2.fromArray(this.instanceColor.array,index*3)}getMatrixAt(index,matrix){matrix.fromArray(this.instanceMatrix.array,index*16)}raycast(raycaster,intersects2){const matrixWorld=this.matrixWorld,raycastTimes=this.count;if(_mesh.geometry=this.geometry,_mesh.material=this.material,_mesh.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),_sphere$2.copy(this.boundingSphere),_sphere$2.applyMatrix4(matrixWorld),raycaster.ray.intersectsSphere(_sphere$2)!==!1))for(let instanceId=0;instanceId<raycastTimes;instanceId++){this.getMatrixAt(instanceId,_instanceLocalMatrix),_instanceWorldMatrix.multiplyMatrices(matrixWorld,_instanceLocalMatrix),_mesh.matrixWorld=_instanceWorldMatrix,_mesh.raycast(raycaster,_instanceIntersects);for(let i2=0,l2=_instanceIntersects.length;i2<l2;i2++){const intersect=_instanceIntersects[i2];intersect.instanceId=instanceId,intersect.object=this,intersects2.push(intersect)}_instanceIntersects.length=0}}setColorAt(index,color2){this.instanceColor===null&&(this.instanceColor=new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count*3),3)),color2.toArray(this.instanceColor.array,index*3)}setMatrixAt(index,matrix){matrix.toArray(this.instanceMatrix.array,index*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class LineBasicMaterial extends Material{constructor(parameters){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Color(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.map=source.map,this.linewidth=source.linewidth,this.linecap=source.linecap,this.linejoin=source.linejoin,this.fog=source.fog,this}}const _start$1=new Vector3,_end$1=new Vector3,_inverseMatrix$1=new Matrix4,_ray$1=new Ray,_sphere$1=new Sphere;class Line extends Object3D{constructor(geometry=new BufferGeometry,material=new LineBasicMaterial){super(),this.isLine=!0,this.type="Line",this.geometry=geometry,this.material=material,this.updateMorphTargets()}copy(source,recursive){return super.copy(source,recursive),this.material=Array.isArray(source.material)?source.material.slice():source.material,this.geometry=source.geometry,this}computeLineDistances(){const geometry=this.geometry;if(geometry.index===null){const positionAttribute=geometry.attributes.position,lineDistances=[0];for(let i2=1,l2=positionAttribute.count;i2<l2;i2++)_start$1.fromBufferAttribute(positionAttribute,i2-1),_end$1.fromBufferAttribute(positionAttribute,i2),lineDistances[i2]=lineDistances[i2-1],lineDistances[i2]+=_start$1.distanceTo(_end$1);geometry.setAttribute("lineDistance",new Float32BufferAttribute(lineDistances,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(raycaster,intersects2){const geometry=this.geometry,matrixWorld=this.matrixWorld,threshold=raycaster.params.Line.threshold,drawRange=geometry.drawRange;if(geometry.boundingSphere===null&&geometry.computeBoundingSphere(),_sphere$1.copy(geometry.boundingSphere),_sphere$1.applyMatrix4(matrixWorld),_sphere$1.radius+=threshold,raycaster.ray.intersectsSphere(_sphere$1)===!1)return;_inverseMatrix$1.copy(matrixWorld).invert(),_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);const localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3),localThresholdSq=localThreshold*localThreshold,vStart=new Vector3,vEnd=new Vector3,interSegment=new Vector3,interRay=new Vector3,step=this.isLineSegments?2:1,index=geometry.index,positionAttribute=geometry.attributes.position;if(index!==null){const start=Math.max(0,drawRange.start),end=Math.min(index.count,drawRange.start+drawRange.count);for(let i2=start,l2=end-1;i2<l2;i2+=step){const a2=index.getX(i2),b2=index.getX(i2+1);if(vStart.fromBufferAttribute(positionAttribute,a2),vEnd.fromBufferAttribute(positionAttribute,b2),_ray$1.distanceSqToSegment(vStart,vEnd,interRay,interSegment)>localThresholdSq)continue;interRay.applyMatrix4(this.matrixWorld);const distance2=raycaster.ray.origin.distanceTo(interRay);distance2<raycaster.near||distance2>raycaster.far||intersects2.push({distance:distance2,point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i2,face:null,faceIndex:null,object:this})}}else{const start=Math.max(0,drawRange.start),end=Math.min(positionAttribute.count,drawRange.start+drawRange.count);for(let i2=start,l2=end-1;i2<l2;i2+=step){if(vStart.fromBufferAttribute(positionAttribute,i2),vEnd.fromBufferAttribute(positionAttribute,i2+1),_ray$1.distanceSqToSegment(vStart,vEnd,interRay,interSegment)>localThresholdSq)continue;interRay.applyMatrix4(this.matrixWorld);const distance2=raycaster.ray.origin.distanceTo(interRay);distance2<raycaster.near||distance2>raycaster.far||intersects2.push({distance:distance2,point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i2,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const morphAttributes=this.geometry.morphAttributes,keys2=Object.keys(morphAttributes);if(keys2.length>0){const morphAttribute=morphAttributes[keys2[0]];if(morphAttribute!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let m2=0,ml=morphAttribute.length;m2<ml;m2++){const name=morphAttribute[m2].name||String(m2);this.morphTargetInfluences.push(0),this.morphTargetDictionary[name]=m2}}}}}const _start=new Vector3,_end=new Vector3;class LineSegments extends Line{constructor(geometry,material){super(geometry,material),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const geometry=this.geometry;if(geometry.index===null){const positionAttribute=geometry.attributes.position,lineDistances=[];for(let i2=0,l2=positionAttribute.count;i2<l2;i2+=2)_start.fromBufferAttribute(positionAttribute,i2),_end.fromBufferAttribute(positionAttribute,i2+1),lineDistances[i2]=i2===0?0:lineDistances[i2-1],lineDistances[i2+1]=lineDistances[i2]+_start.distanceTo(_end);geometry.setAttribute("lineDistance",new Float32BufferAttribute(lineDistances,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class LineLoop extends Line{constructor(geometry,material){super(geometry,material),this.isLineLoop=!0,this.type="LineLoop"}}class PointsMaterial extends Material{constructor(parameters){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.map=source.map,this.alphaMap=source.alphaMap,this.size=source.size,this.sizeAttenuation=source.sizeAttenuation,this.fog=source.fog,this}}const _inverseMatrix=new Matrix4,_ray$4=new Ray,_sphere=new Sphere,_position$2=new Vector3;class Points extends Object3D{constructor(geometry=new BufferGeometry,material=new PointsMaterial){super(),this.isPoints=!0,this.type="Points",this.geometry=geometry,this.material=material,this.updateMorphTargets()}copy(source,recursive){return super.copy(source,recursive),this.material=Array.isArray(source.material)?source.material.slice():source.material,this.geometry=source.geometry,this}raycast(raycaster,intersects2){const geometry=this.geometry,matrixWorld=this.matrixWorld,threshold=raycaster.params.Points.threshold,drawRange=geometry.drawRange;if(geometry.boundingSphere===null&&geometry.computeBoundingSphere(),_sphere.copy(geometry.boundingSphere),_sphere.applyMatrix4(matrixWorld),_sphere.radius+=threshold,raycaster.ray.intersectsSphere(_sphere)===!1)return;_inverseMatrix.copy(matrixWorld).invert(),_ray$4.copy(raycaster.ray).applyMatrix4(_inverseMatrix);const localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3),localThresholdSq=localThreshold*localThreshold,index=geometry.index,positionAttribute=geometry.attributes.position;if(index!==null){const start=Math.max(0,drawRange.start),end=Math.min(index.count,drawRange.start+drawRange.count);for(let i2=start,il=end;i2<il;i2++){const a2=index.getX(i2);_position$2.fromBufferAttribute(positionAttribute,a2),testPoint(_position$2,a2,localThresholdSq,matrixWorld,raycaster,intersects2,this)}}else{const start=Math.max(0,drawRange.start),end=Math.min(positionAttribute.count,drawRange.start+drawRange.count);for(let i2=start,l2=end;i2<l2;i2++)_position$2.fromBufferAttribute(positionAttribute,i2),testPoint(_position$2,i2,localThresholdSq,matrixWorld,raycaster,intersects2,this)}}updateMorphTargets(){const morphAttributes=this.geometry.morphAttributes,keys2=Object.keys(morphAttributes);if(keys2.length>0){const morphAttribute=morphAttributes[keys2[0]];if(morphAttribute!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let m2=0,ml=morphAttribute.length;m2<ml;m2++){const name=morphAttribute[m2].name||String(m2);this.morphTargetInfluences.push(0),this.morphTargetDictionary[name]=m2}}}}}function testPoint(point,index,localThresholdSq,matrixWorld,raycaster,intersects2,object){const rayPointDistanceSq=_ray$4.distanceSqToPoint(point);if(rayPointDistanceSq<localThresholdSq){const intersectPoint=new Vector3;_ray$4.closestPointToPoint(point,intersectPoint),intersectPoint.applyMatrix4(matrixWorld);const distance2=raycaster.ray.origin.distanceTo(intersectPoint);if(distance2<raycaster.near||distance2>raycaster.far)return;intersects2.push({distance:distance2,distanceToRay:Math.sqrt(rayPointDistanceSq),point:intersectPoint,index,face:null,object})}}class VideoTexture extends Texture{constructor(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){super(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy),this.isVideoTexture=!0,this.minFilter=minFilter!==void 0?minFilter:LinearFilter,this.magFilter=magFilter!==void 0?magFilter:LinearFilter,this.generateMipmaps=!1;const scope=this;function updateVideo(){scope.needsUpdate=!0,video.requestVideoFrameCallback(updateVideo)}"requestVideoFrameCallback"in video&&video.requestVideoFrameCallback(updateVideo)}clone(){return new this.constructor(this.image).copy(this)}update(){const video=this.image;"requestVideoFrameCallback"in video===!1&&video.readyState>=video.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class FramebufferTexture extends Texture{constructor(width,height){super({width,height}),this.isFramebufferTexture=!0,this.magFilter=NearestFilter,this.minFilter=NearestFilter,this.generateMipmaps=!1,this.needsUpdate=!0}}class CompressedTexture extends Texture{constructor(mipmaps,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,colorSpace){super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,colorSpace),this.isCompressedTexture=!0,this.image={width,height},this.mipmaps=mipmaps,this.flipY=!1,this.generateMipmaps=!1}}class CompressedArrayTexture extends CompressedTexture{constructor(mipmaps,width,height,depth,format,type){super(mipmaps,width,height,format,type),this.isCompressedArrayTexture=!0,this.image.depth=depth,this.wrapR=ClampToEdgeWrapping}}class CompressedCubeTexture extends CompressedTexture{constructor(images,format,type){super(void 0,images[0].width,images[0].height,format,type,CubeReflectionMapping),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=images}}class CanvasTexture extends Texture{constructor(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){super(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Curve{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(u2,optionalTarget){const t2=this.getUtoTmapping(u2);return this.getPoint(t2,optionalTarget)}getPoints(divisions=5){const points=[];for(let d2=0;d2<=divisions;d2++)points.push(this.getPoint(d2/divisions));return points}getSpacedPoints(divisions=5){const points=[];for(let d2=0;d2<=divisions;d2++)points.push(this.getPointAt(d2/divisions));return points}getLength(){const lengths=this.getLengths();return lengths[lengths.length-1]}getLengths(divisions=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===divisions+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const cache=[];let current,last=this.getPoint(0),sum=0;cache.push(0);for(let p2=1;p2<=divisions;p2++)current=this.getPoint(p2/divisions),sum+=current.distanceTo(last),cache.push(sum),last=current;return this.cacheArcLengths=cache,cache}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(u2,distance2){const arcLengths=this.getLengths();let i2=0;const il=arcLengths.length;let targetArcLength;distance2?targetArcLength=distance2:targetArcLength=u2*arcLengths[il-1];let low=0,high=il-1,comparison;for(;low<=high;)if(i2=Math.floor(low+(high-low)/2),comparison=arcLengths[i2]-targetArcLength,comparison<0)low=i2+1;else if(comparison>0)high=i2-1;else{high=i2;break}if(i2=high,arcLengths[i2]===targetArcLength)return i2/(il-1);const lengthBefore=arcLengths[i2],segmentLength=arcLengths[i2+1]-lengthBefore,segmentFraction=(targetArcLength-lengthBefore)/segmentLength;return(i2+segmentFraction)/(il-1)}getTangent(t2,optionalTarget){let t1=t2-1e-4,t22=t2+1e-4;t1<0&&(t1=0),t22>1&&(t22=1);const pt1=this.getPoint(t1),pt2=this.getPoint(t22),tangent=optionalTarget||(pt1.isVector2?new Vector2:new Vector3);return tangent.copy(pt2).sub(pt1).normalize(),tangent}getTangentAt(u2,optionalTarget){const t2=this.getUtoTmapping(u2);return this.getTangent(t2,optionalTarget)}computeFrenetFrames(segments,closed){const normal=new Vector3,tangents=[],normals=[],binormals=[],vec=new Vector3,mat=new Matrix4;for(let i2=0;i2<=segments;i2++){const u2=i2/segments;tangents[i2]=this.getTangentAt(u2,new Vector3)}normals[0]=new Vector3,binormals[0]=new Vector3;let min=Number.MAX_VALUE;const tx=Math.abs(tangents[0].x),ty=Math.abs(tangents[0].y),tz=Math.abs(tangents[0].z);tx<=min&&(min=tx,normal.set(1,0,0)),ty<=min&&(min=ty,normal.set(0,1,0)),tz<=min&&normal.set(0,0,1),vec.crossVectors(tangents[0],normal).normalize(),normals[0].crossVectors(tangents[0],vec),binormals[0].crossVectors(tangents[0],normals[0]);for(let i2=1;i2<=segments;i2++){if(normals[i2]=normals[i2-1].clone(),binormals[i2]=binormals[i2-1].clone(),vec.crossVectors(tangents[i2-1],tangents[i2]),vec.length()>Number.EPSILON){vec.normalize();const theta=Math.acos(clamp(tangents[i2-1].dot(tangents[i2]),-1,1));normals[i2].applyMatrix4(mat.makeRotationAxis(vec,theta))}binormals[i2].crossVectors(tangents[i2],normals[i2])}if(closed===!0){let theta=Math.acos(clamp(normals[0].dot(normals[segments]),-1,1));theta/=segments,tangents[0].dot(vec.crossVectors(normals[0],normals[segments]))>0&&(theta=-theta);for(let i2=1;i2<=segments;i2++)normals[i2].applyMatrix4(mat.makeRotationAxis(tangents[i2],theta*i2)),binormals[i2].crossVectors(tangents[i2],normals[i2])}return{tangents,normals,binormals}}clone(){return new this.constructor().copy(this)}copy(source){return this.arcLengthDivisions=source.arcLengthDivisions,this}toJSON(){const data={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return data.arcLengthDivisions=this.arcLengthDivisions,data.type=this.type,data}fromJSON(json){return this.arcLengthDivisions=json.arcLengthDivisions,this}}class EllipseCurve extends Curve{constructor(aX=0,aY=0,xRadius=1,yRadius=1,aStartAngle=0,aEndAngle=Math.PI*2,aClockwise=!1,aRotation=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=aX,this.aY=aY,this.xRadius=xRadius,this.yRadius=yRadius,this.aStartAngle=aStartAngle,this.aEndAngle=aEndAngle,this.aClockwise=aClockwise,this.aRotation=aRotation}getPoint(t2,optionalTarget){const point=optionalTarget||new Vector2,twoPi=Math.PI*2;let deltaAngle=this.aEndAngle-this.aStartAngle;const samePoints=Math.abs(deltaAngle)<Number.EPSILON;for(;deltaAngle<0;)deltaAngle+=twoPi;for(;deltaAngle>twoPi;)deltaAngle-=twoPi;deltaAngle<Number.EPSILON&&(samePoints?deltaAngle=0:deltaAngle=twoPi),this.aClockwise===!0&&!samePoints&&(deltaAngle===twoPi?deltaAngle=-twoPi:deltaAngle=deltaAngle-twoPi);const angle=this.aStartAngle+t2*deltaAngle;let x2=this.aX+this.xRadius*Math.cos(angle),y2=this.aY+this.yRadius*Math.sin(angle);if(this.aRotation!==0){const cos=Math.cos(this.aRotation),sin=Math.sin(this.aRotation),tx=x2-this.aX,ty=y2-this.aY;x2=tx*cos-ty*sin+this.aX,y2=tx*sin+ty*cos+this.aY}return point.set(x2,y2)}copy(source){return super.copy(source),this.aX=source.aX,this.aY=source.aY,this.xRadius=source.xRadius,this.yRadius=source.yRadius,this.aStartAngle=source.aStartAngle,this.aEndAngle=source.aEndAngle,this.aClockwise=source.aClockwise,this.aRotation=source.aRotation,this}toJSON(){const data=super.toJSON();return data.aX=this.aX,data.aY=this.aY,data.xRadius=this.xRadius,data.yRadius=this.yRadius,data.aStartAngle=this.aStartAngle,data.aEndAngle=this.aEndAngle,data.aClockwise=this.aClockwise,data.aRotation=this.aRotation,data}fromJSON(json){return super.fromJSON(json),this.aX=json.aX,this.aY=json.aY,this.xRadius=json.xRadius,this.yRadius=json.yRadius,this.aStartAngle=json.aStartAngle,this.aEndAngle=json.aEndAngle,this.aClockwise=json.aClockwise,this.aRotation=json.aRotation,this}}class ArcCurve extends EllipseCurve{constructor(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){super(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise),this.isArcCurve=!0,this.type="ArcCurve"}}function CubicPoly(){let c0=0,c1=0,c2=0,c3=0;function init(x0,x1,t0,t1){c0=x0,c1=t0,c2=-3*x0+3*x1-2*t0-t1,c3=2*x0-2*x1+t0+t1}return{initCatmullRom:function(x0,x1,x2,x3,tension){init(x1,x2,tension*(x2-x0),tension*(x3-x1))},initNonuniformCatmullRom:function(x0,x1,x2,x3,dt0,dt1,dt2){let t1=(x1-x0)/dt0-(x2-x0)/(dt0+dt1)+(x2-x1)/dt1,t2=(x2-x1)/dt1-(x3-x1)/(dt1+dt2)+(x3-x2)/dt2;t1*=dt1,t2*=dt1,init(x1,x2,t1,t2)},calc:function(t2){const t22=t2*t2,t3=t22*t2;return c0+c1*t2+c2*t22+c3*t3}}}const tmp=new Vector3,px=new CubicPoly,py=new CubicPoly,pz=new CubicPoly;class CatmullRomCurve3 extends Curve{constructor(points=[],closed=!1,curveType="centripetal",tension=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=points,this.closed=closed,this.curveType=curveType,this.tension=tension}getPoint(t2,optionalTarget=new Vector3){const point=optionalTarget,points=this.points,l2=points.length,p2=(l2-(this.closed?0:1))*t2;let intPoint=Math.floor(p2),weight=p2-intPoint;this.closed?intPoint+=intPoint>0?0:(Math.floor(Math.abs(intPoint)/l2)+1)*l2:weight===0&&intPoint===l2-1&&(intPoint=l2-2,weight=1);let p0,p3;this.closed||intPoint>0?p0=points[(intPoint-1)%l2]:(tmp.subVectors(points[0],points[1]).add(points[0]),p0=tmp);const p1=points[intPoint%l2],p22=points[(intPoint+1)%l2];if(this.closed||intPoint+2<l2?p3=points[(intPoint+2)%l2]:(tmp.subVectors(points[l2-1],points[l2-2]).add(points[l2-1]),p3=tmp),this.curveType==="centripetal"||this.curveType==="chordal"){const pow=this.curveType==="chordal"?.5:.25;let dt0=Math.pow(p0.distanceToSquared(p1),pow),dt1=Math.pow(p1.distanceToSquared(p22),pow),dt2=Math.pow(p22.distanceToSquared(p3),pow);dt1<1e-4&&(dt1=1),dt0<1e-4&&(dt0=dt1),dt2<1e-4&&(dt2=dt1),px.initNonuniformCatmullRom(p0.x,p1.x,p22.x,p3.x,dt0,dt1,dt2),py.initNonuniformCatmullRom(p0.y,p1.y,p22.y,p3.y,dt0,dt1,dt2),pz.initNonuniformCatmullRom(p0.z,p1.z,p22.z,p3.z,dt0,dt1,dt2)}else this.curveType==="catmullrom"&&(px.initCatmullRom(p0.x,p1.x,p22.x,p3.x,this.tension),py.initCatmullRom(p0.y,p1.y,p22.y,p3.y,this.tension),pz.initCatmullRom(p0.z,p1.z,p22.z,p3.z,this.tension));return point.set(px.calc(weight),py.calc(weight),pz.calc(weight)),point}copy(source){super.copy(source),this.points=[];for(let i2=0,l2=source.points.length;i2<l2;i2++){const point=source.points[i2];this.points.push(point.clone())}return this.closed=source.closed,this.curveType=source.curveType,this.tension=source.tension,this}toJSON(){const data=super.toJSON();data.points=[];for(let i2=0,l2=this.points.length;i2<l2;i2++){const point=this.points[i2];data.points.push(point.toArray())}return data.closed=this.closed,data.curveType=this.curveType,data.tension=this.tension,data}fromJSON(json){super.fromJSON(json),this.points=[];for(let i2=0,l2=json.points.length;i2<l2;i2++){const point=json.points[i2];this.points.push(new Vector3().fromArray(point))}return this.closed=json.closed,this.curveType=json.curveType,this.tension=json.tension,this}}function CatmullRom(t2,p0,p1,p2,p3){const v0=(p2-p0)*.5,v12=(p3-p1)*.5,t22=t2*t2,t3=t2*t22;return(2*p1-2*p2+v0+v12)*t3+(-3*p1+3*p2-2*v0-v12)*t22+v0*t2+p1}function QuadraticBezierP0(t2,p2){const k2=1-t2;return k2*k2*p2}function QuadraticBezierP1(t2,p2){return 2*(1-t2)*t2*p2}function QuadraticBezierP2(t2,p2){return t2*t2*p2}function QuadraticBezier(t2,p0,p1,p2){return QuadraticBezierP0(t2,p0)+QuadraticBezierP1(t2,p1)+QuadraticBezierP2(t2,p2)}function CubicBezierP0(t2,p2){const k2=1-t2;return k2*k2*k2*p2}function CubicBezierP1(t2,p2){const k2=1-t2;return 3*k2*k2*t2*p2}function CubicBezierP2(t2,p2){return 3*(1-t2)*t2*t2*p2}function CubicBezierP3(t2,p2){return t2*t2*t2*p2}function CubicBezier(t2,p0,p1,p2,p3){return CubicBezierP0(t2,p0)+CubicBezierP1(t2,p1)+CubicBezierP2(t2,p2)+CubicBezierP3(t2,p3)}class CubicBezierCurve extends Curve{constructor(v0=new Vector2,v12=new Vector2,v22=new Vector2,v32=new Vector2){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=v0,this.v1=v12,this.v2=v22,this.v3=v32}getPoint(t2,optionalTarget=new Vector2){const point=optionalTarget,v0=this.v0,v12=this.v1,v22=this.v2,v32=this.v3;return point.set(CubicBezier(t2,v0.x,v12.x,v22.x,v32.x),CubicBezier(t2,v0.y,v12.y,v22.y,v32.y)),point}copy(source){return super.copy(source),this.v0.copy(source.v0),this.v1.copy(source.v1),this.v2.copy(source.v2),this.v3.copy(source.v3),this}toJSON(){const data=super.toJSON();return data.v0=this.v0.toArray(),data.v1=this.v1.toArray(),data.v2=this.v2.toArray(),data.v3=this.v3.toArray(),data}fromJSON(json){return super.fromJSON(json),this.v0.fromArray(json.v0),this.v1.fromArray(json.v1),this.v2.fromArray(json.v2),this.v3.fromArray(json.v3),this}}class CubicBezierCurve3 extends Curve{constructor(v0=new Vector3,v12=new Vector3,v22=new Vector3,v32=new Vector3){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=v0,this.v1=v12,this.v2=v22,this.v3=v32}getPoint(t2,optionalTarget=new Vector3){const point=optionalTarget,v0=this.v0,v12=this.v1,v22=this.v2,v32=this.v3;return point.set(CubicBezier(t2,v0.x,v12.x,v22.x,v32.x),CubicBezier(t2,v0.y,v12.y,v22.y,v32.y),CubicBezier(t2,v0.z,v12.z,v22.z,v32.z)),point}copy(source){return super.copy(source),this.v0.copy(source.v0),this.v1.copy(source.v1),this.v2.copy(source.v2),this.v3.copy(source.v3),this}toJSON(){const data=super.toJSON();return data.v0=this.v0.toArray(),data.v1=this.v1.toArray(),data.v2=this.v2.toArray(),data.v3=this.v3.toArray(),data}fromJSON(json){return super.fromJSON(json),this.v0.fromArray(json.v0),this.v1.fromArray(json.v1),this.v2.fromArray(json.v2),this.v3.fromArray(json.v3),this}}class LineCurve extends Curve{constructor(v12=new Vector2,v22=new Vector2){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=v12,this.v2=v22}getPoint(t2,optionalTarget=new Vector2){const point=optionalTarget;return t2===1?point.copy(this.v2):(point.copy(this.v2).sub(this.v1),point.multiplyScalar(t2).add(this.v1)),point}getPointAt(u2,optionalTarget){return this.getPoint(u2,optionalTarget)}getTangent(t2,optionalTarget=new Vector2){return optionalTarget.subVectors(this.v2,this.v1).normalize()}getTangentAt(u2,optionalTarget){return this.getTangent(u2,optionalTarget)}copy(source){return super.copy(source),this.v1.copy(source.v1),this.v2.copy(source.v2),this}toJSON(){const data=super.toJSON();return data.v1=this.v1.toArray(),data.v2=this.v2.toArray(),data}fromJSON(json){return super.fromJSON(json),this.v1.fromArray(json.v1),this.v2.fromArray(json.v2),this}}class LineCurve3 extends Curve{constructor(v12=new Vector3,v22=new Vector3){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=v12,this.v2=v22}getPoint(t2,optionalTarget=new Vector3){const point=optionalTarget;return t2===1?point.copy(this.v2):(point.copy(this.v2).sub(this.v1),point.multiplyScalar(t2).add(this.v1)),point}getPointAt(u2,optionalTarget){return this.getPoint(u2,optionalTarget)}getTangent(t2,optionalTarget=new Vector3){return optionalTarget.subVectors(this.v2,this.v1).normalize()}getTangentAt(u2,optionalTarget){return this.getTangent(u2,optionalTarget)}copy(source){return super.copy(source),this.v1.copy(source.v1),this.v2.copy(source.v2),this}toJSON(){const data=super.toJSON();return data.v1=this.v1.toArray(),data.v2=this.v2.toArray(),data}fromJSON(json){return super.fromJSON(json),this.v1.fromArray(json.v1),this.v2.fromArray(json.v2),this}}class QuadraticBezierCurve extends Curve{constructor(v0=new Vector2,v12=new Vector2,v22=new Vector2){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=v0,this.v1=v12,this.v2=v22}getPoint(t2,optionalTarget=new Vector2){const point=optionalTarget,v0=this.v0,v12=this.v1,v22=this.v2;return point.set(QuadraticBezier(t2,v0.x,v12.x,v22.x),QuadraticBezier(t2,v0.y,v12.y,v22.y)),point}copy(source){return super.copy(source),this.v0.copy(source.v0),this.v1.copy(source.v1),this.v2.copy(source.v2),this}toJSON(){const data=super.toJSON();return data.v0=this.v0.toArray(),data.v1=this.v1.toArray(),data.v2=this.v2.toArray(),data}fromJSON(json){return super.fromJSON(json),this.v0.fromArray(json.v0),this.v1.fromArray(json.v1),this.v2.fromArray(json.v2),this}}class QuadraticBezierCurve3 extends Curve{constructor(v0=new Vector3,v12=new Vector3,v22=new Vector3){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=v0,this.v1=v12,this.v2=v22}getPoint(t2,optionalTarget=new Vector3){const point=optionalTarget,v0=this.v0,v12=this.v1,v22=this.v2;return point.set(QuadraticBezier(t2,v0.x,v12.x,v22.x),QuadraticBezier(t2,v0.y,v12.y,v22.y),QuadraticBezier(t2,v0.z,v12.z,v22.z)),point}copy(source){return super.copy(source),this.v0.copy(source.v0),this.v1.copy(source.v1),this.v2.copy(source.v2),this}toJSON(){const data=super.toJSON();return data.v0=this.v0.toArray(),data.v1=this.v1.toArray(),data.v2=this.v2.toArray(),data}fromJSON(json){return super.fromJSON(json),this.v0.fromArray(json.v0),this.v1.fromArray(json.v1),this.v2.fromArray(json.v2),this}}class SplineCurve extends Curve{constructor(points=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=points}getPoint(t2,optionalTarget=new Vector2){const point=optionalTarget,points=this.points,p2=(points.length-1)*t2,intPoint=Math.floor(p2),weight=p2-intPoint,p0=points[intPoint===0?intPoint:intPoint-1],p1=points[intPoint],p22=points[intPoint>points.length-2?points.length-1:intPoint+1],p3=points[intPoint>points.length-3?points.length-1:intPoint+2];return point.set(CatmullRom(weight,p0.x,p1.x,p22.x,p3.x),CatmullRom(weight,p0.y,p1.y,p22.y,p3.y)),point}copy(source){super.copy(source),this.points=[];for(let i2=0,l2=source.points.length;i2<l2;i2++){const point=source.points[i2];this.points.push(point.clone())}return this}toJSON(){const data=super.toJSON();data.points=[];for(let i2=0,l2=this.points.length;i2<l2;i2++){const point=this.points[i2];data.points.push(point.toArray())}return data}fromJSON(json){super.fromJSON(json),this.points=[];for(let i2=0,l2=json.points.length;i2<l2;i2++){const point=json.points[i2];this.points.push(new Vector2().fromArray(point))}return this}}var Curves=Object.freeze({__proto__:null,ArcCurve,CatmullRomCurve3,CubicBezierCurve,CubicBezierCurve3,EllipseCurve,LineCurve,LineCurve3,QuadraticBezierCurve,QuadraticBezierCurve3,SplineCurve});class CurvePath extends Curve{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(curve){this.curves.push(curve)}closePath(){const startPoint=this.curves[0].getPoint(0),endPoint=this.curves[this.curves.length-1].getPoint(1);if(!startPoint.equals(endPoint)){const lineType=startPoint.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new Curves[lineType](endPoint,startPoint))}return this}getPoint(t2,optionalTarget){const d2=t2*this.getLength(),curveLengths=this.getCurveLengths();let i2=0;for(;i2<curveLengths.length;){if(curveLengths[i2]>=d2){const diff=curveLengths[i2]-d2,curve=this.curves[i2],segmentLength=curve.getLength(),u2=segmentLength===0?0:1-diff/segmentLength;return curve.getPointAt(u2,optionalTarget)}i2++}return null}getLength(){const lens=this.getCurveLengths();return lens[lens.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const lengths=[];let sums=0;for(let i2=0,l2=this.curves.length;i2<l2;i2++)sums+=this.curves[i2].getLength(),lengths.push(sums);return this.cacheLengths=lengths,lengths}getSpacedPoints(divisions=40){const points=[];for(let i2=0;i2<=divisions;i2++)points.push(this.getPoint(i2/divisions));return this.autoClose&&points.push(points[0]),points}getPoints(divisions=12){const points=[];let last;for(let i2=0,curves=this.curves;i2<curves.length;i2++){const curve=curves[i2],resolution=curve.isEllipseCurve?divisions*2:curve.isLineCurve||curve.isLineCurve3?1:curve.isSplineCurve?divisions*curve.points.length:divisions,pts=curve.getPoints(resolution);for(let j2=0;j2<pts.length;j2++){const point=pts[j2];last&&last.equals(point)||(points.push(point),last=point)}}return this.autoClose&&points.length>1&&!points[points.length-1].equals(points[0])&&points.push(points[0]),points}copy(source){super.copy(source),this.curves=[];for(let i2=0,l2=source.curves.length;i2<l2;i2++){const curve=source.curves[i2];this.curves.push(curve.clone())}return this.autoClose=source.autoClose,this}toJSON(){const data=super.toJSON();data.autoClose=this.autoClose,data.curves=[];for(let i2=0,l2=this.curves.length;i2<l2;i2++){const curve=this.curves[i2];data.curves.push(curve.toJSON())}return data}fromJSON(json){super.fromJSON(json),this.autoClose=json.autoClose,this.curves=[];for(let i2=0,l2=json.curves.length;i2<l2;i2++){const curve=json.curves[i2];this.curves.push(new Curves[curve.type]().fromJSON(curve))}return this}}class Path extends CurvePath{constructor(points){super(),this.type="Path",this.currentPoint=new Vector2,points&&this.setFromPoints(points)}setFromPoints(points){this.moveTo(points[0].x,points[0].y);for(let i2=1,l2=points.length;i2<l2;i2++)this.lineTo(points[i2].x,points[i2].y);return this}moveTo(x2,y2){return this.currentPoint.set(x2,y2),this}lineTo(x2,y2){const curve=new LineCurve(this.currentPoint.clone(),new Vector2(x2,y2));return this.curves.push(curve),this.currentPoint.set(x2,y2),this}quadraticCurveTo(aCPx,aCPy,aX,aY){const curve=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(aCPx,aCPy),new Vector2(aX,aY));return this.curves.push(curve),this.currentPoint.set(aX,aY),this}bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){const curve=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(aCP1x,aCP1y),new Vector2(aCP2x,aCP2y),new Vector2(aX,aY));return this.curves.push(curve),this.currentPoint.set(aX,aY),this}splineThru(pts){const npts=[this.currentPoint.clone()].concat(pts),curve=new SplineCurve(npts);return this.curves.push(curve),this.currentPoint.copy(pts[pts.length-1]),this}arc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){const x0=this.currentPoint.x,y0=this.currentPoint.y;return this.absarc(aX+x0,aY+y0,aRadius,aStartAngle,aEndAngle,aClockwise),this}absarc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){return this.absellipse(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise),this}ellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){const x0=this.currentPoint.x,y0=this.currentPoint.y;return this.absellipse(aX+x0,aY+y0,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation),this}absellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){const curve=new EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);if(this.curves.length>0){const firstPoint=curve.getPoint(0);firstPoint.equals(this.currentPoint)||this.lineTo(firstPoint.x,firstPoint.y)}this.curves.push(curve);const lastPoint=curve.getPoint(1);return this.currentPoint.copy(lastPoint),this}copy(source){return super.copy(source),this.currentPoint.copy(source.currentPoint),this}toJSON(){const data=super.toJSON();return data.currentPoint=this.currentPoint.toArray(),data}fromJSON(json){return super.fromJSON(json),this.currentPoint.fromArray(json.currentPoint),this}}class LatheGeometry extends BufferGeometry{constructor(points=[new Vector2(0,-.5),new Vector2(.5,0),new Vector2(0,.5)],segments=12,phiStart=0,phiLength=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points,segments,phiStart,phiLength},segments=Math.floor(segments),phiLength=clamp(phiLength,0,Math.PI*2);const indices=[],vertices=[],uvs=[],initNormals=[],normals=[],inverseSegments=1/segments,vertex2=new Vector3,uv=new Vector2,normal=new Vector3,curNormal=new Vector3,prevNormal=new Vector3;let dx=0,dy=0;for(let j2=0;j2<=points.length-1;j2++)switch(j2){case 0:dx=points[j2+1].x-points[j2].x,dy=points[j2+1].y-points[j2].y,normal.x=dy*1,normal.y=-dx,normal.z=dy*0,prevNormal.copy(normal),normal.normalize(),initNormals.push(normal.x,normal.y,normal.z);break;case points.length-1:initNormals.push(prevNormal.x,prevNormal.y,prevNormal.z);break;default:dx=points[j2+1].x-points[j2].x,dy=points[j2+1].y-points[j2].y,normal.x=dy*1,normal.y=-dx,normal.z=dy*0,curNormal.copy(normal),normal.x+=prevNormal.x,normal.y+=prevNormal.y,normal.z+=prevNormal.z,normal.normalize(),initNormals.push(normal.x,normal.y,normal.z),prevNormal.copy(curNormal)}for(let i2=0;i2<=segments;i2++){const phi=phiStart+i2*inverseSegments*phiLength,sin=Math.sin(phi),cos=Math.cos(phi);for(let j2=0;j2<=points.length-1;j2++){vertex2.x=points[j2].x*sin,vertex2.y=points[j2].y,vertex2.z=points[j2].x*cos,vertices.push(vertex2.x,vertex2.y,vertex2.z),uv.x=i2/segments,uv.y=j2/(points.length-1),uvs.push(uv.x,uv.y);const x2=initNormals[3*j2+0]*sin,y2=initNormals[3*j2+1],z=initNormals[3*j2+0]*cos;normals.push(x2,y2,z)}}for(let i2=0;i2<segments;i2++)for(let j2=0;j2<points.length-1;j2++){const base=j2+i2*points.length,a2=base,b2=base+points.length,c2=base+points.length+1,d2=base+1;indices.push(a2,b2,d2),indices.push(c2,d2,b2)}this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2)),this.setAttribute("normal",new Float32BufferAttribute(normals,3))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new LatheGeometry(data.points,data.segments,data.phiStart,data.phiLength)}}class CapsuleGeometry extends LatheGeometry{constructor(radius=1,length=1,capSegments=4,radialSegments=8){const path2=new Path;path2.absarc(0,-length/2,radius,Math.PI*1.5,0),path2.absarc(0,length/2,radius,0,Math.PI*.5),super(path2.getPoints(capSegments),radialSegments),this.type="CapsuleGeometry",this.parameters={radius,length,capSegments,radialSegments}}static fromJSON(data){return new CapsuleGeometry(data.radius,data.length,data.capSegments,data.radialSegments)}}class CircleGeometry extends BufferGeometry{constructor(radius=1,segments=32,thetaStart=0,thetaLength=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius,segments,thetaStart,thetaLength},segments=Math.max(3,segments);const indices=[],vertices=[],normals=[],uvs=[],vertex2=new Vector3,uv=new Vector2;vertices.push(0,0,0),normals.push(0,0,1),uvs.push(.5,.5);for(let s2=0,i2=3;s2<=segments;s2++,i2+=3){const segment=thetaStart+s2/segments*thetaLength;vertex2.x=radius*Math.cos(segment),vertex2.y=radius*Math.sin(segment),vertices.push(vertex2.x,vertex2.y,vertex2.z),normals.push(0,0,1),uv.x=(vertices[i2]/radius+1)/2,uv.y=(vertices[i2+1]/radius+1)/2,uvs.push(uv.x,uv.y)}for(let i2=1;i2<=segments;i2++)indices.push(i2,i2+1,0);this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new CircleGeometry(data.radius,data.segments,data.thetaStart,data.thetaLength)}}class CylinderGeometry extends BufferGeometry{constructor(radiusTop=1,radiusBottom=1,height=1,radialSegments=32,heightSegments=1,openEnded=!1,thetaStart=0,thetaLength=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength};const scope=this;radialSegments=Math.floor(radialSegments),heightSegments=Math.floor(heightSegments);const indices=[],vertices=[],normals=[],uvs=[];let index=0;const indexArray=[],halfHeight=height/2;let groupStart=0;generateTorso(),openEnded===!1&&(radiusTop>0&&generateCap(!0),radiusBottom>0&&generateCap(!1)),this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2));function generateTorso(){const normal=new Vector3,vertex2=new Vector3;let groupCount=0;const slope=(radiusBottom-radiusTop)/height;for(let y2=0;y2<=heightSegments;y2++){const indexRow=[],v4=y2/heightSegments,radius=v4*(radiusBottom-radiusTop)+radiusTop;for(let x2=0;x2<=radialSegments;x2++){const u2=x2/radialSegments,theta=u2*thetaLength+thetaStart,sinTheta=Math.sin(theta),cosTheta=Math.cos(theta);vertex2.x=radius*sinTheta,vertex2.y=-v4*height+halfHeight,vertex2.z=radius*cosTheta,vertices.push(vertex2.x,vertex2.y,vertex2.z),normal.set(sinTheta,slope,cosTheta).normalize(),normals.push(normal.x,normal.y,normal.z),uvs.push(u2,1-v4),indexRow.push(index++)}indexArray.push(indexRow)}for(let x2=0;x2<radialSegments;x2++)for(let y2=0;y2<heightSegments;y2++){const a2=indexArray[y2][x2],b2=indexArray[y2+1][x2],c2=indexArray[y2+1][x2+1],d2=indexArray[y2][x2+1];indices.push(a2,b2,d2),indices.push(b2,c2,d2),groupCount+=6}scope.addGroup(groupStart,groupCount,0),groupStart+=groupCount}function generateCap(top){const centerIndexStart=index,uv=new Vector2,vertex2=new Vector3;let groupCount=0;const radius=top===!0?radiusTop:radiusBottom,sign2=top===!0?1:-1;for(let x2=1;x2<=radialSegments;x2++)vertices.push(0,halfHeight*sign2,0),normals.push(0,sign2,0),uvs.push(.5,.5),index++;const centerIndexEnd=index;for(let x2=0;x2<=radialSegments;x2++){const theta=x2/radialSegments*thetaLength+thetaStart,cosTheta=Math.cos(theta),sinTheta=Math.sin(theta);vertex2.x=radius*sinTheta,vertex2.y=halfHeight*sign2,vertex2.z=radius*cosTheta,vertices.push(vertex2.x,vertex2.y,vertex2.z),normals.push(0,sign2,0),uv.x=cosTheta*.5+.5,uv.y=sinTheta*.5*sign2+.5,uvs.push(uv.x,uv.y),index++}for(let x2=0;x2<radialSegments;x2++){const c2=centerIndexStart+x2,i2=centerIndexEnd+x2;top===!0?indices.push(i2,i2+1,c2):indices.push(i2+1,i2,c2),groupCount+=3}scope.addGroup(groupStart,groupCount,top===!0?1:2),groupStart+=groupCount}}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new CylinderGeometry(data.radiusTop,data.radiusBottom,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength)}}class ConeGeometry extends CylinderGeometry{constructor(radius=1,height=1,radialSegments=32,heightSegments=1,openEnded=!1,thetaStart=0,thetaLength=Math.PI*2){super(0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength),this.type="ConeGeometry",this.parameters={radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength}}static fromJSON(data){return new ConeGeometry(data.radius,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength)}}class PolyhedronGeometry extends BufferGeometry{constructor(vertices=[],indices=[],radius=1,detail=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices,indices,radius,detail};const vertexBuffer=[],uvBuffer=[];subdivide(detail),applyRadius(radius),generateUVs(),this.setAttribute("position",new Float32BufferAttribute(vertexBuffer,3)),this.setAttribute("normal",new Float32BufferAttribute(vertexBuffer.slice(),3)),this.setAttribute("uv",new Float32BufferAttribute(uvBuffer,2)),detail===0?this.computeVertexNormals():this.normalizeNormals();function subdivide(detail2){const a2=new Vector3,b2=new Vector3,c2=new Vector3;for(let i2=0;i2<indices.length;i2+=3)getVertexByIndex(indices[i2+0],a2),getVertexByIndex(indices[i2+1],b2),getVertexByIndex(indices[i2+2],c2),subdivideFace(a2,b2,c2,detail2)}function subdivideFace(a2,b2,c2,detail2){const cols=detail2+1,v4=[];for(let i2=0;i2<=cols;i2++){v4[i2]=[];const aj=a2.clone().lerp(c2,i2/cols),bj=b2.clone().lerp(c2,i2/cols),rows=cols-i2;for(let j2=0;j2<=rows;j2++)j2===0&&i2===cols?v4[i2][j2]=aj:v4[i2][j2]=aj.clone().lerp(bj,j2/rows)}for(let i2=0;i2<cols;i2++)for(let j2=0;j2<2*(cols-i2)-1;j2++){const k2=Math.floor(j2/2);j2%2===0?(pushVertex(v4[i2][k2+1]),pushVertex(v4[i2+1][k2]),pushVertex(v4[i2][k2])):(pushVertex(v4[i2][k2+1]),pushVertex(v4[i2+1][k2+1]),pushVertex(v4[i2+1][k2]))}}function applyRadius(radius2){const vertex2=new Vector3;for(let i2=0;i2<vertexBuffer.length;i2+=3)vertex2.x=vertexBuffer[i2+0],vertex2.y=vertexBuffer[i2+1],vertex2.z=vertexBuffer[i2+2],vertex2.normalize().multiplyScalar(radius2),vertexBuffer[i2+0]=vertex2.x,vertexBuffer[i2+1]=vertex2.y,vertexBuffer[i2+2]=vertex2.z}function generateUVs(){const vertex2=new Vector3;for(let i2=0;i2<vertexBuffer.length;i2+=3){vertex2.x=vertexBuffer[i2+0],vertex2.y=vertexBuffer[i2+1],vertex2.z=vertexBuffer[i2+2];const u2=azimuth(vertex2)/2/Math.PI+.5,v4=inclination(vertex2)/Math.PI+.5;uvBuffer.push(u2,1-v4)}correctUVs(),correctSeam()}function correctSeam(){for(let i2=0;i2<uvBuffer.length;i2+=6){const x0=uvBuffer[i2+0],x1=uvBuffer[i2+2],x2=uvBuffer[i2+4],max2=Math.max(x0,x1,x2),min=Math.min(x0,x1,x2);max2>.9&&min<.1&&(x0<.2&&(uvBuffer[i2+0]+=1),x1<.2&&(uvBuffer[i2+2]+=1),x2<.2&&(uvBuffer[i2+4]+=1))}}function pushVertex(vertex2){vertexBuffer.push(vertex2.x,vertex2.y,vertex2.z)}function getVertexByIndex(index,vertex2){const stride=index*3;vertex2.x=vertices[stride+0],vertex2.y=vertices[stride+1],vertex2.z=vertices[stride+2]}function correctUVs(){const a2=new Vector3,b2=new Vector3,c2=new Vector3,centroid=new Vector3,uvA=new Vector2,uvB=new Vector2,uvC=new Vector2;for(let i2=0,j2=0;i2<vertexBuffer.length;i2+=9,j2+=6){a2.set(vertexBuffer[i2+0],vertexBuffer[i2+1],vertexBuffer[i2+2]),b2.set(vertexBuffer[i2+3],vertexBuffer[i2+4],vertexBuffer[i2+5]),c2.set(vertexBuffer[i2+6],vertexBuffer[i2+7],vertexBuffer[i2+8]),uvA.set(uvBuffer[j2+0],uvBuffer[j2+1]),uvB.set(uvBuffer[j2+2],uvBuffer[j2+3]),uvC.set(uvBuffer[j2+4],uvBuffer[j2+5]),centroid.copy(a2).add(b2).add(c2).divideScalar(3);const azi=azimuth(centroid);correctUV(uvA,j2+0,a2,azi),correctUV(uvB,j2+2,b2,azi),correctUV(uvC,j2+4,c2,azi)}}function correctUV(uv,stride,vector,azimuth2){azimuth2<0&&uv.x===1&&(uvBuffer[stride]=uv.x-1),vector.x===0&&vector.z===0&&(uvBuffer[stride]=azimuth2/2/Math.PI+.5)}function azimuth(vector){return Math.atan2(vector.z,-vector.x)}function inclination(vector){return Math.atan2(-vector.y,Math.sqrt(vector.x*vector.x+vector.z*vector.z))}}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new PolyhedronGeometry(data.vertices,data.indices,data.radius,data.details)}}class DodecahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){const t2=(1+Math.sqrt(5))/2,r2=1/t2,vertices=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r2,-t2,0,-r2,t2,0,r2,-t2,0,r2,t2,-r2,-t2,0,-r2,t2,0,r2,-t2,0,r2,t2,0,-t2,0,-r2,t2,0,-r2,-t2,0,r2,t2,0,r2],indices=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(vertices,indices,radius,detail),this.type="DodecahedronGeometry",this.parameters={radius,detail}}static fromJSON(data){return new DodecahedronGeometry(data.radius,data.detail)}}const _v0=new Vector3,_v1$1=new Vector3,_normal=new Vector3,_triangle=new Triangle;class EdgesGeometry extends BufferGeometry{constructor(geometry=null,thresholdAngle=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry,thresholdAngle},geometry!==null){const precision=Math.pow(10,4),thresholdDot=Math.cos(DEG2RAD*thresholdAngle),indexAttr=geometry.getIndex(),positionAttr=geometry.getAttribute("position"),indexCount=indexAttr?indexAttr.count:positionAttr.count,indexArr=[0,0,0],vertKeys=["a","b","c"],hashes=new Array(3),edgeData={},vertices=[];for(let i2=0;i2<indexCount;i2+=3){indexAttr?(indexArr[0]=indexAttr.getX(i2),indexArr[1]=indexAttr.getX(i2+1),indexArr[2]=indexAttr.getX(i2+2)):(indexArr[0]=i2,indexArr[1]=i2+1,indexArr[2]=i2+2);const{a:a2,b:b2,c:c2}=_triangle;if(a2.fromBufferAttribute(positionAttr,indexArr[0]),b2.fromBufferAttribute(positionAttr,indexArr[1]),c2.fromBufferAttribute(positionAttr,indexArr[2]),_triangle.getNormal(_normal),hashes[0]=`${Math.round(a2.x*precision)},${Math.round(a2.y*precision)},${Math.round(a2.z*precision)}`,hashes[1]=`${Math.round(b2.x*precision)},${Math.round(b2.y*precision)},${Math.round(b2.z*precision)}`,hashes[2]=`${Math.round(c2.x*precision)},${Math.round(c2.y*precision)},${Math.round(c2.z*precision)}`,!(hashes[0]===hashes[1]||hashes[1]===hashes[2]||hashes[2]===hashes[0]))for(let j2=0;j2<3;j2++){const jNext=(j2+1)%3,vecHash0=hashes[j2],vecHash1=hashes[jNext],v0=_triangle[vertKeys[j2]],v12=_triangle[vertKeys[jNext]],hash=`${vecHash0}_${vecHash1}`,reverseHash=`${vecHash1}_${vecHash0}`;reverseHash in edgeData&&edgeData[reverseHash]?(_normal.dot(edgeData[reverseHash].normal)<=thresholdDot&&(vertices.push(v0.x,v0.y,v0.z),vertices.push(v12.x,v12.y,v12.z)),edgeData[reverseHash]=null):hash in edgeData||(edgeData[hash]={index0:indexArr[j2],index1:indexArr[jNext],normal:_normal.clone()})}}for(const key in edgeData)if(edgeData[key]){const{index0,index1}=edgeData[key];_v0.fromBufferAttribute(positionAttr,index0),_v1$1.fromBufferAttribute(positionAttr,index1),vertices.push(_v0.x,_v0.y,_v0.z),vertices.push(_v1$1.x,_v1$1.y,_v1$1.z)}this.setAttribute("position",new Float32BufferAttribute(vertices,3))}}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}}class Shape extends Path{constructor(points){super(points),this.uuid=generateUUID(),this.type="Shape",this.holes=[]}getPointsHoles(divisions){const holesPts=[];for(let i2=0,l2=this.holes.length;i2<l2;i2++)holesPts[i2]=this.holes[i2].getPoints(divisions);return holesPts}extractPoints(divisions){return{shape:this.getPoints(divisions),holes:this.getPointsHoles(divisions)}}copy(source){super.copy(source),this.holes=[];for(let i2=0,l2=source.holes.length;i2<l2;i2++){const hole=source.holes[i2];this.holes.push(hole.clone())}return this}toJSON(){const data=super.toJSON();data.uuid=this.uuid,data.holes=[];for(let i2=0,l2=this.holes.length;i2<l2;i2++){const hole=this.holes[i2];data.holes.push(hole.toJSON())}return data}fromJSON(json){super.fromJSON(json),this.uuid=json.uuid,this.holes=[];for(let i2=0,l2=json.holes.length;i2<l2;i2++){const hole=json.holes[i2];this.holes.push(new Path().fromJSON(hole))}return this}}const Earcut={triangulate:function(data,holeIndices,dim=2){const hasHoles=holeIndices&&holeIndices.length,outerLen=hasHoles?holeIndices[0]*dim:data.length;let outerNode=linkedList(data,0,outerLen,dim,!0);const triangles=[];if(!outerNode||outerNode.next===outerNode.prev)return triangles;let minX,minY,maxX,maxY,x2,y2,invSize;if(hasHoles&&(outerNode=eliminateHoles(data,holeIndices,outerNode,dim)),data.length>80*dim){minX=maxX=data[0],minY=maxY=data[1];for(let i2=dim;i2<outerLen;i2+=dim)x2=data[i2],y2=data[i2+1],x2<minX&&(minX=x2),y2<minY&&(minY=y2),x2>maxX&&(maxX=x2),y2>maxY&&(maxY=y2);invSize=Math.max(maxX-minX,maxY-minY),invSize=invSize!==0?32767/invSize:0}return earcutLinked(outerNode,triangles,dim,minX,minY,invSize,0),triangles}};function linkedList(data,start,end,dim,clockwise){let i2,last;if(clockwise===signedArea(data,start,end,dim)>0)for(i2=start;i2<end;i2+=dim)last=insertNode(i2,data[i2],data[i2+1],last);else for(i2=end-dim;i2>=start;i2-=dim)last=insertNode(i2,data[i2],data[i2+1],last);return last&&equals(last,last.next)&&(removeNode(last),last=last.next),last}function filterPoints(start,end){if(!start)return start;end||(end=start);let p2=start,again;do if(again=!1,!p2.steiner&&(equals(p2,p2.next)||area(p2.prev,p2,p2.next)===0)){if(removeNode(p2),p2=end=p2.prev,p2===p2.next)break;again=!0}else p2=p2.next;while(again||p2!==end);return end}function earcutLinked(ear,triangles,dim,minX,minY,invSize,pass){if(!ear)return;!pass&&invSize&&indexCurve(ear,minX,minY,invSize);let stop=ear,prev,next;for(;ear.prev!==ear.next;){if(prev=ear.prev,next=ear.next,invSize?isEarHashed(ear,minX,minY,invSize):isEar(ear)){triangles.push(prev.i/dim|0),triangles.push(ear.i/dim|0),triangles.push(next.i/dim|0),removeNode(ear),ear=next.next,stop=next.next;continue}if(ear=next,ear===stop){pass?pass===1?(ear=cureLocalIntersections(filterPoints(ear),triangles,dim),earcutLinked(ear,triangles,dim,minX,minY,invSize,2)):pass===2&&splitEarcut(ear,triangles,dim,minX,minY,invSize):earcutLinked(filterPoints(ear),triangles,dim,minX,minY,invSize,1);break}}}function isEar(ear){const a2=ear.prev,b2=ear,c2=ear.next;if(area(a2,b2,c2)>=0)return!1;const ax=a2.x,bx=b2.x,cx=c2.x,ay=a2.y,by=b2.y,cy=c2.y,x0=ax<bx?ax<cx?ax:cx:bx<cx?bx:cx,y0=ay<by?ay<cy?ay:cy:by<cy?by:cy,x1=ax>bx?ax>cx?ax:cx:bx>cx?bx:cx,y1=ay>by?ay>cy?ay:cy:by>cy?by:cy;let p2=c2.next;for(;p2!==a2;){if(p2.x>=x0&&p2.x<=x1&&p2.y>=y0&&p2.y<=y1&&pointInTriangle(ax,ay,bx,by,cx,cy,p2.x,p2.y)&&area(p2.prev,p2,p2.next)>=0)return!1;p2=p2.next}return!0}function isEarHashed(ear,minX,minY,invSize){const a2=ear.prev,b2=ear,c2=ear.next;if(area(a2,b2,c2)>=0)return!1;const ax=a2.x,bx=b2.x,cx=c2.x,ay=a2.y,by=b2.y,cy=c2.y,x0=ax<bx?ax<cx?ax:cx:bx<cx?bx:cx,y0=ay<by?ay<cy?ay:cy:by<cy?by:cy,x1=ax>bx?ax>cx?ax:cx:bx>cx?bx:cx,y1=ay>by?ay>cy?ay:cy:by>cy?by:cy,minZ=zOrder(x0,y0,minX,minY,invSize),maxZ=zOrder(x1,y1,minX,minY,invSize);let p2=ear.prevZ,n=ear.nextZ;for(;p2&&p2.z>=minZ&&n&&n.z<=maxZ;){if(p2.x>=x0&&p2.x<=x1&&p2.y>=y0&&p2.y<=y1&&p2!==a2&&p2!==c2&&pointInTriangle(ax,ay,bx,by,cx,cy,p2.x,p2.y)&&area(p2.prev,p2,p2.next)>=0||(p2=p2.prevZ,n.x>=x0&&n.x<=x1&&n.y>=y0&&n.y<=y1&&n!==a2&&n!==c2&&pointInTriangle(ax,ay,bx,by,cx,cy,n.x,n.y)&&area(n.prev,n,n.next)>=0))return!1;n=n.nextZ}for(;p2&&p2.z>=minZ;){if(p2.x>=x0&&p2.x<=x1&&p2.y>=y0&&p2.y<=y1&&p2!==a2&&p2!==c2&&pointInTriangle(ax,ay,bx,by,cx,cy,p2.x,p2.y)&&area(p2.prev,p2,p2.next)>=0)return!1;p2=p2.prevZ}for(;n&&n.z<=maxZ;){if(n.x>=x0&&n.x<=x1&&n.y>=y0&&n.y<=y1&&n!==a2&&n!==c2&&pointInTriangle(ax,ay,bx,by,cx,cy,n.x,n.y)&&area(n.prev,n,n.next)>=0)return!1;n=n.nextZ}return!0}function cureLocalIntersections(start,triangles,dim){let p2=start;do{const a2=p2.prev,b2=p2.next.next;!equals(a2,b2)&&intersects(a2,p2,p2.next,b2)&&locallyInside(a2,b2)&&locallyInside(b2,a2)&&(triangles.push(a2.i/dim|0),triangles.push(p2.i/dim|0),triangles.push(b2.i/dim|0),removeNode(p2),removeNode(p2.next),p2=start=b2),p2=p2.next}while(p2!==start);return filterPoints(p2)}function splitEarcut(start,triangles,dim,minX,minY,invSize){let a2=start;do{let b2=a2.next.next;for(;b2!==a2.prev;){if(a2.i!==b2.i&&isValidDiagonal(a2,b2)){let c2=splitPolygon(a2,b2);a2=filterPoints(a2,a2.next),c2=filterPoints(c2,c2.next),earcutLinked(a2,triangles,dim,minX,minY,invSize,0),earcutLinked(c2,triangles,dim,minX,minY,invSize,0);return}b2=b2.next}a2=a2.next}while(a2!==start)}function eliminateHoles(data,holeIndices,outerNode,dim){const queue=[];let i2,len,start,end,list;for(i2=0,len=holeIndices.length;i2<len;i2++)start=holeIndices[i2]*dim,end=i2<len-1?holeIndices[i2+1]*dim:data.length,list=linkedList(data,start,end,dim,!1),list===list.next&&(list.steiner=!0),queue.push(getLeftmost(list));for(queue.sort(compareX),i2=0;i2<queue.length;i2++)outerNode=eliminateHole(queue[i2],outerNode);return outerNode}function compareX(a2,b2){return a2.x-b2.x}function eliminateHole(hole,outerNode){const bridge=findHoleBridge(hole,outerNode);if(!bridge)return outerNode;const bridgeReverse=splitPolygon(bridge,hole);return filterPoints(bridgeReverse,bridgeReverse.next),filterPoints(bridge,bridge.next)}function findHoleBridge(hole,outerNode){let p2=outerNode,qx=-1/0,m2;const hx=hole.x,hy=hole.y;do{if(hy<=p2.y&&hy>=p2.next.y&&p2.next.y!==p2.y){const x2=p2.x+(hy-p2.y)*(p2.next.x-p2.x)/(p2.next.y-p2.y);if(x2<=hx&&x2>qx&&(qx=x2,m2=p2.x<p2.next.x?p2:p2.next,x2===hx))return m2}p2=p2.next}while(p2!==outerNode);if(!m2)return null;const stop=m2,mx=m2.x,my=m2.y;let tanMin=1/0,tan;p2=m2;do hx>=p2.x&&p2.x>=mx&&hx!==p2.x&&pointInTriangle(hy<my?hx:qx,hy,mx,my,hy<my?qx:hx,hy,p2.x,p2.y)&&(tan=Math.abs(hy-p2.y)/(hx-p2.x),locallyInside(p2,hole)&&(tan<tanMin||tan===tanMin&&(p2.x>m2.x||p2.x===m2.x&&sectorContainsSector(m2,p2)))&&(m2=p2,tanMin=tan)),p2=p2.next;while(p2!==stop);return m2}function sectorContainsSector(m2,p2){return area(m2.prev,m2,p2.prev)<0&&area(p2.next,m2,m2.next)<0}function indexCurve(start,minX,minY,invSize){let p2=start;do p2.z===0&&(p2.z=zOrder(p2.x,p2.y,minX,minY,invSize)),p2.prevZ=p2.prev,p2.nextZ=p2.next,p2=p2.next;while(p2!==start);p2.prevZ.nextZ=null,p2.prevZ=null,sortLinked(p2)}function sortLinked(list){let i2,p2,q,e2,tail,numMerges,pSize,qSize,inSize=1;do{for(p2=list,list=null,tail=null,numMerges=0;p2;){for(numMerges++,q=p2,pSize=0,i2=0;i2<inSize&&(pSize++,q=q.nextZ,!!q);i2++);for(qSize=inSize;pSize>0||qSize>0&&q;)pSize!==0&&(qSize===0||!q||p2.z<=q.z)?(e2=p2,p2=p2.nextZ,pSize--):(e2=q,q=q.nextZ,qSize--),tail?tail.nextZ=e2:list=e2,e2.prevZ=tail,tail=e2;p2=q}tail.nextZ=null,inSize*=2}while(numMerges>1);return list}function zOrder(x2,y2,minX,minY,invSize){return x2=(x2-minX)*invSize|0,y2=(y2-minY)*invSize|0,x2=(x2|x2<<8)&16711935,x2=(x2|x2<<4)&252645135,x2=(x2|x2<<2)&858993459,x2=(x2|x2<<1)&1431655765,y2=(y2|y2<<8)&16711935,y2=(y2|y2<<4)&252645135,y2=(y2|y2<<2)&858993459,y2=(y2|y2<<1)&1431655765,x2|y2<<1}function getLeftmost(start){let p2=start,leftmost=start;do(p2.x<leftmost.x||p2.x===leftmost.x&&p2.y<leftmost.y)&&(leftmost=p2),p2=p2.next;while(p2!==start);return leftmost}function pointInTriangle(ax,ay,bx,by,cx,cy,px2,py2){return(cx-px2)*(ay-py2)>=(ax-px2)*(cy-py2)&&(ax-px2)*(by-py2)>=(bx-px2)*(ay-py2)&&(bx-px2)*(cy-py2)>=(cx-px2)*(by-py2)}function isValidDiagonal(a2,b2){return a2.next.i!==b2.i&&a2.prev.i!==b2.i&&!intersectsPolygon(a2,b2)&&(locallyInside(a2,b2)&&locallyInside(b2,a2)&&middleInside(a2,b2)&&(area(a2.prev,a2,b2.prev)||area(a2,b2.prev,b2))||equals(a2,b2)&&area(a2.prev,a2,a2.next)>0&&area(b2.prev,b2,b2.next)>0)}function area(p2,q,r2){return(q.y-p2.y)*(r2.x-q.x)-(q.x-p2.x)*(r2.y-q.y)}function equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y}function intersects(p1,q1,p2,q2){const o1=sign(area(p1,q1,p2)),o2=sign(area(p1,q1,q2)),o3=sign(area(p2,q2,p1)),o4=sign(area(p2,q2,q1));return!!(o1!==o2&&o3!==o4||o1===0&&onSegment(p1,p2,q1)||o2===0&&onSegment(p1,q2,q1)||o3===0&&onSegment(p2,p1,q2)||o4===0&&onSegment(p2,q1,q2))}function onSegment(p2,q,r2){return q.x<=Math.max(p2.x,r2.x)&&q.x>=Math.min(p2.x,r2.x)&&q.y<=Math.max(p2.y,r2.y)&&q.y>=Math.min(p2.y,r2.y)}function sign(num){return num>0?1:num<0?-1:0}function intersectsPolygon(a2,b2){let p2=a2;do{if(p2.i!==a2.i&&p2.next.i!==a2.i&&p2.i!==b2.i&&p2.next.i!==b2.i&&intersects(p2,p2.next,a2,b2))return!0;p2=p2.next}while(p2!==a2);return!1}function locallyInside(a2,b2){return area(a2.prev,a2,a2.next)<0?area(a2,b2,a2.next)>=0&&area(a2,a2.prev,b2)>=0:area(a2,b2,a2.prev)<0||area(a2,a2.next,b2)<0}function middleInside(a2,b2){let p2=a2,inside=!1;const px2=(a2.x+b2.x)/2,py2=(a2.y+b2.y)/2;do p2.y>py2!=p2.next.y>py2&&p2.next.y!==p2.y&&px2<(p2.next.x-p2.x)*(py2-p2.y)/(p2.next.y-p2.y)+p2.x&&(inside=!inside),p2=p2.next;while(p2!==a2);return inside}function splitPolygon(a2,b2){const a22=new Node(a2.i,a2.x,a2.y),b22=new Node(b2.i,b2.x,b2.y),an=a2.next,bp=b2.prev;return a2.next=b2,b2.prev=a2,a22.next=an,an.prev=a22,b22.next=a22,a22.prev=b22,bp.next=b22,b22.prev=bp,b22}function insertNode(i2,x2,y2,last){const p2=new Node(i2,x2,y2);return last?(p2.next=last.next,p2.prev=last,last.next.prev=p2,last.next=p2):(p2.prev=p2,p2.next=p2),p2}function removeNode(p2){p2.next.prev=p2.prev,p2.prev.next=p2.next,p2.prevZ&&(p2.prevZ.nextZ=p2.nextZ),p2.nextZ&&(p2.nextZ.prevZ=p2.prevZ)}function Node(i2,x2,y2){this.i=i2,this.x=x2,this.y=y2,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function signedArea(data,start,end,dim){let sum=0;for(let i2=start,j2=end-dim;i2<end;i2+=dim)sum+=(data[j2]-data[i2])*(data[i2+1]+data[j2+1]),j2=i2;return sum}class ShapeUtils{static area(contour){const n=contour.length;let a2=0;for(let p2=n-1,q=0;q<n;p2=q++)a2+=contour[p2].x*contour[q].y-contour[q].x*contour[p2].y;return a2*.5}static isClockWise(pts){return ShapeUtils.area(pts)<0}static triangulateShape(contour,holes){const vertices=[],holeIndices=[],faces=[];removeDupEndPts(contour),addContour(vertices,contour);let holeIndex=contour.length;holes.forEach(removeDupEndPts);for(let i2=0;i2<holes.length;i2++)holeIndices.push(holeIndex),holeIndex+=holes[i2].length,addContour(vertices,holes[i2]);const triangles=Earcut.triangulate(vertices,holeIndices);for(let i2=0;i2<triangles.length;i2+=3)faces.push(triangles.slice(i2,i2+3));return faces}}function removeDupEndPts(points){const l2=points.length;l2>2&&points[l2-1].equals(points[0])&&points.pop()}function addContour(vertices,contour){for(let i2=0;i2<contour.length;i2++)vertices.push(contour[i2].x),vertices.push(contour[i2].y)}class ExtrudeGeometry extends BufferGeometry{constructor(shapes=new Shape([new Vector2(.5,.5),new Vector2(-.5,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),options={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes,options},shapes=Array.isArray(shapes)?shapes:[shapes];const scope=this,verticesArray=[],uvArray=[];for(let i2=0,l2=shapes.length;i2<l2;i2++){const shape=shapes[i2];addShape(shape)}this.setAttribute("position",new Float32BufferAttribute(verticesArray,3)),this.setAttribute("uv",new Float32BufferAttribute(uvArray,2)),this.computeVertexNormals();function addShape(shape){const placeholder=[],curveSegments=options.curveSegments!==void 0?options.curveSegments:12,steps2=options.steps!==void 0?options.steps:1,depth=options.depth!==void 0?options.depth:1;let bevelEnabled=options.bevelEnabled!==void 0?options.bevelEnabled:!0,bevelThickness=options.bevelThickness!==void 0?options.bevelThickness:.2,bevelSize=options.bevelSize!==void 0?options.bevelSize:bevelThickness-.1,bevelOffset=options.bevelOffset!==void 0?options.bevelOffset:0,bevelSegments=options.bevelSegments!==void 0?options.bevelSegments:3;const extrudePath=options.extrudePath,uvgen=options.UVGenerator!==void 0?options.UVGenerator:WorldUVGenerator;let extrudePts,extrudeByPath=!1,splineTube,binormal,normal,position2;extrudePath&&(extrudePts=extrudePath.getSpacedPoints(steps2),extrudeByPath=!0,bevelEnabled=!1,splineTube=extrudePath.computeFrenetFrames(steps2,!1),binormal=new Vector3,normal=new Vector3,position2=new Vector3),bevelEnabled||(bevelSegments=0,bevelThickness=0,bevelSize=0,bevelOffset=0);const shapePoints=shape.extractPoints(curveSegments);let vertices=shapePoints.shape;const holes=shapePoints.holes;if(!ShapeUtils.isClockWise(vertices)){vertices=vertices.reverse();for(let h2=0,hl=holes.length;h2<hl;h2++){const ahole=holes[h2];ShapeUtils.isClockWise(ahole)&&(holes[h2]=ahole.reverse())}}const faces=ShapeUtils.triangulateShape(vertices,holes),contour=vertices;for(let h2=0,hl=holes.length;h2<hl;h2++){const ahole=holes[h2];vertices=vertices.concat(ahole)}function scalePt2(pt,vec,size){return vec||console.error("THREE.ExtrudeGeometry: vec does not exist"),pt.clone().addScaledVector(vec,size)}const vlen=vertices.length,flen=faces.length;function getBevelVec(inPt,inPrev,inNext){let v_trans_x,v_trans_y,shrink_by;const v_prev_x=inPt.x-inPrev.x,v_prev_y=inPt.y-inPrev.y,v_next_x=inNext.x-inPt.x,v_next_y=inNext.y-inPt.y,v_prev_lensq=v_prev_x*v_prev_x+v_prev_y*v_prev_y,collinear0=v_prev_x*v_next_y-v_prev_y*v_next_x;if(Math.abs(collinear0)>Number.EPSILON){const v_prev_len=Math.sqrt(v_prev_lensq),v_next_len=Math.sqrt(v_next_x*v_next_x+v_next_y*v_next_y),ptPrevShift_x=inPrev.x-v_prev_y/v_prev_len,ptPrevShift_y=inPrev.y+v_prev_x/v_prev_len,ptNextShift_x=inNext.x-v_next_y/v_next_len,ptNextShift_y=inNext.y+v_next_x/v_next_len,sf=((ptNextShift_x-ptPrevShift_x)*v_next_y-(ptNextShift_y-ptPrevShift_y)*v_next_x)/(v_prev_x*v_next_y-v_prev_y*v_next_x);v_trans_x=ptPrevShift_x+v_prev_x*sf-inPt.x,v_trans_y=ptPrevShift_y+v_prev_y*sf-inPt.y;const v_trans_lensq=v_trans_x*v_trans_x+v_trans_y*v_trans_y;if(v_trans_lensq<=2)return new Vector2(v_trans_x,v_trans_y);shrink_by=Math.sqrt(v_trans_lensq/2)}else{let direction_eq=!1;v_prev_x>Number.EPSILON?v_next_x>Number.EPSILON&&(direction_eq=!0):v_prev_x<-Number.EPSILON?v_next_x<-Number.EPSILON&&(direction_eq=!0):Math.sign(v_prev_y)===Math.sign(v_next_y)&&(direction_eq=!0),direction_eq?(v_trans_x=-v_prev_y,v_trans_y=v_prev_x,shrink_by=Math.sqrt(v_prev_lensq)):(v_trans_x=v_prev_x,v_trans_y=v_prev_y,shrink_by=Math.sqrt(v_prev_lensq/2))}return new Vector2(v_trans_x/shrink_by,v_trans_y/shrink_by)}const contourMovements=[];for(let i2=0,il=contour.length,j2=il-1,k2=i2+1;i2<il;i2++,j2++,k2++)j2===il&&(j2=0),k2===il&&(k2=0),contourMovements[i2]=getBevelVec(contour[i2],contour[j2],contour[k2]);const holesMovements=[];let oneHoleMovements,verticesMovements=contourMovements.concat();for(let h2=0,hl=holes.length;h2<hl;h2++){const ahole=holes[h2];oneHoleMovements=[];for(let i2=0,il=ahole.length,j2=il-1,k2=i2+1;i2<il;i2++,j2++,k2++)j2===il&&(j2=0),k2===il&&(k2=0),oneHoleMovements[i2]=getBevelVec(ahole[i2],ahole[j2],ahole[k2]);holesMovements.push(oneHoleMovements),verticesMovements=verticesMovements.concat(oneHoleMovements)}for(let b2=0;b2<bevelSegments;b2++){const t2=b2/bevelSegments,z=bevelThickness*Math.cos(t2*Math.PI/2),bs2=bevelSize*Math.sin(t2*Math.PI/2)+bevelOffset;for(let i2=0,il=contour.length;i2<il;i2++){const vert=scalePt2(contour[i2],contourMovements[i2],bs2);v4(vert.x,vert.y,-z)}for(let h2=0,hl=holes.length;h2<hl;h2++){const ahole=holes[h2];oneHoleMovements=holesMovements[h2];for(let i2=0,il=ahole.length;i2<il;i2++){const vert=scalePt2(ahole[i2],oneHoleMovements[i2],bs2);v4(vert.x,vert.y,-z)}}}const bs=bevelSize+bevelOffset;for(let i2=0;i2<vlen;i2++){const vert=bevelEnabled?scalePt2(vertices[i2],verticesMovements[i2],bs):vertices[i2];extrudeByPath?(normal.copy(splineTube.normals[0]).multiplyScalar(vert.x),binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y),position2.copy(extrudePts[0]).add(normal).add(binormal),v4(position2.x,position2.y,position2.z)):v4(vert.x,vert.y,0)}for(let s2=1;s2<=steps2;s2++)for(let i2=0;i2<vlen;i2++){const vert=bevelEnabled?scalePt2(vertices[i2],verticesMovements[i2],bs):vertices[i2];extrudeByPath?(normal.copy(splineTube.normals[s2]).multiplyScalar(vert.x),binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y),position2.copy(extrudePts[s2]).add(normal).add(binormal),v4(position2.x,position2.y,position2.z)):v4(vert.x,vert.y,depth/steps2*s2)}for(let b2=bevelSegments-1;b2>=0;b2--){const t2=b2/bevelSegments,z=bevelThickness*Math.cos(t2*Math.PI/2),bs2=bevelSize*Math.sin(t2*Math.PI/2)+bevelOffset;for(let i2=0,il=contour.length;i2<il;i2++){const vert=scalePt2(contour[i2],contourMovements[i2],bs2);v4(vert.x,vert.y,depth+z)}for(let h2=0,hl=holes.length;h2<hl;h2++){const ahole=holes[h2];oneHoleMovements=holesMovements[h2];for(let i2=0,il=ahole.length;i2<il;i2++){const vert=scalePt2(ahole[i2],oneHoleMovements[i2],bs2);extrudeByPath?v4(vert.x,vert.y+extrudePts[steps2-1].y,extrudePts[steps2-1].x+z):v4(vert.x,vert.y,depth+z)}}}buildLidFaces(),buildSideFaces();function buildLidFaces(){const start=verticesArray.length/3;if(bevelEnabled){let layer=0,offset=vlen*layer;for(let i2=0;i2<flen;i2++){const face=faces[i2];f3(face[2]+offset,face[1]+offset,face[0]+offset)}layer=steps2+bevelSegments*2,offset=vlen*layer;for(let i2=0;i2<flen;i2++){const face=faces[i2];f3(face[0]+offset,face[1]+offset,face[2]+offset)}}else{for(let i2=0;i2<flen;i2++){const face=faces[i2];f3(face[2],face[1],face[0])}for(let i2=0;i2<flen;i2++){const face=faces[i2];f3(face[0]+vlen*steps2,face[1]+vlen*steps2,face[2]+vlen*steps2)}}scope.addGroup(start,verticesArray.length/3-start,0)}function buildSideFaces(){const start=verticesArray.length/3;let layeroffset=0;sidewalls(contour,layeroffset),layeroffset+=contour.length;for(let h2=0,hl=holes.length;h2<hl;h2++){const ahole=holes[h2];sidewalls(ahole,layeroffset),layeroffset+=ahole.length}scope.addGroup(start,verticesArray.length/3-start,1)}function sidewalls(contour2,layeroffset){let i2=contour2.length;for(;--i2>=0;){const j2=i2;let k2=i2-1;k2<0&&(k2=contour2.length-1);for(let s2=0,sl=steps2+bevelSegments*2;s2<sl;s2++){const slen1=vlen*s2,slen2=vlen*(s2+1),a2=layeroffset+j2+slen1,b2=layeroffset+k2+slen1,c2=layeroffset+k2+slen2,d2=layeroffset+j2+slen2;f4(a2,b2,c2,d2)}}}function v4(x2,y2,z){placeholder.push(x2),placeholder.push(y2),placeholder.push(z)}function f3(a2,b2,c2){addVertex(a2),addVertex(b2),addVertex(c2);const nextIndex=verticesArray.length/3,uvs=uvgen.generateTopUV(scope,verticesArray,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]),addUV(uvs[1]),addUV(uvs[2])}function f4(a2,b2,c2,d2){addVertex(a2),addVertex(b2),addVertex(d2),addVertex(b2),addVertex(c2),addVertex(d2);const nextIndex=verticesArray.length/3,uvs=uvgen.generateSideWallUV(scope,verticesArray,nextIndex-6,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]),addUV(uvs[1]),addUV(uvs[3]),addUV(uvs[1]),addUV(uvs[2]),addUV(uvs[3])}function addVertex(index){verticesArray.push(placeholder[index*3+0]),verticesArray.push(placeholder[index*3+1]),verticesArray.push(placeholder[index*3+2])}function addUV(vector2){uvArray.push(vector2.x),uvArray.push(vector2.y)}}}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}toJSON(){const data=super.toJSON(),shapes=this.parameters.shapes,options=this.parameters.options;return toJSON$1(shapes,options,data)}static fromJSON(data,shapes){const geometryShapes=[];for(let j2=0,jl=data.shapes.length;j2<jl;j2++){const shape=shapes[data.shapes[j2]];geometryShapes.push(shape)}const extrudePath=data.options.extrudePath;return extrudePath!==void 0&&(data.options.extrudePath=new Curves[extrudePath.type]().fromJSON(extrudePath)),new ExtrudeGeometry(geometryShapes,data.options)}}const WorldUVGenerator={generateTopUV:function(geometry,vertices,indexA,indexB,indexC){const a_x=vertices[indexA*3],a_y=vertices[indexA*3+1],b_x=vertices[indexB*3],b_y=vertices[indexB*3+1],c_x=vertices[indexC*3],c_y=vertices[indexC*3+1];return[new Vector2(a_x,a_y),new Vector2(b_x,b_y),new Vector2(c_x,c_y)]},generateSideWallUV:function(geometry,vertices,indexA,indexB,indexC,indexD){const a_x=vertices[indexA*3],a_y=vertices[indexA*3+1],a_z=vertices[indexA*3+2],b_x=vertices[indexB*3],b_y=vertices[indexB*3+1],b_z=vertices[indexB*3+2],c_x=vertices[indexC*3],c_y=vertices[indexC*3+1],c_z=vertices[indexC*3+2],d_x=vertices[indexD*3],d_y=vertices[indexD*3+1],d_z=vertices[indexD*3+2];return Math.abs(a_y-b_y)<Math.abs(a_x-b_x)?[new Vector2(a_x,1-a_z),new Vector2(b_x,1-b_z),new Vector2(c_x,1-c_z),new Vector2(d_x,1-d_z)]:[new Vector2(a_y,1-a_z),new Vector2(b_y,1-b_z),new Vector2(c_y,1-c_z),new Vector2(d_y,1-d_z)]}};function toJSON$1(shapes,options,data){if(data.shapes=[],Array.isArray(shapes))for(let i2=0,l2=shapes.length;i2<l2;i2++){const shape=shapes[i2];data.shapes.push(shape.uuid)}else data.shapes.push(shapes.uuid);return data.options=Object.assign({},options),options.extrudePath!==void 0&&(data.options.extrudePath=options.extrudePath.toJSON()),data}class IcosahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){const t2=(1+Math.sqrt(5))/2,vertices=[-1,t2,0,1,t2,0,-1,-t2,0,1,-t2,0,0,-1,t2,0,1,t2,0,-1,-t2,0,1,-t2,t2,0,-1,t2,0,1,-t2,0,-1,-t2,0,1],indices=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(vertices,indices,radius,detail),this.type="IcosahedronGeometry",this.parameters={radius,detail}}static fromJSON(data){return new IcosahedronGeometry(data.radius,data.detail)}}class OctahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){const vertices=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],indices=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(vertices,indices,radius,detail),this.type="OctahedronGeometry",this.parameters={radius,detail}}static fromJSON(data){return new OctahedronGeometry(data.radius,data.detail)}}class RingGeometry extends BufferGeometry{constructor(innerRadius=.5,outerRadius=1,thetaSegments=32,phiSegments=1,thetaStart=0,thetaLength=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength},thetaSegments=Math.max(3,thetaSegments),phiSegments=Math.max(1,phiSegments);const indices=[],vertices=[],normals=[],uvs=[];let radius=innerRadius;const radiusStep=(outerRadius-innerRadius)/phiSegments,vertex2=new Vector3,uv=new Vector2;for(let j2=0;j2<=phiSegments;j2++){for(let i2=0;i2<=thetaSegments;i2++){const segment=thetaStart+i2/thetaSegments*thetaLength;vertex2.x=radius*Math.cos(segment),vertex2.y=radius*Math.sin(segment),vertices.push(vertex2.x,vertex2.y,vertex2.z),normals.push(0,0,1),uv.x=(vertex2.x/outerRadius+1)/2,uv.y=(vertex2.y/outerRadius+1)/2,uvs.push(uv.x,uv.y)}radius+=radiusStep}for(let j2=0;j2<phiSegments;j2++){const thetaSegmentLevel=j2*(thetaSegments+1);for(let i2=0;i2<thetaSegments;i2++){const segment=i2+thetaSegmentLevel,a2=segment,b2=segment+thetaSegments+1,c2=segment+thetaSegments+2,d2=segment+1;indices.push(a2,b2,d2),indices.push(b2,c2,d2)}}this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new RingGeometry(data.innerRadius,data.outerRadius,data.thetaSegments,data.phiSegments,data.thetaStart,data.thetaLength)}}class ShapeGeometry extends BufferGeometry{constructor(shapes=new Shape([new Vector2(0,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),curveSegments=12){super(),this.type="ShapeGeometry",this.parameters={shapes,curveSegments};const indices=[],vertices=[],normals=[],uvs=[];let groupStart=0,groupCount=0;if(Array.isArray(shapes)===!1)addShape(shapes);else for(let i2=0;i2<shapes.length;i2++)addShape(shapes[i2]),this.addGroup(groupStart,groupCount,i2),groupStart+=groupCount,groupCount=0;this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2));function addShape(shape){const indexOffset=vertices.length/3,points=shape.extractPoints(curveSegments);let shapeVertices=points.shape;const shapeHoles=points.holes;ShapeUtils.isClockWise(shapeVertices)===!1&&(shapeVertices=shapeVertices.reverse());for(let i2=0,l2=shapeHoles.length;i2<l2;i2++){const shapeHole=shapeHoles[i2];ShapeUtils.isClockWise(shapeHole)===!0&&(shapeHoles[i2]=shapeHole.reverse())}const faces=ShapeUtils.triangulateShape(shapeVertices,shapeHoles);for(let i2=0,l2=shapeHoles.length;i2<l2;i2++){const shapeHole=shapeHoles[i2];shapeVertices=shapeVertices.concat(shapeHole)}for(let i2=0,l2=shapeVertices.length;i2<l2;i2++){const vertex2=shapeVertices[i2];vertices.push(vertex2.x,vertex2.y,0),normals.push(0,0,1),uvs.push(vertex2.x,vertex2.y)}for(let i2=0,l2=faces.length;i2<l2;i2++){const face=faces[i2],a2=face[0]+indexOffset,b2=face[1]+indexOffset,c2=face[2]+indexOffset;indices.push(a2,b2,c2),groupCount+=3}}}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}toJSON(){const data=super.toJSON(),shapes=this.parameters.shapes;return toJSON(shapes,data)}static fromJSON(data,shapes){const geometryShapes=[];for(let j2=0,jl=data.shapes.length;j2<jl;j2++){const shape=shapes[data.shapes[j2]];geometryShapes.push(shape)}return new ShapeGeometry(geometryShapes,data.curveSegments)}}function toJSON(shapes,data){if(data.shapes=[],Array.isArray(shapes))for(let i2=0,l2=shapes.length;i2<l2;i2++){const shape=shapes[i2];data.shapes.push(shape.uuid)}else data.shapes.push(shapes.uuid);return data}class SphereGeometry extends BufferGeometry{constructor(radius=1,widthSegments=32,heightSegments=16,phiStart=0,phiLength=Math.PI*2,thetaStart=0,thetaLength=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength},widthSegments=Math.max(3,Math.floor(widthSegments)),heightSegments=Math.max(2,Math.floor(heightSegments));const thetaEnd=Math.min(thetaStart+thetaLength,Math.PI);let index=0;const grid=[],vertex2=new Vector3,normal=new Vector3,indices=[],vertices=[],normals=[],uvs=[];for(let iy=0;iy<=heightSegments;iy++){const verticesRow=[],v4=iy/heightSegments;let uOffset=0;iy===0&&thetaStart===0?uOffset=.5/widthSegments:iy===heightSegments&&thetaEnd===Math.PI&&(uOffset=-.5/widthSegments);for(let ix=0;ix<=widthSegments;ix++){const u2=ix/widthSegments;vertex2.x=-radius*Math.cos(phiStart+u2*phiLength)*Math.sin(thetaStart+v4*thetaLength),vertex2.y=radius*Math.cos(thetaStart+v4*thetaLength),vertex2.z=radius*Math.sin(phiStart+u2*phiLength)*Math.sin(thetaStart+v4*thetaLength),vertices.push(vertex2.x,vertex2.y,vertex2.z),normal.copy(vertex2).normalize(),normals.push(normal.x,normal.y,normal.z),uvs.push(u2+uOffset,1-v4),verticesRow.push(index++)}grid.push(verticesRow)}for(let iy=0;iy<heightSegments;iy++)for(let ix=0;ix<widthSegments;ix++){const a2=grid[iy][ix+1],b2=grid[iy][ix],c2=grid[iy+1][ix],d2=grid[iy+1][ix+1];(iy!==0||thetaStart>0)&&indices.push(a2,b2,d2),(iy!==heightSegments-1||thetaEnd<Math.PI)&&indices.push(b2,c2,d2)}this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new SphereGeometry(data.radius,data.widthSegments,data.heightSegments,data.phiStart,data.phiLength,data.thetaStart,data.thetaLength)}}class TetrahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){const vertices=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],indices=[2,1,0,0,3,2,1,3,0,2,3,1];super(vertices,indices,radius,detail),this.type="TetrahedronGeometry",this.parameters={radius,detail}}static fromJSON(data){return new TetrahedronGeometry(data.radius,data.detail)}}class TorusGeometry extends BufferGeometry{constructor(radius=1,tube=.4,radialSegments=12,tubularSegments=48,arc=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius,tube,radialSegments,tubularSegments,arc},radialSegments=Math.floor(radialSegments),tubularSegments=Math.floor(tubularSegments);const indices=[],vertices=[],normals=[],uvs=[],center=new Vector3,vertex2=new Vector3,normal=new Vector3;for(let j2=0;j2<=radialSegments;j2++)for(let i2=0;i2<=tubularSegments;i2++){const u2=i2/tubularSegments*arc,v4=j2/radialSegments*Math.PI*2;vertex2.x=(radius+tube*Math.cos(v4))*Math.cos(u2),vertex2.y=(radius+tube*Math.cos(v4))*Math.sin(u2),vertex2.z=tube*Math.sin(v4),vertices.push(vertex2.x,vertex2.y,vertex2.z),center.x=radius*Math.cos(u2),center.y=radius*Math.sin(u2),normal.subVectors(vertex2,center).normalize(),normals.push(normal.x,normal.y,normal.z),uvs.push(i2/tubularSegments),uvs.push(j2/radialSegments)}for(let j2=1;j2<=radialSegments;j2++)for(let i2=1;i2<=tubularSegments;i2++){const a2=(tubularSegments+1)*j2+i2-1,b2=(tubularSegments+1)*(j2-1)+i2-1,c2=(tubularSegments+1)*(j2-1)+i2,d2=(tubularSegments+1)*j2+i2;indices.push(a2,b2,d2),indices.push(b2,c2,d2)}this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new TorusGeometry(data.radius,data.tube,data.radialSegments,data.tubularSegments,data.arc)}}class TorusKnotGeometry extends BufferGeometry{constructor(radius=1,tube=.4,tubularSegments=64,radialSegments=8,p2=2,q=3){super(),this.type="TorusKnotGeometry",this.parameters={radius,tube,tubularSegments,radialSegments,p:p2,q},tubularSegments=Math.floor(tubularSegments),radialSegments=Math.floor(radialSegments);const indices=[],vertices=[],normals=[],uvs=[],vertex2=new Vector3,normal=new Vector3,P1=new Vector3,P2=new Vector3,B=new Vector3,T=new Vector3,N=new Vector3;for(let i2=0;i2<=tubularSegments;++i2){const u2=i2/tubularSegments*p2*Math.PI*2;calculatePositionOnCurve(u2,p2,q,radius,P1),calculatePositionOnCurve(u2+.01,p2,q,radius,P2),T.subVectors(P2,P1),N.addVectors(P2,P1),B.crossVectors(T,N),N.crossVectors(B,T),B.normalize(),N.normalize();for(let j2=0;j2<=radialSegments;++j2){const v4=j2/radialSegments*Math.PI*2,cx=-tube*Math.cos(v4),cy=tube*Math.sin(v4);vertex2.x=P1.x+(cx*N.x+cy*B.x),vertex2.y=P1.y+(cx*N.y+cy*B.y),vertex2.z=P1.z+(cx*N.z+cy*B.z),vertices.push(vertex2.x,vertex2.y,vertex2.z),normal.subVectors(vertex2,P1).normalize(),normals.push(normal.x,normal.y,normal.z),uvs.push(i2/tubularSegments),uvs.push(j2/radialSegments)}}for(let j2=1;j2<=tubularSegments;j2++)for(let i2=1;i2<=radialSegments;i2++){const a2=(radialSegments+1)*(j2-1)+(i2-1),b2=(radialSegments+1)*j2+(i2-1),c2=(radialSegments+1)*j2+i2,d2=(radialSegments+1)*(j2-1)+i2;indices.push(a2,b2,d2),indices.push(b2,c2,d2)}this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2));function calculatePositionOnCurve(u2,p3,q2,radius2,position){const cu=Math.cos(u2),su=Math.sin(u2),quOverP=q2/p3*u2,cs=Math.cos(quOverP);position.x=radius2*(2+cs)*.5*cu,position.y=radius2*(2+cs)*su*.5,position.z=radius2*Math.sin(quOverP)*.5}}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new TorusKnotGeometry(data.radius,data.tube,data.tubularSegments,data.radialSegments,data.p,data.q)}}class TubeGeometry extends BufferGeometry{constructor(path2=new QuadraticBezierCurve3(new Vector3(-1,-1,0),new Vector3(-1,1,0),new Vector3(1,1,0)),tubularSegments=64,radius=1,radialSegments=8,closed=!1){super(),this.type="TubeGeometry",this.parameters={path:path2,tubularSegments,radius,radialSegments,closed};const frames=path2.computeFrenetFrames(tubularSegments,closed);this.tangents=frames.tangents,this.normals=frames.normals,this.binormals=frames.binormals;const vertex2=new Vector3,normal=new Vector3,uv=new Vector2;let P2=new Vector3;const vertices=[],normals=[],uvs=[],indices=[];generateBufferData(),this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2));function generateBufferData(){for(let i2=0;i2<tubularSegments;i2++)generateSegment(i2);generateSegment(closed===!1?tubularSegments:0),generateUVs(),generateIndices()}function generateSegment(i2){P2=path2.getPointAt(i2/tubularSegments,P2);const N=frames.normals[i2],B=frames.binormals[i2];for(let j2=0;j2<=radialSegments;j2++){const v4=j2/radialSegments*Math.PI*2,sin=Math.sin(v4),cos=-Math.cos(v4);normal.x=cos*N.x+sin*B.x,normal.y=cos*N.y+sin*B.y,normal.z=cos*N.z+sin*B.z,normal.normalize(),normals.push(normal.x,normal.y,normal.z),vertex2.x=P2.x+radius*normal.x,vertex2.y=P2.y+radius*normal.y,vertex2.z=P2.z+radius*normal.z,vertices.push(vertex2.x,vertex2.y,vertex2.z)}}function generateIndices(){for(let j2=1;j2<=tubularSegments;j2++)for(let i2=1;i2<=radialSegments;i2++){const a2=(radialSegments+1)*(j2-1)+(i2-1),b2=(radialSegments+1)*j2+(i2-1),c2=(radialSegments+1)*j2+i2,d2=(radialSegments+1)*(j2-1)+i2;indices.push(a2,b2,d2),indices.push(b2,c2,d2)}}function generateUVs(){for(let i2=0;i2<=tubularSegments;i2++)for(let j2=0;j2<=radialSegments;j2++)uv.x=i2/tubularSegments,uv.y=j2/radialSegments,uvs.push(uv.x,uv.y)}}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}toJSON(){const data=super.toJSON();return data.path=this.parameters.path.toJSON(),data}static fromJSON(data){return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path),data.tubularSegments,data.radius,data.radialSegments,data.closed)}}class WireframeGeometry extends BufferGeometry{constructor(geometry=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry},geometry!==null){const vertices=[],edges=new Set,start=new Vector3,end=new Vector3;if(geometry.index!==null){const position=geometry.attributes.position,indices=geometry.index;let groups=geometry.groups;groups.length===0&&(groups=[{start:0,count:indices.count,materialIndex:0}]);for(let o2=0,ol=groups.length;o2<ol;++o2){const group=groups[o2],groupStart=group.start,groupCount=group.count;for(let i2=groupStart,l2=groupStart+groupCount;i2<l2;i2+=3)for(let j2=0;j2<3;j2++){const index1=indices.getX(i2+j2),index2=indices.getX(i2+(j2+1)%3);start.fromBufferAttribute(position,index1),end.fromBufferAttribute(position,index2),isUniqueEdge(start,end,edges)===!0&&(vertices.push(start.x,start.y,start.z),vertices.push(end.x,end.y,end.z))}}}else{const position=geometry.attributes.position;for(let i2=0,l2=position.count/3;i2<l2;i2++)for(let j2=0;j2<3;j2++){const index1=3*i2+j2,index2=3*i2+(j2+1)%3;start.fromBufferAttribute(position,index1),end.fromBufferAttribute(position,index2),isUniqueEdge(start,end,edges)===!0&&(vertices.push(start.x,start.y,start.z),vertices.push(end.x,end.y,end.z))}}this.setAttribute("position",new Float32BufferAttribute(vertices,3))}}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}}function isUniqueEdge(start,end,edges){const hash1=`${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`,hash2=`${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;return edges.has(hash1)===!0||edges.has(hash2)===!0?!1:(edges.add(hash1),edges.add(hash2),!0)}var Geometries=Object.freeze({__proto__:null,BoxGeometry,CapsuleGeometry,CircleGeometry,ConeGeometry,CylinderGeometry,DodecahedronGeometry,EdgesGeometry,ExtrudeGeometry,IcosahedronGeometry,LatheGeometry,OctahedronGeometry,PlaneGeometry,PolyhedronGeometry,RingGeometry,ShapeGeometry,SphereGeometry,TetrahedronGeometry,TorusGeometry,TorusKnotGeometry,TubeGeometry,WireframeGeometry});class ShadowMaterial extends Material{constructor(parameters){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Color(0),this.transparent=!0,this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.fog=source.fog,this}}class RawShaderMaterial extends ShaderMaterial{constructor(parameters){super(parameters),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class MeshStandardMaterial extends Material{constructor(parameters){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Color(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.defines={STANDARD:""},this.color.copy(source.color),this.roughness=source.roughness,this.metalness=source.metalness,this.map=source.map,this.lightMap=source.lightMap,this.lightMapIntensity=source.lightMapIntensity,this.aoMap=source.aoMap,this.aoMapIntensity=source.aoMapIntensity,this.emissive.copy(source.emissive),this.emissiveMap=source.emissiveMap,this.emissiveIntensity=source.emissiveIntensity,this.bumpMap=source.bumpMap,this.bumpScale=source.bumpScale,this.normalMap=source.normalMap,this.normalMapType=source.normalMapType,this.normalScale.copy(source.normalScale),this.displacementMap=source.displacementMap,this.displacementScale=source.displacementScale,this.displacementBias=source.displacementBias,this.roughnessMap=source.roughnessMap,this.metalnessMap=source.metalnessMap,this.alphaMap=source.alphaMap,this.envMap=source.envMap,this.envMapIntensity=source.envMapIntensity,this.wireframe=source.wireframe,this.wireframeLinewidth=source.wireframeLinewidth,this.wireframeLinecap=source.wireframeLinecap,this.wireframeLinejoin=source.wireframeLinejoin,this.flatShading=source.flatShading,this.fog=source.fog,this}}class MeshPhysicalMaterial extends MeshStandardMaterial{constructor(parameters){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Vector2(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return clamp(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(reflectivity){this.ior=(1+.4*reflectivity)/(1-.4*reflectivity)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Color(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Color(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Color(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(parameters)}get anisotropy(){return this._anisotropy}set anisotropy(value){this._anisotropy>0!=value>0&&this.version++,this._anisotropy=value}get clearcoat(){return this._clearcoat}set clearcoat(value){this._clearcoat>0!=value>0&&this.version++,this._clearcoat=value}get iridescence(){return this._iridescence}set iridescence(value){this._iridescence>0!=value>0&&this.version++,this._iridescence=value}get sheen(){return this._sheen}set sheen(value){this._sheen>0!=value>0&&this.version++,this._sheen=value}get transmission(){return this._transmission}set transmission(value){this._transmission>0!=value>0&&this.version++,this._transmission=value}copy(source){return super.copy(source),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=source.anisotropy,this.anisotropyRotation=source.anisotropyRotation,this.anisotropyMap=source.anisotropyMap,this.clearcoat=source.clearcoat,this.clearcoatMap=source.clearcoatMap,this.clearcoatRoughness=source.clearcoatRoughness,this.clearcoatRoughnessMap=source.clearcoatRoughnessMap,this.clearcoatNormalMap=source.clearcoatNormalMap,this.clearcoatNormalScale.copy(source.clearcoatNormalScale),this.ior=source.ior,this.iridescence=source.iridescence,this.iridescenceMap=source.iridescenceMap,this.iridescenceIOR=source.iridescenceIOR,this.iridescenceThicknessRange=[...source.iridescenceThicknessRange],this.iridescenceThicknessMap=source.iridescenceThicknessMap,this.sheen=source.sheen,this.sheenColor.copy(source.sheenColor),this.sheenColorMap=source.sheenColorMap,this.sheenRoughness=source.sheenRoughness,this.sheenRoughnessMap=source.sheenRoughnessMap,this.transmission=source.transmission,this.transmissionMap=source.transmissionMap,this.thickness=source.thickness,this.thicknessMap=source.thicknessMap,this.attenuationDistance=source.attenuationDistance,this.attenuationColor.copy(source.attenuationColor),this.specularIntensity=source.specularIntensity,this.specularIntensityMap=source.specularIntensityMap,this.specularColor.copy(source.specularColor),this.specularColorMap=source.specularColorMap,this}}class MeshPhongMaterial extends Material{constructor(parameters){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Color(16777215),this.specular=new Color(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.specular.copy(source.specular),this.shininess=source.shininess,this.map=source.map,this.lightMap=source.lightMap,this.lightMapIntensity=source.lightMapIntensity,this.aoMap=source.aoMap,this.aoMapIntensity=source.aoMapIntensity,this.emissive.copy(source.emissive),this.emissiveMap=source.emissiveMap,this.emissiveIntensity=source.emissiveIntensity,this.bumpMap=source.bumpMap,this.bumpScale=source.bumpScale,this.normalMap=source.normalMap,this.normalMapType=source.normalMapType,this.normalScale.copy(source.normalScale),this.displacementMap=source.displacementMap,this.displacementScale=source.displacementScale,this.displacementBias=source.displacementBias,this.specularMap=source.specularMap,this.alphaMap=source.alphaMap,this.envMap=source.envMap,this.combine=source.combine,this.reflectivity=source.reflectivity,this.refractionRatio=source.refractionRatio,this.wireframe=source.wireframe,this.wireframeLinewidth=source.wireframeLinewidth,this.wireframeLinecap=source.wireframeLinecap,this.wireframeLinejoin=source.wireframeLinejoin,this.flatShading=source.flatShading,this.fog=source.fog,this}}class MeshToonMaterial extends Material{constructor(parameters){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Color(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.map=source.map,this.gradientMap=source.gradientMap,this.lightMap=source.lightMap,this.lightMapIntensity=source.lightMapIntensity,this.aoMap=source.aoMap,this.aoMapIntensity=source.aoMapIntensity,this.emissive.copy(source.emissive),this.emissiveMap=source.emissiveMap,this.emissiveIntensity=source.emissiveIntensity,this.bumpMap=source.bumpMap,this.bumpScale=source.bumpScale,this.normalMap=source.normalMap,this.normalMapType=source.normalMapType,this.normalScale.copy(source.normalScale),this.displacementMap=source.displacementMap,this.displacementScale=source.displacementScale,this.displacementBias=source.displacementBias,this.alphaMap=source.alphaMap,this.wireframe=source.wireframe,this.wireframeLinewidth=source.wireframeLinewidth,this.wireframeLinecap=source.wireframeLinecap,this.wireframeLinejoin=source.wireframeLinejoin,this.fog=source.fog,this}}class MeshNormalMaterial extends Material{constructor(parameters){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(parameters)}copy(source){return super.copy(source),this.bumpMap=source.bumpMap,this.bumpScale=source.bumpScale,this.normalMap=source.normalMap,this.normalMapType=source.normalMapType,this.normalScale.copy(source.normalScale),this.displacementMap=source.displacementMap,this.displacementScale=source.displacementScale,this.displacementBias=source.displacementBias,this.wireframe=source.wireframe,this.wireframeLinewidth=source.wireframeLinewidth,this.flatShading=source.flatShading,this}}class MeshLambertMaterial extends Material{constructor(parameters){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=MultiplyOperation,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.map=source.map,this.lightMap=source.lightMap,this.lightMapIntensity=source.lightMapIntensity,this.aoMap=source.aoMap,this.aoMapIntensity=source.aoMapIntensity,this.emissive.copy(source.emissive),this.emissiveMap=source.emissiveMap,this.emissiveIntensity=source.emissiveIntensity,this.bumpMap=source.bumpMap,this.bumpScale=source.bumpScale,this.normalMap=source.normalMap,this.normalMapType=source.normalMapType,this.normalScale.copy(source.normalScale),this.displacementMap=source.displacementMap,this.displacementScale=source.displacementScale,this.displacementBias=source.displacementBias,this.specularMap=source.specularMap,this.alphaMap=source.alphaMap,this.envMap=source.envMap,this.combine=source.combine,this.reflectivity=source.reflectivity,this.refractionRatio=source.refractionRatio,this.wireframe=source.wireframe,this.wireframeLinewidth=source.wireframeLinewidth,this.wireframeLinecap=source.wireframeLinecap,this.wireframeLinejoin=source.wireframeLinejoin,this.flatShading=source.flatShading,this.fog=source.fog,this}}class MeshMatcapMaterial extends Material{constructor(parameters){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Color(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=TangentSpaceNormalMap,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.defines={MATCAP:""},this.color.copy(source.color),this.matcap=source.matcap,this.map=source.map,this.bumpMap=source.bumpMap,this.bumpScale=source.bumpScale,this.normalMap=source.normalMap,this.normalMapType=source.normalMapType,this.normalScale.copy(source.normalScale),this.displacementMap=source.displacementMap,this.displacementScale=source.displacementScale,this.displacementBias=source.displacementBias,this.alphaMap=source.alphaMap,this.flatShading=source.flatShading,this.fog=source.fog,this}}class LineDashedMaterial extends LineBasicMaterial{constructor(parameters){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(parameters)}copy(source){return super.copy(source),this.scale=source.scale,this.dashSize=source.dashSize,this.gapSize=source.gapSize,this}}function convertArray(array,type,forceClone){return!array||!forceClone&&array.constructor===type?array:typeof type.BYTES_PER_ELEMENT=="number"?new type(array):Array.prototype.slice.call(array)}function isTypedArray(object){return ArrayBuffer.isView(object)&&!(object instanceof DataView)}function getKeyframeOrder(times){function compareTime(i2,j2){return times[i2]-times[j2]}const n=times.length,result=new Array(n);for(let i2=0;i2!==n;++i2)result[i2]=i2;return result.sort(compareTime),result}function sortedArray(values,stride,order){const nValues=values.length,result=new values.constructor(nValues);for(let i2=0,dstOffset=0;dstOffset!==nValues;++i2){const srcOffset=order[i2]*stride;for(let j2=0;j2!==stride;++j2)result[dstOffset++]=values[srcOffset+j2]}return result}function flattenJSON(jsonKeys,times,values,valuePropertyName){let i2=1,key=jsonKeys[0];for(;key!==void 0&&key[valuePropertyName]===void 0;)key=jsonKeys[i2++];if(key===void 0)return;let value=key[valuePropertyName];if(value!==void 0)if(Array.isArray(value))do value=key[valuePropertyName],value!==void 0&&(times.push(key.time),values.push.apply(values,value)),key=jsonKeys[i2++];while(key!==void 0);else if(value.toArray!==void 0)do value=key[valuePropertyName],value!==void 0&&(times.push(key.time),value.toArray(values,values.length)),key=jsonKeys[i2++];while(key!==void 0);else do value=key[valuePropertyName],value!==void 0&&(times.push(key.time),values.push(value)),key=jsonKeys[i2++];while(key!==void 0)}function subclip(sourceClip,name,startFrame,endFrame,fps=30){const clip=sourceClip.clone();clip.name=name;const tracks=[];for(let i2=0;i2<clip.tracks.length;++i2){const track=clip.tracks[i2],valueSize=track.getValueSize(),times=[],values=[];for(let j2=0;j2<track.times.length;++j2){const frame2=track.times[j2]*fps;if(!(frame2<startFrame||frame2>=endFrame)){times.push(track.times[j2]);for(let k2=0;k2<valueSize;++k2)values.push(track.values[j2*valueSize+k2])}}times.length!==0&&(track.times=convertArray(times,track.times.constructor),track.values=convertArray(values,track.values.constructor),tracks.push(track))}clip.tracks=tracks;let minStartTime=1/0;for(let i2=0;i2<clip.tracks.length;++i2)minStartTime>clip.tracks[i2].times[0]&&(minStartTime=clip.tracks[i2].times[0]);for(let i2=0;i2<clip.tracks.length;++i2)clip.tracks[i2].shift(-1*minStartTime);return clip.resetDuration(),clip}function makeClipAdditive(targetClip,referenceFrame=0,referenceClip=targetClip,fps=30){fps<=0&&(fps=30);const numTracks=referenceClip.tracks.length,referenceTime=referenceFrame/fps;for(let i2=0;i2<numTracks;++i2){const referenceTrack=referenceClip.tracks[i2],referenceTrackType=referenceTrack.ValueTypeName;if(referenceTrackType==="bool"||referenceTrackType==="string")continue;const targetTrack=targetClip.tracks.find(function(track){return track.name===referenceTrack.name&&track.ValueTypeName===referenceTrackType});if(targetTrack===void 0)continue;let referenceOffset=0;const referenceValueSize=referenceTrack.getValueSize();referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(referenceOffset=referenceValueSize/3);let targetOffset=0;const targetValueSize=targetTrack.getValueSize();targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(targetOffset=targetValueSize/3);const lastIndex=referenceTrack.times.length-1;let referenceValue;if(referenceTime<=referenceTrack.times[0]){const startIndex=referenceOffset,endIndex=referenceValueSize-referenceOffset;referenceValue=referenceTrack.values.slice(startIndex,endIndex)}else if(referenceTime>=referenceTrack.times[lastIndex]){const startIndex=lastIndex*referenceValueSize+referenceOffset,endIndex=startIndex+referenceValueSize-referenceOffset;referenceValue=referenceTrack.values.slice(startIndex,endIndex)}else{const interpolant=referenceTrack.createInterpolant(),startIndex=referenceOffset,endIndex=referenceValueSize-referenceOffset;interpolant.evaluate(referenceTime),referenceValue=interpolant.resultBuffer.slice(startIndex,endIndex)}referenceTrackType==="quaternion"&&new Quaternion().fromArray(referenceValue).normalize().conjugate().toArray(referenceValue);const numTimes=targetTrack.times.length;for(let j2=0;j2<numTimes;++j2){const valueStart=j2*targetValueSize+targetOffset;if(referenceTrackType==="quaternion")Quaternion.multiplyQuaternionsFlat(targetTrack.values,valueStart,referenceValue,0,targetTrack.values,valueStart);else{const valueEnd=targetValueSize-targetOffset*2;for(let k2=0;k2<valueEnd;++k2)targetTrack.values[valueStart+k2]-=referenceValue[k2]}}}return targetClip.blendMode=AdditiveAnimationBlendMode,targetClip}const AnimationUtils={convertArray,isTypedArray,getKeyframeOrder,sortedArray,flattenJSON,subclip,makeClipAdditive};class Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){this.parameterPositions=parameterPositions,this._cachedIndex=0,this.resultBuffer=resultBuffer!==void 0?resultBuffer:new sampleValues.constructor(sampleSize),this.sampleValues=sampleValues,this.valueSize=sampleSize,this.settings=null,this.DefaultSettings_={}}evaluate(t2){const pp=this.parameterPositions;let i1=this._cachedIndex,t1=pp[i1],t0=pp[i1-1];validate_interval:{seek:{let right;linear_scan:{forward_scan:if(!(t2<t1)){for(let giveUpAt=i1+2;;){if(t1===void 0){if(t2<t0)break forward_scan;return i1=pp.length,this._cachedIndex=i1,this.copySampleValue_(i1-1)}if(i1===giveUpAt)break;if(t0=t1,t1=pp[++i1],t2<t1)break seek}right=pp.length;break linear_scan}if(!(t2>=t0)){const t1global=pp[1];t2<t1global&&(i1=2,t0=t1global);for(let giveUpAt=i1-2;;){if(t0===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i1===giveUpAt)break;if(t1=t0,t0=pp[--i1-1],t2>=t0)break seek}right=i1,i1=0;break linear_scan}break validate_interval}for(;i1<right;){const mid=i1+right>>>1;t2<pp[mid]?right=mid:i1=mid+1}if(t1=pp[i1],t0=pp[i1-1],t0===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(t1===void 0)return i1=pp.length,this._cachedIndex=i1,this.copySampleValue_(i1-1)}this._cachedIndex=i1,this.intervalChanged_(i1,t0,t1)}return this.interpolate_(i1,t0,t2,t1)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(index){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=index*stride;for(let i2=0;i2!==stride;++i2)result[i2]=values[offset+i2];return result}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class CubicInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding}}intervalChanged_(i1,t0,t1){const pp=this.parameterPositions;let iPrev=i1-2,iNext=i1+1,tPrev=pp[iPrev],tNext=pp[iNext];if(tPrev===void 0)switch(this.getSettings_().endingStart){case ZeroSlopeEnding:iPrev=i1,tPrev=2*t0-t1;break;case WrapAroundEnding:iPrev=pp.length-2,tPrev=t0+pp[iPrev]-pp[iPrev+1];break;default:iPrev=i1,tPrev=t1}if(tNext===void 0)switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:iNext=i1,tNext=2*t1-t0;break;case WrapAroundEnding:iNext=1,tNext=t1+pp[1]-pp[0];break;default:iNext=i1-1,tNext=t0}const halfDt=(t1-t0)*.5,stride=this.valueSize;this._weightPrev=halfDt/(t0-tPrev),this._weightNext=halfDt/(tNext-t1),this._offsetPrev=iPrev*stride,this._offsetNext=iNext*stride}interpolate_(i1,t0,t2,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,o1=i1*stride,o0=o1-stride,oP=this._offsetPrev,oN=this._offsetNext,wP=this._weightPrev,wN=this._weightNext,p2=(t2-t0)/(t1-t0),pp=p2*p2,ppp=pp*p2,sP=-wP*ppp+2*wP*pp-wP*p2,s0=(1+wP)*ppp+(-1.5-2*wP)*pp+(-.5+wP)*p2+1,s1=(-1-wN)*ppp+(1.5+wN)*pp+.5*p2,sN=wN*ppp-wN*pp;for(let i2=0;i2!==stride;++i2)result[i2]=sP*values[oP+i2]+s0*values[o0+i2]+s1*values[o1+i2]+sN*values[oN+i2];return result}}class LinearInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer)}interpolate_(i1,t0,t2,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset1=i1*stride,offset0=offset1-stride,weight1=(t2-t0)/(t1-t0),weight0=1-weight1;for(let i2=0;i2!==stride;++i2)result[i2]=values[offset0+i2]*weight0+values[offset1+i2]*weight1;return result}}class DiscreteInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer)}interpolate_(i1){return this.copySampleValue_(i1-1)}}class KeyframeTrack{constructor(name,times,values,interpolation){if(name===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(times===void 0||times.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+name);this.name=name,this.times=convertArray(times,this.TimeBufferType),this.values=convertArray(values,this.ValueBufferType),this.setInterpolation(interpolation||this.DefaultInterpolation)}static toJSON(track){const trackType=track.constructor;let json;if(trackType.toJSON!==this.toJSON)json=trackType.toJSON(track);else{json={name:track.name,times:convertArray(track.times,Array),values:convertArray(track.values,Array)};const interpolation=track.getInterpolation();interpolation!==track.DefaultInterpolation&&(json.interpolation=interpolation)}return json.type=track.ValueTypeName,json}InterpolantFactoryMethodDiscrete(result){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),result)}InterpolantFactoryMethodLinear(result){return new LinearInterpolant(this.times,this.values,this.getValueSize(),result)}InterpolantFactoryMethodSmooth(result){return new CubicInterpolant(this.times,this.values,this.getValueSize(),result)}setInterpolation(interpolation){let factoryMethod;switch(interpolation){case InterpolateDiscrete:factoryMethod=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:factoryMethod=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:factoryMethod=this.InterpolantFactoryMethodSmooth;break}if(factoryMethod===void 0){const message="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(interpolation!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(message);return console.warn("THREE.KeyframeTrack:",message),this}return this.createInterpolant=factoryMethod,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth}}getValueSize(){return this.values.length/this.times.length}shift(timeOffset){if(timeOffset!==0){const times=this.times;for(let i2=0,n=times.length;i2!==n;++i2)times[i2]+=timeOffset}return this}scale(timeScale){if(timeScale!==1){const times=this.times;for(let i2=0,n=times.length;i2!==n;++i2)times[i2]*=timeScale}return this}trim(startTime,endTime){const times=this.times,nKeys=times.length;let from=0,to=nKeys-1;for(;from!==nKeys&&times[from]<startTime;)++from;for(;to!==-1&&times[to]>endTime;)--to;if(++to,from!==0||to!==nKeys){from>=to&&(to=Math.max(to,1),from=to-1);const stride=this.getValueSize();this.times=times.slice(from,to),this.values=this.values.slice(from*stride,to*stride)}return this}validate(){let valid=!0;const valueSize=this.getValueSize();valueSize-Math.floor(valueSize)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),valid=!1);const times=this.times,values=this.values,nKeys=times.length;nKeys===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),valid=!1);let prevTime=null;for(let i2=0;i2!==nKeys;i2++){const currTime=times[i2];if(typeof currTime=="number"&&isNaN(currTime)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,i2,currTime),valid=!1;break}if(prevTime!==null&&prevTime>currTime){console.error("THREE.KeyframeTrack: Out of order keys.",this,i2,currTime,prevTime),valid=!1;break}prevTime=currTime}if(values!==void 0&&isTypedArray(values))for(let i2=0,n=values.length;i2!==n;++i2){const value=values[i2];if(isNaN(value)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,i2,value),valid=!1;break}}return valid}optimize(){const times=this.times.slice(),values=this.values.slice(),stride=this.getValueSize(),smoothInterpolation=this.getInterpolation()===InterpolateSmooth,lastIndex=times.length-1;let writeIndex=1;for(let i2=1;i2<lastIndex;++i2){let keep=!1;const time=times[i2],timeNext=times[i2+1];if(time!==timeNext&&(i2!==1||time!==times[0]))if(smoothInterpolation)keep=!0;else{const offset=i2*stride,offsetP=offset-stride,offsetN=offset+stride;for(let j2=0;j2!==stride;++j2){const value=values[offset+j2];if(value!==values[offsetP+j2]||value!==values[offsetN+j2]){keep=!0;break}}}if(keep){if(i2!==writeIndex){times[writeIndex]=times[i2];const readOffset=i2*stride,writeOffset=writeIndex*stride;for(let j2=0;j2!==stride;++j2)values[writeOffset+j2]=values[readOffset+j2]}++writeIndex}}if(lastIndex>0){times[writeIndex]=times[lastIndex];for(let readOffset=lastIndex*stride,writeOffset=writeIndex*stride,j2=0;j2!==stride;++j2)values[writeOffset+j2]=values[readOffset+j2];++writeIndex}return writeIndex!==times.length?(this.times=times.slice(0,writeIndex),this.values=values.slice(0,writeIndex*stride)):(this.times=times,this.values=values),this}clone(){const times=this.times.slice(),values=this.values.slice(),TypedKeyframeTrack=this.constructor,track=new TypedKeyframeTrack(this.name,times,values);return track.createInterpolant=this.createInterpolant,track}}KeyframeTrack.prototype.TimeBufferType=Float32Array;KeyframeTrack.prototype.ValueBufferType=Float32Array;KeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;class BooleanKeyframeTrack extends KeyframeTrack{}BooleanKeyframeTrack.prototype.ValueTypeName="bool";BooleanKeyframeTrack.prototype.ValueBufferType=Array;BooleanKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class ColorKeyframeTrack extends KeyframeTrack{}ColorKeyframeTrack.prototype.ValueTypeName="color";class NumberKeyframeTrack extends KeyframeTrack{}NumberKeyframeTrack.prototype.ValueTypeName="number";class QuaternionLinearInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer)}interpolate_(i1,t0,t2,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,alpha2=(t2-t0)/(t1-t0);let offset=i1*stride;for(let end=offset+stride;offset!==end;offset+=4)Quaternion.slerpFlat(result,0,values,offset-stride,values,offset,alpha2);return result}}class QuaternionKeyframeTrack extends KeyframeTrack{InterpolantFactoryMethodLinear(result){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),result)}}QuaternionKeyframeTrack.prototype.ValueTypeName="quaternion";QuaternionKeyframeTrack.prototype.DefaultInterpolation=InterpolateLinear;QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class StringKeyframeTrack extends KeyframeTrack{}StringKeyframeTrack.prototype.ValueTypeName="string";StringKeyframeTrack.prototype.ValueBufferType=Array;StringKeyframeTrack.prototype.DefaultInterpolation=InterpolateDiscrete;StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class VectorKeyframeTrack extends KeyframeTrack{}VectorKeyframeTrack.prototype.ValueTypeName="vector";class AnimationClip{constructor(name,duration=-1,tracks,blendMode=NormalAnimationBlendMode){this.name=name,this.tracks=tracks,this.duration=duration,this.blendMode=blendMode,this.uuid=generateUUID(),this.duration<0&&this.resetDuration()}static parse(json){const tracks=[],jsonTracks=json.tracks,frameTime=1/(json.fps||1);for(let i2=0,n=jsonTracks.length;i2!==n;++i2)tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));const clip=new this(json.name,json.duration,tracks,json.blendMode);return clip.uuid=json.uuid,clip}static toJSON(clip){const tracks=[],clipTracks=clip.tracks,json={name:clip.name,duration:clip.duration,tracks,uuid:clip.uuid,blendMode:clip.blendMode};for(let i2=0,n=clipTracks.length;i2!==n;++i2)tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));return json}static CreateFromMorphTargetSequence(name,morphTargetSequence,fps,noLoop){const numMorphTargets=morphTargetSequence.length,tracks=[];for(let i2=0;i2<numMorphTargets;i2++){let times=[],values=[];times.push((i2+numMorphTargets-1)%numMorphTargets,i2,(i2+1)%numMorphTargets),values.push(0,1,0);const order=getKeyframeOrder(times);times=sortedArray(times,1,order),values=sortedArray(values,1,order),!noLoop&&times[0]===0&&(times.push(numMorphTargets),values.push(values[0])),tracks.push(new NumberKeyframeTrack(".morphTargetInfluences["+morphTargetSequence[i2].name+"]",times,values).scale(1/fps))}return new this(name,-1,tracks)}static findByName(objectOrClipArray,name){let clipArray=objectOrClipArray;if(!Array.isArray(objectOrClipArray)){const o2=objectOrClipArray;clipArray=o2.geometry&&o2.geometry.animations||o2.animations}for(let i2=0;i2<clipArray.length;i2++)if(clipArray[i2].name===name)return clipArray[i2];return null}static CreateClipsFromMorphTargetSequences(morphTargets,fps,noLoop){const animationToMorphTargets={},pattern=/^([\w-]*?)([\d]+)$/;for(let i2=0,il=morphTargets.length;i2<il;i2++){const morphTarget=morphTargets[i2],parts=morphTarget.name.match(pattern);if(parts&&parts.length>1){const name=parts[1];let animationMorphTargets=animationToMorphTargets[name];animationMorphTargets||(animationToMorphTargets[name]=animationMorphTargets=[]),animationMorphTargets.push(morphTarget)}}const clips=[];for(const name in animationToMorphTargets)clips.push(this.CreateFromMorphTargetSequence(name,animationToMorphTargets[name],fps,noLoop));return clips}static parseAnimation(animation,bones){if(!animation)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const addNonemptyTrack=function(trackType,trackName,animationKeys,propertyName,destTracks){if(animationKeys.length!==0){const times=[],values=[];flattenJSON(animationKeys,times,values,propertyName),times.length!==0&&destTracks.push(new trackType(trackName,times,values))}},tracks=[],clipName=animation.name||"default",fps=animation.fps||30,blendMode=animation.blendMode;let duration=animation.length||-1;const hierarchyTracks=animation.hierarchy||[];for(let h2=0;h2<hierarchyTracks.length;h2++){const animationKeys=hierarchyTracks[h2].keys;if(!(!animationKeys||animationKeys.length===0))if(animationKeys[0].morphTargets){const morphTargetNames={};let k2;for(k2=0;k2<animationKeys.length;k2++)if(animationKeys[k2].morphTargets)for(let m2=0;m2<animationKeys[k2].morphTargets.length;m2++)morphTargetNames[animationKeys[k2].morphTargets[m2]]=-1;for(const morphTargetName in morphTargetNames){const times=[],values=[];for(let m2=0;m2!==animationKeys[k2].morphTargets.length;++m2){const animationKey=animationKeys[k2];times.push(animationKey.time),values.push(animationKey.morphTarget===morphTargetName?1:0)}tracks.push(new NumberKeyframeTrack(".morphTargetInfluence["+morphTargetName+"]",times,values))}duration=morphTargetNames.length*fps}else{const boneName=".bones["+bones[h2].name+"]";addNonemptyTrack(VectorKeyframeTrack,boneName+".position",animationKeys,"pos",tracks),addNonemptyTrack(QuaternionKeyframeTrack,boneName+".quaternion",animationKeys,"rot",tracks),addNonemptyTrack(VectorKeyframeTrack,boneName+".scale",animationKeys,"scl",tracks)}}return tracks.length===0?null:new this(clipName,duration,tracks,blendMode)}resetDuration(){const tracks=this.tracks;let duration=0;for(let i2=0,n=tracks.length;i2!==n;++i2){const track=this.tracks[i2];duration=Math.max(duration,track.times[track.times.length-1])}return this.duration=duration,this}trim(){for(let i2=0;i2<this.tracks.length;i2++)this.tracks[i2].trim(0,this.duration);return this}validate(){let valid=!0;for(let i2=0;i2<this.tracks.length;i2++)valid=valid&&this.tracks[i2].validate();return valid}optimize(){for(let i2=0;i2<this.tracks.length;i2++)this.tracks[i2].optimize();return this}clone(){const tracks=[];for(let i2=0;i2<this.tracks.length;i2++)tracks.push(this.tracks[i2].clone());return new this.constructor(this.name,this.duration,tracks,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function getTrackTypeForValueTypeName(typeName){switch(typeName.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return NumberKeyframeTrack;case"vector":case"vector2":case"vector3":case"vector4":return VectorKeyframeTrack;case"color":return ColorKeyframeTrack;case"quaternion":return QuaternionKeyframeTrack;case"bool":case"boolean":return BooleanKeyframeTrack;case"string":return StringKeyframeTrack}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+typeName)}function parseKeyframeTrack(json){if(json.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const trackType=getTrackTypeForValueTypeName(json.type);if(json.times===void 0){const times=[],values=[];flattenJSON(json.keys,times,values,"value"),json.times=times,json.values=values}return trackType.parse!==void 0?trackType.parse(json):new trackType(json.name,json.times,json.values,json.interpolation)}const Cache={enabled:!1,files:{},add:function(key,file){this.enabled!==!1&&(this.files[key]=file)},get:function(key){if(this.enabled!==!1)return this.files[key]},remove:function(key){delete this.files[key]},clear:function(){this.files={}}};class LoadingManager{constructor(onLoad,onProgress,onError){const scope=this;let isLoading=!1,itemsLoaded=0,itemsTotal=0,urlModifier;const handlers=[];this.onStart=void 0,this.onLoad=onLoad,this.onProgress=onProgress,this.onError=onError,this.itemStart=function(url){itemsTotal++,isLoading===!1&&scope.onStart!==void 0&&scope.onStart(url,itemsLoaded,itemsTotal),isLoading=!0},this.itemEnd=function(url){itemsLoaded++,scope.onProgress!==void 0&&scope.onProgress(url,itemsLoaded,itemsTotal),itemsLoaded===itemsTotal&&(isLoading=!1,scope.onLoad!==void 0&&scope.onLoad())},this.itemError=function(url){scope.onError!==void 0&&scope.onError(url)},this.resolveURL=function(url){return urlModifier?urlModifier(url):url},this.setURLModifier=function(transform){return urlModifier=transform,this},this.addHandler=function(regex,loader){return handlers.push(regex,loader),this},this.removeHandler=function(regex){const index=handlers.indexOf(regex);return index!==-1&&handlers.splice(index,2),this},this.getHandler=function(file){for(let i2=0,l2=handlers.length;i2<l2;i2+=2){const regex=handlers[i2],loader=handlers[i2+1];if(regex.global&&(regex.lastIndex=0),regex.test(file))return loader}return null}}}const DefaultLoadingManager=new LoadingManager;class Loader{constructor(manager){this.manager=manager!==void 0?manager:DefaultLoadingManager,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(url,onProgress){const scope=this;return new Promise(function(resolve2,reject){scope.load(url,resolve2,onProgress,reject)})}parse(){}setCrossOrigin(crossOrigin){return this.crossOrigin=crossOrigin,this}setWithCredentials(value){return this.withCredentials=value,this}setPath(path2){return this.path=path2,this}setResourcePath(resourcePath){return this.resourcePath=resourcePath,this}setRequestHeader(requestHeader){return this.requestHeader=requestHeader,this}}Loader.DEFAULT_MATERIAL_NAME="__DEFAULT";const loading={};class HttpError extends Error{constructor(message,response){super(message),this.response=response}}class FileLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){url===void 0&&(url=""),this.path!==void 0&&(url=this.path+url),url=this.manager.resolveURL(url);const cached=Cache.get(url);if(cached!==void 0)return this.manager.itemStart(url),setTimeout(()=>{onLoad&&onLoad(cached),this.manager.itemEnd(url)},0),cached;if(loading[url]!==void 0){loading[url].push({onLoad,onProgress,onError});return}loading[url]=[],loading[url].push({onLoad,onProgress,onError});const req=new Request(url,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),mimeType=this.mimeType,responseType=this.responseType;fetch(req).then(response=>{if(response.status===200||response.status===0){if(response.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||response.body===void 0||response.body.getReader===void 0)return response;const callbacks=loading[url],reader=response.body.getReader(),contentLength=response.headers.get("Content-Length")||response.headers.get("X-File-Size"),total=contentLength?parseInt(contentLength):0,lengthComputable=total!==0;let loaded=0;const stream=new ReadableStream({start(controller){readData();function readData(){reader.read().then(({done,value})=>{if(done)controller.close();else{loaded+=value.byteLength;const event=new ProgressEvent("progress",{lengthComputable,loaded,total});for(let i2=0,il=callbacks.length;i2<il;i2++){const callback=callbacks[i2];callback.onProgress&&callback.onProgress(event)}controller.enqueue(value),readData()}})}}});return new Response(stream)}else throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`,response)}).then(response=>{switch(responseType){case"arraybuffer":return response.arrayBuffer();case"blob":return response.blob();case"document":return response.text().then(text=>new DOMParser().parseFromString(text,mimeType));case"json":return response.json();default:if(mimeType===void 0)return response.text();{const exec=/charset="?([^;"\s]*)"?/i.exec(mimeType),label=exec&&exec[1]?exec[1].toLowerCase():void 0,decoder=new TextDecoder(label);return response.arrayBuffer().then(ab=>decoder.decode(ab))}}}).then(data=>{Cache.add(url,data);const callbacks=loading[url];delete loading[url];for(let i2=0,il=callbacks.length;i2<il;i2++){const callback=callbacks[i2];callback.onLoad&&callback.onLoad(data)}}).catch(err=>{const callbacks=loading[url];if(callbacks===void 0)throw this.manager.itemError(url),err;delete loading[url];for(let i2=0,il=callbacks.length;i2<il;i2++){const callback=callbacks[i2];callback.onError&&callback.onError(err)}this.manager.itemError(url)}).finally(()=>{this.manager.itemEnd(url)}),this.manager.itemStart(url)}setResponseType(value){return this.responseType=value,this}setMimeType(value){return this.mimeType=value,this}}class AnimationLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){const scope=this,loader=new FileLoader(this.manager);loader.setPath(this.path),loader.setRequestHeader(this.requestHeader),loader.setWithCredentials(this.withCredentials),loader.load(url,function(text){try{onLoad(scope.parse(JSON.parse(text)))}catch(e2){onError?onError(e2):console.error(e2),scope.manager.itemError(url)}},onProgress,onError)}parse(json){const animations2=[];for(let i2=0;i2<json.length;i2++){const clip=AnimationClip.parse(json[i2]);animations2.push(clip)}return animations2}}class CompressedTextureLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){const scope=this,images=[],texture=new CompressedTexture,loader=new FileLoader(this.manager);loader.setPath(this.path),loader.setResponseType("arraybuffer"),loader.setRequestHeader(this.requestHeader),loader.setWithCredentials(scope.withCredentials);let loaded=0;function loadTexture(i2){loader.load(url[i2],function(buffer){const texDatas=scope.parse(buffer,!0);images[i2]={width:texDatas.width,height:texDatas.height,format:texDatas.format,mipmaps:texDatas.mipmaps},loaded+=1,loaded===6&&(texDatas.mipmapCount===1&&(texture.minFilter=LinearFilter),texture.image=images,texture.format=texDatas.format,texture.needsUpdate=!0,onLoad&&onLoad(texture))},onProgress,onError)}if(Array.isArray(url))for(let i2=0,il=url.length;i2<il;++i2)loadTexture(i2);else loader.load(url,function(buffer){const texDatas=scope.parse(buffer,!0);if(texDatas.isCubemap){const faces=texDatas.mipmaps.length/texDatas.mipmapCount;for(let f2=0;f2<faces;f2++){images[f2]={mipmaps:[]};for(let i2=0;i2<texDatas.mipmapCount;i2++)images[f2].mipmaps.push(texDatas.mipmaps[f2*texDatas.mipmapCount+i2]),images[f2].format=texDatas.format,images[f2].width=texDatas.width,images[f2].height=texDatas.height}texture.image=images}else texture.image.width=texDatas.width,texture.image.height=texDatas.height,texture.mipmaps=texDatas.mipmaps;texDatas.mipmapCount===1&&(texture.minFilter=LinearFilter),texture.format=texDatas.format,texture.needsUpdate=!0,onLoad&&onLoad(texture)},onProgress,onError);return texture}}class ImageLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){this.path!==void 0&&(url=this.path+url),url=this.manager.resolveURL(url);const scope=this,cached=Cache.get(url);if(cached!==void 0)return scope.manager.itemStart(url),setTimeout(function(){onLoad&&onLoad(cached),scope.manager.itemEnd(url)},0),cached;const image=createElementNS("img");function onImageLoad(){removeEventListeners(),Cache.add(url,this),onLoad&&onLoad(this),scope.manager.itemEnd(url)}function onImageError(event){removeEventListeners(),onError&&onError(event),scope.manager.itemError(url),scope.manager.itemEnd(url)}function removeEventListeners(){image.removeEventListener("load",onImageLoad,!1),image.removeEventListener("error",onImageError,!1)}return image.addEventListener("load",onImageLoad,!1),image.addEventListener("error",onImageError,!1),url.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(image.crossOrigin=this.crossOrigin),scope.manager.itemStart(url),image.src=url,image}}class CubeTextureLoader extends Loader{constructor(manager){super(manager)}load(urls,onLoad,onProgress,onError){const texture=new CubeTexture;texture.colorSpace=SRGBColorSpace;const loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin),loader.setPath(this.path);let loaded=0;function loadTexture(i2){loader.load(urls[i2],function(image){texture.images[i2]=image,loaded++,loaded===6&&(texture.needsUpdate=!0,onLoad&&onLoad(texture))},void 0,onError)}for(let i2=0;i2<urls.length;++i2)loadTexture(i2);return texture}}class DataTextureLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){const scope=this,texture=new DataTexture,loader=new FileLoader(this.manager);return loader.setResponseType("arraybuffer"),loader.setRequestHeader(this.requestHeader),loader.setPath(this.path),loader.setWithCredentials(scope.withCredentials),loader.load(url,function(buffer){let texData;try{texData=scope.parse(buffer)}catch(error){if(onError!==void 0)onError(error);else{console.error(error);return}}texData.image!==void 0?texture.image=texData.image:texData.data!==void 0&&(texture.image.width=texData.width,texture.image.height=texData.height,texture.image.data=texData.data),texture.wrapS=texData.wrapS!==void 0?texData.wrapS:ClampToEdgeWrapping,texture.wrapT=texData.wrapT!==void 0?texData.wrapT:ClampToEdgeWrapping,texture.magFilter=texData.magFilter!==void 0?texData.magFilter:LinearFilter,texture.minFilter=texData.minFilter!==void 0?texData.minFilter:LinearFilter,texture.anisotropy=texData.anisotropy!==void 0?texData.anisotropy:1,texData.colorSpace!==void 0?texture.colorSpace=texData.colorSpace:texData.encoding!==void 0&&(texture.encoding=texData.encoding),texData.flipY!==void 0&&(texture.flipY=texData.flipY),texData.format!==void 0&&(texture.format=texData.format),texData.type!==void 0&&(texture.type=texData.type),texData.mipmaps!==void 0&&(texture.mipmaps=texData.mipmaps,texture.minFilter=LinearMipmapLinearFilter),texData.mipmapCount===1&&(texture.minFilter=LinearFilter),texData.generateMipmaps!==void 0&&(texture.generateMipmaps=texData.generateMipmaps),texture.needsUpdate=!0,onLoad&&onLoad(texture,texData)},onProgress,onError),texture}}class TextureLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){const texture=new Texture,loader=new ImageLoader(this.manager);return loader.setCrossOrigin(this.crossOrigin),loader.setPath(this.path),loader.load(url,function(image){texture.image=image,texture.needsUpdate=!0,onLoad!==void 0&&onLoad(texture)},onProgress,onError),texture}}class Light extends Object3D{constructor(color2,intensity=1){super(),this.isLight=!0,this.type="Light",this.color=new Color(color2),this.intensity=intensity}dispose(){}copy(source,recursive){return super.copy(source,recursive),this.color.copy(source.color),this.intensity=source.intensity,this}toJSON(meta){const data=super.toJSON(meta);return data.object.color=this.color.getHex(),data.object.intensity=this.intensity,this.groundColor!==void 0&&(data.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(data.object.distance=this.distance),this.angle!==void 0&&(data.object.angle=this.angle),this.decay!==void 0&&(data.object.decay=this.decay),this.penumbra!==void 0&&(data.object.penumbra=this.penumbra),this.shadow!==void 0&&(data.object.shadow=this.shadow.toJSON()),data}}class HemisphereLight extends Light{constructor(skyColor,groundColor,intensity){super(skyColor,intensity),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Color(groundColor)}copy(source,recursive){return super.copy(source,recursive),this.groundColor.copy(source.groundColor),this}}const _projScreenMatrix$1=new Matrix4,_lightPositionWorld$1=new Vector3,_lookTarget$1=new Vector3;class LightShadow{constructor(camera){this.camera=camera,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Vector2(512,512),this.map=null,this.mapPass=null,this.matrix=new Matrix4,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Frustum,this._frameExtents=new Vector2(1,1),this._viewportCount=1,this._viewports=[new Vector4(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(light){const shadowCamera=this.camera,shadowMatrix=this.matrix;_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld),shadowCamera.position.copy(_lightPositionWorld$1),_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld),shadowCamera.lookAt(_lookTarget$1),shadowCamera.updateMatrixWorld(),_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_projScreenMatrix$1),shadowMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),shadowMatrix.multiply(_projScreenMatrix$1)}getViewport(viewportIndex){return this._viewports[viewportIndex]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(source){return this.camera=source.camera.clone(),this.bias=source.bias,this.radius=source.radius,this.mapSize.copy(source.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const object={};return this.bias!==0&&(object.bias=this.bias),this.normalBias!==0&&(object.normalBias=this.normalBias),this.radius!==1&&(object.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(object.mapSize=this.mapSize.toArray()),object.camera=this.camera.toJSON(!1).object,delete object.camera.matrix,object}}class SpotLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera$1(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(light){const camera=this.camera,fov2=RAD2DEG*2*light.angle*this.focus,aspect2=this.mapSize.width/this.mapSize.height,far=light.distance||camera.far;(fov2!==camera.fov||aspect2!==camera.aspect||far!==camera.far)&&(camera.fov=fov2,camera.aspect=aspect2,camera.far=far,camera.updateProjectionMatrix()),super.updateMatrices(light)}copy(source){return super.copy(source),this.focus=source.focus,this}}class SpotLight extends Light{constructor(color2,intensity,distance2=0,angle=Math.PI/3,penumbra=0,decay=2){super(color2,intensity),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.distance=distance2,this.angle=angle,this.penumbra=penumbra,this.decay=decay,this.map=null,this.shadow=new SpotLightShadow}get power(){return this.intensity*Math.PI}set power(power){this.intensity=power/Math.PI}dispose(){this.shadow.dispose()}copy(source,recursive){return super.copy(source,recursive),this.distance=source.distance,this.angle=source.angle,this.penumbra=source.penumbra,this.decay=source.decay,this.target=source.target.clone(),this.shadow=source.shadow.clone(),this}}const _projScreenMatrix=new Matrix4,_lightPositionWorld=new Vector3,_lookTarget=new Vector3;class PointLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera$1(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Vector2(4,2),this._viewportCount=6,this._viewports=[new Vector4(2,1,1,1),new Vector4(0,1,1,1),new Vector4(3,1,1,1),new Vector4(1,1,1,1),new Vector4(3,0,1,1),new Vector4(1,0,1,1)],this._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)],this._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)]}updateMatrices(light,viewportIndex=0){const camera=this.camera,shadowMatrix=this.matrix,far=light.distance||camera.far;far!==camera.far&&(camera.far=far,camera.updateProjectionMatrix()),_lightPositionWorld.setFromMatrixPosition(light.matrixWorld),camera.position.copy(_lightPositionWorld),_lookTarget.copy(camera.position),_lookTarget.add(this._cubeDirections[viewportIndex]),camera.up.copy(this._cubeUps[viewportIndex]),camera.lookAt(_lookTarget),camera.updateMatrixWorld(),shadowMatrix.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z),_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_projScreenMatrix)}}class PointLight extends Light{constructor(color2,intensity,distance2=0,decay=2){super(color2,intensity),this.isPointLight=!0,this.type="PointLight",this.distance=distance2,this.decay=decay,this.shadow=new PointLightShadow}get power(){return this.intensity*4*Math.PI}set power(power){this.intensity=power/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(source,recursive){return super.copy(source,recursive),this.distance=source.distance,this.decay=source.decay,this.shadow=source.shadow.clone(),this}}class DirectionalLightShadow extends LightShadow{constructor(){super(new OrthographicCamera(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class DirectionalLight extends Light{constructor(color2,intensity){super(color2,intensity),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.shadow=new DirectionalLightShadow}dispose(){this.shadow.dispose()}copy(source){return super.copy(source),this.target=source.target.clone(),this.shadow=source.shadow.clone(),this}}class AmbientLight extends Light{constructor(color2,intensity){super(color2,intensity),this.isAmbientLight=!0,this.type="AmbientLight"}}class RectAreaLight extends Light{constructor(color2,intensity,width=10,height=10){super(color2,intensity),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=width,this.height=height}get power(){return this.intensity*this.width*this.height*Math.PI}set power(power){this.intensity=power/(this.width*this.height*Math.PI)}copy(source){return super.copy(source),this.width=source.width,this.height=source.height,this}toJSON(meta){const data=super.toJSON(meta);return data.object.width=this.width,data.object.height=this.height,data}}class SphericalHarmonics3{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let i2=0;i2<9;i2++)this.coefficients.push(new Vector3)}set(coefficients){for(let i2=0;i2<9;i2++)this.coefficients[i2].copy(coefficients[i2]);return this}zero(){for(let i2=0;i2<9;i2++)this.coefficients[i2].set(0,0,0);return this}getAt(normal,target){const x2=normal.x,y2=normal.y,z=normal.z,coeff=this.coefficients;return target.copy(coeff[0]).multiplyScalar(.282095),target.addScaledVector(coeff[1],.488603*y2),target.addScaledVector(coeff[2],.488603*z),target.addScaledVector(coeff[3],.488603*x2),target.addScaledVector(coeff[4],1.092548*(x2*y2)),target.addScaledVector(coeff[5],1.092548*(y2*z)),target.addScaledVector(coeff[6],.315392*(3*z*z-1)),target.addScaledVector(coeff[7],1.092548*(x2*z)),target.addScaledVector(coeff[8],.546274*(x2*x2-y2*y2)),target}getIrradianceAt(normal,target){const x2=normal.x,y2=normal.y,z=normal.z,coeff=this.coefficients;return target.copy(coeff[0]).multiplyScalar(.886227),target.addScaledVector(coeff[1],2*.511664*y2),target.addScaledVector(coeff[2],2*.511664*z),target.addScaledVector(coeff[3],2*.511664*x2),target.addScaledVector(coeff[4],2*.429043*x2*y2),target.addScaledVector(coeff[5],2*.429043*y2*z),target.addScaledVector(coeff[6],.743125*z*z-.247708),target.addScaledVector(coeff[7],2*.429043*x2*z),target.addScaledVector(coeff[8],.429043*(x2*x2-y2*y2)),target}add(sh){for(let i2=0;i2<9;i2++)this.coefficients[i2].add(sh.coefficients[i2]);return this}addScaledSH(sh,s2){for(let i2=0;i2<9;i2++)this.coefficients[i2].addScaledVector(sh.coefficients[i2],s2);return this}scale(s2){for(let i2=0;i2<9;i2++)this.coefficients[i2].multiplyScalar(s2);return this}lerp(sh,alpha2){for(let i2=0;i2<9;i2++)this.coefficients[i2].lerp(sh.coefficients[i2],alpha2);return this}equals(sh){for(let i2=0;i2<9;i2++)if(!this.coefficients[i2].equals(sh.coefficients[i2]))return!1;return!0}copy(sh){return this.set(sh.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(array,offset=0){const coefficients=this.coefficients;for(let i2=0;i2<9;i2++)coefficients[i2].fromArray(array,offset+i2*3);return this}toArray(array=[],offset=0){const coefficients=this.coefficients;for(let i2=0;i2<9;i2++)coefficients[i2].toArray(array,offset+i2*3);return array}static getBasisAt(normal,shBasis){const x2=normal.x,y2=normal.y,z=normal.z;shBasis[0]=.282095,shBasis[1]=.488603*y2,shBasis[2]=.488603*z,shBasis[3]=.488603*x2,shBasis[4]=1.092548*x2*y2,shBasis[5]=1.092548*y2*z,shBasis[6]=.315392*(3*z*z-1),shBasis[7]=1.092548*x2*z,shBasis[8]=.546274*(x2*x2-y2*y2)}}class LightProbe extends Light{constructor(sh=new SphericalHarmonics3,intensity=1){super(void 0,intensity),this.isLightProbe=!0,this.sh=sh}copy(source){return super.copy(source),this.sh.copy(source.sh),this}fromJSON(json){return this.intensity=json.intensity,this.sh.fromArray(json.sh),this}toJSON(meta){const data=super.toJSON(meta);return data.object.sh=this.sh.toArray(),data}}class MaterialLoader extends Loader{constructor(manager){super(manager),this.textures={}}load(url,onLoad,onProgress,onError){const scope=this,loader=new FileLoader(scope.manager);loader.setPath(scope.path),loader.setRequestHeader(scope.requestHeader),loader.setWithCredentials(scope.withCredentials),loader.load(url,function(text){try{onLoad(scope.parse(JSON.parse(text)))}catch(e2){onError?onError(e2):console.error(e2),scope.manager.itemError(url)}},onProgress,onError)}parse(json){const textures=this.textures;function getTexture(name){return textures[name]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",name),textures[name]}const material=MaterialLoader.createMaterialFromType(json.type);if(json.uuid!==void 0&&(material.uuid=json.uuid),json.name!==void 0&&(material.name=json.name),json.color!==void 0&&material.color!==void 0&&material.color.setHex(json.color),json.roughness!==void 0&&(material.roughness=json.roughness),json.metalness!==void 0&&(material.metalness=json.metalness),json.sheen!==void 0&&(material.sheen=json.sheen),json.sheenColor!==void 0&&(material.sheenColor=new Color().setHex(json.sheenColor)),json.sheenRoughness!==void 0&&(material.sheenRoughness=json.sheenRoughness),json.emissive!==void 0&&material.emissive!==void 0&&material.emissive.setHex(json.emissive),json.specular!==void 0&&material.specular!==void 0&&material.specular.setHex(json.specular),json.specularIntensity!==void 0&&(material.specularIntensity=json.specularIntensity),json.specularColor!==void 0&&material.specularColor!==void 0&&material.specularColor.setHex(json.specularColor),json.shininess!==void 0&&(material.shininess=json.shininess),json.clearcoat!==void 0&&(material.clearcoat=json.clearcoat),json.clearcoatRoughness!==void 0&&(material.clearcoatRoughness=json.clearcoatRoughness),json.iridescence!==void 0&&(material.iridescence=json.iridescence),json.iridescenceIOR!==void 0&&(material.iridescenceIOR=json.iridescenceIOR),json.iridescenceThicknessRange!==void 0&&(material.iridescenceThicknessRange=json.iridescenceThicknessRange),json.transmission!==void 0&&(material.transmission=json.transmission),json.thickness!==void 0&&(material.thickness=json.thickness),json.attenuationDistance!==void 0&&(material.attenuationDistance=json.attenuationDistance),json.attenuationColor!==void 0&&material.attenuationColor!==void 0&&material.attenuationColor.setHex(json.attenuationColor),json.anisotropy!==void 0&&(material.anisotropy=json.anisotropy),json.anisotropyRotation!==void 0&&(material.anisotropyRotation=json.anisotropyRotation),json.fog!==void 0&&(material.fog=json.fog),json.flatShading!==void 0&&(material.flatShading=json.flatShading),json.blending!==void 0&&(material.blending=json.blending),json.combine!==void 0&&(material.combine=json.combine),json.side!==void 0&&(material.side=json.side),json.shadowSide!==void 0&&(material.shadowSide=json.shadowSide),json.opacity!==void 0&&(material.opacity=json.opacity),json.transparent!==void 0&&(material.transparent=json.transparent),json.alphaTest!==void 0&&(material.alphaTest=json.alphaTest),json.alphaHash!==void 0&&(material.alphaHash=json.alphaHash),json.depthFunc!==void 0&&(material.depthFunc=json.depthFunc),json.depthTest!==void 0&&(material.depthTest=json.depthTest),json.depthWrite!==void 0&&(material.depthWrite=json.depthWrite),json.colorWrite!==void 0&&(material.colorWrite=json.colorWrite),json.blendSrc!==void 0&&(material.blendSrc=json.blendSrc),json.blendDst!==void 0&&(material.blendDst=json.blendDst),json.blendEquation!==void 0&&(material.blendEquation=json.blendEquation),json.blendSrcAlpha!==void 0&&(material.blendSrcAlpha=json.blendSrcAlpha),json.blendDstAlpha!==void 0&&(material.blendDstAlpha=json.blendDstAlpha),json.blendEquationAlpha!==void 0&&(material.blendEquationAlpha=json.blendEquationAlpha),json.blendColor!==void 0&&material.blendColor!==void 0&&material.blendColor.setHex(json.blendColor),json.blendAlpha!==void 0&&(material.blendAlpha=json.blendAlpha),json.stencilWriteMask!==void 0&&(material.stencilWriteMask=json.stencilWriteMask),json.stencilFunc!==void 0&&(material.stencilFunc=json.stencilFunc),json.stencilRef!==void 0&&(material.stencilRef=json.stencilRef),json.stencilFuncMask!==void 0&&(material.stencilFuncMask=json.stencilFuncMask),json.stencilFail!==void 0&&(material.stencilFail=json.stencilFail),json.stencilZFail!==void 0&&(material.stencilZFail=json.stencilZFail),json.stencilZPass!==void 0&&(material.stencilZPass=json.stencilZPass),json.stencilWrite!==void 0&&(material.stencilWrite=json.stencilWrite),json.wireframe!==void 0&&(material.wireframe=json.wireframe),json.wireframeLinewidth!==void 0&&(material.wireframeLinewidth=json.wireframeLinewidth),json.wireframeLinecap!==void 0&&(material.wireframeLinecap=json.wireframeLinecap),json.wireframeLinejoin!==void 0&&(material.wireframeLinejoin=json.wireframeLinejoin),json.rotation!==void 0&&(material.rotation=json.rotation),json.linewidth!==void 0&&(material.linewidth=json.linewidth),json.dashSize!==void 0&&(material.dashSize=json.dashSize),json.gapSize!==void 0&&(material.gapSize=json.gapSize),json.scale!==void 0&&(material.scale=json.scale),json.polygonOffset!==void 0&&(material.polygonOffset=json.polygonOffset),json.polygonOffsetFactor!==void 0&&(material.polygonOffsetFactor=json.polygonOffsetFactor),json.polygonOffsetUnits!==void 0&&(material.polygonOffsetUnits=json.polygonOffsetUnits),json.dithering!==void 0&&(material.dithering=json.dithering),json.alphaToCoverage!==void 0&&(material.alphaToCoverage=json.alphaToCoverage),json.premultipliedAlpha!==void 0&&(material.premultipliedAlpha=json.premultipliedAlpha),json.forceSinglePass!==void 0&&(material.forceSinglePass=json.forceSinglePass),json.visible!==void 0&&(material.visible=json.visible),json.toneMapped!==void 0&&(material.toneMapped=json.toneMapped),json.userData!==void 0&&(material.userData=json.userData),json.vertexColors!==void 0&&(typeof json.vertexColors=="number"?material.vertexColors=json.vertexColors>0:material.vertexColors=json.vertexColors),json.uniforms!==void 0)for(const name in json.uniforms){const uniform=json.uniforms[name];switch(material.uniforms[name]={},uniform.type){case"t":material.uniforms[name].value=getTexture(uniform.value);break;case"c":material.uniforms[name].value=new Color().setHex(uniform.value);break;case"v2":material.uniforms[name].value=new Vector2().fromArray(uniform.value);break;case"v3":material.uniforms[name].value=new Vector3().fromArray(uniform.value);break;case"v4":material.uniforms[name].value=new Vector4().fromArray(uniform.value);break;case"m3":material.uniforms[name].value=new Matrix3().fromArray(uniform.value);break;case"m4":material.uniforms[name].value=new Matrix4().fromArray(uniform.value);break;default:material.uniforms[name].value=uniform.value}}if(json.defines!==void 0&&(material.defines=json.defines),json.vertexShader!==void 0&&(material.vertexShader=json.vertexShader),json.fragmentShader!==void 0&&(material.fragmentShader=json.fragmentShader),json.glslVersion!==void 0&&(material.glslVersion=json.glslVersion),json.extensions!==void 0)for(const key in json.extensions)material.extensions[key]=json.extensions[key];if(json.lights!==void 0&&(material.lights=json.lights),json.clipping!==void 0&&(material.clipping=json.clipping),json.size!==void 0&&(material.size=json.size),json.sizeAttenuation!==void 0&&(material.sizeAttenuation=json.sizeAttenuation),json.map!==void 0&&(material.map=getTexture(json.map)),json.matcap!==void 0&&(material.matcap=getTexture(json.matcap)),json.alphaMap!==void 0&&(material.alphaMap=getTexture(json.alphaMap)),json.bumpMap!==void 0&&(material.bumpMap=getTexture(json.bumpMap)),json.bumpScale!==void 0&&(material.bumpScale=json.bumpScale),json.normalMap!==void 0&&(material.normalMap=getTexture(json.normalMap)),json.normalMapType!==void 0&&(material.normalMapType=json.normalMapType),json.normalScale!==void 0){let normalScale=json.normalScale;Array.isArray(normalScale)===!1&&(normalScale=[normalScale,normalScale]),material.normalScale=new Vector2().fromArray(normalScale)}return json.displacementMap!==void 0&&(material.displacementMap=getTexture(json.displacementMap)),json.displacementScale!==void 0&&(material.displacementScale=json.displacementScale),json.displacementBias!==void 0&&(material.displacementBias=json.displacementBias),json.roughnessMap!==void 0&&(material.roughnessMap=getTexture(json.roughnessMap)),json.metalnessMap!==void 0&&(material.metalnessMap=getTexture(json.metalnessMap)),json.emissiveMap!==void 0&&(material.emissiveMap=getTexture(json.emissiveMap)),json.emissiveIntensity!==void 0&&(material.emissiveIntensity=json.emissiveIntensity),json.specularMap!==void 0&&(material.specularMap=getTexture(json.specularMap)),json.specularIntensityMap!==void 0&&(material.specularIntensityMap=getTexture(json.specularIntensityMap)),json.specularColorMap!==void 0&&(material.specularColorMap=getTexture(json.specularColorMap)),json.envMap!==void 0&&(material.envMap=getTexture(json.envMap)),json.envMapIntensity!==void 0&&(material.envMapIntensity=json.envMapIntensity),json.reflectivity!==void 0&&(material.reflectivity=json.reflectivity),json.refractionRatio!==void 0&&(material.refractionRatio=json.refractionRatio),json.lightMap!==void 0&&(material.lightMap=getTexture(json.lightMap)),json.lightMapIntensity!==void 0&&(material.lightMapIntensity=json.lightMapIntensity),json.aoMap!==void 0&&(material.aoMap=getTexture(json.aoMap)),json.aoMapIntensity!==void 0&&(material.aoMapIntensity=json.aoMapIntensity),json.gradientMap!==void 0&&(material.gradientMap=getTexture(json.gradientMap)),json.clearcoatMap!==void 0&&(material.clearcoatMap=getTexture(json.clearcoatMap)),json.clearcoatRoughnessMap!==void 0&&(material.clearcoatRoughnessMap=getTexture(json.clearcoatRoughnessMap)),json.clearcoatNormalMap!==void 0&&(material.clearcoatNormalMap=getTexture(json.clearcoatNormalMap)),json.clearcoatNormalScale!==void 0&&(material.clearcoatNormalScale=new Vector2().fromArray(json.clearcoatNormalScale)),json.iridescenceMap!==void 0&&(material.iridescenceMap=getTexture(json.iridescenceMap)),json.iridescenceThicknessMap!==void 0&&(material.iridescenceThicknessMap=getTexture(json.iridescenceThicknessMap)),json.transmissionMap!==void 0&&(material.transmissionMap=getTexture(json.transmissionMap)),json.thicknessMap!==void 0&&(material.thicknessMap=getTexture(json.thicknessMap)),json.anisotropyMap!==void 0&&(material.anisotropyMap=getTexture(json.anisotropyMap)),json.sheenColorMap!==void 0&&(material.sheenColorMap=getTexture(json.sheenColorMap)),json.sheenRoughnessMap!==void 0&&(material.sheenRoughnessMap=getTexture(json.sheenRoughnessMap)),material}setTextures(value){return this.textures=value,this}static createMaterialFromType(type){const materialLib={ShadowMaterial,SpriteMaterial,RawShaderMaterial,ShaderMaterial,PointsMaterial,MeshPhysicalMaterial,MeshStandardMaterial,MeshPhongMaterial,MeshToonMaterial,MeshNormalMaterial,MeshLambertMaterial,MeshDepthMaterial,MeshDistanceMaterial,MeshBasicMaterial,MeshMatcapMaterial,LineDashedMaterial,LineBasicMaterial,Material};return new materialLib[type]}}class LoaderUtils{static decodeText(array){if(typeof TextDecoder<"u")return new TextDecoder().decode(array);let s2="";for(let i2=0,il=array.length;i2<il;i2++)s2+=String.fromCharCode(array[i2]);try{return decodeURIComponent(escape(s2))}catch{return s2}}static extractUrlBase(url){const index=url.lastIndexOf("/");return index===-1?"./":url.slice(0,index+1)}static resolveURL(url,path2){return typeof url!="string"||url===""?"":(/^https?:\/\//i.test(path2)&&/^\//.test(url)&&(path2=path2.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(url)||/^data:.*,.*$/i.test(url)||/^blob:.*$/i.test(url)?url:path2+url)}}class InstancedBufferGeometry extends BufferGeometry{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(source){return super.copy(source),this.instanceCount=source.instanceCount,this}toJSON(){const data=super.toJSON();return data.instanceCount=this.instanceCount,data.isInstancedBufferGeometry=!0,data}}class BufferGeometryLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){const scope=this,loader=new FileLoader(scope.manager);loader.setPath(scope.path),loader.setRequestHeader(scope.requestHeader),loader.setWithCredentials(scope.withCredentials),loader.load(url,function(text){try{onLoad(scope.parse(JSON.parse(text)))}catch(e2){onError?onError(e2):console.error(e2),scope.manager.itemError(url)}},onProgress,onError)}parse(json){const interleavedBufferMap={},arrayBufferMap={};function getInterleavedBuffer(json2,uuid){if(interleavedBufferMap[uuid]!==void 0)return interleavedBufferMap[uuid];const interleavedBuffer=json2.interleavedBuffers[uuid],buffer=getArrayBuffer(json2,interleavedBuffer.buffer),array=getTypedArray(interleavedBuffer.type,buffer),ib=new InterleavedBuffer(array,interleavedBuffer.stride);return ib.uuid=interleavedBuffer.uuid,interleavedBufferMap[uuid]=ib,ib}function getArrayBuffer(json2,uuid){if(arrayBufferMap[uuid]!==void 0)return arrayBufferMap[uuid];const arrayBuffer=json2.arrayBuffers[uuid],ab=new Uint32Array(arrayBuffer).buffer;return arrayBufferMap[uuid]=ab,ab}const geometry=json.isInstancedBufferGeometry?new InstancedBufferGeometry:new BufferGeometry,index=json.data.index;if(index!==void 0){const typedArray=getTypedArray(index.type,index.array);geometry.setIndex(new BufferAttribute(typedArray,1))}const attributes=json.data.attributes;for(const key in attributes){const attribute=attributes[key];let bufferAttribute;if(attribute.isInterleavedBufferAttribute){const interleavedBuffer=getInterleavedBuffer(json.data,attribute.data);bufferAttribute=new InterleavedBufferAttribute(interleavedBuffer,attribute.itemSize,attribute.offset,attribute.normalized)}else{const typedArray=getTypedArray(attribute.type,attribute.array),bufferAttributeConstr=attribute.isInstancedBufferAttribute?InstancedBufferAttribute:BufferAttribute;bufferAttribute=new bufferAttributeConstr(typedArray,attribute.itemSize,attribute.normalized)}attribute.name!==void 0&&(bufferAttribute.name=attribute.name),attribute.usage!==void 0&&bufferAttribute.setUsage(attribute.usage),attribute.updateRange!==void 0&&(bufferAttribute.updateRange.offset=attribute.updateRange.offset,bufferAttribute.updateRange.count=attribute.updateRange.count),geometry.setAttribute(key,bufferAttribute)}const morphAttributes=json.data.morphAttributes;if(morphAttributes)for(const key in morphAttributes){const attributeArray=morphAttributes[key],array=[];for(let i2=0,il=attributeArray.length;i2<il;i2++){const attribute=attributeArray[i2];let bufferAttribute;if(attribute.isInterleavedBufferAttribute){const interleavedBuffer=getInterleavedBuffer(json.data,attribute.data);bufferAttribute=new InterleavedBufferAttribute(interleavedBuffer,attribute.itemSize,attribute.offset,attribute.normalized)}else{const typedArray=getTypedArray(attribute.type,attribute.array);bufferAttribute=new BufferAttribute(typedArray,attribute.itemSize,attribute.normalized)}attribute.name!==void 0&&(bufferAttribute.name=attribute.name),array.push(bufferAttribute)}geometry.morphAttributes[key]=array}json.data.morphTargetsRelative&&(geometry.morphTargetsRelative=!0);const groups=json.data.groups||json.data.drawcalls||json.data.offsets;if(groups!==void 0)for(let i2=0,n=groups.length;i2!==n;++i2){const group=groups[i2];geometry.addGroup(group.start,group.count,group.materialIndex)}const boundingSphere=json.data.boundingSphere;if(boundingSphere!==void 0){const center=new Vector3;boundingSphere.center!==void 0&&center.fromArray(boundingSphere.center),geometry.boundingSphere=new Sphere(center,boundingSphere.radius)}return json.name&&(geometry.name=json.name),json.userData&&(geometry.userData=json.userData),geometry}}class ObjectLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){const scope=this,path2=this.path===""?LoaderUtils.extractUrlBase(url):this.path;this.resourcePath=this.resourcePath||path2;const loader=new FileLoader(this.manager);loader.setPath(this.path),loader.setRequestHeader(this.requestHeader),loader.setWithCredentials(this.withCredentials),loader.load(url,function(text){let json=null;try{json=JSON.parse(text)}catch(error){onError!==void 0&&onError(error),console.error("THREE:ObjectLoader: Can't parse "+url+".",error.message);return}const metadata=json.metadata;if(metadata===void 0||metadata.type===void 0||metadata.type.toLowerCase()==="geometry"){onError!==void 0&&onError(new Error("THREE.ObjectLoader: Can't load "+url)),console.error("THREE.ObjectLoader: Can't load "+url);return}scope.parse(json,onLoad)},onProgress,onError)}async loadAsync(url,onProgress){const scope=this,path2=this.path===""?LoaderUtils.extractUrlBase(url):this.path;this.resourcePath=this.resourcePath||path2;const loader=new FileLoader(this.manager);loader.setPath(this.path),loader.setRequestHeader(this.requestHeader),loader.setWithCredentials(this.withCredentials);const text=await loader.loadAsync(url,onProgress),json=JSON.parse(text),metadata=json.metadata;if(metadata===void 0||metadata.type===void 0||metadata.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+url);return await scope.parseAsync(json)}parse(json,onLoad){const animations2=this.parseAnimations(json.animations),shapes=this.parseShapes(json.shapes),geometries=this.parseGeometries(json.geometries,shapes),images=this.parseImages(json.images,function(){onLoad!==void 0&&onLoad(object)}),textures=this.parseTextures(json.textures,images),materials=this.parseMaterials(json.materials,textures),object=this.parseObject(json.object,geometries,materials,textures,animations2),skeletons=this.parseSkeletons(json.skeletons,object);if(this.bindSkeletons(object,skeletons),onLoad!==void 0){let hasImages=!1;for(const uuid in images)if(images[uuid].data instanceof HTMLImageElement){hasImages=!0;break}hasImages===!1&&onLoad(object)}return object}async parseAsync(json){const animations2=this.parseAnimations(json.animations),shapes=this.parseShapes(json.shapes),geometries=this.parseGeometries(json.geometries,shapes),images=await this.parseImagesAsync(json.images),textures=this.parseTextures(json.textures,images),materials=this.parseMaterials(json.materials,textures),object=this.parseObject(json.object,geometries,materials,textures,animations2),skeletons=this.parseSkeletons(json.skeletons,object);return this.bindSkeletons(object,skeletons),object}parseShapes(json){const shapes={};if(json!==void 0)for(let i2=0,l2=json.length;i2<l2;i2++){const shape=new Shape().fromJSON(json[i2]);shapes[shape.uuid]=shape}return shapes}parseSkeletons(json,object){const skeletons={},bones={};if(object.traverse(function(child){child.isBone&&(bones[child.uuid]=child)}),json!==void 0)for(let i2=0,l2=json.length;i2<l2;i2++){const skeleton=new Skeleton().fromJSON(json[i2],bones);skeletons[skeleton.uuid]=skeleton}return skeletons}parseGeometries(json,shapes){const geometries={};if(json!==void 0){const bufferGeometryLoader=new BufferGeometryLoader;for(let i2=0,l2=json.length;i2<l2;i2++){let geometry;const data=json[i2];switch(data.type){case"BufferGeometry":case"InstancedBufferGeometry":geometry=bufferGeometryLoader.parse(data);break;default:data.type in Geometries?geometry=Geometries[data.type].fromJSON(data,shapes):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`)}geometry.uuid=data.uuid,data.name!==void 0&&(geometry.name=data.name),data.userData!==void 0&&(geometry.userData=data.userData),geometries[data.uuid]=geometry}}return geometries}parseMaterials(json,textures){const cache={},materials={};if(json!==void 0){const loader=new MaterialLoader;loader.setTextures(textures);for(let i2=0,l2=json.length;i2<l2;i2++){const data=json[i2];cache[data.uuid]===void 0&&(cache[data.uuid]=loader.parse(data)),materials[data.uuid]=cache[data.uuid]}}return materials}parseAnimations(json){const animations2={};if(json!==void 0)for(let i2=0;i2<json.length;i2++){const data=json[i2],clip=AnimationClip.parse(data);animations2[clip.uuid]=clip}return animations2}parseImages(json,onLoad){const scope=this,images={};let loader;function loadImage(url){return scope.manager.itemStart(url),loader.load(url,function(){scope.manager.itemEnd(url)},void 0,function(){scope.manager.itemError(url),scope.manager.itemEnd(url)})}function deserializeImage(image){if(typeof image=="string"){const url=image,path2=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(url)?url:scope.resourcePath+url;return loadImage(path2)}else return image.data?{data:getTypedArray(image.type,image.data),width:image.width,height:image.height}:null}if(json!==void 0&&json.length>0){const manager=new LoadingManager(onLoad);loader=new ImageLoader(manager),loader.setCrossOrigin(this.crossOrigin);for(let i2=0,il=json.length;i2<il;i2++){const image=json[i2],url=image.url;if(Array.isArray(url)){const imageArray=[];for(let j2=0,jl=url.length;j2<jl;j2++){const currentUrl=url[j2],deserializedImage=deserializeImage(currentUrl);deserializedImage!==null&&(deserializedImage instanceof HTMLImageElement?imageArray.push(deserializedImage):imageArray.push(new DataTexture(deserializedImage.data,deserializedImage.width,deserializedImage.height)))}images[image.uuid]=new Source(imageArray)}else{const deserializedImage=deserializeImage(image.url);images[image.uuid]=new Source(deserializedImage)}}}return images}async parseImagesAsync(json){const scope=this,images={};let loader;async function deserializeImage(image){if(typeof image=="string"){const url=image,path2=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(url)?url:scope.resourcePath+url;return await loader.loadAsync(path2)}else return image.data?{data:getTypedArray(image.type,image.data),width:image.width,height:image.height}:null}if(json!==void 0&&json.length>0){loader=new ImageLoader(this.manager),loader.setCrossOrigin(this.crossOrigin);for(let i2=0,il=json.length;i2<il;i2++){const image=json[i2],url=image.url;if(Array.isArray(url)){const imageArray=[];for(let j2=0,jl=url.length;j2<jl;j2++){const currentUrl=url[j2],deserializedImage=await deserializeImage(currentUrl);deserializedImage!==null&&(deserializedImage instanceof HTMLImageElement?imageArray.push(deserializedImage):imageArray.push(new DataTexture(deserializedImage.data,deserializedImage.width,deserializedImage.height)))}images[image.uuid]=new Source(imageArray)}else{const deserializedImage=await deserializeImage(image.url);images[image.uuid]=new Source(deserializedImage)}}}return images}parseTextures(json,images){function parseConstant(value,type){return typeof value=="number"?value:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",value),type[value])}const textures={};if(json!==void 0)for(let i2=0,l2=json.length;i2<l2;i2++){const data=json[i2];data.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',data.uuid),images[data.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",data.image);const source=images[data.image],image=source.data;let texture;Array.isArray(image)?(texture=new CubeTexture,image.length===6&&(texture.needsUpdate=!0)):(image&&image.data?texture=new DataTexture:texture=new Texture,image&&(texture.needsUpdate=!0)),texture.source=source,texture.uuid=data.uuid,data.name!==void 0&&(texture.name=data.name),data.mapping!==void 0&&(texture.mapping=parseConstant(data.mapping,TEXTURE_MAPPING)),data.channel!==void 0&&(texture.channel=data.channel),data.offset!==void 0&&texture.offset.fromArray(data.offset),data.repeat!==void 0&&texture.repeat.fromArray(data.repeat),data.center!==void 0&&texture.center.fromArray(data.center),data.rotation!==void 0&&(texture.rotation=data.rotation),data.wrap!==void 0&&(texture.wrapS=parseConstant(data.wrap[0],TEXTURE_WRAPPING),texture.wrapT=parseConstant(data.wrap[1],TEXTURE_WRAPPING)),data.format!==void 0&&(texture.format=data.format),data.internalFormat!==void 0&&(texture.internalFormat=data.internalFormat),data.type!==void 0&&(texture.type=data.type),data.colorSpace!==void 0&&(texture.colorSpace=data.colorSpace),data.encoding!==void 0&&(texture.encoding=data.encoding),data.minFilter!==void 0&&(texture.minFilter=parseConstant(data.minFilter,TEXTURE_FILTER)),data.magFilter!==void 0&&(texture.magFilter=parseConstant(data.magFilter,TEXTURE_FILTER)),data.anisotropy!==void 0&&(texture.anisotropy=data.anisotropy),data.flipY!==void 0&&(texture.flipY=data.flipY),data.generateMipmaps!==void 0&&(texture.generateMipmaps=data.generateMipmaps),data.premultiplyAlpha!==void 0&&(texture.premultiplyAlpha=data.premultiplyAlpha),data.unpackAlignment!==void 0&&(texture.unpackAlignment=data.unpackAlignment),data.compareFunction!==void 0&&(texture.compareFunction=data.compareFunction),data.userData!==void 0&&(texture.userData=data.userData),textures[data.uuid]=texture}return textures}parseObject(data,geometries,materials,textures,animations2){let object;function getGeometry(name){return geometries[name]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",name),geometries[name]}function getMaterial(name){if(name!==void 0){if(Array.isArray(name)){const array=[];for(let i2=0,l2=name.length;i2<l2;i2++){const uuid=name[i2];materials[uuid]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",uuid),array.push(materials[uuid])}return array}return materials[name]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",name),materials[name]}}function getTexture(uuid){return textures[uuid]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",uuid),textures[uuid]}let geometry,material;switch(data.type){case"Scene":object=new Scene$1,data.background!==void 0&&(Number.isInteger(data.background)?object.background=new Color(data.background):object.background=getTexture(data.background)),data.environment!==void 0&&(object.environment=getTexture(data.environment)),data.fog!==void 0&&(data.fog.type==="Fog"?object.fog=new Fog(data.fog.color,data.fog.near,data.fog.far):data.fog.type==="FogExp2"&&(object.fog=new FogExp2(data.fog.color,data.fog.density)),data.fog.name!==""&&(object.fog.name=data.fog.name)),data.backgroundBlurriness!==void 0&&(object.backgroundBlurriness=data.backgroundBlurriness),data.backgroundIntensity!==void 0&&(object.backgroundIntensity=data.backgroundIntensity);break;case"PerspectiveCamera":object=new PerspectiveCamera$1(data.fov,data.aspect,data.near,data.far),data.focus!==void 0&&(object.focus=data.focus),data.zoom!==void 0&&(object.zoom=data.zoom),data.filmGauge!==void 0&&(object.filmGauge=data.filmGauge),data.filmOffset!==void 0&&(object.filmOffset=data.filmOffset),data.view!==void 0&&(object.view=Object.assign({},data.view));break;case"OrthographicCamera":object=new OrthographicCamera(data.left,data.right,data.top,data.bottom,data.near,data.far),data.zoom!==void 0&&(object.zoom=data.zoom),data.view!==void 0&&(object.view=Object.assign({},data.view));break;case"AmbientLight":object=new AmbientLight(data.color,data.intensity);break;case"DirectionalLight":object=new DirectionalLight(data.color,data.intensity);break;case"PointLight":object=new PointLight(data.color,data.intensity,data.distance,data.decay);break;case"RectAreaLight":object=new RectAreaLight(data.color,data.intensity,data.width,data.height);break;case"SpotLight":object=new SpotLight(data.color,data.intensity,data.distance,data.angle,data.penumbra,data.decay);break;case"HemisphereLight":object=new HemisphereLight(data.color,data.groundColor,data.intensity);break;case"LightProbe":object=new LightProbe().fromJSON(data);break;case"SkinnedMesh":geometry=getGeometry(data.geometry),material=getMaterial(data.material),object=new SkinnedMesh(geometry,material),data.bindMode!==void 0&&(object.bindMode=data.bindMode),data.bindMatrix!==void 0&&object.bindMatrix.fromArray(data.bindMatrix),data.skeleton!==void 0&&(object.skeleton=data.skeleton);break;case"Mesh":geometry=getGeometry(data.geometry),material=getMaterial(data.material),object=new Mesh(geometry,material);break;case"InstancedMesh":geometry=getGeometry(data.geometry),material=getMaterial(data.material);const count=data.count,instanceMatrix=data.instanceMatrix,instanceColor=data.instanceColor;object=new InstancedMesh(geometry,material,count),object.instanceMatrix=new InstancedBufferAttribute(new Float32Array(instanceMatrix.array),16),instanceColor!==void 0&&(object.instanceColor=new InstancedBufferAttribute(new Float32Array(instanceColor.array),instanceColor.itemSize));break;case"LOD":object=new LOD;break;case"Line":object=new Line(getGeometry(data.geometry),getMaterial(data.material));break;case"LineLoop":object=new LineLoop(getGeometry(data.geometry),getMaterial(data.material));break;case"LineSegments":object=new LineSegments(getGeometry(data.geometry),getMaterial(data.material));break;case"PointCloud":case"Points":object=new Points(getGeometry(data.geometry),getMaterial(data.material));break;case"Sprite":object=new Sprite(getMaterial(data.material));break;case"Group":object=new Group;break;case"Bone":object=new Bone;break;default:object=new Object3D}if(object.uuid=data.uuid,data.name!==void 0&&(object.name=data.name),data.matrix!==void 0?(object.matrix.fromArray(data.matrix),data.matrixAutoUpdate!==void 0&&(object.matrixAutoUpdate=data.matrixAutoUpdate),object.matrixAutoUpdate&&object.matrix.decompose(object.position,object.quaternion,object.scale)):(data.position!==void 0&&object.position.fromArray(data.position),data.rotation!==void 0&&object.rotation.fromArray(data.rotation),data.quaternion!==void 0&&object.quaternion.fromArray(data.quaternion),data.scale!==void 0&&object.scale.fromArray(data.scale)),data.up!==void 0&&object.up.fromArray(data.up),data.castShadow!==void 0&&(object.castShadow=data.castShadow),data.receiveShadow!==void 0&&(object.receiveShadow=data.receiveShadow),data.shadow&&(data.shadow.bias!==void 0&&(object.shadow.bias=data.shadow.bias),data.shadow.normalBias!==void 0&&(object.shadow.normalBias=data.shadow.normalBias),data.shadow.radius!==void 0&&(object.shadow.radius=data.shadow.radius),data.shadow.mapSize!==void 0&&object.shadow.mapSize.fromArray(data.shadow.mapSize),data.shadow.camera!==void 0&&(object.shadow.camera=this.parseObject(data.shadow.camera))),data.visible!==void 0&&(object.visible=data.visible),data.frustumCulled!==void 0&&(object.frustumCulled=data.frustumCulled),data.renderOrder!==void 0&&(object.renderOrder=data.renderOrder),data.userData!==void 0&&(object.userData=data.userData),data.layers!==void 0&&(object.layers.mask=data.layers),data.children!==void 0){const children=data.children;for(let i2=0;i2<children.length;i2++)object.add(this.parseObject(children[i2],geometries,materials,textures,animations2))}if(data.animations!==void 0){const objectAnimations=data.animations;for(let i2=0;i2<objectAnimations.length;i2++){const uuid=objectAnimations[i2];object.animations.push(animations2[uuid])}}if(data.type==="LOD"){data.autoUpdate!==void 0&&(object.autoUpdate=data.autoUpdate);const levels=data.levels;for(let l2=0;l2<levels.length;l2++){const level=levels[l2],child=object.getObjectByProperty("uuid",level.object);child!==void 0&&object.addLevel(child,level.distance,level.hysteresis)}}return object}bindSkeletons(object,skeletons){Object.keys(skeletons).length!==0&&object.traverse(function(child){if(child.isSkinnedMesh===!0&&child.skeleton!==void 0){const skeleton=skeletons[child.skeleton];skeleton===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",child.skeleton):child.bind(skeleton,child.bindMatrix)}})}}const TEXTURE_MAPPING={UVMapping,CubeReflectionMapping,CubeRefractionMapping,EquirectangularReflectionMapping,EquirectangularRefractionMapping,CubeUVReflectionMapping},TEXTURE_WRAPPING={RepeatWrapping,ClampToEdgeWrapping,MirroredRepeatWrapping},TEXTURE_FILTER={NearestFilter,NearestMipmapNearestFilter,NearestMipmapLinearFilter,LinearFilter,LinearMipmapNearestFilter,LinearMipmapLinearFilter};class ImageBitmapLoader extends Loader{constructor(manager){super(manager),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(options){return this.options=options,this}load(url,onLoad,onProgress,onError){url===void 0&&(url=""),this.path!==void 0&&(url=this.path+url),url=this.manager.resolveURL(url);const scope=this,cached=Cache.get(url);if(cached!==void 0)return scope.manager.itemStart(url),setTimeout(function(){onLoad&&onLoad(cached),scope.manager.itemEnd(url)},0),cached;const fetchOptions={};fetchOptions.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",fetchOptions.headers=this.requestHeader,fetch(url,fetchOptions).then(function(res){return res.blob()}).then(function(blob){return createImageBitmap(blob,Object.assign(scope.options,{colorSpaceConversion:"none"}))}).then(function(imageBitmap){Cache.add(url,imageBitmap),onLoad&&onLoad(imageBitmap),scope.manager.itemEnd(url)}).catch(function(e2){onError&&onError(e2),scope.manager.itemError(url),scope.manager.itemEnd(url)}),scope.manager.itemStart(url)}}let _context;class AudioContext{static getContext(){return _context===void 0&&(_context=new(window.AudioContext||window.webkitAudioContext)),_context}static setContext(value){_context=value}}class AudioLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){const scope=this,loader=new FileLoader(this.manager);loader.setResponseType("arraybuffer"),loader.setPath(this.path),loader.setRequestHeader(this.requestHeader),loader.setWithCredentials(this.withCredentials),loader.load(url,function(buffer){try{const bufferCopy=buffer.slice(0);AudioContext.getContext().decodeAudioData(bufferCopy,function(audioBuffer){onLoad(audioBuffer)},handleError)}catch(e2){handleError(e2)}},onProgress,onError);function handleError(e2){onError?onError(e2):console.error(e2),scope.manager.itemError(url)}}}const _eyeRight=new Matrix4,_eyeLeft=new Matrix4,_projectionMatrix=new Matrix4;class StereoCamera{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new PerspectiveCamera$1,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new PerspectiveCamera$1,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(camera){const cache=this._cache;if(cache.focus!==camera.focus||cache.fov!==camera.fov||cache.aspect!==camera.aspect*this.aspect||cache.near!==camera.near||cache.far!==camera.far||cache.zoom!==camera.zoom||cache.eyeSep!==this.eyeSep){cache.focus=camera.focus,cache.fov=camera.fov,cache.aspect=camera.aspect*this.aspect,cache.near=camera.near,cache.far=camera.far,cache.zoom=camera.zoom,cache.eyeSep=this.eyeSep,_projectionMatrix.copy(camera.projectionMatrix);const eyeSepHalf=cache.eyeSep/2,eyeSepOnProjection=eyeSepHalf*cache.near/cache.focus,ymax=cache.near*Math.tan(DEG2RAD*cache.fov*.5)/cache.zoom;let xmin,xmax;_eyeLeft.elements[12]=-eyeSepHalf,_eyeRight.elements[12]=eyeSepHalf,xmin=-ymax*cache.aspect+eyeSepOnProjection,xmax=ymax*cache.aspect+eyeSepOnProjection,_projectionMatrix.elements[0]=2*cache.near/(xmax-xmin),_projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin),this.cameraL.projectionMatrix.copy(_projectionMatrix),xmin=-ymax*cache.aspect-eyeSepOnProjection,xmax=ymax*cache.aspect-eyeSepOnProjection,_projectionMatrix.elements[0]=2*cache.near/(xmax-xmin),_projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin),this.cameraR.projectionMatrix.copy(_projectionMatrix)}this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft),this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight)}}class Clock{constructor(autoStart=!0){this.autoStart=autoStart,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let diff=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const newTime=now();diff=(newTime-this.oldTime)/1e3,this.oldTime=newTime,this.elapsedTime+=diff}return diff}}function now(){return(typeof performance>"u"?Date:performance).now()}const _position$1=new Vector3,_quaternion$1=new Quaternion,_scale$1=new Vector3,_orientation$1=new Vector3;class AudioListener extends Object3D{constructor(){super(),this.type="AudioListener",this.context=AudioContext.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Clock}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(value){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=value,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(value){return this.gain.gain.setTargetAtTime(value,this.context.currentTime,.01),this}updateMatrixWorld(force){super.updateMatrixWorld(force);const listener=this.context.listener,up=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(_position$1,_quaternion$1,_scale$1),_orientation$1.set(0,0,-1).applyQuaternion(_quaternion$1),listener.positionX){const endTime=this.context.currentTime+this.timeDelta;listener.positionX.linearRampToValueAtTime(_position$1.x,endTime),listener.positionY.linearRampToValueAtTime(_position$1.y,endTime),listener.positionZ.linearRampToValueAtTime(_position$1.z,endTime),listener.forwardX.linearRampToValueAtTime(_orientation$1.x,endTime),listener.forwardY.linearRampToValueAtTime(_orientation$1.y,endTime),listener.forwardZ.linearRampToValueAtTime(_orientation$1.z,endTime),listener.upX.linearRampToValueAtTime(up.x,endTime),listener.upY.linearRampToValueAtTime(up.y,endTime),listener.upZ.linearRampToValueAtTime(up.z,endTime)}else listener.setPosition(_position$1.x,_position$1.y,_position$1.z),listener.setOrientation(_orientation$1.x,_orientation$1.y,_orientation$1.z,up.x,up.y,up.z)}}class Audio extends Object3D{constructor(listener){super(),this.type="Audio",this.listener=listener,this.context=listener.context,this.gain=this.context.createGain(),this.gain.connect(listener.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(audioNode){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=audioNode,this.connect(),this}setMediaElementSource(mediaElement){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(mediaElement),this.connect(),this}setMediaStreamSource(mediaStream){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(mediaStream),this.connect(),this}setBuffer(audioBuffer){return this.buffer=audioBuffer,this.sourceType="buffer",this.autoplay&&this.play(),this}play(delay2=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+delay2;const source=this.context.createBufferSource();return source.buffer=this.buffer,source.loop=this.loop,source.loopStart=this.loopStart,source.loopEnd=this.loopEnd,source.onended=this.onEnded.bind(this),source.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=source,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let i2=1,l2=this.filters.length;i2<l2;i2++)this.filters[i2-1].connect(this.filters[i2]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let i2=1,l2=this.filters.length;i2<l2;i2++)this.filters[i2-1].disconnect(this.filters[i2]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(value){return value||(value=[]),this._connected===!0?(this.disconnect(),this.filters=value.slice(),this.connect()):this.filters=value.slice(),this}setDetune(value){if(this.detune=value,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(filter2){return this.setFilters(filter2?[filter2]:[])}setPlaybackRate(value){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=value,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(value){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=value,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(value){return this.loopStart=value,this}setLoopEnd(value){return this.loopEnd=value,this}getVolume(){return this.gain.gain.value}setVolume(value){return this.gain.gain.setTargetAtTime(value,this.context.currentTime,.01),this}}const _position=new Vector3,_quaternion=new Quaternion,_scale=new Vector3,_orientation=new Vector3;class PositionalAudio extends Audio{constructor(listener){super(listener),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(value){return this.panner.refDistance=value,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(value){return this.panner.rolloffFactor=value,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(value){return this.panner.distanceModel=value,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(value){return this.panner.maxDistance=value,this}setDirectionalCone(coneInnerAngle,coneOuterAngle,coneOuterGain){return this.panner.coneInnerAngle=coneInnerAngle,this.panner.coneOuterAngle=coneOuterAngle,this.panner.coneOuterGain=coneOuterGain,this}updateMatrixWorld(force){if(super.updateMatrixWorld(force),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(_position,_quaternion,_scale),_orientation.set(0,0,1).applyQuaternion(_quaternion);const panner=this.panner;if(panner.positionX){const endTime=this.context.currentTime+this.listener.timeDelta;panner.positionX.linearRampToValueAtTime(_position.x,endTime),panner.positionY.linearRampToValueAtTime(_position.y,endTime),panner.positionZ.linearRampToValueAtTime(_position.z,endTime),panner.orientationX.linearRampToValueAtTime(_orientation.x,endTime),panner.orientationY.linearRampToValueAtTime(_orientation.y,endTime),panner.orientationZ.linearRampToValueAtTime(_orientation.z,endTime)}else panner.setPosition(_position.x,_position.y,_position.z),panner.setOrientation(_orientation.x,_orientation.y,_orientation.z)}}class AudioAnalyser{constructor(audio,fftSize=2048){this.analyser=audio.context.createAnalyser(),this.analyser.fftSize=fftSize,this.data=new Uint8Array(this.analyser.frequencyBinCount),audio.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let value=0;const data=this.getFrequencyData();for(let i2=0;i2<data.length;i2++)value+=data[i2];return value/data.length}}class PropertyMixer{constructor(binding,typeName,valueSize){this.binding=binding,this.valueSize=valueSize;let mixFunction,mixFunctionAdditive,setIdentity;switch(typeName){case"quaternion":mixFunction=this._slerp,mixFunctionAdditive=this._slerpAdditive,setIdentity=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(valueSize*6),this._workIndex=5;break;case"string":case"bool":mixFunction=this._select,mixFunctionAdditive=this._select,setIdentity=this._setAdditiveIdentityOther,this.buffer=new Array(valueSize*5);break;default:mixFunction=this._lerp,mixFunctionAdditive=this._lerpAdditive,setIdentity=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(valueSize*5)}this._mixBufferRegion=mixFunction,this._mixBufferRegionAdditive=mixFunctionAdditive,this._setIdentity=setIdentity,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(accuIndex,weight){const buffer=this.buffer,stride=this.valueSize,offset=accuIndex*stride+stride;let currentWeight=this.cumulativeWeight;if(currentWeight===0){for(let i2=0;i2!==stride;++i2)buffer[offset+i2]=buffer[i2];currentWeight=weight}else{currentWeight+=weight;const mix2=weight/currentWeight;this._mixBufferRegion(buffer,offset,0,mix2,stride)}this.cumulativeWeight=currentWeight}accumulateAdditive(weight){const buffer=this.buffer,stride=this.valueSize,offset=stride*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(buffer,offset,0,weight,stride),this.cumulativeWeightAdditive+=weight}apply(accuIndex){const stride=this.valueSize,buffer=this.buffer,offset=accuIndex*stride+stride,weight=this.cumulativeWeight,weightAdditive=this.cumulativeWeightAdditive,binding=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,weight<1){const originalValueOffset=stride*this._origIndex;this._mixBufferRegion(buffer,offset,originalValueOffset,1-weight,stride)}weightAdditive>0&&this._mixBufferRegionAdditive(buffer,offset,this._addIndex*stride,1,stride);for(let i2=stride,e2=stride+stride;i2!==e2;++i2)if(buffer[i2]!==buffer[i2+stride]){binding.setValue(buffer,offset);break}}saveOriginalState(){const binding=this.binding,buffer=this.buffer,stride=this.valueSize,originalValueOffset=stride*this._origIndex;binding.getValue(buffer,originalValueOffset);for(let i2=stride,e2=originalValueOffset;i2!==e2;++i2)buffer[i2]=buffer[originalValueOffset+i2%stride];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const originalValueOffset=this.valueSize*3;this.binding.setValue(this.buffer,originalValueOffset)}_setAdditiveIdentityNumeric(){const startIndex=this._addIndex*this.valueSize,endIndex=startIndex+this.valueSize;for(let i2=startIndex;i2<endIndex;i2++)this.buffer[i2]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const startIndex=this._origIndex*this.valueSize,targetIndex=this._addIndex*this.valueSize;for(let i2=0;i2<this.valueSize;i2++)this.buffer[targetIndex+i2]=this.buffer[startIndex+i2]}_select(buffer,dstOffset,srcOffset,t2,stride){if(t2>=.5)for(let i2=0;i2!==stride;++i2)buffer[dstOffset+i2]=buffer[srcOffset+i2]}_slerp(buffer,dstOffset,srcOffset,t2){Quaternion.slerpFlat(buffer,dstOffset,buffer,dstOffset,buffer,srcOffset,t2)}_slerpAdditive(buffer,dstOffset,srcOffset,t2,stride){const workOffset=this._workIndex*stride;Quaternion.multiplyQuaternionsFlat(buffer,workOffset,buffer,dstOffset,buffer,srcOffset),Quaternion.slerpFlat(buffer,dstOffset,buffer,dstOffset,buffer,workOffset,t2)}_lerp(buffer,dstOffset,srcOffset,t2,stride){const s2=1-t2;for(let i2=0;i2!==stride;++i2){const j2=dstOffset+i2;buffer[j2]=buffer[j2]*s2+buffer[srcOffset+i2]*t2}}_lerpAdditive(buffer,dstOffset,srcOffset,t2,stride){for(let i2=0;i2!==stride;++i2){const j2=dstOffset+i2;buffer[j2]=buffer[j2]+buffer[srcOffset+i2]*t2}}}const _RESERVED_CHARS_RE="\\[\\]\\.:\\/",_reservedRe=new RegExp("["+_RESERVED_CHARS_RE+"]","g"),_wordChar="[^"+_RESERVED_CHARS_RE+"]",_wordCharOrDot="[^"+_RESERVED_CHARS_RE.replace("\\.","")+"]",_directoryRe=/((?:WC+[\/:])*)/.source.replace("WC",_wordChar),_nodeRe=/(WCOD+)?/.source.replace("WCOD",_wordCharOrDot),_objectRe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",_wordChar),_propertyRe=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",_wordChar),_trackRe=new RegExp("^"+_directoryRe+_nodeRe+_objectRe+_propertyRe+"$"),_supportedObjectNames=["material","materials","bones","map"];class Composite{constructor(targetGroup,path2,optionalParsedPath){const parsedPath=optionalParsedPath||PropertyBinding.parseTrackName(path2);this._targetGroup=targetGroup,this._bindings=targetGroup.subscribe_(path2,parsedPath)}getValue(array,offset){this.bind();const firstValidIndex=this._targetGroup.nCachedObjects_,binding=this._bindings[firstValidIndex];binding!==void 0&&binding.getValue(array,offset)}setValue(array,offset){const bindings=this._bindings;for(let i2=this._targetGroup.nCachedObjects_,n=bindings.length;i2!==n;++i2)bindings[i2].setValue(array,offset)}bind(){const bindings=this._bindings;for(let i2=this._targetGroup.nCachedObjects_,n=bindings.length;i2!==n;++i2)bindings[i2].bind()}unbind(){const bindings=this._bindings;for(let i2=this._targetGroup.nCachedObjects_,n=bindings.length;i2!==n;++i2)bindings[i2].unbind()}}class PropertyBinding{constructor(rootNode,path2,parsedPath){this.path=path2,this.parsedPath=parsedPath||PropertyBinding.parseTrackName(path2),this.node=PropertyBinding.findNode(rootNode,this.parsedPath.nodeName),this.rootNode=rootNode,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(root,path2,parsedPath){return root&&root.isAnimationObjectGroup?new PropertyBinding.Composite(root,path2,parsedPath):new PropertyBinding(root,path2,parsedPath)}static sanitizeNodeName(name){return name.replace(/\s/g,"_").replace(_reservedRe,"")}static parseTrackName(trackName){const matches=_trackRe.exec(trackName);if(matches===null)throw new Error("PropertyBinding: Cannot parse trackName: "+trackName);const results={nodeName:matches[2],objectName:matches[3],objectIndex:matches[4],propertyName:matches[5],propertyIndex:matches[6]},lastDot=results.nodeName&&results.nodeName.lastIndexOf(".");if(lastDot!==void 0&&lastDot!==-1){const objectName=results.nodeName.substring(lastDot+1);_supportedObjectNames.indexOf(objectName)!==-1&&(results.nodeName=results.nodeName.substring(0,lastDot),results.objectName=objectName)}if(results.propertyName===null||results.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+trackName);return results}static findNode(root,nodeName){if(nodeName===void 0||nodeName===""||nodeName==="."||nodeName===-1||nodeName===root.name||nodeName===root.uuid)return root;if(root.skeleton){const bone=root.skeleton.getBoneByName(nodeName);if(bone!==void 0)return bone}if(root.children){const searchNodeSubtree=function(children){for(let i2=0;i2<children.length;i2++){const childNode=children[i2];if(childNode.name===nodeName||childNode.uuid===nodeName)return childNode;const result=searchNodeSubtree(childNode.children);if(result)return result}return null},subTreeNode=searchNodeSubtree(root.children);if(subTreeNode)return subTreeNode}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(buffer,offset){buffer[offset]=this.targetObject[this.propertyName]}_getValue_array(buffer,offset){const source=this.resolvedProperty;for(let i2=0,n=source.length;i2!==n;++i2)buffer[offset++]=source[i2]}_getValue_arrayElement(buffer,offset){buffer[offset]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(buffer,offset){this.resolvedProperty.toArray(buffer,offset)}_setValue_direct(buffer,offset){this.targetObject[this.propertyName]=buffer[offset]}_setValue_direct_setNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(buffer,offset){const dest=this.resolvedProperty;for(let i2=0,n=dest.length;i2!==n;++i2)dest[i2]=buffer[offset++]}_setValue_array_setNeedsUpdate(buffer,offset){const dest=this.resolvedProperty;for(let i2=0,n=dest.length;i2!==n;++i2)dest[i2]=buffer[offset++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(buffer,offset){const dest=this.resolvedProperty;for(let i2=0,n=dest.length;i2!==n;++i2)dest[i2]=buffer[offset++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset]}_setValue_arrayElement_setNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(buffer,offset){this.resolvedProperty.fromArray(buffer,offset)}_setValue_fromArray_setNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(targetArray,offset){this.bind(),this.getValue(targetArray,offset)}_setValue_unbound(sourceArray,offset){this.bind(),this.setValue(sourceArray,offset)}bind(){let targetObject=this.node;const parsedPath=this.parsedPath,objectName=parsedPath.objectName,propertyName=parsedPath.propertyName;let propertyIndex=parsedPath.propertyIndex;if(targetObject||(targetObject=PropertyBinding.findNode(this.rootNode,parsedPath.nodeName),this.node=targetObject),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!targetObject){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(objectName){let objectIndex=parsedPath.objectIndex;switch(objectName){case"materials":if(!targetObject.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!targetObject.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}targetObject=targetObject.material.materials;break;case"bones":if(!targetObject.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}targetObject=targetObject.skeleton.bones;for(let i2=0;i2<targetObject.length;i2++)if(targetObject[i2].name===objectIndex){objectIndex=i2;break}break;case"map":if("map"in targetObject){targetObject=targetObject.map;break}if(!targetObject.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!targetObject.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}targetObject=targetObject.material.map;break;default:if(targetObject[objectName]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}targetObject=targetObject[objectName]}if(objectIndex!==void 0){if(targetObject[objectIndex]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,targetObject);return}targetObject=targetObject[objectIndex]}}const nodeProperty=targetObject[propertyName];if(nodeProperty===void 0){const nodeName=parsedPath.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+nodeName+"."+propertyName+" but it wasn't found.",targetObject);return}let versioning=this.Versioning.None;this.targetObject=targetObject,targetObject.needsUpdate!==void 0?versioning=this.Versioning.NeedsUpdate:targetObject.matrixWorldNeedsUpdate!==void 0&&(versioning=this.Versioning.MatrixWorldNeedsUpdate);let bindingType=this.BindingType.Direct;if(propertyIndex!==void 0){if(propertyName==="morphTargetInfluences"){if(!targetObject.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!targetObject.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}targetObject.morphTargetDictionary[propertyIndex]!==void 0&&(propertyIndex=targetObject.morphTargetDictionary[propertyIndex])}bindingType=this.BindingType.ArrayElement,this.resolvedProperty=nodeProperty,this.propertyIndex=propertyIndex}else nodeProperty.fromArray!==void 0&&nodeProperty.toArray!==void 0?(bindingType=this.BindingType.HasFromToArray,this.resolvedProperty=nodeProperty):Array.isArray(nodeProperty)?(bindingType=this.BindingType.EntireArray,this.resolvedProperty=nodeProperty):this.propertyName=propertyName;this.getValue=this.GetterByBindingType[bindingType],this.setValue=this.SetterByBindingTypeAndVersioning[bindingType][versioning]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}PropertyBinding.Composite=Composite;PropertyBinding.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};PropertyBinding.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};PropertyBinding.prototype.GetterByBindingType=[PropertyBinding.prototype._getValue_direct,PropertyBinding.prototype._getValue_array,PropertyBinding.prototype._getValue_arrayElement,PropertyBinding.prototype._getValue_toArray];PropertyBinding.prototype.SetterByBindingTypeAndVersioning=[[PropertyBinding.prototype._setValue_direct,PropertyBinding.prototype._setValue_direct_setNeedsUpdate,PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_array,PropertyBinding.prototype._setValue_array_setNeedsUpdate,PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_arrayElement,PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_fromArray,PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class AnimationObjectGroup{constructor(){this.isAnimationObjectGroup=!0,this.uuid=generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const indices={};this._indicesByUUID=indices;for(let i2=0,n=arguments.length;i2!==n;++i2)indices[arguments[i2].uuid]=i2;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const scope=this;this.stats={objects:{get total(){return scope._objects.length},get inUse(){return this.total-scope.nCachedObjects_}},get bindingsPerObject(){return scope._bindings.length}}}add(){const objects=this._objects,indicesByUUID=this._indicesByUUID,paths2=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,nBindings=bindings.length;let knownObject,nObjects=objects.length,nCachedObjects=this.nCachedObjects_;for(let i2=0,n=arguments.length;i2!==n;++i2){const object=arguments[i2],uuid=object.uuid;let index=indicesByUUID[uuid];if(index===void 0){index=nObjects++,indicesByUUID[uuid]=index,objects.push(object);for(let j2=0,m2=nBindings;j2!==m2;++j2)bindings[j2].push(new PropertyBinding(object,paths2[j2],parsedPaths[j2]))}else if(index<nCachedObjects){knownObject=objects[index];const firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex];indicesByUUID[lastCachedObject.uuid]=index,objects[index]=lastCachedObject,indicesByUUID[uuid]=firstActiveIndex,objects[firstActiveIndex]=object;for(let j2=0,m2=nBindings;j2!==m2;++j2){const bindingsForPath=bindings[j2],lastCached=bindingsForPath[firstActiveIndex];let binding=bindingsForPath[index];bindingsForPath[index]=lastCached,binding===void 0&&(binding=new PropertyBinding(object,paths2[j2],parsedPaths[j2])),bindingsForPath[firstActiveIndex]=binding}}else objects[index]!==knownObject&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=nCachedObjects}remove(){const objects=this._objects,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;let nCachedObjects=this.nCachedObjects_;for(let i2=0,n=arguments.length;i2!==n;++i2){const object=arguments[i2],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==void 0&&index>=nCachedObjects){const lastCachedIndex=nCachedObjects++,firstActiveObject=objects[lastCachedIndex];indicesByUUID[firstActiveObject.uuid]=index,objects[index]=firstActiveObject,indicesByUUID[uuid]=lastCachedIndex,objects[lastCachedIndex]=object;for(let j2=0,m2=nBindings;j2!==m2;++j2){const bindingsForPath=bindings[j2],firstActive=bindingsForPath[lastCachedIndex],binding=bindingsForPath[index];bindingsForPath[index]=firstActive,bindingsForPath[lastCachedIndex]=binding}}}this.nCachedObjects_=nCachedObjects}uncache(){const objects=this._objects,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;let nCachedObjects=this.nCachedObjects_,nObjects=objects.length;for(let i2=0,n=arguments.length;i2!==n;++i2){const object=arguments[i2],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==void 0)if(delete indicesByUUID[uuid],index<nCachedObjects){const firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex],lastIndex=--nObjects,lastObject=objects[lastIndex];indicesByUUID[lastCachedObject.uuid]=index,objects[index]=lastCachedObject,indicesByUUID[lastObject.uuid]=firstActiveIndex,objects[firstActiveIndex]=lastObject,objects.pop();for(let j2=0,m2=nBindings;j2!==m2;++j2){const bindingsForPath=bindings[j2],lastCached=bindingsForPath[firstActiveIndex],last=bindingsForPath[lastIndex];bindingsForPath[index]=lastCached,bindingsForPath[firstActiveIndex]=last,bindingsForPath.pop()}}else{const lastIndex=--nObjects,lastObject=objects[lastIndex];lastIndex>0&&(indicesByUUID[lastObject.uuid]=index),objects[index]=lastObject,objects.pop();for(let j2=0,m2=nBindings;j2!==m2;++j2){const bindingsForPath=bindings[j2];bindingsForPath[index]=bindingsForPath[lastIndex],bindingsForPath.pop()}}}this.nCachedObjects_=nCachedObjects}subscribe_(path2,parsedPath){const indicesByPath=this._bindingsIndicesByPath;let index=indicesByPath[path2];const bindings=this._bindings;if(index!==void 0)return bindings[index];const paths2=this._paths,parsedPaths=this._parsedPaths,objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,bindingsForPath=new Array(nObjects);index=bindings.length,indicesByPath[path2]=index,paths2.push(path2),parsedPaths.push(parsedPath),bindings.push(bindingsForPath);for(let i2=nCachedObjects,n=objects.length;i2!==n;++i2){const object=objects[i2];bindingsForPath[i2]=new PropertyBinding(object,path2,parsedPath)}return bindingsForPath}unsubscribe_(path2){const indicesByPath=this._bindingsIndicesByPath,index=indicesByPath[path2];if(index!==void 0){const paths2=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,lastBindingsIndex=bindings.length-1,lastBindings=bindings[lastBindingsIndex],lastBindingsPath=path2[lastBindingsIndex];indicesByPath[lastBindingsPath]=index,bindings[index]=lastBindings,bindings.pop(),parsedPaths[index]=parsedPaths[lastBindingsIndex],parsedPaths.pop(),paths2[index]=paths2[lastBindingsIndex],paths2.pop()}}}class AnimationAction{constructor(mixer,clip,localRoot=null,blendMode=clip.blendMode){this._mixer=mixer,this._clip=clip,this._localRoot=localRoot,this.blendMode=blendMode;const tracks=clip.tracks,nTracks=tracks.length,interpolants=new Array(nTracks),interpolantSettings={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};for(let i2=0;i2!==nTracks;++i2){const interpolant=tracks[i2].createInterpolant(null);interpolants[i2]=interpolant,interpolant.settings=interpolantSettings}this._interpolantSettings=interpolantSettings,this._interpolants=interpolants,this._propertyBindings=new Array(nTracks),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=LoopRepeat,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(time){return this._startTime=time,this}setLoop(mode,repetitions){return this.loop=mode,this.repetitions=repetitions,this}setEffectiveWeight(weight){return this.weight=weight,this._effectiveWeight=this.enabled?weight:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(duration){return this._scheduleFading(duration,0,1)}fadeOut(duration){return this._scheduleFading(duration,1,0)}crossFadeFrom(fadeOutAction,duration,warp){if(fadeOutAction.fadeOut(duration),this.fadeIn(duration),warp){const fadeInDuration=this._clip.duration,fadeOutDuration=fadeOutAction._clip.duration,startEndRatio=fadeOutDuration/fadeInDuration,endStartRatio=fadeInDuration/fadeOutDuration;fadeOutAction.warp(1,startEndRatio,duration),this.warp(endStartRatio,1,duration)}return this}crossFadeTo(fadeInAction,duration,warp){return fadeInAction.crossFadeFrom(this,duration,warp)}stopFading(){const weightInterpolant=this._weightInterpolant;return weightInterpolant!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(weightInterpolant)),this}setEffectiveTimeScale(timeScale){return this.timeScale=timeScale,this._effectiveTimeScale=this.paused?0:timeScale,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(duration){return this.timeScale=this._clip.duration/duration,this.stopWarping()}syncWith(action){return this.time=action.time,this.timeScale=action.timeScale,this.stopWarping()}halt(duration){return this.warp(this._effectiveTimeScale,0,duration)}warp(startTimeScale,endTimeScale,duration){const mixer=this._mixer,now2=mixer.time,timeScale=this.timeScale;let interpolant=this._timeScaleInterpolant;interpolant===null&&(interpolant=mixer._lendControlInterpolant(),this._timeScaleInterpolant=interpolant);const times=interpolant.parameterPositions,values=interpolant.sampleValues;return times[0]=now2,times[1]=now2+duration,values[0]=startTimeScale/timeScale,values[1]=endTimeScale/timeScale,this}stopWarping(){const timeScaleInterpolant=this._timeScaleInterpolant;return timeScaleInterpolant!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(timeScaleInterpolant)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(time,deltaTime,timeDirection,accuIndex){if(!this.enabled){this._updateWeight(time);return}const startTime=this._startTime;if(startTime!==null){const timeRunning=(time-startTime)*timeDirection;timeRunning<0||timeDirection===0?deltaTime=0:(this._startTime=null,deltaTime=timeDirection*timeRunning)}deltaTime*=this._updateTimeScale(time);const clipTime=this._updateTime(deltaTime),weight=this._updateWeight(time);if(weight>0){const interpolants=this._interpolants,propertyMixers=this._propertyBindings;switch(this.blendMode){case AdditiveAnimationBlendMode:for(let j2=0,m2=interpolants.length;j2!==m2;++j2)interpolants[j2].evaluate(clipTime),propertyMixers[j2].accumulateAdditive(weight);break;case NormalAnimationBlendMode:default:for(let j2=0,m2=interpolants.length;j2!==m2;++j2)interpolants[j2].evaluate(clipTime),propertyMixers[j2].accumulate(accuIndex,weight)}}}_updateWeight(time){let weight=0;if(this.enabled){weight=this.weight;const interpolant=this._weightInterpolant;if(interpolant!==null){const interpolantValue=interpolant.evaluate(time)[0];weight*=interpolantValue,time>interpolant.parameterPositions[1]&&(this.stopFading(),interpolantValue===0&&(this.enabled=!1))}}return this._effectiveWeight=weight,weight}_updateTimeScale(time){let timeScale=0;if(!this.paused){timeScale=this.timeScale;const interpolant=this._timeScaleInterpolant;if(interpolant!==null){const interpolantValue=interpolant.evaluate(time)[0];timeScale*=interpolantValue,time>interpolant.parameterPositions[1]&&(this.stopWarping(),timeScale===0?this.paused=!0:this.timeScale=timeScale)}}return this._effectiveTimeScale=timeScale,timeScale}_updateTime(deltaTime){const duration=this._clip.duration,loop=this.loop;let time=this.time+deltaTime,loopCount=this._loopCount;const pingPong=loop===LoopPingPong;if(deltaTime===0)return loopCount===-1?time:pingPong&&(loopCount&1)===1?duration-time:time;if(loop===LoopOnce){loopCount===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));handle_stop:{if(time>=duration)time=duration;else if(time<0)time=0;else{this.time=time;break handle_stop}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=time,this._mixer.dispatchEvent({type:"finished",action:this,direction:deltaTime<0?-1:1})}}else{if(loopCount===-1&&(deltaTime>=0?(loopCount=0,this._setEndings(!0,this.repetitions===0,pingPong)):this._setEndings(this.repetitions===0,!0,pingPong)),time>=duration||time<0){const loopDelta=Math.floor(time/duration);time-=duration*loopDelta,loopCount+=Math.abs(loopDelta);const pending=this.repetitions-loopCount;if(pending<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,time=deltaTime>0?duration:0,this.time=time,this._mixer.dispatchEvent({type:"finished",action:this,direction:deltaTime>0?1:-1});else{if(pending===1){const atStart=deltaTime<0;this._setEndings(atStart,!atStart,pingPong)}else this._setEndings(!1,!1,pingPong);this._loopCount=loopCount,this.time=time,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta})}}else this.time=time;if(pingPong&&(loopCount&1)===1)return duration-time}return time}_setEndings(atStart,atEnd,pingPong){const settings=this._interpolantSettings;pingPong?(settings.endingStart=ZeroSlopeEnding,settings.endingEnd=ZeroSlopeEnding):(atStart?settings.endingStart=this.zeroSlopeAtStart?ZeroSlopeEnding:ZeroCurvatureEnding:settings.endingStart=WrapAroundEnding,atEnd?settings.endingEnd=this.zeroSlopeAtEnd?ZeroSlopeEnding:ZeroCurvatureEnding:settings.endingEnd=WrapAroundEnding)}_scheduleFading(duration,weightNow,weightThen){const mixer=this._mixer,now2=mixer.time;let interpolant=this._weightInterpolant;interpolant===null&&(interpolant=mixer._lendControlInterpolant(),this._weightInterpolant=interpolant);const times=interpolant.parameterPositions,values=interpolant.sampleValues;return times[0]=now2,values[0]=weightNow,times[1]=now2+duration,values[1]=weightThen,this}}const _controlInterpolantsResultBuffer=new Float32Array(1);class AnimationMixer extends EventDispatcher{constructor(root){super(),this._root=root,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(action,prototypeAction){const root=action._localRoot||this._root,tracks=action._clip.tracks,nTracks=tracks.length,bindings=action._propertyBindings,interpolants=action._interpolants,rootUuid=root.uuid,bindingsByRoot=this._bindingsByRootAndName;let bindingsByName=bindingsByRoot[rootUuid];bindingsByName===void 0&&(bindingsByName={},bindingsByRoot[rootUuid]=bindingsByName);for(let i2=0;i2!==nTracks;++i2){const track=tracks[i2],trackName=track.name;let binding=bindingsByName[trackName];if(binding!==void 0)++binding.referenceCount,bindings[i2]=binding;else{if(binding=bindings[i2],binding!==void 0){binding._cacheIndex===null&&(++binding.referenceCount,this._addInactiveBinding(binding,rootUuid,trackName));continue}const path2=prototypeAction&&prototypeAction._propertyBindings[i2].binding.parsedPath;binding=new PropertyMixer(PropertyBinding.create(root,trackName,path2),track.ValueTypeName,track.getValueSize()),++binding.referenceCount,this._addInactiveBinding(binding,rootUuid,trackName),bindings[i2]=binding}interpolants[i2].resultBuffer=binding.buffer}}_activateAction(action){if(!this._isActiveAction(action)){if(action._cacheIndex===null){const rootUuid=(action._localRoot||this._root).uuid,clipUuid=action._clip.uuid,actionsForClip=this._actionsByClip[clipUuid];this._bindAction(action,actionsForClip&&actionsForClip.knownActions[0]),this._addInactiveAction(action,clipUuid,rootUuid)}const bindings=action._propertyBindings;for(let i2=0,n=bindings.length;i2!==n;++i2){const binding=bindings[i2];binding.useCount++===0&&(this._lendBinding(binding),binding.saveOriginalState())}this._lendAction(action)}}_deactivateAction(action){if(this._isActiveAction(action)){const bindings=action._propertyBindings;for(let i2=0,n=bindings.length;i2!==n;++i2){const binding=bindings[i2];--binding.useCount===0&&(binding.restoreOriginalState(),this._takeBackBinding(binding))}this._takeBackAction(action)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const scope=this;this.stats={actions:{get total(){return scope._actions.length},get inUse(){return scope._nActiveActions}},bindings:{get total(){return scope._bindings.length},get inUse(){return scope._nActiveBindings}},controlInterpolants:{get total(){return scope._controlInterpolants.length},get inUse(){return scope._nActiveControlInterpolants}}}}_isActiveAction(action){const index=action._cacheIndex;return index!==null&&index<this._nActiveActions}_addInactiveAction(action,clipUuid,rootUuid){const actions=this._actions,actionsByClip=this._actionsByClip;let actionsForClip=actionsByClip[clipUuid];if(actionsForClip===void 0)actionsForClip={knownActions:[action],actionByRoot:{}},action._byClipCacheIndex=0,actionsByClip[clipUuid]=actionsForClip;else{const knownActions=actionsForClip.knownActions;action._byClipCacheIndex=knownActions.length,knownActions.push(action)}action._cacheIndex=actions.length,actions.push(action),actionsForClip.actionByRoot[rootUuid]=action}_removeInactiveAction(action){const actions=this._actions,lastInactiveAction=actions[actions.length-1],cacheIndex=action._cacheIndex;lastInactiveAction._cacheIndex=cacheIndex,actions[cacheIndex]=lastInactiveAction,actions.pop(),action._cacheIndex=null;const clipUuid=action._clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid],knownActionsForClip=actionsForClip.knownActions,lastKnownAction=knownActionsForClip[knownActionsForClip.length-1],byClipCacheIndex=action._byClipCacheIndex;lastKnownAction._byClipCacheIndex=byClipCacheIndex,knownActionsForClip[byClipCacheIndex]=lastKnownAction,knownActionsForClip.pop(),action._byClipCacheIndex=null;const actionByRoot=actionsForClip.actionByRoot,rootUuid=(action._localRoot||this._root).uuid;delete actionByRoot[rootUuid],knownActionsForClip.length===0&&delete actionsByClip[clipUuid],this._removeInactiveBindingsForAction(action)}_removeInactiveBindingsForAction(action){const bindings=action._propertyBindings;for(let i2=0,n=bindings.length;i2!==n;++i2){const binding=bindings[i2];--binding.referenceCount===0&&this._removeInactiveBinding(binding)}}_lendAction(action){const actions=this._actions,prevIndex=action._cacheIndex,lastActiveIndex=this._nActiveActions++,firstInactiveAction=actions[lastActiveIndex];action._cacheIndex=lastActiveIndex,actions[lastActiveIndex]=action,firstInactiveAction._cacheIndex=prevIndex,actions[prevIndex]=firstInactiveAction}_takeBackAction(action){const actions=this._actions,prevIndex=action._cacheIndex,firstInactiveIndex=--this._nActiveActions,lastActiveAction=actions[firstInactiveIndex];action._cacheIndex=firstInactiveIndex,actions[firstInactiveIndex]=action,lastActiveAction._cacheIndex=prevIndex,actions[prevIndex]=lastActiveAction}_addInactiveBinding(binding,rootUuid,trackName){const bindingsByRoot=this._bindingsByRootAndName,bindings=this._bindings;let bindingByName=bindingsByRoot[rootUuid];bindingByName===void 0&&(bindingByName={},bindingsByRoot[rootUuid]=bindingByName),bindingByName[trackName]=binding,binding._cacheIndex=bindings.length,bindings.push(binding)}_removeInactiveBinding(binding){const bindings=this._bindings,propBinding=binding.binding,rootUuid=propBinding.rootNode.uuid,trackName=propBinding.path,bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid],lastInactiveBinding=bindings[bindings.length-1],cacheIndex=binding._cacheIndex;lastInactiveBinding._cacheIndex=cacheIndex,bindings[cacheIndex]=lastInactiveBinding,bindings.pop(),delete bindingByName[trackName],Object.keys(bindingByName).length===0&&delete bindingsByRoot[rootUuid]}_lendBinding(binding){const bindings=this._bindings,prevIndex=binding._cacheIndex,lastActiveIndex=this._nActiveBindings++,firstInactiveBinding=bindings[lastActiveIndex];binding._cacheIndex=lastActiveIndex,bindings[lastActiveIndex]=binding,firstInactiveBinding._cacheIndex=prevIndex,bindings[prevIndex]=firstInactiveBinding}_takeBackBinding(binding){const bindings=this._bindings,prevIndex=binding._cacheIndex,firstInactiveIndex=--this._nActiveBindings,lastActiveBinding=bindings[firstInactiveIndex];binding._cacheIndex=firstInactiveIndex,bindings[firstInactiveIndex]=binding,lastActiveBinding._cacheIndex=prevIndex,bindings[prevIndex]=lastActiveBinding}_lendControlInterpolant(){const interpolants=this._controlInterpolants,lastActiveIndex=this._nActiveControlInterpolants++;let interpolant=interpolants[lastActiveIndex];return interpolant===void 0&&(interpolant=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,_controlInterpolantsResultBuffer),interpolant.__cacheIndex=lastActiveIndex,interpolants[lastActiveIndex]=interpolant),interpolant}_takeBackControlInterpolant(interpolant){const interpolants=this._controlInterpolants,prevIndex=interpolant.__cacheIndex,firstInactiveIndex=--this._nActiveControlInterpolants,lastActiveInterpolant=interpolants[firstInactiveIndex];interpolant.__cacheIndex=firstInactiveIndex,interpolants[firstInactiveIndex]=interpolant,lastActiveInterpolant.__cacheIndex=prevIndex,interpolants[prevIndex]=lastActiveInterpolant}clipAction(clip,optionalRoot,blendMode){const root=optionalRoot||this._root,rootUuid=root.uuid;let clipObject=typeof clip=="string"?AnimationClip.findByName(root,clip):clip;const clipUuid=clipObject!==null?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid];let prototypeAction=null;if(blendMode===void 0&&(clipObject!==null?blendMode=clipObject.blendMode:blendMode=NormalAnimationBlendMode),actionsForClip!==void 0){const existingAction=actionsForClip.actionByRoot[rootUuid];if(existingAction!==void 0&&existingAction.blendMode===blendMode)return existingAction;prototypeAction=actionsForClip.knownActions[0],clipObject===null&&(clipObject=prototypeAction._clip)}if(clipObject===null)return null;const newAction=new AnimationAction(this,clipObject,optionalRoot,blendMode);return this._bindAction(newAction,prototypeAction),this._addInactiveAction(newAction,clipUuid,rootUuid),newAction}existingAction(clip,optionalRoot){const root=optionalRoot||this._root,rootUuid=root.uuid,clipObject=typeof clip=="string"?AnimationClip.findByName(root,clip):clip,clipUuid=clipObject?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid];return actionsForClip!==void 0&&actionsForClip.actionByRoot[rootUuid]||null}stopAllAction(){const actions=this._actions,nActions=this._nActiveActions;for(let i2=nActions-1;i2>=0;--i2)actions[i2].stop();return this}update(deltaTime){deltaTime*=this.timeScale;const actions=this._actions,nActions=this._nActiveActions,time=this.time+=deltaTime,timeDirection=Math.sign(deltaTime),accuIndex=this._accuIndex^=1;for(let i2=0;i2!==nActions;++i2)actions[i2]._update(time,deltaTime,timeDirection,accuIndex);const bindings=this._bindings,nBindings=this._nActiveBindings;for(let i2=0;i2!==nBindings;++i2)bindings[i2].apply(accuIndex);return this}setTime(timeInSeconds){this.time=0;for(let i2=0;i2<this._actions.length;i2++)this._actions[i2].time=0;return this.update(timeInSeconds)}getRoot(){return this._root}uncacheClip(clip){const actions=this._actions,clipUuid=clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid];if(actionsForClip!==void 0){const actionsToRemove=actionsForClip.knownActions;for(let i2=0,n=actionsToRemove.length;i2!==n;++i2){const action=actionsToRemove[i2];this._deactivateAction(action);const cacheIndex=action._cacheIndex,lastInactiveAction=actions[actions.length-1];action._cacheIndex=null,action._byClipCacheIndex=null,lastInactiveAction._cacheIndex=cacheIndex,actions[cacheIndex]=lastInactiveAction,actions.pop(),this._removeInactiveBindingsForAction(action)}delete actionsByClip[clipUuid]}}uncacheRoot(root){const rootUuid=root.uuid,actionsByClip=this._actionsByClip;for(const clipUuid in actionsByClip){const actionByRoot=actionsByClip[clipUuid].actionByRoot,action=actionByRoot[rootUuid];action!==void 0&&(this._deactivateAction(action),this._removeInactiveAction(action))}const bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid];if(bindingByName!==void 0)for(const trackName in bindingByName){const binding=bindingByName[trackName];binding.restoreOriginalState(),this._removeInactiveBinding(binding)}}uncacheAction(clip,optionalRoot){const action=this.existingAction(clip,optionalRoot);action!==null&&(this._deactivateAction(action),this._removeInactiveAction(action))}}class Uniform{constructor(value){this.value=value}clone(){return new Uniform(this.value.clone===void 0?this.value:this.value.clone())}}let _id=0;class UniformsGroup extends EventDispatcher{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:_id++}),this.name="",this.usage=StaticDrawUsage,this.uniforms=[]}add(uniform){return this.uniforms.push(uniform),this}remove(uniform){const index=this.uniforms.indexOf(uniform);return index!==-1&&this.uniforms.splice(index,1),this}setName(name){return this.name=name,this}setUsage(value){return this.usage=value,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(source){this.name=source.name,this.usage=source.usage;const uniformsSource=source.uniforms;this.uniforms.length=0;for(let i2=0,l2=uniformsSource.length;i2<l2;i2++)this.uniforms.push(uniformsSource[i2].clone());return this}clone(){return new this.constructor().copy(this)}}class InstancedInterleavedBuffer extends InterleavedBuffer{constructor(array,stride,meshPerAttribute=1){super(array,stride),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=meshPerAttribute}copy(source){return super.copy(source),this.meshPerAttribute=source.meshPerAttribute,this}clone(data){const ib=super.clone(data);return ib.meshPerAttribute=this.meshPerAttribute,ib}toJSON(data){const json=super.toJSON(data);return json.isInstancedInterleavedBuffer=!0,json.meshPerAttribute=this.meshPerAttribute,json}}class GLBufferAttribute{constructor(buffer,type,itemSize,elementSize,count){this.isGLBufferAttribute=!0,this.name="",this.buffer=buffer,this.type=type,this.itemSize=itemSize,this.elementSize=elementSize,this.count=count,this.version=0}set needsUpdate(value){value===!0&&this.version++}setBuffer(buffer){return this.buffer=buffer,this}setType(type,elementSize){return this.type=type,this.elementSize=elementSize,this}setItemSize(itemSize){return this.itemSize=itemSize,this}setCount(count){return this.count=count,this}}class Raycaster{constructor(origin,direction,near=0,far=1/0){this.ray=new Ray(origin,direction),this.near=near,this.far=far,this.camera=null,this.layers=new Layers,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(origin,direction){this.ray.set(origin,direction)}setFromCamera(coords,camera){camera.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(camera.matrixWorld),this.ray.direction.set(coords.x,coords.y,.5).unproject(camera).sub(this.ray.origin).normalize(),this.camera=camera):camera.isOrthographicCamera?(this.ray.origin.set(coords.x,coords.y,(camera.near+camera.far)/(camera.near-camera.far)).unproject(camera),this.ray.direction.set(0,0,-1).transformDirection(camera.matrixWorld),this.camera=camera):console.error("THREE.Raycaster: Unsupported camera type: "+camera.type)}intersectObject(object,recursive=!0,intersects2=[]){return intersectObject(object,this,intersects2,recursive),intersects2.sort(ascSort),intersects2}intersectObjects(objects,recursive=!0,intersects2=[]){for(let i2=0,l2=objects.length;i2<l2;i2++)intersectObject(objects[i2],this,intersects2,recursive);return intersects2.sort(ascSort),intersects2}}function ascSort(a2,b2){return a2.distance-b2.distance}function intersectObject(object,raycaster,intersects2,recursive){if(object.layers.test(raycaster.layers)&&object.raycast(raycaster,intersects2),recursive===!0){const children=object.children;for(let i2=0,l2=children.length;i2<l2;i2++)intersectObject(children[i2],raycaster,intersects2,!0)}}class Spherical{constructor(radius=1,phi=0,theta=0){return this.radius=radius,this.phi=phi,this.theta=theta,this}set(radius,phi,theta){return this.radius=radius,this.phi=phi,this.theta=theta,this}copy(other){return this.radius=other.radius,this.phi=other.phi,this.theta=other.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(v4){return this.setFromCartesianCoords(v4.x,v4.y,v4.z)}setFromCartesianCoords(x2,y2,z){return this.radius=Math.sqrt(x2*x2+y2*y2+z*z),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(x2,z),this.phi=Math.acos(clamp(y2/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class Cylindrical{constructor(radius=1,theta=0,y2=0){return this.radius=radius,this.theta=theta,this.y=y2,this}set(radius,theta,y2){return this.radius=radius,this.theta=theta,this.y=y2,this}copy(other){return this.radius=other.radius,this.theta=other.theta,this.y=other.y,this}setFromVector3(v4){return this.setFromCartesianCoords(v4.x,v4.y,v4.z)}setFromCartesianCoords(x2,y2,z){return this.radius=Math.sqrt(x2*x2+z*z),this.theta=Math.atan2(x2,z),this.y=y2,this}clone(){return new this.constructor().copy(this)}}const _vector$4=new Vector2;class Box2{constructor(min=new Vector2(1/0,1/0),max2=new Vector2(-1/0,-1/0)){this.isBox2=!0,this.min=min,this.max=max2}set(min,max2){return this.min.copy(min),this.max.copy(max2),this}setFromPoints(points){this.makeEmpty();for(let i2=0,il=points.length;i2<il;i2++)this.expandByPoint(points[i2]);return this}setFromCenterAndSize(center,size){const halfSize=_vector$4.copy(size).multiplyScalar(.5);return this.min.copy(center).sub(halfSize),this.max.copy(center).add(halfSize),this}clone(){return new this.constructor().copy(this)}copy(box){return this.min.copy(box.min),this.max.copy(box.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(target){return this.isEmpty()?target.set(0,0):target.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(target){return this.isEmpty()?target.set(0,0):target.subVectors(this.max,this.min)}expandByPoint(point){return this.min.min(point),this.max.max(point),this}expandByVector(vector){return this.min.sub(vector),this.max.add(vector),this}expandByScalar(scalar){return this.min.addScalar(-scalar),this.max.addScalar(scalar),this}containsPoint(point){return!(point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y)}containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y}getParameter(point,target){return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(box){return!(box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y)}clampPoint(point,target){return target.copy(point).clamp(this.min,this.max)}distanceToPoint(point){return this.clampPoint(point,_vector$4).distanceTo(point)}intersect(box){return this.min.max(box.min),this.max.min(box.max),this.isEmpty()&&this.makeEmpty(),this}union(box){return this.min.min(box.min),this.max.max(box.max),this}translate(offset){return this.min.add(offset),this.max.add(offset),this}equals(box){return box.min.equals(this.min)&&box.max.equals(this.max)}}const _startP=new Vector3,_startEnd=new Vector3;class Line3{constructor(start=new Vector3,end=new Vector3){this.start=start,this.end=end}set(start,end){return this.start.copy(start),this.end.copy(end),this}copy(line){return this.start.copy(line.start),this.end.copy(line.end),this}getCenter(target){return target.addVectors(this.start,this.end).multiplyScalar(.5)}delta(target){return target.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t2,target){return this.delta(target).multiplyScalar(t2).add(this.start)}closestPointToPointParameter(point,clampToLine){_startP.subVectors(point,this.start),_startEnd.subVectors(this.end,this.start);const startEnd2=_startEnd.dot(_startEnd);let t2=_startEnd.dot(_startP)/startEnd2;return clampToLine&&(t2=clamp(t2,0,1)),t2}closestPointToPoint(point,clampToLine,target){const t2=this.closestPointToPointParameter(point,clampToLine);return this.delta(target).multiplyScalar(t2).add(this.start)}applyMatrix4(matrix){return this.start.applyMatrix4(matrix),this.end.applyMatrix4(matrix),this}equals(line){return line.start.equals(this.start)&&line.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const _vector$3=new Vector3;class SpotLightHelper extends Object3D{constructor(light,color2){super(),this.light=light,this.matrix=light.matrixWorld,this.matrixAutoUpdate=!1,this.color=color2,this.type="SpotLightHelper";const geometry=new BufferGeometry,positions=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let i2=0,j2=1,l2=32;i2<l2;i2++,j2++){const p1=i2/l2*Math.PI*2,p2=j2/l2*Math.PI*2;positions.push(Math.cos(p1),Math.sin(p1),1,Math.cos(p2),Math.sin(p2),1)}geometry.setAttribute("position",new Float32BufferAttribute(positions,3));const material=new LineBasicMaterial({fog:!1,toneMapped:!1});this.cone=new LineSegments(geometry,material),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1);const coneLength=this.light.distance?this.light.distance:1e3,coneWidth=coneLength*Math.tan(this.light.angle);this.cone.scale.set(coneWidth,coneWidth,coneLength),_vector$3.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(_vector$3),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const _vector$2=new Vector3,_boneMatrix=new Matrix4,_matrixWorldInv=new Matrix4;class SkeletonHelper extends LineSegments{constructor(object){const bones=getBoneList(object),geometry=new BufferGeometry,vertices=[],colors=[],color1=new Color(0,0,1),color2=new Color(0,1,0);for(let i2=0;i2<bones.length;i2++){const bone=bones[i2];bone.parent&&bone.parent.isBone&&(vertices.push(0,0,0),vertices.push(0,0,0),colors.push(color1.r,color1.g,color1.b),colors.push(color2.r,color2.g,color2.b))}geometry.setAttribute("position",new Float32BufferAttribute(vertices,3)),geometry.setAttribute("color",new Float32BufferAttribute(colors,3));const material=new LineBasicMaterial({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(geometry,material),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=object,this.bones=bones,this.matrix=object.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(force){const bones=this.bones,geometry=this.geometry,position=geometry.getAttribute("position");_matrixWorldInv.copy(this.root.matrixWorld).invert();for(let i2=0,j2=0;i2<bones.length;i2++){const bone=bones[i2];bone.parent&&bone.parent.isBone&&(_boneMatrix.multiplyMatrices(_matrixWorldInv,bone.matrixWorld),_vector$2.setFromMatrixPosition(_boneMatrix),position.setXYZ(j2,_vector$2.x,_vector$2.y,_vector$2.z),_boneMatrix.multiplyMatrices(_matrixWorldInv,bone.parent.matrixWorld),_vector$2.setFromMatrixPosition(_boneMatrix),position.setXYZ(j2+1,_vector$2.x,_vector$2.y,_vector$2.z),j2+=2)}geometry.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(force)}dispose(){this.geometry.dispose(),this.material.dispose()}}function getBoneList(object){const boneList=[];object.isBone===!0&&boneList.push(object);for(let i2=0;i2<object.children.length;i2++)boneList.push.apply(boneList,getBoneList(object.children[i2]));return boneList}class PointLightHelper extends Mesh{constructor(light,sphereSize,color2){const geometry=new SphereGeometry(sphereSize,4,2),material=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1});super(geometry,material),this.light=light,this.color=color2,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const _vector$1=new Vector3,_color1=new Color,_color2=new Color;class HemisphereLightHelper extends Object3D{constructor(light,size,color2){super(),this.light=light,this.matrix=light.matrixWorld,this.matrixAutoUpdate=!1,this.color=color2,this.type="HemisphereLightHelper";const geometry=new OctahedronGeometry(size);geometry.rotateY(Math.PI*.5),this.material=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const position=geometry.getAttribute("position"),colors=new Float32Array(position.count*3);geometry.setAttribute("color",new BufferAttribute(colors,3)),this.add(new Mesh(geometry,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const mesh=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const colors=mesh.geometry.getAttribute("color");_color1.copy(this.light.color),_color2.copy(this.light.groundColor);for(let i2=0,l2=colors.count;i2<l2;i2++){const color2=i2<l2/2?_color1:_color2;colors.setXYZ(i2,color2.r,color2.g,color2.b)}colors.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate())}}class GridHelper extends LineSegments{constructor(size=10,divisions=10,color1=4473924,color2=8947848){color1=new Color(color1),color2=new Color(color2);const center=divisions/2,step=size/divisions,halfSize=size/2,vertices=[],colors=[];for(let i2=0,j2=0,k2=-halfSize;i2<=divisions;i2++,k2+=step){vertices.push(-halfSize,0,k2,halfSize,0,k2),vertices.push(k2,0,-halfSize,k2,0,halfSize);const color3=i2===center?color1:color2;color3.toArray(colors,j2),j2+=3,color3.toArray(colors,j2),j2+=3,color3.toArray(colors,j2),j2+=3,color3.toArray(colors,j2),j2+=3}const geometry=new BufferGeometry;geometry.setAttribute("position",new Float32BufferAttribute(vertices,3)),geometry.setAttribute("color",new Float32BufferAttribute(colors,3));const material=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(geometry,material),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class PolarGridHelper extends LineSegments{constructor(radius=10,sectors=16,rings=8,divisions=64,color1=4473924,color2=8947848){color1=new Color(color1),color2=new Color(color2);const vertices=[],colors=[];if(sectors>1)for(let i2=0;i2<sectors;i2++){const v4=i2/sectors*(Math.PI*2),x2=Math.sin(v4)*radius,z=Math.cos(v4)*radius;vertices.push(0,0,0),vertices.push(x2,0,z);const color3=i2&1?color1:color2;colors.push(color3.r,color3.g,color3.b),colors.push(color3.r,color3.g,color3.b)}for(let i2=0;i2<rings;i2++){const color3=i2&1?color1:color2,r2=radius-radius/rings*i2;for(let j2=0;j2<divisions;j2++){let v4=j2/divisions*(Math.PI*2),x2=Math.sin(v4)*r2,z=Math.cos(v4)*r2;vertices.push(x2,0,z),colors.push(color3.r,color3.g,color3.b),v4=(j2+1)/divisions*(Math.PI*2),x2=Math.sin(v4)*r2,z=Math.cos(v4)*r2,vertices.push(x2,0,z),colors.push(color3.r,color3.g,color3.b)}}const geometry=new BufferGeometry;geometry.setAttribute("position",new Float32BufferAttribute(vertices,3)),geometry.setAttribute("color",new Float32BufferAttribute(colors,3));const material=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(geometry,material),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const _v1=new Vector3,_v2=new Vector3,_v3=new Vector3;class DirectionalLightHelper extends Object3D{constructor(light,size,color2){super(),this.light=light,this.matrix=light.matrixWorld,this.matrixAutoUpdate=!1,this.color=color2,this.type="DirectionalLightHelper",size===void 0&&(size=1);let geometry=new BufferGeometry;geometry.setAttribute("position",new Float32BufferAttribute([-size,size,0,size,size,0,size,-size,0,-size,-size,0,-size,size,0],3));const material=new LineBasicMaterial({fog:!1,toneMapped:!1});this.lightPlane=new Line(geometry,material),this.add(this.lightPlane),geometry=new BufferGeometry,geometry.setAttribute("position",new Float32BufferAttribute([0,0,0,0,0,1],3)),this.targetLine=new Line(geometry,material),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),_v1.setFromMatrixPosition(this.light.matrixWorld),_v2.setFromMatrixPosition(this.light.target.matrixWorld),_v3.subVectors(_v2,_v1),this.lightPlane.lookAt(_v2),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(_v2),this.targetLine.scale.z=_v3.length()}}const _vector=new Vector3,_camera=new Camera;class CameraHelper extends LineSegments{constructor(camera){const geometry=new BufferGeometry,material=new LineBasicMaterial({color:16777215,vertexColors:!0,toneMapped:!1}),vertices=[],colors=[],pointMap={};addLine("n1","n2"),addLine("n2","n4"),addLine("n4","n3"),addLine("n3","n1"),addLine("f1","f2"),addLine("f2","f4"),addLine("f4","f3"),addLine("f3","f1"),addLine("n1","f1"),addLine("n2","f2"),addLine("n3","f3"),addLine("n4","f4"),addLine("p","n1"),addLine("p","n2"),addLine("p","n3"),addLine("p","n4"),addLine("u1","u2"),addLine("u2","u3"),addLine("u3","u1"),addLine("c","t"),addLine("p","c"),addLine("cn1","cn2"),addLine("cn3","cn4"),addLine("cf1","cf2"),addLine("cf3","cf4");function addLine(a2,b2){addPoint(a2),addPoint(b2)}function addPoint(id2){vertices.push(0,0,0),colors.push(0,0,0),pointMap[id2]===void 0&&(pointMap[id2]=[]),pointMap[id2].push(vertices.length/3-1)}geometry.setAttribute("position",new Float32BufferAttribute(vertices,3)),geometry.setAttribute("color",new Float32BufferAttribute(colors,3)),super(geometry,material),this.type="CameraHelper",this.camera=camera,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=camera.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=pointMap,this.update();const colorFrustum=new Color(16755200),colorCone=new Color(16711680),colorUp=new Color(43775),colorTarget=new Color(16777215),colorCross=new Color(3355443);this.setColors(colorFrustum,colorCone,colorUp,colorTarget,colorCross)}setColors(frustum,cone,up,target,cross){const colorAttribute=this.geometry.getAttribute("color");colorAttribute.setXYZ(0,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(1,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(2,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(3,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(4,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(5,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(6,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(7,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(8,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(9,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(10,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(11,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(12,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(13,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(14,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(15,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(16,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(17,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(18,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(19,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(20,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(21,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(22,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(23,frustum.r,frustum.g,frustum.b),colorAttribute.setXYZ(24,cone.r,cone.g,cone.b),colorAttribute.setXYZ(25,cone.r,cone.g,cone.b),colorAttribute.setXYZ(26,cone.r,cone.g,cone.b),colorAttribute.setXYZ(27,cone.r,cone.g,cone.b),colorAttribute.setXYZ(28,cone.r,cone.g,cone.b),colorAttribute.setXYZ(29,cone.r,cone.g,cone.b),colorAttribute.setXYZ(30,cone.r,cone.g,cone.b),colorAttribute.setXYZ(31,cone.r,cone.g,cone.b),colorAttribute.setXYZ(32,up.r,up.g,up.b),colorAttribute.setXYZ(33,up.r,up.g,up.b),colorAttribute.setXYZ(34,up.r,up.g,up.b),colorAttribute.setXYZ(35,up.r,up.g,up.b),colorAttribute.setXYZ(36,up.r,up.g,up.b),colorAttribute.setXYZ(37,up.r,up.g,up.b),colorAttribute.setXYZ(38,target.r,target.g,target.b),colorAttribute.setXYZ(39,target.r,target.g,target.b),colorAttribute.setXYZ(40,cross.r,cross.g,cross.b),colorAttribute.setXYZ(41,cross.r,cross.g,cross.b),colorAttribute.setXYZ(42,cross.r,cross.g,cross.b),colorAttribute.setXYZ(43,cross.r,cross.g,cross.b),colorAttribute.setXYZ(44,cross.r,cross.g,cross.b),colorAttribute.setXYZ(45,cross.r,cross.g,cross.b),colorAttribute.setXYZ(46,cross.r,cross.g,cross.b),colorAttribute.setXYZ(47,cross.r,cross.g,cross.b),colorAttribute.setXYZ(48,cross.r,cross.g,cross.b),colorAttribute.setXYZ(49,cross.r,cross.g,cross.b),colorAttribute.needsUpdate=!0}update(){const geometry=this.geometry,pointMap=this.pointMap,w2=1,h2=1;_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),setPoint("c",pointMap,geometry,_camera,0,0,-1),setPoint("t",pointMap,geometry,_camera,0,0,1),setPoint("n1",pointMap,geometry,_camera,-w2,-h2,-1),setPoint("n2",pointMap,geometry,_camera,w2,-h2,-1),setPoint("n3",pointMap,geometry,_camera,-w2,h2,-1),setPoint("n4",pointMap,geometry,_camera,w2,h2,-1),setPoint("f1",pointMap,geometry,_camera,-w2,-h2,1),setPoint("f2",pointMap,geometry,_camera,w2,-h2,1),setPoint("f3",pointMap,geometry,_camera,-w2,h2,1),setPoint("f4",pointMap,geometry,_camera,w2,h2,1),setPoint("u1",pointMap,geometry,_camera,w2*.7,h2*1.1,-1),setPoint("u2",pointMap,geometry,_camera,-w2*.7,h2*1.1,-1),setPoint("u3",pointMap,geometry,_camera,0,h2*2,-1),setPoint("cf1",pointMap,geometry,_camera,-w2,0,1),setPoint("cf2",pointMap,geometry,_camera,w2,0,1),setPoint("cf3",pointMap,geometry,_camera,0,-h2,1),setPoint("cf4",pointMap,geometry,_camera,0,h2,1),setPoint("cn1",pointMap,geometry,_camera,-w2,0,-1),setPoint("cn2",pointMap,geometry,_camera,w2,0,-1),setPoint("cn3",pointMap,geometry,_camera,0,-h2,-1),setPoint("cn4",pointMap,geometry,_camera,0,h2,-1),geometry.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function setPoint(point,pointMap,geometry,camera,x2,y2,z){_vector.set(x2,y2,z).unproject(camera);const points=pointMap[point];if(points!==void 0){const position=geometry.getAttribute("position");for(let i2=0,l2=points.length;i2<l2;i2++)position.setXYZ(points[i2],_vector.x,_vector.y,_vector.z)}}const _box=new Box3;class BoxHelper extends LineSegments{constructor(object,color2=16776960){const indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),positions=new Float32Array(8*3),geometry=new BufferGeometry;geometry.setIndex(new BufferAttribute(indices,1)),geometry.setAttribute("position",new BufferAttribute(positions,3)),super(geometry,new LineBasicMaterial({color:color2,toneMapped:!1})),this.object=object,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(object){if(object!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&_box.setFromObject(this.object),_box.isEmpty())return;const min=_box.min,max2=_box.max,position=this.geometry.attributes.position,array=position.array;array[0]=max2.x,array[1]=max2.y,array[2]=max2.z,array[3]=min.x,array[4]=max2.y,array[5]=max2.z,array[6]=min.x,array[7]=min.y,array[8]=max2.z,array[9]=max2.x,array[10]=min.y,array[11]=max2.z,array[12]=max2.x,array[13]=max2.y,array[14]=min.z,array[15]=min.x,array[16]=max2.y,array[17]=min.z,array[18]=min.x,array[19]=min.y,array[20]=min.z,array[21]=max2.x,array[22]=min.y,array[23]=min.z,position.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(object){return this.object=object,this.update(),this}copy(source,recursive){return super.copy(source,recursive),this.object=source.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class Box3Helper extends LineSegments{constructor(box,color2=16776960){const indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),positions=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],geometry=new BufferGeometry;geometry.setIndex(new BufferAttribute(indices,1)),geometry.setAttribute("position",new Float32BufferAttribute(positions,3)),super(geometry,new LineBasicMaterial({color:color2,toneMapped:!1})),this.box=box,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(force){const box=this.box;box.isEmpty()||(box.getCenter(this.position),box.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(force))}dispose(){this.geometry.dispose(),this.material.dispose()}}class PlaneHelper extends Line{constructor(plane,size=1,hex2=16776960){const color2=hex2,positions=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],geometry=new BufferGeometry;geometry.setAttribute("position",new Float32BufferAttribute(positions,3)),geometry.computeBoundingSphere(),super(geometry,new LineBasicMaterial({color:color2,toneMapped:!1})),this.type="PlaneHelper",this.plane=plane,this.size=size;const positions2=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],geometry2=new BufferGeometry;geometry2.setAttribute("position",new Float32BufferAttribute(positions2,3)),geometry2.computeBoundingSphere(),this.add(new Mesh(geometry2,new MeshBasicMaterial({color:color2,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(force){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(force)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const _axis=new Vector3;let _lineGeometry,_coneGeometry;class ArrowHelper extends Object3D{constructor(dir=new Vector3(0,0,1),origin=new Vector3(0,0,0),length=1,color2=16776960,headLength=length*.2,headWidth=headLength*.2){super(),this.type="ArrowHelper",_lineGeometry===void 0&&(_lineGeometry=new BufferGeometry,_lineGeometry.setAttribute("position",new Float32BufferAttribute([0,0,0,0,1,0],3)),_coneGeometry=new CylinderGeometry(0,.5,1,5,1),_coneGeometry.translate(0,-.5,0)),this.position.copy(origin),this.line=new Line(_lineGeometry,new LineBasicMaterial({color:color2,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new Mesh(_coneGeometry,new MeshBasicMaterial({color:color2,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(dir),this.setLength(length,headLength,headWidth)}setDirection(dir){if(dir.y>.99999)this.quaternion.set(0,0,0,1);else if(dir.y<-.99999)this.quaternion.set(1,0,0,0);else{_axis.set(dir.z,0,-dir.x).normalize();const radians=Math.acos(dir.y);this.quaternion.setFromAxisAngle(_axis,radians)}}setLength(length,headLength=length*.2,headWidth=headLength*.2){this.line.scale.set(1,Math.max(1e-4,length-headLength),1),this.line.updateMatrix(),this.cone.scale.set(headWidth,headLength,headWidth),this.cone.position.y=length,this.cone.updateMatrix()}setColor(color2){this.line.material.color.set(color2),this.cone.material.color.set(color2)}copy(source){return super.copy(source,!1),this.line.copy(source.line),this.cone.copy(source.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class AxesHelper extends LineSegments{constructor(size=1){const vertices=[0,0,0,size,0,0,0,0,0,0,size,0,0,0,0,0,0,size],colors=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],geometry=new BufferGeometry;geometry.setAttribute("position",new Float32BufferAttribute(vertices,3)),geometry.setAttribute("color",new Float32BufferAttribute(colors,3));const material=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(geometry,material),this.type="AxesHelper"}setColors(xAxisColor,yAxisColor,zAxisColor){const color2=new Color,array=this.geometry.attributes.color.array;return color2.set(xAxisColor),color2.toArray(array,0),color2.toArray(array,3),color2.set(yAxisColor),color2.toArray(array,6),color2.toArray(array,9),color2.set(zAxisColor),color2.toArray(array,12),color2.toArray(array,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class ShapePath{constructor(){this.type="ShapePath",this.color=new Color,this.subPaths=[],this.currentPath=null}moveTo(x2,y2){return this.currentPath=new Path,this.subPaths.push(this.currentPath),this.currentPath.moveTo(x2,y2),this}lineTo(x2,y2){return this.currentPath.lineTo(x2,y2),this}quadraticCurveTo(aCPx,aCPy,aX,aY){return this.currentPath.quadraticCurveTo(aCPx,aCPy,aX,aY),this}bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){return this.currentPath.bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY),this}splineThru(pts){return this.currentPath.splineThru(pts),this}toShapes(isCCW){function toShapesNoHoles(inSubpaths){const shapes2=[];for(let i2=0,l2=inSubpaths.length;i2<l2;i2++){const tmpPath2=inSubpaths[i2],tmpShape2=new Shape;tmpShape2.curves=tmpPath2.curves,shapes2.push(tmpShape2)}return shapes2}function isPointInsidePolygon(inPt,inPolygon){const polyLen=inPolygon.length;let inside=!1;for(let p2=polyLen-1,q=0;q<polyLen;p2=q++){let edgeLowPt=inPolygon[p2],edgeHighPt=inPolygon[q],edgeDx=edgeHighPt.x-edgeLowPt.x,edgeDy=edgeHighPt.y-edgeLowPt.y;if(Math.abs(edgeDy)>Number.EPSILON){if(edgeDy<0&&(edgeLowPt=inPolygon[q],edgeDx=-edgeDx,edgeHighPt=inPolygon[p2],edgeDy=-edgeDy),inPt.y<edgeLowPt.y||inPt.y>edgeHighPt.y)continue;if(inPt.y===edgeLowPt.y){if(inPt.x===edgeLowPt.x)return!0}else{const perpEdge=edgeDy*(inPt.x-edgeLowPt.x)-edgeDx*(inPt.y-edgeLowPt.y);if(perpEdge===0)return!0;if(perpEdge<0)continue;inside=!inside}}else{if(inPt.y!==edgeLowPt.y)continue;if(edgeHighPt.x<=inPt.x&&inPt.x<=edgeLowPt.x||edgeLowPt.x<=inPt.x&&inPt.x<=edgeHighPt.x)return!0}}return inside}const isClockWise=ShapeUtils.isClockWise,subPaths=this.subPaths;if(subPaths.length===0)return[];let solid,tmpPath,tmpShape;const shapes=[];if(subPaths.length===1)return tmpPath=subPaths[0],tmpShape=new Shape,tmpShape.curves=tmpPath.curves,shapes.push(tmpShape),shapes;let holesFirst=!isClockWise(subPaths[0].getPoints());holesFirst=isCCW?!holesFirst:holesFirst;const betterShapeHoles=[],newShapes=[];let newShapeHoles=[],mainIdx=0,tmpPoints;newShapes[mainIdx]=void 0,newShapeHoles[mainIdx]=[];for(let i2=0,l2=subPaths.length;i2<l2;i2++)tmpPath=subPaths[i2],tmpPoints=tmpPath.getPoints(),solid=isClockWise(tmpPoints),solid=isCCW?!solid:solid,solid?(!holesFirst&&newShapes[mainIdx]&&mainIdx++,newShapes[mainIdx]={s:new Shape,p:tmpPoints},newShapes[mainIdx].s.curves=tmpPath.curves,holesFirst&&mainIdx++,newShapeHoles[mainIdx]=[]):newShapeHoles[mainIdx].push({h:tmpPath,p:tmpPoints[0]});if(!newShapes[0])return toShapesNoHoles(subPaths);if(newShapes.length>1){let ambiguous=!1,toChange=0;for(let sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++)betterShapeHoles[sIdx]=[];for(let sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){const sho=newShapeHoles[sIdx];for(let hIdx=0;hIdx<sho.length;hIdx++){const ho=sho[hIdx];let hole_unassigned=!0;for(let s2Idx=0;s2Idx<newShapes.length;s2Idx++)isPointInsidePolygon(ho.p,newShapes[s2Idx].p)&&(sIdx!==s2Idx&&toChange++,hole_unassigned?(hole_unassigned=!1,betterShapeHoles[s2Idx].push(ho)):ambiguous=!0);hole_unassigned&&betterShapeHoles[sIdx].push(ho)}}toChange>0&&ambiguous===!1&&(newShapeHoles=betterShapeHoles)}let tmpHoles;for(let i2=0,il=newShapes.length;i2<il;i2++){tmpShape=newShapes[i2].s,shapes.push(tmpShape),tmpHoles=newShapeHoles[i2];for(let j2=0,jl=tmpHoles.length;j2<jl;j2++)tmpShape.holes.push(tmpHoles[j2].h)}return shapes}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:REVISION}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=REVISION);const THREE=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping,AddEquation,AddOperation,AdditiveAnimationBlendMode,AdditiveBlending,AlphaFormat,AlwaysCompare,AlwaysDepth,AlwaysStencilFunc,AmbientLight,AnimationAction,AnimationClip,AnimationLoader,AnimationMixer,AnimationObjectGroup,AnimationUtils,ArcCurve,ArrayCamera,ArrowHelper,AttachedBindMode,Audio,AudioAnalyser,AudioContext,AudioListener,AudioLoader,AxesHelper,BackSide,BasicDepthPacking,BasicShadowMap,Bone,BooleanKeyframeTrack,Box2,Box3,Box3Helper,BoxGeometry,BoxHelper,BufferAttribute,BufferGeometry,BufferGeometryLoader,ByteType,Cache,Camera,CameraHelper,CanvasTexture,CapsuleGeometry,CatmullRomCurve3,CineonToneMapping,CircleGeometry,ClampToEdgeWrapping,Clock,Color,ColorKeyframeTrack,ColorManagement,CompressedArrayTexture,CompressedCubeTexture,CompressedTexture,CompressedTextureLoader,ConeGeometry,ConstantAlphaFactor,ConstantColorFactor,CubeCamera,CubeReflectionMapping,CubeRefractionMapping,CubeTexture,CubeTextureLoader,CubeUVReflectionMapping,CubicBezierCurve,CubicBezierCurve3,CubicInterpolant,CullFaceBack,CullFaceFront,CullFaceFrontBack,CullFaceNone,Curve,CurvePath,CustomBlending,CustomToneMapping,CylinderGeometry,Cylindrical,Data3DTexture,DataArrayTexture,DataTexture,DataTextureLoader,DataUtils,DecrementStencilOp,DecrementWrapStencilOp,DefaultLoadingManager,DepthFormat,DepthStencilFormat,DepthTexture,DetachedBindMode,DirectionalLight,DirectionalLightHelper,DiscreteInterpolant,DisplayP3ColorSpace,DodecahedronGeometry,DoubleSide,DstAlphaFactor,DstColorFactor,DynamicCopyUsage,DynamicDrawUsage,DynamicReadUsage,EdgesGeometry,EllipseCurve,EqualCompare,EqualDepth,EqualStencilFunc,EquirectangularReflectionMapping,EquirectangularRefractionMapping,Euler,EventDispatcher,ExtrudeGeometry,FileLoader,Float16BufferAttribute,Float32BufferAttribute,Float64BufferAttribute,FloatType,Fog,FogExp2,FramebufferTexture,FrontSide,Frustum,GLBufferAttribute,GLSL1,GLSL3,GreaterCompare,GreaterDepth,GreaterEqualCompare,GreaterEqualDepth,GreaterEqualStencilFunc,GreaterStencilFunc,GridHelper,Group,HalfFloatType,HemisphereLight,HemisphereLightHelper,IcosahedronGeometry,ImageBitmapLoader,ImageLoader,ImageUtils,IncrementStencilOp,IncrementWrapStencilOp,InstancedBufferAttribute,InstancedBufferGeometry,InstancedInterleavedBuffer,InstancedMesh,Int16BufferAttribute,Int32BufferAttribute,Int8BufferAttribute,IntType,InterleavedBuffer,InterleavedBufferAttribute,Interpolant,InterpolateDiscrete,InterpolateLinear,InterpolateSmooth,InvertStencilOp,KeepStencilOp,KeyframeTrack,LOD,LatheGeometry,Layers,LessCompare,LessDepth,LessEqualCompare,LessEqualDepth,LessEqualStencilFunc,LessStencilFunc,Light,LightProbe,Line,Line3,LineBasicMaterial,LineCurve,LineCurve3,LineDashedMaterial,LineLoop,LineSegments,LinearDisplayP3ColorSpace,LinearEncoding,LinearFilter,LinearInterpolant,LinearMipMapLinearFilter,LinearMipMapNearestFilter,LinearMipmapLinearFilter,LinearMipmapNearestFilter,LinearSRGBColorSpace,LinearToneMapping,LinearTransfer,Loader,LoaderUtils,LoadingManager,LoopOnce,LoopPingPong,LoopRepeat,LuminanceAlphaFormat,LuminanceFormat,MOUSE,Material,MaterialLoader,MathUtils,Matrix3,Matrix4,MaxEquation,Mesh,MeshBasicMaterial,MeshDepthMaterial,MeshDistanceMaterial,MeshLambertMaterial,MeshMatcapMaterial,MeshNormalMaterial,MeshPhongMaterial,MeshPhysicalMaterial,MeshStandardMaterial,MeshToonMaterial,MinEquation,MirroredRepeatWrapping,MixOperation,MultiplyBlending,MultiplyOperation,NearestFilter,NearestMipMapLinearFilter,NearestMipMapNearestFilter,NearestMipmapLinearFilter,NearestMipmapNearestFilter,NeverCompare,NeverDepth,NeverStencilFunc,NoBlending,NoColorSpace,NoToneMapping,NormalAnimationBlendMode,NormalBlending,NotEqualCompare,NotEqualDepth,NotEqualStencilFunc,NumberKeyframeTrack,Object3D,ObjectLoader,ObjectSpaceNormalMap,OctahedronGeometry,OneFactor,OneMinusConstantAlphaFactor,OneMinusConstantColorFactor,OneMinusDstAlphaFactor,OneMinusDstColorFactor,OneMinusSrcAlphaFactor,OneMinusSrcColorFactor,OrthographicCamera,P3Primaries,PCFShadowMap,PCFSoftShadowMap,PMREMGenerator,Path,PerspectiveCamera:PerspectiveCamera$1,Plane,PlaneGeometry,PlaneHelper,PointLight,PointLightHelper,Points,PointsMaterial,PolarGridHelper,PolyhedronGeometry,PositionalAudio,PropertyBinding,PropertyMixer,QuadraticBezierCurve,QuadraticBezierCurve3,Quaternion,QuaternionKeyframeTrack,QuaternionLinearInterpolant,RED_GREEN_RGTC2_Format,RED_RGTC1_Format,REVISION,RGBADepthPacking,RGBAFormat,RGBAIntegerFormat,RGBA_ASTC_10x10_Format,RGBA_ASTC_10x5_Format,RGBA_ASTC_10x6_Format,RGBA_ASTC_10x8_Format,RGBA_ASTC_12x10_Format,RGBA_ASTC_12x12_Format,RGBA_ASTC_4x4_Format,RGBA_ASTC_5x4_Format,RGBA_ASTC_5x5_Format,RGBA_ASTC_6x5_Format,RGBA_ASTC_6x6_Format,RGBA_ASTC_8x5_Format,RGBA_ASTC_8x6_Format,RGBA_ASTC_8x8_Format,RGBA_BPTC_Format,RGBA_ETC2_EAC_Format,RGBA_PVRTC_2BPPV1_Format,RGBA_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT1_Format,RGBA_S3TC_DXT3_Format,RGBA_S3TC_DXT5_Format,RGB_BPTC_SIGNED_Format,RGB_BPTC_UNSIGNED_Format,RGB_ETC1_Format,RGB_ETC2_Format,RGB_PVRTC_2BPPV1_Format,RGB_PVRTC_4BPPV1_Format,RGB_S3TC_DXT1_Format,RGFormat,RGIntegerFormat,RawShaderMaterial,Ray,Raycaster,Rec709Primaries,RectAreaLight,RedFormat,RedIntegerFormat,ReinhardToneMapping,RenderTarget,RepeatWrapping,ReplaceStencilOp,ReverseSubtractEquation,RingGeometry,SIGNED_RED_GREEN_RGTC2_Format,SIGNED_RED_RGTC1_Format,SRGBColorSpace,SRGBTransfer,Scene:Scene$1,ShaderChunk,ShaderLib,ShaderMaterial,ShadowMaterial,Shape,ShapeGeometry,ShapePath,ShapeUtils,ShortType,Skeleton,SkeletonHelper,SkinnedMesh,Source,Sphere,SphereGeometry,Spherical,SphericalHarmonics3,SplineCurve,SpotLight,SpotLightHelper,Sprite,SpriteMaterial,SrcAlphaFactor,SrcAlphaSaturateFactor,SrcColorFactor,StaticCopyUsage,StaticDrawUsage,StaticReadUsage,StereoCamera,StreamCopyUsage,StreamDrawUsage,StreamReadUsage,StringKeyframeTrack,SubtractEquation,SubtractiveBlending,TOUCH,TangentSpaceNormalMap,TetrahedronGeometry,Texture,TextureLoader,TorusGeometry,TorusKnotGeometry,Triangle,TriangleFanDrawMode,TriangleStripDrawMode,TrianglesDrawMode,TubeGeometry,TwoPassDoubleSide,UVMapping,Uint16BufferAttribute,Uint32BufferAttribute,Uint8BufferAttribute,Uint8ClampedBufferAttribute,Uniform,UniformsGroup,UniformsLib,UniformsUtils,UnsignedByteType,UnsignedInt248Type,UnsignedIntType,UnsignedShort4444Type,UnsignedShort5551Type,UnsignedShortType,VSMShadowMap,Vector2,Vector3,Vector4,VectorKeyframeTrack,VideoTexture,WebGL1Renderer,WebGL3DRenderTarget,WebGLArrayRenderTarget,WebGLCoordinateSystem,WebGLCubeRenderTarget,WebGLMultipleRenderTargets,WebGLRenderTarget,WebGLRenderer,WebGLUtils,WebGPUCoordinateSystem,WireframeGeometry,WrapAroundEnding,ZeroCurvatureEnding,ZeroFactor,ZeroSlopeEnding,ZeroStencilOp,_SRGBAFormat,createCanvasElement,sRGBEncoding},Symbol.toStringTag,{value:"Module"}));var constants={exports:{}},reactReconcilerConstants_development={};/**
 * @license React
 * react-reconciler-constants.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(){var SyncLane=1,InputContinuousLane=4,DefaultLane=16,IdleLane=536870912,DiscreteEventPriority=SyncLane,ContinuousEventPriority=InputContinuousLane,DefaultEventPriority=DefaultLane,IdleEventPriority=IdleLane,LegacyRoot=0,ConcurrentRoot=1;reactReconcilerConstants_development.ConcurrentRoot=ConcurrentRoot,reactReconcilerConstants_development.ContinuousEventPriority=ContinuousEventPriority,reactReconcilerConstants_development.DefaultEventPriority=DefaultEventPriority,reactReconcilerConstants_development.DiscreteEventPriority=DiscreteEventPriority,reactReconcilerConstants_development.IdleEventPriority=IdleEventPriority,reactReconcilerConstants_development.LegacyRoot=LegacyRoot})();constants.exports=reactReconcilerConstants_development;var constantsExports=constants.exports;function createStore$1(createState2){let state;const listeners=new Set,setState=(partial,replace)=>{const nextState=typeof partial=="function"?partial(state):partial;if(nextState!==state){const previousState=state;state=replace?nextState:Object.assign({},state,nextState),listeners.forEach(listener=>listener(state,previousState))}},getState=()=>state,subscribeWithSelector=(listener,selector=getState,equalityFn=Object.is)=>{console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");let currentSlice=selector(state);function listenerToAdd(){const nextSlice=selector(state);if(!equalityFn(currentSlice,nextSlice)){const previousSlice=currentSlice;listener(currentSlice=nextSlice,previousSlice)}}return listeners.add(listenerToAdd),()=>listeners.delete(listenerToAdd)},api={setState,getState,subscribe:(listener,selector,equalityFn)=>selector||equalityFn?subscribeWithSelector(listener,selector,equalityFn):(listeners.add(listener),()=>listeners.delete(listener)),destroy:()=>listeners.clear()};return state=createState2(setState,getState,api),api}const isSSR=typeof window>"u"||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent),useIsomorphicLayoutEffect$1=isSSR?reactExports.useEffect:reactExports.useLayoutEffect;function create(createState2){const api=typeof createState2=="function"?createStore$1(createState2):createState2,useStore2=(selector=api.getState,equalityFn=Object.is)=>{const[,forceUpdate]=reactExports.useReducer(c2=>c2+1,0),state=api.getState(),stateRef=reactExports.useRef(state),selectorRef=reactExports.useRef(selector),equalityFnRef=reactExports.useRef(equalityFn),erroredRef=reactExports.useRef(!1),currentSliceRef=reactExports.useRef();currentSliceRef.current===void 0&&(currentSliceRef.current=selector(state));let newStateSlice,hasNewStateSlice=!1;(stateRef.current!==state||selectorRef.current!==selector||equalityFnRef.current!==equalityFn||erroredRef.current)&&(newStateSlice=selector(state),hasNewStateSlice=!equalityFn(currentSliceRef.current,newStateSlice)),useIsomorphicLayoutEffect$1(()=>{hasNewStateSlice&&(currentSliceRef.current=newStateSlice),stateRef.current=state,selectorRef.current=selector,equalityFnRef.current=equalityFn,erroredRef.current=!1});const stateBeforeSubscriptionRef=reactExports.useRef(state);useIsomorphicLayoutEffect$1(()=>{const listener=()=>{try{const nextState=api.getState(),nextStateSlice=selectorRef.current(nextState);equalityFnRef.current(currentSliceRef.current,nextStateSlice)||(stateRef.current=nextState,currentSliceRef.current=nextStateSlice,forceUpdate())}catch{erroredRef.current=!0,forceUpdate()}},unsubscribe=api.subscribe(listener);return api.getState()!==stateBeforeSubscriptionRef.current&&listener(),unsubscribe},[]);const sliceToReturn=hasNewStateSlice?newStateSlice:currentSliceRef.current;return reactExports.useDebugValue(sliceToReturn),sliceToReturn};return Object.assign(useStore2,api),useStore2[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");const items=[useStore2,api];return{next(){const done=items.length<=0;return{value:items.shift(),done}}}},useStore2}var reactReconciler={exports:{}},reactReconciler_development={exports:{}},scheduler={exports:{}},scheduler_development={};/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(exports){(function(){typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart=="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);var enableSchedulerDebugging=!1,enableProfiling=!1,frameYieldMs=5;function push(heap,node){var index=heap.length;heap.push(node),siftUp(heap,node,index)}function peek(heap){return heap.length===0?null:heap[0]}function pop(heap){if(heap.length===0)return null;var first=heap[0],last=heap.pop();return last!==first&&(heap[0]=last,siftDown(heap,last,0)),first}function siftUp(heap,node,i2){for(var index=i2;index>0;){var parentIndex=index-1>>>1,parent=heap[parentIndex];if(compare(parent,node)>0)heap[parentIndex]=node,heap[index]=parent,index=parentIndex;else return}}function siftDown(heap,node,i2){for(var index=i2,length=heap.length,halfLength=length>>>1;index<halfLength;){var leftIndex=(index+1)*2-1,left=heap[leftIndex],rightIndex=leftIndex+1,right=heap[rightIndex];if(compare(left,node)<0)rightIndex<length&&compare(right,left)<0?(heap[index]=right,heap[rightIndex]=node,index=rightIndex):(heap[index]=left,heap[leftIndex]=node,index=leftIndex);else if(rightIndex<length&&compare(right,node)<0)heap[index]=right,heap[rightIndex]=node,index=rightIndex;else return}}function compare(a2,b2){var diff=a2.sortIndex-b2.sortIndex;return diff!==0?diff:a2.id-b2.id}var ImmediatePriority=1,UserBlockingPriority=2,NormalPriority=3,LowPriority=4,IdlePriority=5;function markTaskErrored(task,ms){}var hasPerformanceNow=typeof performance=="object"&&typeof performance.now=="function";if(hasPerformanceNow){var localPerformance=performance;exports.unstable_now=function(){return localPerformance.now()}}else{var localDate=Date,initialTime=localDate.now();exports.unstable_now=function(){return localDate.now()-initialTime}}var maxSigned31BitInt=1073741823,IMMEDIATE_PRIORITY_TIMEOUT=-1,USER_BLOCKING_PRIORITY_TIMEOUT=250,NORMAL_PRIORITY_TIMEOUT=5e3,LOW_PRIORITY_TIMEOUT=1e4,IDLE_PRIORITY_TIMEOUT=maxSigned31BitInt,taskQueue=[],timerQueue=[],taskIdCounter=1,currentTask=null,currentPriorityLevel=NormalPriority,isPerformingWork=!1,isHostCallbackScheduled=!1,isHostTimeoutScheduled=!1,localSetTimeout=typeof setTimeout=="function"?setTimeout:null,localClearTimeout=typeof clearTimeout=="function"?clearTimeout:null,localSetImmediate=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function advanceTimers(currentTime){for(var timer=peek(timerQueue);timer!==null;){if(timer.callback===null)pop(timerQueue);else if(timer.startTime<=currentTime)pop(timerQueue),timer.sortIndex=timer.expirationTime,push(taskQueue,timer);else return;timer=peek(timerQueue)}}function handleTimeout(currentTime){if(isHostTimeoutScheduled=!1,advanceTimers(currentTime),!isHostCallbackScheduled)if(peek(taskQueue)!==null)isHostCallbackScheduled=!0,requestHostCallback(flushWork);else{var firstTimer=peek(timerQueue);firstTimer!==null&&requestHostTimeout(handleTimeout,firstTimer.startTime-currentTime)}}function flushWork(hasTimeRemaining,initialTime2){isHostCallbackScheduled=!1,isHostTimeoutScheduled&&(isHostTimeoutScheduled=!1,cancelHostTimeout()),isPerformingWork=!0;var previousPriorityLevel=currentPriorityLevel;try{var currentTime;if(!enableProfiling)return workLoop(hasTimeRemaining,initialTime2)}finally{currentTask=null,currentPriorityLevel=previousPriorityLevel,isPerformingWork=!1}}function workLoop(hasTimeRemaining,initialTime2){var currentTime=initialTime2;for(advanceTimers(currentTime),currentTask=peek(taskQueue);currentTask!==null&&!enableSchedulerDebugging&&!(currentTask.expirationTime>currentTime&&(!hasTimeRemaining||shouldYieldToHost()));){var callback=currentTask.callback;if(typeof callback=="function"){currentTask.callback=null,currentPriorityLevel=currentTask.priorityLevel;var didUserCallbackTimeout=currentTask.expirationTime<=currentTime,continuationCallback=callback(didUserCallbackTimeout);currentTime=exports.unstable_now(),typeof continuationCallback=="function"?currentTask.callback=continuationCallback:currentTask===peek(taskQueue)&&pop(taskQueue),advanceTimers(currentTime)}else pop(taskQueue);currentTask=peek(taskQueue)}if(currentTask!==null)return!0;var firstTimer=peek(timerQueue);return firstTimer!==null&&requestHostTimeout(handleTimeout,firstTimer.startTime-currentTime),!1}function unstable_runWithPriority(priorityLevel,eventHandler){switch(priorityLevel){case ImmediatePriority:case UserBlockingPriority:case NormalPriority:case LowPriority:case IdlePriority:break;default:priorityLevel=NormalPriority}var previousPriorityLevel=currentPriorityLevel;currentPriorityLevel=priorityLevel;try{return eventHandler()}finally{currentPriorityLevel=previousPriorityLevel}}function unstable_next(eventHandler){var priorityLevel;switch(currentPriorityLevel){case ImmediatePriority:case UserBlockingPriority:case NormalPriority:priorityLevel=NormalPriority;break;default:priorityLevel=currentPriorityLevel;break}var previousPriorityLevel=currentPriorityLevel;currentPriorityLevel=priorityLevel;try{return eventHandler()}finally{currentPriorityLevel=previousPriorityLevel}}function unstable_wrapCallback(callback){var parentPriorityLevel=currentPriorityLevel;return function(){var previousPriorityLevel=currentPriorityLevel;currentPriorityLevel=parentPriorityLevel;try{return callback.apply(this,arguments)}finally{currentPriorityLevel=previousPriorityLevel}}}function unstable_scheduleCallback(priorityLevel,callback,options){var currentTime=exports.unstable_now(),startTime2;if(typeof options=="object"&&options!==null){var delay2=options.delay;typeof delay2=="number"&&delay2>0?startTime2=currentTime+delay2:startTime2=currentTime}else startTime2=currentTime;var timeout;switch(priorityLevel){case ImmediatePriority:timeout=IMMEDIATE_PRIORITY_TIMEOUT;break;case UserBlockingPriority:timeout=USER_BLOCKING_PRIORITY_TIMEOUT;break;case IdlePriority:timeout=IDLE_PRIORITY_TIMEOUT;break;case LowPriority:timeout=LOW_PRIORITY_TIMEOUT;break;case NormalPriority:default:timeout=NORMAL_PRIORITY_TIMEOUT;break}var expirationTime=startTime2+timeout,newTask={id:taskIdCounter++,callback,priorityLevel,startTime:startTime2,expirationTime,sortIndex:-1};return startTime2>currentTime?(newTask.sortIndex=startTime2,push(timerQueue,newTask),peek(taskQueue)===null&&newTask===peek(timerQueue)&&(isHostTimeoutScheduled?cancelHostTimeout():isHostTimeoutScheduled=!0,requestHostTimeout(handleTimeout,startTime2-currentTime))):(newTask.sortIndex=expirationTime,push(taskQueue,newTask),!isHostCallbackScheduled&&!isPerformingWork&&(isHostCallbackScheduled=!0,requestHostCallback(flushWork))),newTask}function unstable_pauseExecution(){}function unstable_continueExecution(){!isHostCallbackScheduled&&!isPerformingWork&&(isHostCallbackScheduled=!0,requestHostCallback(flushWork))}function unstable_getFirstCallbackNode(){return peek(taskQueue)}function unstable_cancelCallback(task){task.callback=null}function unstable_getCurrentPriorityLevel(){return currentPriorityLevel}var isMessageLoopRunning=!1,scheduledHostCallback=null,taskTimeoutID=-1,frameInterval=frameYieldMs,startTime=-1;function shouldYieldToHost(){var timeElapsed=exports.unstable_now()-startTime;return!(timeElapsed<frameInterval)}function requestPaint(){}function forceFrameRate(fps){if(fps<0||fps>125){console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");return}fps>0?frameInterval=Math.floor(1e3/fps):frameInterval=frameYieldMs}var performWorkUntilDeadline=function(){if(scheduledHostCallback!==null){var currentTime=exports.unstable_now();startTime=currentTime;var hasTimeRemaining=!0,hasMoreWork=!0;try{hasMoreWork=scheduledHostCallback(hasTimeRemaining,currentTime)}finally{hasMoreWork?schedulePerformWorkUntilDeadline():(isMessageLoopRunning=!1,scheduledHostCallback=null)}}else isMessageLoopRunning=!1},schedulePerformWorkUntilDeadline;if(typeof localSetImmediate=="function")schedulePerformWorkUntilDeadline=function(){localSetImmediate(performWorkUntilDeadline)};else if(typeof MessageChannel<"u"){var channel=new MessageChannel,port=channel.port2;channel.port1.onmessage=performWorkUntilDeadline,schedulePerformWorkUntilDeadline=function(){port.postMessage(null)}}else schedulePerformWorkUntilDeadline=function(){localSetTimeout(performWorkUntilDeadline,0)};function requestHostCallback(callback){scheduledHostCallback=callback,isMessageLoopRunning||(isMessageLoopRunning=!0,schedulePerformWorkUntilDeadline())}function requestHostTimeout(callback,ms){taskTimeoutID=localSetTimeout(function(){callback(exports.unstable_now())},ms)}function cancelHostTimeout(){localClearTimeout(taskTimeoutID),taskTimeoutID=-1}var unstable_requestPaint=requestPaint,unstable_Profiling=null;exports.unstable_IdlePriority=IdlePriority,exports.unstable_ImmediatePriority=ImmediatePriority,exports.unstable_LowPriority=LowPriority,exports.unstable_NormalPriority=NormalPriority,exports.unstable_Profiling=unstable_Profiling,exports.unstable_UserBlockingPriority=UserBlockingPriority,exports.unstable_cancelCallback=unstable_cancelCallback,exports.unstable_continueExecution=unstable_continueExecution,exports.unstable_forceFrameRate=forceFrameRate,exports.unstable_getCurrentPriorityLevel=unstable_getCurrentPriorityLevel,exports.unstable_getFirstCallbackNode=unstable_getFirstCallbackNode,exports.unstable_next=unstable_next,exports.unstable_pauseExecution=unstable_pauseExecution,exports.unstable_requestPaint=unstable_requestPaint,exports.unstable_runWithPriority=unstable_runWithPriority,exports.unstable_scheduleCallback=unstable_scheduleCallback,exports.unstable_shouldYield=shouldYieldToHost,exports.unstable_wrapCallback=unstable_wrapCallback,typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop=="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error)})()})(scheduler_development);scheduler.exports=scheduler_development;var schedulerExports=scheduler.exports;/**
 * @license React
 * react-reconciler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */reactReconciler_development.exports=function($$$hostConfig){var exports={},React=reactExports,Scheduler=schedulerExports,ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,suppressWarning=!1;function setSuppressWarning(newSuppressWarning){suppressWarning=newSuppressWarning}function warn(format){if(!suppressWarning){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];printWarning("warn",format,args)}}function error(format){if(!suppressWarning){for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++)args[_key2-1]=arguments[_key2];printWarning("error",format,args)}}function printWarning(level,format,args){{var ReactDebugCurrentFrame2=ReactSharedInternals.ReactDebugCurrentFrame,stack=ReactDebugCurrentFrame2.getStackAddendum();stack!==""&&(format+="%s",args=args.concat([stack]));var argsWithFormat=args.map(function(item){return String(item)});argsWithFormat.unshift("Warning: "+format),Function.prototype.apply.call(console[level],console,argsWithFormat)}}var assign=Object.assign;function get(key){return key._reactInternals}function set(key,value){key._reactInternals=value}var enablePersistentOffscreenHostContainer=!1,enableNewReconciler=!1,enableLazyContextPropagation=!1,enableLegacyHidden=!1,enableSuspenseAvoidThisFallback=!1,warnAboutStringRefs=!1,enableSchedulingProfiler=!0,enableProfilerTimer=!0,enableProfilerCommitHooks=!0,FunctionComponent=0,ClassComponent=1,IndeterminateComponent=2,HostRoot=3,HostPortal=4,HostComponent=5,HostText=6,Fragment=7,Mode=8,ContextConsumer=9,ContextProvider=10,ForwardRef=11,Profiler=12,SuspenseComponent=13,MemoComponent=14,SimpleMemoComponent=15,LazyComponent=16,IncompleteClassComponent=17,DehydratedFragment=18,SuspenseListComponent=19,ScopeComponent=21,OffscreenComponent=22,LegacyHiddenComponent=23,CacheComponent=24,TracingMarkerComponent=25,REACT_ELEMENT_TYPE=Symbol.for("react.element"),REACT_PORTAL_TYPE=Symbol.for("react.portal"),REACT_FRAGMENT_TYPE=Symbol.for("react.fragment"),REACT_STRICT_MODE_TYPE=Symbol.for("react.strict_mode"),REACT_PROFILER_TYPE=Symbol.for("react.profiler"),REACT_PROVIDER_TYPE=Symbol.for("react.provider"),REACT_CONTEXT_TYPE=Symbol.for("react.context"),REACT_FORWARD_REF_TYPE=Symbol.for("react.forward_ref"),REACT_SUSPENSE_TYPE=Symbol.for("react.suspense"),REACT_SUSPENSE_LIST_TYPE=Symbol.for("react.suspense_list"),REACT_MEMO_TYPE=Symbol.for("react.memo"),REACT_LAZY_TYPE=Symbol.for("react.lazy"),REACT_SCOPE_TYPE=Symbol.for("react.scope"),REACT_DEBUG_TRACING_MODE_TYPE=Symbol.for("react.debug_trace_mode"),REACT_OFFSCREEN_TYPE=Symbol.for("react.offscreen"),REACT_LEGACY_HIDDEN_TYPE=Symbol.for("react.legacy_hidden"),REACT_CACHE_TYPE=Symbol.for("react.cache"),REACT_TRACING_MARKER_TYPE=Symbol.for("react.tracing_marker"),MAYBE_ITERATOR_SYMBOL=Symbol.iterator,FAUX_ITERATOR_SYMBOL="@@iterator";function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable!="object")return null;var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];return typeof maybeIterator=="function"?maybeIterator:null}function getWrappedName(outerType,innerType,wrapperName){var displayName=outerType.displayName;if(displayName)return displayName;var functionName=innerType.displayName||innerType.name||"";return functionName!==""?wrapperName+"("+functionName+")":wrapperName}function getContextName(type){return type.displayName||"Context"}function getComponentNameFromType(type){if(type==null)return null;if(typeof type.tag=="number"&&error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."),typeof type=="function")return type.displayName||type.name||null;if(typeof type=="string")return type;switch(type){case REACT_FRAGMENT_TYPE:return"Fragment";case REACT_PORTAL_TYPE:return"Portal";case REACT_PROFILER_TYPE:return"Profiler";case REACT_STRICT_MODE_TYPE:return"StrictMode";case REACT_SUSPENSE_TYPE:return"Suspense";case REACT_SUSPENSE_LIST_TYPE:return"SuspenseList"}if(typeof type=="object")switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context2=type;return getContextName(context2)+".Consumer";case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+".Provider";case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,"ForwardRef");case REACT_MEMO_TYPE:var outerName=type.displayName||null;return outerName!==null?outerName:getComponentNameFromType(type.type)||"Memo";case REACT_LAZY_TYPE:{var lazyComponent=type,payload=lazyComponent._payload,init=lazyComponent._init;try{return getComponentNameFromType(init(payload))}catch{return null}}}return null}function getWrappedName$1(outerType,innerType,wrapperName){var functionName=innerType.displayName||innerType.name||"";return outerType.displayName||(functionName!==""?wrapperName+"("+functionName+")":wrapperName)}function getContextName$1(type){return type.displayName||"Context"}function getComponentNameFromFiber(fiber){var tag=fiber.tag,type=fiber.type;switch(tag){case CacheComponent:return"Cache";case ContextConsumer:var context2=type;return getContextName$1(context2)+".Consumer";case ContextProvider:var provider=type;return getContextName$1(provider._context)+".Provider";case DehydratedFragment:return"DehydratedFragment";case ForwardRef:return getWrappedName$1(type,type.render,"ForwardRef");case Fragment:return"Fragment";case HostComponent:return type;case HostPortal:return"Portal";case HostRoot:return"Root";case HostText:return"Text";case LazyComponent:return getComponentNameFromType(type);case Mode:return type===REACT_STRICT_MODE_TYPE?"StrictMode":"Mode";case OffscreenComponent:return"Offscreen";case Profiler:return"Profiler";case ScopeComponent:return"Scope";case SuspenseComponent:return"Suspense";case SuspenseListComponent:return"SuspenseList";case TracingMarkerComponent:return"TracingMarker";case ClassComponent:case FunctionComponent:case IncompleteClassComponent:case IndeterminateComponent:case MemoComponent:case SimpleMemoComponent:if(typeof type=="function")return type.displayName||type.name||null;if(typeof type=="string")return type;break}return null}var NoFlags=0,PerformedWork=1,Placement=2,Update=4,PlacementAndUpdate=Placement|Update,ChildDeletion=16,ContentReset=32,Callback=64,DidCapture=128,ForceClientRender=256,Ref=512,Snapshot=1024,Passive=2048,Hydrating=4096,HydratingAndUpdate=Hydrating|Update,Visibility=8192,StoreConsistency=16384,LifecycleEffectMask=Passive|Update|Callback|Ref|Snapshot|StoreConsistency,HostEffectMask=32767,Incomplete=32768,ShouldCapture=65536,ForceUpdateForLegacySuspense=131072,Forked=1048576,RefStatic=2097152,LayoutStatic=4194304,PassiveStatic=8388608,MountLayoutDev=16777216,MountPassiveDev=33554432,BeforeMutationMask=Update|Snapshot|0,MutationMask=Placement|Update|ChildDeletion|ContentReset|Ref|Hydrating|Visibility,LayoutMask=Update|Callback|Ref|Visibility,PassiveMask=Passive|ChildDeletion,StaticMask=LayoutStatic|PassiveStatic|RefStatic,ReactCurrentOwner2=ReactSharedInternals.ReactCurrentOwner;function getNearestMountedFiber(fiber){var node=fiber,nearestMounted=fiber;if(fiber.alternate)for(;node.return;)node=node.return;else{var nextNode=node;do node=nextNode,(node.flags&(Placement|Hydrating))!==NoFlags&&(nearestMounted=node.return),nextNode=node.return;while(nextNode)}return node.tag===HostRoot?nearestMounted:null}function isFiberMounted(fiber){return getNearestMountedFiber(fiber)===fiber}function isMounted(component){{var owner=ReactCurrentOwner2.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner,instance=ownerFiber.stateNode;instance._warnedAboutRefsInRender||error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.",getComponentNameFromFiber(ownerFiber)||"A component"),instance._warnedAboutRefsInRender=!0}}var fiber=get(component);return fiber?getNearestMountedFiber(fiber)===fiber:!1}function assertIsMounted(fiber){if(getNearestMountedFiber(fiber)!==fiber)throw new Error("Unable to find node on an unmounted component.")}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){var nearestMounted=getNearestMountedFiber(fiber);if(nearestMounted===null)throw new Error("Unable to find node on an unmounted component.");return nearestMounted!==fiber?null:fiber}for(var a2=fiber,b2=alternate;;){var parentA=a2.return;if(parentA===null)break;var parentB=parentA.alternate;if(parentB===null){var nextParent=parentA.return;if(nextParent!==null){a2=b2=nextParent;continue}break}if(parentA.child===parentB.child){for(var child=parentA.child;child;){if(child===a2)return assertIsMounted(parentA),fiber;if(child===b2)return assertIsMounted(parentA),alternate;child=child.sibling}throw new Error("Unable to find node on an unmounted component.")}if(a2.return!==b2.return)a2=parentA,b2=parentB;else{for(var didFindChild=!1,_child=parentA.child;_child;){if(_child===a2){didFindChild=!0,a2=parentA,b2=parentB;break}if(_child===b2){didFindChild=!0,b2=parentA,a2=parentB;break}_child=_child.sibling}if(!didFindChild){for(_child=parentB.child;_child;){if(_child===a2){didFindChild=!0,a2=parentB,b2=parentA;break}if(_child===b2){didFindChild=!0,b2=parentB,a2=parentA;break}_child=_child.sibling}if(!didFindChild)throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.")}}if(a2.alternate!==b2)throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.")}if(a2.tag!==HostRoot)throw new Error("Unable to find node on an unmounted component.");return a2.stateNode.current===a2?fiber:alternate}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberImpl(currentParent):null}function findCurrentHostFiberImpl(node){if(node.tag===HostComponent||node.tag===HostText)return node;for(var child=node.child;child!==null;){var match=findCurrentHostFiberImpl(child);if(match!==null)return match;child=child.sibling}return null}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);return currentParent!==null?findCurrentHostFiberWithNoPortalsImpl(currentParent):null}function findCurrentHostFiberWithNoPortalsImpl(node){if(node.tag===HostComponent||node.tag===HostText)return node;for(var child=node.child;child!==null;){if(child.tag!==HostPortal){var match=findCurrentHostFiberWithNoPortalsImpl(child);if(match!==null)return match}child=child.sibling}return null}var isArrayImpl=Array.isArray;function isArray(a2){return isArrayImpl(a2)}var getPublicInstance=$$$hostConfig.getPublicInstance,getRootHostContext=$$$hostConfig.getRootHostContext,getChildHostContext=$$$hostConfig.getChildHostContext,prepareForCommit=$$$hostConfig.prepareForCommit,resetAfterCommit=$$$hostConfig.resetAfterCommit,createInstance=$$$hostConfig.createInstance,appendInitialChild=$$$hostConfig.appendInitialChild,finalizeInitialChildren=$$$hostConfig.finalizeInitialChildren,prepareUpdate=$$$hostConfig.prepareUpdate,shouldSetTextContent=$$$hostConfig.shouldSetTextContent,createTextInstance=$$$hostConfig.createTextInstance,scheduleTimeout=$$$hostConfig.scheduleTimeout,cancelTimeout=$$$hostConfig.cancelTimeout,noTimeout=$$$hostConfig.noTimeout;$$$hostConfig.now;var isPrimaryRenderer=$$$hostConfig.isPrimaryRenderer,warnsIfNotActing=$$$hostConfig.warnsIfNotActing,supportsMutation=$$$hostConfig.supportsMutation,supportsPersistence=$$$hostConfig.supportsPersistence,supportsHydration=$$$hostConfig.supportsHydration,getInstanceFromNode=$$$hostConfig.getInstanceFromNode;$$$hostConfig.beforeActiveInstanceBlur,$$$hostConfig.afterActiveInstanceBlur;var preparePortalMount=$$$hostConfig.preparePortalMount;$$$hostConfig.preparePortalMount,$$$hostConfig.getInstanceFromScope;var getCurrentEventPriority=$$$hostConfig.getCurrentEventPriority,detachDeletedInstance=$$$hostConfig.detachDeletedInstance,supportsMicrotasks=$$$hostConfig.supportsMicrotasks,scheduleMicrotask=$$$hostConfig.scheduleMicrotask,supportsTestSelectors=$$$hostConfig.supportsTestSelectors,findFiberRoot=$$$hostConfig.findFiberRoot,getBoundingRect=$$$hostConfig.getBoundingRect,getTextContent=$$$hostConfig.getTextContent,isHiddenSubtree=$$$hostConfig.isHiddenSubtree,matchAccessibilityRole=$$$hostConfig.matchAccessibilityRole,setFocusIfFocusable=$$$hostConfig.setFocusIfFocusable,setupIntersectionObserver=$$$hostConfig.setupIntersectionObserver,appendChild=$$$hostConfig.appendChild,appendChildToContainer=$$$hostConfig.appendChildToContainer,commitTextUpdate=$$$hostConfig.commitTextUpdate,commitMount=$$$hostConfig.commitMount,commitUpdate=$$$hostConfig.commitUpdate,insertBefore=$$$hostConfig.insertBefore,insertInContainerBefore=$$$hostConfig.insertInContainerBefore,removeChild=$$$hostConfig.removeChild,removeChildFromContainer=$$$hostConfig.removeChildFromContainer,resetTextContent=$$$hostConfig.resetTextContent,hideInstance=$$$hostConfig.hideInstance,hideTextInstance=$$$hostConfig.hideTextInstance,unhideInstance=$$$hostConfig.unhideInstance,unhideTextInstance=$$$hostConfig.unhideTextInstance,clearContainer=$$$hostConfig.clearContainer,cloneInstance=$$$hostConfig.cloneInstance,createContainerChildSet=$$$hostConfig.createContainerChildSet,appendChildToContainerChildSet=$$$hostConfig.appendChildToContainerChildSet,finalizeContainerChildren=$$$hostConfig.finalizeContainerChildren,replaceContainerChildren=$$$hostConfig.replaceContainerChildren;$$$hostConfig.getOffscreenContainerType;var getOffscreenContainerProps=$$$hostConfig.getOffscreenContainerProps,cloneHiddenInstance=$$$hostConfig.cloneHiddenInstance,cloneHiddenTextInstance=$$$hostConfig.cloneHiddenTextInstance,canHydrateInstance=$$$hostConfig.canHydrateInstance,canHydrateTextInstance=$$$hostConfig.canHydrateTextInstance,canHydrateSuspenseInstance=$$$hostConfig.canHydrateSuspenseInstance,isSuspenseInstancePending=$$$hostConfig.isSuspenseInstancePending,isSuspenseInstanceFallback=$$$hostConfig.isSuspenseInstanceFallback,registerSuspenseInstanceRetry=$$$hostConfig.registerSuspenseInstanceRetry,getNextHydratableSibling=$$$hostConfig.getNextHydratableSibling,getFirstHydratableChild=$$$hostConfig.getFirstHydratableChild,getFirstHydratableChildWithinContainer=$$$hostConfig.getFirstHydratableChildWithinContainer,getFirstHydratableChildWithinSuspenseInstance=$$$hostConfig.getFirstHydratableChildWithinSuspenseInstance,hydrateInstance=$$$hostConfig.hydrateInstance,hydrateTextInstance=$$$hostConfig.hydrateTextInstance,hydrateSuspenseInstance=$$$hostConfig.hydrateSuspenseInstance,getNextHydratableInstanceAfterSuspenseInstance=$$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance,commitHydratedContainer=$$$hostConfig.commitHydratedContainer,commitHydratedSuspenseInstance=$$$hostConfig.commitHydratedSuspenseInstance,clearSuspenseBoundary=$$$hostConfig.clearSuspenseBoundary,clearSuspenseBoundaryFromContainer=$$$hostConfig.clearSuspenseBoundaryFromContainer,shouldDeleteUnhydratedTailInstances=$$$hostConfig.shouldDeleteUnhydratedTailInstances,didNotMatchHydratedContainerTextInstance=$$$hostConfig.didNotMatchHydratedContainerTextInstance,didNotMatchHydratedTextInstance=$$$hostConfig.didNotMatchHydratedTextInstance,didNotHydrateInstanceWithinContainer=$$$hostConfig.didNotHydrateInstanceWithinContainer,didNotHydrateInstanceWithinSuspenseInstance=$$$hostConfig.didNotHydrateInstanceWithinSuspenseInstance,didNotHydrateInstance=$$$hostConfig.didNotHydrateInstance,didNotFindHydratableInstanceWithinContainer=$$$hostConfig.didNotFindHydratableInstanceWithinContainer,didNotFindHydratableTextInstanceWithinContainer=$$$hostConfig.didNotFindHydratableTextInstanceWithinContainer,didNotFindHydratableSuspenseInstanceWithinContainer=$$$hostConfig.didNotFindHydratableSuspenseInstanceWithinContainer,didNotFindHydratableInstanceWithinSuspenseInstance=$$$hostConfig.didNotFindHydratableInstanceWithinSuspenseInstance,didNotFindHydratableTextInstanceWithinSuspenseInstance=$$$hostConfig.didNotFindHydratableTextInstanceWithinSuspenseInstance,didNotFindHydratableSuspenseInstanceWithinSuspenseInstance=$$$hostConfig.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance,didNotFindHydratableInstance=$$$hostConfig.didNotFindHydratableInstance,didNotFindHydratableTextInstance=$$$hostConfig.didNotFindHydratableTextInstance,didNotFindHydratableSuspenseInstance=$$$hostConfig.didNotFindHydratableSuspenseInstance,errorHydratingContainer=$$$hostConfig.errorHydratingContainer,disabledDepth=0,prevLog,prevInfo,prevWarn,prevError,prevGroup,prevGroupCollapsed,prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=!0;function disableLogs(){{if(disabledDepth===0){prevLog=console.log,prevInfo=console.info,prevWarn=console.warn,prevError=console.error,prevGroup=console.group,prevGroupCollapsed=console.groupCollapsed,prevGroupEnd=console.groupEnd;var props={configurable:!0,enumerable:!0,value:disabledLog,writable:!0};Object.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props})}disabledDepth++}}function reenableLogs(){{if(disabledDepth--,disabledDepth===0){var props={configurable:!0,enumerable:!0,writable:!0};Object.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})})}disabledDepth<0&&error("disabledDepth fell below zero. This is a bug in React. Please file an issue.")}}var ReactCurrentDispatcher2=ReactSharedInternals.ReactCurrentDispatcher,prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===void 0)try{throw Error()}catch(x2){var match=x2.stack.trim().match(/\n( *(at )?)/);prefix=match&&match[1]||""}return`
`+prefix+name}}var reentry=!1,componentFrameCache;{var PossiblyWeakMap=typeof WeakMap=="function"?WeakMap:Map;componentFrameCache=new PossiblyWeakMap}function describeNativeComponentFrame(fn,construct){if(!fn||reentry)return"";{var frame2=componentFrameCache.get(fn);if(frame2!==void 0)return frame2}var control;reentry=!0;var previousPrepareStackTrace=Error.prepareStackTrace;Error.prepareStackTrace=void 0;var previousDispatcher;previousDispatcher=ReactCurrentDispatcher2.current,ReactCurrentDispatcher2.current=null,disableLogs();try{if(construct){var Fake=function(){throw Error()};if(Object.defineProperty(Fake.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Fake,[])}catch(x2){control=x2}Reflect.construct(fn,[],Fake)}else{try{Fake.call()}catch(x2){control=x2}fn.call(Fake.prototype)}}else{try{throw Error()}catch(x2){control=x2}fn()}}catch(sample){if(sample&&control&&typeof sample.stack=="string"){for(var sampleLines=sample.stack.split(`
`),controlLines=control.stack.split(`
`),s2=sampleLines.length-1,c2=controlLines.length-1;s2>=1&&c2>=0&&sampleLines[s2]!==controlLines[c2];)c2--;for(;s2>=1&&c2>=0;s2--,c2--)if(sampleLines[s2]!==controlLines[c2]){if(s2!==1||c2!==1)do if(s2--,c2--,c2<0||sampleLines[s2]!==controlLines[c2]){var _frame=`
`+sampleLines[s2].replace(" at new "," at ");return fn.displayName&&_frame.includes("<anonymous>")&&(_frame=_frame.replace("<anonymous>",fn.displayName)),typeof fn=="function"&&componentFrameCache.set(fn,_frame),_frame}while(s2>=1&&c2>=0);break}}}finally{reentry=!1,ReactCurrentDispatcher2.current=previousDispatcher,reenableLogs(),Error.prepareStackTrace=previousPrepareStackTrace}var name=fn?fn.displayName||fn.name:"",syntheticFrame=name?describeBuiltInComponentFrame(name):"";return typeof fn=="function"&&componentFrameCache.set(fn,syntheticFrame),syntheticFrame}function describeClassComponentFrame(ctor,source,ownerFn){return describeNativeComponentFrame(ctor,!0)}function describeFunctionComponentFrame(fn,source,ownerFn){return describeNativeComponentFrame(fn,!1)}function shouldConstruct(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent)}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null)return"";if(typeof type=="function")return describeNativeComponentFrame(type,shouldConstruct(type));if(typeof type=="string")return describeBuiltInComponentFrame(type);switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame("Suspense");case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame("SuspenseList")}if(typeof type=="object")switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:return describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:{var lazyComponent=type,payload=lazyComponent._payload,init=lazyComponent._init;try{return describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn)}catch{}}}return""}var hasOwnProperty=Object.prototype.hasOwnProperty,loggedTypeFailures={},ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){if(element){var owner=element._owner,stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame.setExtraStackFrame(stack)}else ReactDebugCurrentFrame.setExtraStackFrame(null)}function checkPropTypes(typeSpecs,values,location,componentName,element){{var has=Function.call.bind(hasOwnProperty);for(var typeSpecName in typeSpecs)if(has(typeSpecs,typeSpecName)){var error$1=void 0;try{if(typeof typeSpecs[typeSpecName]!="function"){var err=Error((componentName||"React class")+": "+location+" type `"+typeSpecName+"` is invalid; it must be a function, usually from the `prop-types` package, but received `"+typeof typeSpecs[typeSpecName]+"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");throw err.name="Invariant Violation",err}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(ex){error$1=ex}error$1&&!(error$1 instanceof Error)&&(setCurrentlyValidatingElement(element),error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).",componentName||"React class",location,typeSpecName,typeof error$1),setCurrentlyValidatingElement(null)),error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)&&(loggedTypeFailures[error$1.message]=!0,setCurrentlyValidatingElement(element),error("Failed %s type: %s",location,error$1.message),setCurrentlyValidatingElement(null))}}}var valueStack=[],fiberStack;fiberStack=[];var index=-1;function createCursor(defaultValue){return{current:defaultValue}}function pop(cursor,fiber){if(index<0){error("Unexpected pop.");return}fiber!==fiberStack[index]&&error("Unexpected Fiber popped."),cursor.current=valueStack[index],valueStack[index]=null,fiberStack[index]=null,index--}function push(cursor,value,fiber){index++,valueStack[index]=cursor.current,fiberStack[index]=fiber,cursor.current=value}var warnedAboutMissingGetChildContext;warnedAboutMissingGetChildContext={};var emptyContextObject={};Object.freeze(emptyContextObject);var contextStackCursor=createCursor(emptyContextObject),didPerformWorkStackCursor=createCursor(!1),previousContext=emptyContextObject;function getUnmaskedContext(workInProgress2,Component,didPushOwnContextIfProvider){return didPushOwnContextIfProvider&&isContextProvider(Component)?previousContext:contextStackCursor.current}function cacheContext(workInProgress2,unmaskedContext,maskedContext){{var instance=workInProgress2.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext,instance.__reactInternalMemoizedMaskedChildContext=maskedContext}}function getMaskedContext(workInProgress2,unmaskedContext){{var type=workInProgress2.type,contextTypes=type.contextTypes;if(!contextTypes)return emptyContextObject;var instance=workInProgress2.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext)return instance.__reactInternalMemoizedMaskedChildContext;var context2={};for(var key in contextTypes)context2[key]=unmaskedContext[key];{var name=getComponentNameFromFiber(workInProgress2)||"Unknown";checkPropTypes(contextTypes,context2,"context",name)}return instance&&cacheContext(workInProgress2,unmaskedContext,context2),context2}}function hasContextChanged(){return didPerformWorkStackCursor.current}function isContextProvider(type){{var childContextTypes=type.childContextTypes;return childContextTypes!=null}}function popContext(fiber){pop(didPerformWorkStackCursor,fiber),pop(contextStackCursor,fiber)}function popTopLevelContextObject(fiber){pop(didPerformWorkStackCursor,fiber),pop(contextStackCursor,fiber)}function pushTopLevelContextObject(fiber,context2,didChange){{if(contextStackCursor.current!==emptyContextObject)throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");push(contextStackCursor,context2,fiber),push(didPerformWorkStackCursor,didChange,fiber)}}function processChildContext(fiber,type,parentContext){{var instance=fiber.stateNode,childContextTypes=type.childContextTypes;if(typeof instance.getChildContext!="function"){{var componentName=getComponentNameFromFiber(fiber)||"Unknown";warnedAboutMissingGetChildContext[componentName]||(warnedAboutMissingGetChildContext[componentName]=!0,error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.",componentName,componentName))}return parentContext}var childContext=instance.getChildContext();for(var contextKey in childContext)if(!(contextKey in childContextTypes))throw new Error((getComponentNameFromFiber(fiber)||"Unknown")+'.getChildContext(): key "'+contextKey+'" is not defined in childContextTypes.');{var name=getComponentNameFromFiber(fiber)||"Unknown";checkPropTypes(childContextTypes,childContext,"child context",name)}return assign({},parentContext,childContext)}}function pushContextProvider(workInProgress2){{var instance=workInProgress2.stateNode,memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;return previousContext=contextStackCursor.current,push(contextStackCursor,memoizedMergedChildContext,workInProgress2),push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress2),!0}}function invalidateContextProvider(workInProgress2,type,didChange){{var instance=workInProgress2.stateNode;if(!instance)throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");if(didChange){var mergedContext=processChildContext(workInProgress2,type,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext,pop(didPerformWorkStackCursor,workInProgress2),pop(contextStackCursor,workInProgress2),push(contextStackCursor,mergedContext,workInProgress2),push(didPerformWorkStackCursor,didChange,workInProgress2)}else pop(didPerformWorkStackCursor,workInProgress2),push(didPerformWorkStackCursor,didChange,workInProgress2)}}function findCurrentUnmaskedContext(fiber){{if(!isFiberMounted(fiber)||fiber.tag!==ClassComponent)throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");var node=fiber;do{switch(node.tag){case HostRoot:return node.stateNode.context;case ClassComponent:{var Component=node.type;if(isContextProvider(Component))return node.stateNode.__reactInternalMemoizedMergedChildContext;break}}node=node.return}while(node!==null);throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.")}}var LegacyRoot=0,ConcurrentRoot=1,NoMode=0,ConcurrentMode=1,ProfileMode=2,StrictLegacyMode=8,StrictEffectsMode=16,clz32=Math.clz32?Math.clz32:clz32Fallback,log=Math.log,LN2=Math.LN2;function clz32Fallback(x2){var asUint=x2>>>0;return asUint===0?32:31-(log(asUint)/LN2|0)|0}var TotalLanes=31,NoLanes=0,NoLane=0,SyncLane=1,InputContinuousHydrationLane=2,InputContinuousLane=4,DefaultHydrationLane=8,DefaultLane=16,TransitionHydrationLane=32,TransitionLanes=4194240,TransitionLane1=64,TransitionLane2=128,TransitionLane3=256,TransitionLane4=512,TransitionLane5=1024,TransitionLane6=2048,TransitionLane7=4096,TransitionLane8=8192,TransitionLane9=16384,TransitionLane10=32768,TransitionLane11=65536,TransitionLane12=131072,TransitionLane13=262144,TransitionLane14=524288,TransitionLane15=1048576,TransitionLane16=2097152,RetryLanes=130023424,RetryLane1=4194304,RetryLane2=8388608,RetryLane3=16777216,RetryLane4=33554432,RetryLane5=67108864,SomeRetryLane=RetryLane1,SelectiveHydrationLane=134217728,NonIdleLanes=268435455,IdleHydrationLane=268435456,IdleLane=536870912,OffscreenLane=1073741824;function getLabelForLane(lane){{if(lane&SyncLane)return"Sync";if(lane&InputContinuousHydrationLane)return"InputContinuousHydration";if(lane&InputContinuousLane)return"InputContinuous";if(lane&DefaultHydrationLane)return"DefaultHydration";if(lane&DefaultLane)return"Default";if(lane&TransitionHydrationLane)return"TransitionHydration";if(lane&TransitionLanes)return"Transition";if(lane&RetryLanes)return"Retry";if(lane&SelectiveHydrationLane)return"SelectiveHydration";if(lane&IdleHydrationLane)return"IdleHydration";if(lane&IdleLane)return"Idle";if(lane&OffscreenLane)return"Offscreen"}}var NoTimestamp=-1,nextTransitionLane=TransitionLane1,nextRetryLane=RetryLane1;function getHighestPriorityLanes(lanes){switch(getHighestPriorityLane(lanes)){case SyncLane:return SyncLane;case InputContinuousHydrationLane:return InputContinuousHydrationLane;case InputContinuousLane:return InputContinuousLane;case DefaultHydrationLane:return DefaultHydrationLane;case DefaultLane:return DefaultLane;case TransitionHydrationLane:return TransitionHydrationLane;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return lanes&TransitionLanes;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:return lanes&RetryLanes;case SelectiveHydrationLane:return SelectiveHydrationLane;case IdleHydrationLane:return IdleHydrationLane;case IdleLane:return IdleLane;case OffscreenLane:return OffscreenLane;default:return error("Should have found matching lanes. This is a bug in React."),lanes}}function getNextLanes(root,wipLanes){var pendingLanes=root.pendingLanes;if(pendingLanes===NoLanes)return NoLanes;var nextLanes=NoLanes,suspendedLanes=root.suspendedLanes,pingedLanes=root.pingedLanes,nonIdlePendingLanes=pendingLanes&NonIdleLanes;if(nonIdlePendingLanes!==NoLanes){var nonIdleUnblockedLanes=nonIdlePendingLanes&~suspendedLanes;if(nonIdleUnblockedLanes!==NoLanes)nextLanes=getHighestPriorityLanes(nonIdleUnblockedLanes);else{var nonIdlePingedLanes=nonIdlePendingLanes&pingedLanes;nonIdlePingedLanes!==NoLanes&&(nextLanes=getHighestPriorityLanes(nonIdlePingedLanes))}}else{var unblockedLanes=pendingLanes&~suspendedLanes;unblockedLanes!==NoLanes?nextLanes=getHighestPriorityLanes(unblockedLanes):pingedLanes!==NoLanes&&(nextLanes=getHighestPriorityLanes(pingedLanes))}if(nextLanes===NoLanes)return NoLanes;if(wipLanes!==NoLanes&&wipLanes!==nextLanes&&(wipLanes&suspendedLanes)===NoLanes){var nextLane=getHighestPriorityLane(nextLanes),wipLane=getHighestPriorityLane(wipLanes);if(nextLane>=wipLane||nextLane===DefaultLane&&(wipLane&TransitionLanes)!==NoLanes)return wipLanes}(nextLanes&InputContinuousLane)!==NoLanes&&(nextLanes|=pendingLanes&DefaultLane);var entangledLanes=root.entangledLanes;if(entangledLanes!==NoLanes)for(var entanglements=root.entanglements,lanes=nextLanes&entangledLanes;lanes>0;){var index2=pickArbitraryLaneIndex(lanes),lane=1<<index2;nextLanes|=entanglements[index2],lanes&=~lane}return nextLanes}function getMostRecentEventTime(root,lanes){for(var eventTimes=root.eventTimes,mostRecentEventTime=NoTimestamp;lanes>0;){var index2=pickArbitraryLaneIndex(lanes),lane=1<<index2,eventTime=eventTimes[index2];eventTime>mostRecentEventTime&&(mostRecentEventTime=eventTime),lanes&=~lane}return mostRecentEventTime}function computeExpirationTime(lane,currentTime){switch(lane){case SyncLane:case InputContinuousHydrationLane:case InputContinuousLane:return currentTime+250;case DefaultHydrationLane:case DefaultLane:case TransitionHydrationLane:case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:return currentTime+5e3;case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:return NoTimestamp;case SelectiveHydrationLane:case IdleHydrationLane:case IdleLane:case OffscreenLane:return NoTimestamp;default:return error("Should have found matching lanes. This is a bug in React."),NoTimestamp}}function markStarvedLanesAsExpired(root,currentTime){for(var pendingLanes=root.pendingLanes,suspendedLanes=root.suspendedLanes,pingedLanes=root.pingedLanes,expirationTimes=root.expirationTimes,lanes=pendingLanes;lanes>0;){var index2=pickArbitraryLaneIndex(lanes),lane=1<<index2,expirationTime=expirationTimes[index2];expirationTime===NoTimestamp?((lane&suspendedLanes)===NoLanes||(lane&pingedLanes)!==NoLanes)&&(expirationTimes[index2]=computeExpirationTime(lane,currentTime)):expirationTime<=currentTime&&(root.expiredLanes|=lane),lanes&=~lane}}function getHighestPriorityPendingLanes(root){return getHighestPriorityLanes(root.pendingLanes)}function getLanesToRetrySynchronouslyOnError(root){var everythingButOffscreen=root.pendingLanes&~OffscreenLane;return everythingButOffscreen!==NoLanes?everythingButOffscreen:everythingButOffscreen&OffscreenLane?OffscreenLane:NoLanes}function includesSyncLane(lanes){return(lanes&SyncLane)!==NoLanes}function includesNonIdleWork(lanes){return(lanes&NonIdleLanes)!==NoLanes}function includesOnlyRetries(lanes){return(lanes&RetryLanes)===lanes}function includesOnlyTransitions(lanes){return(lanes&TransitionLanes)===lanes}function includesBlockingLane(root,lanes){var SyncDefaultLanes=InputContinuousHydrationLane|InputContinuousLane|DefaultHydrationLane|DefaultLane;return(lanes&SyncDefaultLanes)!==NoLanes}function includesExpiredLane(root,lanes){return(lanes&root.expiredLanes)!==NoLanes}function isTransitionLane(lane){return(lane&TransitionLanes)!==0}function claimNextTransitionLane(){var lane=nextTransitionLane;return nextTransitionLane<<=1,nextTransitionLane&TransitionLanes||(nextTransitionLane=TransitionLane1),lane}function claimNextRetryLane(){var lane=nextRetryLane;return nextRetryLane<<=1,nextRetryLane&RetryLanes||(nextRetryLane=RetryLane1),lane}function getHighestPriorityLane(lanes){return lanes&-lanes}function pickArbitraryLane(lanes){return getHighestPriorityLane(lanes)}function pickArbitraryLaneIndex(lanes){return 31-clz32(lanes)}function laneToIndex(lane){return pickArbitraryLaneIndex(lane)}function includesSomeLane(a2,b2){return(a2&b2)!==NoLanes}function isSubsetOfLanes(set2,subset){return(set2&subset)===subset}function mergeLanes(a2,b2){return a2|b2}function removeLanes(set2,subset){return set2&~subset}function intersectLanes(a2,b2){return a2&b2}function laneToLanes(lane){return lane}function higherPriorityLane(a2,b2){return a2!==NoLane&&a2<b2?a2:b2}function createLaneMap(initial){for(var laneMap=[],i2=0;i2<TotalLanes;i2++)laneMap.push(initial);return laneMap}function markRootUpdated(root,updateLane,eventTime){root.pendingLanes|=updateLane,updateLane!==IdleLane&&(root.suspendedLanes=NoLanes,root.pingedLanes=NoLanes);var eventTimes=root.eventTimes,index2=laneToIndex(updateLane);eventTimes[index2]=eventTime}function markRootSuspended(root,suspendedLanes){root.suspendedLanes|=suspendedLanes,root.pingedLanes&=~suspendedLanes;for(var expirationTimes=root.expirationTimes,lanes=suspendedLanes;lanes>0;){var index2=pickArbitraryLaneIndex(lanes),lane=1<<index2;expirationTimes[index2]=NoTimestamp,lanes&=~lane}}function markRootPinged(root,pingedLanes,eventTime){root.pingedLanes|=root.suspendedLanes&pingedLanes}function markRootFinished(root,remainingLanes){var noLongerPendingLanes=root.pendingLanes&~remainingLanes;root.pendingLanes=remainingLanes,root.suspendedLanes=0,root.pingedLanes=0,root.expiredLanes&=remainingLanes,root.mutableReadLanes&=remainingLanes,root.entangledLanes&=remainingLanes;for(var entanglements=root.entanglements,eventTimes=root.eventTimes,expirationTimes=root.expirationTimes,lanes=noLongerPendingLanes;lanes>0;){var index2=pickArbitraryLaneIndex(lanes),lane=1<<index2;entanglements[index2]=NoLanes,eventTimes[index2]=NoTimestamp,expirationTimes[index2]=NoTimestamp,lanes&=~lane}}function markRootEntangled(root,entangledLanes){for(var rootEntangledLanes=root.entangledLanes|=entangledLanes,entanglements=root.entanglements,lanes=rootEntangledLanes;lanes;){var index2=pickArbitraryLaneIndex(lanes),lane=1<<index2;lane&entangledLanes|entanglements[index2]&entangledLanes&&(entanglements[index2]|=entangledLanes),lanes&=~lane}}function getBumpedLaneForHydration(root,renderLanes2){var renderLane=getHighestPriorityLane(renderLanes2),lane;switch(renderLane){case InputContinuousLane:lane=InputContinuousHydrationLane;break;case DefaultLane:lane=DefaultHydrationLane;break;case TransitionLane1:case TransitionLane2:case TransitionLane3:case TransitionLane4:case TransitionLane5:case TransitionLane6:case TransitionLane7:case TransitionLane8:case TransitionLane9:case TransitionLane10:case TransitionLane11:case TransitionLane12:case TransitionLane13:case TransitionLane14:case TransitionLane15:case TransitionLane16:case RetryLane1:case RetryLane2:case RetryLane3:case RetryLane4:case RetryLane5:lane=TransitionHydrationLane;break;case IdleLane:lane=IdleHydrationLane;break;default:lane=NoLane;break}return(lane&(root.suspendedLanes|renderLanes2))!==NoLane?NoLane:lane}function addFiberToLanesMap(root,fiber,lanes){if(isDevToolsPresent)for(var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap;lanes>0;){var index2=laneToIndex(lanes),lane=1<<index2,updaters=pendingUpdatersLaneMap[index2];updaters.add(fiber),lanes&=~lane}}function movePendingFibersToMemoized(root,lanes){if(isDevToolsPresent)for(var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap,memoizedUpdaters=root.memoizedUpdaters;lanes>0;){var index2=laneToIndex(lanes),lane=1<<index2,updaters=pendingUpdatersLaneMap[index2];updaters.size>0&&(updaters.forEach(function(fiber){var alternate=fiber.alternate;(alternate===null||!memoizedUpdaters.has(alternate))&&memoizedUpdaters.add(fiber)}),updaters.clear()),lanes&=~lane}}var DiscreteEventPriority=SyncLane,ContinuousEventPriority=InputContinuousLane,DefaultEventPriority=DefaultLane,IdleEventPriority=IdleLane,currentUpdatePriority=NoLane;function getCurrentUpdatePriority(){return currentUpdatePriority}function setCurrentUpdatePriority(newPriority){currentUpdatePriority=newPriority}function runWithPriority(priority,fn){var previousPriority=currentUpdatePriority;try{return currentUpdatePriority=priority,fn()}finally{currentUpdatePriority=previousPriority}}function higherEventPriority(a2,b2){return a2!==0&&a2<b2?a2:b2}function lowerEventPriority(a2,b2){return a2===0||a2>b2?a2:b2}function isHigherEventPriority(a2,b2){return a2!==0&&a2<b2}function lanesToEventPriority(lanes){var lane=getHighestPriorityLane(lanes);return isHigherEventPriority(DiscreteEventPriority,lane)?isHigherEventPriority(ContinuousEventPriority,lane)?includesNonIdleWork(lane)?DefaultEventPriority:IdleEventPriority:ContinuousEventPriority:DiscreteEventPriority}var scheduleCallback=Scheduler.unstable_scheduleCallback,cancelCallback=Scheduler.unstable_cancelCallback,shouldYield=Scheduler.unstable_shouldYield,requestPaint=Scheduler.unstable_requestPaint,now$1=Scheduler.unstable_now,ImmediatePriority=Scheduler.unstable_ImmediatePriority,UserBlockingPriority=Scheduler.unstable_UserBlockingPriority,NormalPriority=Scheduler.unstable_NormalPriority,IdlePriority=Scheduler.unstable_IdlePriority,unstable_yieldValue=Scheduler.unstable_yieldValue,unstable_setDisableYieldValue=Scheduler.unstable_setDisableYieldValue,rendererID=null,injectedHook=null,injectedProfilingHooks=null,hasLoggedError=!1,isDevToolsPresent=typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u";function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")return!1;var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled)return!0;if(!hook.supportsFiber)return error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"),!0;try{enableSchedulingProfiler&&(internals=assign({},internals,{getLaneLabelMap,injectProfilingHooks})),rendererID=hook.inject(internals),injectedHook=hook}catch(err){error("React instrumentation encountered an error: %s.",err)}return!!hook.checkDCE}function onScheduleRoot(root,children){if(injectedHook&&typeof injectedHook.onScheduleFiberRoot=="function")try{injectedHook.onScheduleFiberRoot(rendererID,root,children)}catch(err){hasLoggedError||(hasLoggedError=!0,error("React instrumentation encountered an error: %s",err))}}function onCommitRoot(root,eventPriority){if(injectedHook&&typeof injectedHook.onCommitFiberRoot=="function")try{var didError=(root.current.flags&DidCapture)===DidCapture;if(enableProfilerTimer){var schedulerPriority;switch(eventPriority){case DiscreteEventPriority:schedulerPriority=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriority=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriority=NormalPriority;break;case IdleEventPriority:schedulerPriority=IdlePriority;break;default:schedulerPriority=NormalPriority;break}injectedHook.onCommitFiberRoot(rendererID,root,schedulerPriority,didError)}}catch(err){hasLoggedError||(hasLoggedError=!0,error("React instrumentation encountered an error: %s",err))}}function onPostCommitRoot(root){if(injectedHook&&typeof injectedHook.onPostCommitFiberRoot=="function")try{injectedHook.onPostCommitFiberRoot(rendererID,root)}catch(err){hasLoggedError||(hasLoggedError=!0,error("React instrumentation encountered an error: %s",err))}}function onCommitUnmount(fiber){if(injectedHook&&typeof injectedHook.onCommitFiberUnmount=="function")try{injectedHook.onCommitFiberUnmount(rendererID,fiber)}catch(err){hasLoggedError||(hasLoggedError=!0,error("React instrumentation encountered an error: %s",err))}}function setIsStrictModeForDevtools(newIsStrictMode){if(typeof unstable_yieldValue=="function"&&(unstable_setDisableYieldValue(newIsStrictMode),setSuppressWarning(newIsStrictMode)),injectedHook&&typeof injectedHook.setStrictMode=="function")try{injectedHook.setStrictMode(rendererID,newIsStrictMode)}catch(err){hasLoggedError||(hasLoggedError=!0,error("React instrumentation encountered an error: %s",err))}}function injectProfilingHooks(profilingHooks){injectedProfilingHooks=profilingHooks}function getLaneLabelMap(){{for(var map=new Map,lane=1,index2=0;index2<TotalLanes;index2++){var label=getLabelForLane(lane);map.set(lane,label),lane*=2}return map}}function markCommitStarted(lanes){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStarted=="function"&&injectedProfilingHooks.markCommitStarted(lanes)}function markCommitStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markCommitStopped=="function"&&injectedProfilingHooks.markCommitStopped()}function markComponentRenderStarted(fiber){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStarted=="function"&&injectedProfilingHooks.markComponentRenderStarted(fiber)}function markComponentRenderStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentRenderStopped=="function"&&injectedProfilingHooks.markComponentRenderStopped()}function markComponentPassiveEffectMountStarted(fiber){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted=="function"&&injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber)}function markComponentPassiveEffectMountStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped=="function"&&injectedProfilingHooks.markComponentPassiveEffectMountStopped()}function markComponentPassiveEffectUnmountStarted(fiber){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted=="function"&&injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber)}function markComponentPassiveEffectUnmountStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped=="function"&&injectedProfilingHooks.markComponentPassiveEffectUnmountStopped()}function markComponentLayoutEffectMountStarted(fiber){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted=="function"&&injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber)}function markComponentLayoutEffectMountStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped=="function"&&injectedProfilingHooks.markComponentLayoutEffectMountStopped()}function markComponentLayoutEffectUnmountStarted(fiber){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted=="function"&&injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber)}function markComponentLayoutEffectUnmountStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped=="function"&&injectedProfilingHooks.markComponentLayoutEffectUnmountStopped()}function markComponentErrored(fiber,thrownValue,lanes){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentErrored=="function"&&injectedProfilingHooks.markComponentErrored(fiber,thrownValue,lanes)}function markComponentSuspended(fiber,wakeable,lanes){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markComponentSuspended=="function"&&injectedProfilingHooks.markComponentSuspended(fiber,wakeable,lanes)}function markLayoutEffectsStarted(lanes){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStarted=="function"&&injectedProfilingHooks.markLayoutEffectsStarted(lanes)}function markLayoutEffectsStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markLayoutEffectsStopped=="function"&&injectedProfilingHooks.markLayoutEffectsStopped()}function markPassiveEffectsStarted(lanes){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStarted=="function"&&injectedProfilingHooks.markPassiveEffectsStarted(lanes)}function markPassiveEffectsStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markPassiveEffectsStopped=="function"&&injectedProfilingHooks.markPassiveEffectsStopped()}function markRenderStarted(lanes){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStarted=="function"&&injectedProfilingHooks.markRenderStarted(lanes)}function markRenderYielded(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderYielded=="function"&&injectedProfilingHooks.markRenderYielded()}function markRenderStopped(){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderStopped=="function"&&injectedProfilingHooks.markRenderStopped()}function markRenderScheduled(lane){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markRenderScheduled=="function"&&injectedProfilingHooks.markRenderScheduled(lane)}function markForceUpdateScheduled(fiber,lane){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markForceUpdateScheduled=="function"&&injectedProfilingHooks.markForceUpdateScheduled(fiber,lane)}function markStateUpdateScheduled(fiber,lane){injectedProfilingHooks!==null&&typeof injectedProfilingHooks.markStateUpdateScheduled=="function"&&injectedProfilingHooks.markStateUpdateScheduled(fiber,lane)}function is2(x2,y2){return x2===y2&&(x2!==0||1/x2===1/y2)||x2!==x2&&y2!==y2}var objectIs=typeof Object.is=="function"?Object.is:is2,syncQueue=null,includesLegacySyncCallbacks=!1,isFlushingSyncQueue=!1;function scheduleSyncCallback(callback){syncQueue===null?syncQueue=[callback]:syncQueue.push(callback)}function scheduleLegacySyncCallback(callback){includesLegacySyncCallbacks=!0,scheduleSyncCallback(callback)}function flushSyncCallbacksOnlyInLegacyMode(){includesLegacySyncCallbacks&&flushSyncCallbacks()}function flushSyncCallbacks(){if(!isFlushingSyncQueue&&syncQueue!==null){isFlushingSyncQueue=!0;var i2=0,previousUpdatePriority=getCurrentUpdatePriority();try{var isSync=!0,queue=syncQueue;for(setCurrentUpdatePriority(DiscreteEventPriority);i2<queue.length;i2++){var callback=queue[i2];do callback=callback(isSync);while(callback!==null)}syncQueue=null,includesLegacySyncCallbacks=!1}catch(error2){throw syncQueue!==null&&(syncQueue=syncQueue.slice(i2+1)),scheduleCallback(ImmediatePriority,flushSyncCallbacks),error2}finally{setCurrentUpdatePriority(previousUpdatePriority),isFlushingSyncQueue=!1}}return null}function isRootDehydrated(root){var currentState=root.current.memoizedState;return currentState.isDehydrated}var ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig,NoTransition=null;function requestCurrentTransition(){return ReactCurrentBatchConfig.transition}function shallowEqual(objA,objB){if(objectIs(objA,objB))return!0;if(typeof objA!="object"||objA===null||typeof objB!="object"||objB===null)return!1;var keysA=Object.keys(objA),keysB=Object.keys(objB);if(keysA.length!==keysB.length)return!1;for(var i2=0;i2<keysA.length;i2++){var currentKey=keysA[i2];if(!hasOwnProperty.call(objB,currentKey)||!objectIs(objA[currentKey],objB[currentKey]))return!1}return!0}function describeFiber(fiber){switch(fiber._debugOwner&&fiber._debugOwner.type,fiber._debugSource,fiber.tag){case HostComponent:return describeBuiltInComponentFrame(fiber.type);case LazyComponent:return describeBuiltInComponentFrame("Lazy");case SuspenseComponent:return describeBuiltInComponentFrame("Suspense");case SuspenseListComponent:return describeBuiltInComponentFrame("SuspenseList");case FunctionComponent:case IndeterminateComponent:case SimpleMemoComponent:return describeFunctionComponentFrame(fiber.type);case ForwardRef:return describeFunctionComponentFrame(fiber.type.render);case ClassComponent:return describeClassComponentFrame(fiber.type);default:return""}}function getStackByFiberInDevAndProd(workInProgress2){try{var info="",node=workInProgress2;do info+=describeFiber(node),node=node.return;while(node);return info}catch(x2){return`
Error generating stack: `+x2.message+`
`+x2.stack}}var ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame,current=null,isRendering=!1;function getCurrentFiberOwnerNameInDevOrNull(){{if(current===null)return null;var owner=current._debugOwner;if(owner!==null&&typeof owner<"u")return getComponentNameFromFiber(owner)}return null}function getCurrentFiberStackInDev(){return current===null?"":getStackByFiberInDevAndProd(current)}function resetCurrentFiber(){ReactDebugCurrentFrame$1.getCurrentStack=null,current=null,isRendering=!1}function setCurrentFiber(fiber){ReactDebugCurrentFrame$1.getCurrentStack=getCurrentFiberStackInDev,current=fiber,isRendering=!1}function setIsRendering(rendering){isRendering=rendering}var ReactStrictModeWarnings={recordUnsafeLifecycleWarnings:function(fiber,instance){},flushPendingUnsafeLifecycleWarnings:function(){},recordLegacyContextWarning:function(fiber,instance){},flushLegacyContextWarning:function(){},discardPendingWarnings:function(){}};{var findStrictRoot=function(fiber){for(var maybeStrictRoot=null,node=fiber;node!==null;)node.mode&StrictLegacyMode&&(maybeStrictRoot=node),node=node.return;return maybeStrictRoot},setToSortedString=function(set2){var array=[];return set2.forEach(function(value){array.push(value)}),array.sort().join(", ")},pendingComponentWillMountWarnings=[],pendingUNSAFE_ComponentWillMountWarnings=[],pendingComponentWillReceivePropsWarnings=[],pendingUNSAFE_ComponentWillReceivePropsWarnings=[],pendingComponentWillUpdateWarnings=[],pendingUNSAFE_ComponentWillUpdateWarnings=[],didWarnAboutUnsafeLifecycles=new Set;ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){didWarnAboutUnsafeLifecycles.has(fiber.type)||(typeof instance.componentWillMount=="function"&&instance.componentWillMount.__suppressDeprecationWarning!==!0&&pendingComponentWillMountWarnings.push(fiber),fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillMount=="function"&&pendingUNSAFE_ComponentWillMountWarnings.push(fiber),typeof instance.componentWillReceiveProps=="function"&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==!0&&pendingComponentWillReceivePropsWarnings.push(fiber),fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillReceiveProps=="function"&&pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber),typeof instance.componentWillUpdate=="function"&&instance.componentWillUpdate.__suppressDeprecationWarning!==!0&&pendingComponentWillUpdateWarnings.push(fiber),fiber.mode&StrictLegacyMode&&typeof instance.UNSAFE_componentWillUpdate=="function"&&pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber))},ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){var componentWillMountUniqueNames=new Set;pendingComponentWillMountWarnings.length>0&&(pendingComponentWillMountWarnings.forEach(function(fiber){componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||"Component"),didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingComponentWillMountWarnings=[]);var UNSAFE_componentWillMountUniqueNames=new Set;pendingUNSAFE_ComponentWillMountWarnings.length>0&&(pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber){UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||"Component"),didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingUNSAFE_ComponentWillMountWarnings=[]);var componentWillReceivePropsUniqueNames=new Set;pendingComponentWillReceivePropsWarnings.length>0&&(pendingComponentWillReceivePropsWarnings.forEach(function(fiber){componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||"Component"),didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingComponentWillReceivePropsWarnings=[]);var UNSAFE_componentWillReceivePropsUniqueNames=new Set;pendingUNSAFE_ComponentWillReceivePropsWarnings.length>0&&(pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber){UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||"Component"),didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingUNSAFE_ComponentWillReceivePropsWarnings=[]);var componentWillUpdateUniqueNames=new Set;pendingComponentWillUpdateWarnings.length>0&&(pendingComponentWillUpdateWarnings.forEach(function(fiber){componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||"Component"),didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingComponentWillUpdateWarnings=[]);var UNSAFE_componentWillUpdateUniqueNames=new Set;if(pendingUNSAFE_ComponentWillUpdateWarnings.length>0&&(pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber){UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||"Component"),didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingUNSAFE_ComponentWillUpdateWarnings=[]),UNSAFE_componentWillMountUniqueNames.size>0){var sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);error(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`,sortedNames)}if(UNSAFE_componentWillReceivePropsUniqueNames.size>0){var _sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);error(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`,_sortedNames)}if(UNSAFE_componentWillUpdateUniqueNames.size>0){var _sortedNames2=setToSortedString(UNSAFE_componentWillUpdateUniqueNames);error(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`,_sortedNames2)}if(componentWillMountUniqueNames.size>0){var _sortedNames3=setToSortedString(componentWillMountUniqueNames);warn(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,_sortedNames3)}if(componentWillReceivePropsUniqueNames.size>0){var _sortedNames4=setToSortedString(componentWillReceivePropsUniqueNames);warn(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,_sortedNames4)}if(componentWillUpdateUniqueNames.size>0){var _sortedNames5=setToSortedString(componentWillUpdateUniqueNames);warn(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`,_sortedNames5)}};var pendingLegacyContextWarning=new Map,didWarnAboutLegacyContext=new Set;ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=findStrictRoot(fiber);if(strictRoot===null){error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");return}if(!didWarnAboutLegacyContext.has(fiber.type)){var warningsForRoot=pendingLegacyContextWarning.get(strictRoot);(fiber.type.contextTypes!=null||fiber.type.childContextTypes!=null||instance!==null&&typeof instance.getChildContext=="function")&&(warningsForRoot===void 0&&(warningsForRoot=[],pendingLegacyContextWarning.set(strictRoot,warningsForRoot)),warningsForRoot.push(fiber))}},ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){if(fiberArray.length!==0){var firstFiber=fiberArray[0],uniqueNames=new Set;fiberArray.forEach(function(fiber){uniqueNames.add(getComponentNameFromFiber(fiber)||"Component"),didWarnAboutLegacyContext.add(fiber.type)});var sortedNames=setToSortedString(uniqueNames);try{setCurrentFiber(firstFiber),error(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`,sortedNames)}finally{resetCurrentFiber()}}})},ReactStrictModeWarnings.discardPendingWarnings=function(){pendingComponentWillMountWarnings=[],pendingUNSAFE_ComponentWillMountWarnings=[],pendingComponentWillReceivePropsWarnings=[],pendingUNSAFE_ComponentWillReceivePropsWarnings=[],pendingComponentWillUpdateWarnings=[],pendingUNSAFE_ComponentWillUpdateWarnings=[],pendingLegacyContextWarning=new Map}}function typeName(value){{var hasToStringTag=typeof Symbol=="function"&&Symbol.toStringTag,type=hasToStringTag&&value[Symbol.toStringTag]||value.constructor.name||"Object";return type}}function willCoercionThrow(value){try{return testStringCoercion(value),!1}catch{return!0}}function testStringCoercion(value){return""+value}function checkKeyStringCoercion(value){if(willCoercionThrow(value))return error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.",typeName(value)),testStringCoercion(value)}function checkPropStringCoercion(value,propName){if(willCoercionThrow(value))return error("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.",propName,typeName(value)),testStringCoercion(value)}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){var props=assign({},baseProps),defaultProps=Component.defaultProps;for(var propName in defaultProps)props[propName]===void 0&&(props[propName]=defaultProps[propName]);return props}return baseProps}var valueCursor=createCursor(null),rendererSigil;rendererSigil={};var currentlyRenderingFiber=null,lastContextDependency=null,lastFullyObservedContext=null,isDisallowedContextReadInDEV=!1;function resetContextDependencies(){currentlyRenderingFiber=null,lastContextDependency=null,lastFullyObservedContext=null,isDisallowedContextReadInDEV=!1}function enterDisallowedContextReadInDEV(){isDisallowedContextReadInDEV=!0}function exitDisallowedContextReadInDEV(){isDisallowedContextReadInDEV=!1}function pushProvider(providerFiber,context2,nextValue){isPrimaryRenderer?(push(valueCursor,context2._currentValue,providerFiber),context2._currentValue=nextValue,context2._currentRenderer!==void 0&&context2._currentRenderer!==null&&context2._currentRenderer!==rendererSigil&&error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."),context2._currentRenderer=rendererSigil):(push(valueCursor,context2._currentValue2,providerFiber),context2._currentValue2=nextValue,context2._currentRenderer2!==void 0&&context2._currentRenderer2!==null&&context2._currentRenderer2!==rendererSigil&&error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."),context2._currentRenderer2=rendererSigil)}function popProvider(context2,providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber),isPrimaryRenderer?context2._currentValue=currentValue:context2._currentValue2=currentValue}function scheduleContextWorkOnParentPath(parent,renderLanes2,propagationRoot){for(var node=parent;node!==null;){var alternate=node.alternate;if(isSubsetOfLanes(node.childLanes,renderLanes2)?alternate!==null&&!isSubsetOfLanes(alternate.childLanes,renderLanes2)&&(alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes2)):(node.childLanes=mergeLanes(node.childLanes,renderLanes2),alternate!==null&&(alternate.childLanes=mergeLanes(alternate.childLanes,renderLanes2))),node===propagationRoot)break;node=node.return}node!==propagationRoot&&error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.")}function propagateContextChange(workInProgress2,context2,renderLanes2){propagateContextChange_eager(workInProgress2,context2,renderLanes2)}function propagateContextChange_eager(workInProgress2,context2,renderLanes2){var fiber=workInProgress2.child;for(fiber!==null&&(fiber.return=workInProgress2);fiber!==null;){var nextFiber=void 0,list=fiber.dependencies;if(list!==null){nextFiber=fiber.child;for(var dependency=list.firstContext;dependency!==null;){if(dependency.context===context2){if(fiber.tag===ClassComponent){var lane=pickArbitraryLane(renderLanes2),update=createUpdate(NoTimestamp,lane);update.tag=ForceUpdate;var updateQueue=fiber.updateQueue;if(updateQueue!==null){var sharedQueue=updateQueue.shared,pending=sharedQueue.pending;pending===null?update.next=update:(update.next=pending.next,pending.next=update),sharedQueue.pending=update}}fiber.lanes=mergeLanes(fiber.lanes,renderLanes2);var alternate=fiber.alternate;alternate!==null&&(alternate.lanes=mergeLanes(alternate.lanes,renderLanes2)),scheduleContextWorkOnParentPath(fiber.return,renderLanes2,workInProgress2),list.lanes=mergeLanes(list.lanes,renderLanes2);break}dependency=dependency.next}}else if(fiber.tag===ContextProvider)nextFiber=fiber.type===workInProgress2.type?null:fiber.child;else if(fiber.tag===DehydratedFragment){var parentSuspense=fiber.return;if(parentSuspense===null)throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");parentSuspense.lanes=mergeLanes(parentSuspense.lanes,renderLanes2);var _alternate=parentSuspense.alternate;_alternate!==null&&(_alternate.lanes=mergeLanes(_alternate.lanes,renderLanes2)),scheduleContextWorkOnParentPath(parentSuspense,renderLanes2,workInProgress2),nextFiber=fiber.sibling}else nextFiber=fiber.child;if(nextFiber!==null)nextFiber.return=fiber;else for(nextFiber=fiber;nextFiber!==null;){if(nextFiber===workInProgress2){nextFiber=null;break}var sibling=nextFiber.sibling;if(sibling!==null){sibling.return=nextFiber.return,nextFiber=sibling;break}nextFiber=nextFiber.return}fiber=nextFiber}}function prepareToReadContext(workInProgress2,renderLanes2){currentlyRenderingFiber=workInProgress2,lastContextDependency=null,lastFullyObservedContext=null;var dependencies=workInProgress2.dependencies;if(dependencies!==null){var firstContext=dependencies.firstContext;firstContext!==null&&(includesSomeLane(dependencies.lanes,renderLanes2)&&markWorkInProgressReceivedUpdate(),dependencies.firstContext=null)}}function readContext(context2){isDisallowedContextReadInDEV&&error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");var value=isPrimaryRenderer?context2._currentValue:context2._currentValue2;if(lastFullyObservedContext!==context2){var contextItem={context:context2,memoizedValue:value,next:null};if(lastContextDependency===null){if(currentlyRenderingFiber===null)throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");lastContextDependency=contextItem,currentlyRenderingFiber.dependencies={lanes:NoLanes,firstContext:contextItem}}else lastContextDependency=lastContextDependency.next=contextItem}return value}var interleavedQueues=null;function pushInterleavedQueue(queue){interleavedQueues===null?interleavedQueues=[queue]:interleavedQueues.push(queue)}function enqueueInterleavedUpdates(){if(interleavedQueues!==null){for(var i2=0;i2<interleavedQueues.length;i2++){var queue=interleavedQueues[i2],lastInterleavedUpdate=queue.interleaved;if(lastInterleavedUpdate!==null){queue.interleaved=null;var firstInterleavedUpdate=lastInterleavedUpdate.next,lastPendingUpdate=queue.pending;if(lastPendingUpdate!==null){var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=firstInterleavedUpdate,lastInterleavedUpdate.next=firstPendingUpdate}queue.pending=lastInterleavedUpdate}}interleavedQueues=null}}var UpdateState=0,ReplaceState=1,ForceUpdate=2,CaptureUpdate=3,hasForceUpdate=!1,didWarnUpdateInsideUpdate,currentlyProcessingQueue;didWarnUpdateInsideUpdate=!1,currentlyProcessingQueue=null;function initializeUpdateQueue(fiber){var queue={baseState:fiber.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:NoLanes},effects:null};fiber.updateQueue=queue}function cloneUpdateQueue(current2,workInProgress2){var queue=workInProgress2.updateQueue,currentQueue=current2.updateQueue;if(queue===currentQueue){var clone={baseState:currentQueue.baseState,firstBaseUpdate:currentQueue.firstBaseUpdate,lastBaseUpdate:currentQueue.lastBaseUpdate,shared:currentQueue.shared,effects:currentQueue.effects};workInProgress2.updateQueue=clone}}function createUpdate(eventTime,lane){var update={eventTime,lane,tag:UpdateState,payload:null,callback:null,next:null};return update}function enqueueUpdate(fiber,update,lane){var updateQueue=fiber.updateQueue;if(updateQueue!==null){var sharedQueue=updateQueue.shared;if(isInterleavedUpdate(fiber)){var interleaved=sharedQueue.interleaved;interleaved===null?(update.next=update,pushInterleavedQueue(sharedQueue)):(update.next=interleaved.next,interleaved.next=update),sharedQueue.interleaved=update}else{var pending=sharedQueue.pending;pending===null?update.next=update:(update.next=pending.next,pending.next=update),sharedQueue.pending=update}currentlyProcessingQueue===sharedQueue&&!didWarnUpdateInsideUpdate&&(error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."),didWarnUpdateInsideUpdate=!0)}}function entangleTransitions(root,fiber,lane){var updateQueue=fiber.updateQueue;if(updateQueue!==null){var sharedQueue=updateQueue.shared;if(isTransitionLane(lane)){var queueLanes=sharedQueue.lanes;queueLanes=intersectLanes(queueLanes,root.pendingLanes);var newQueueLanes=mergeLanes(queueLanes,lane);sharedQueue.lanes=newQueueLanes,markRootEntangled(root,newQueueLanes)}}}function enqueueCapturedUpdate(workInProgress2,capturedUpdate){var queue=workInProgress2.updateQueue,current2=workInProgress2.alternate;if(current2!==null){var currentQueue=current2.updateQueue;if(queue===currentQueue){var newFirst=null,newLast=null,firstBaseUpdate=queue.firstBaseUpdate;if(firstBaseUpdate!==null){var update=firstBaseUpdate;do{var clone={eventTime:update.eventTime,lane:update.lane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLast===null?newFirst=newLast=clone:(newLast.next=clone,newLast=clone),update=update.next}while(update!==null);newLast===null?newFirst=newLast=capturedUpdate:(newLast.next=capturedUpdate,newLast=capturedUpdate)}else newFirst=newLast=capturedUpdate;queue={baseState:currentQueue.baseState,firstBaseUpdate:newFirst,lastBaseUpdate:newLast,shared:currentQueue.shared,effects:currentQueue.effects},workInProgress2.updateQueue=queue;return}}var lastBaseUpdate=queue.lastBaseUpdate;lastBaseUpdate===null?queue.firstBaseUpdate=capturedUpdate:lastBaseUpdate.next=capturedUpdate,queue.lastBaseUpdate=capturedUpdate}function getStateFromUpdate(workInProgress2,queue,update,prevState,nextProps,instance){switch(update.tag){case ReplaceState:{var payload=update.payload;if(typeof payload=="function"){enterDisallowedContextReadInDEV();var nextState=payload.call(instance,prevState,nextProps);{if(workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{payload.call(instance,prevState,nextProps)}finally{setIsStrictModeForDevtools(!1)}}exitDisallowedContextReadInDEV()}return nextState}return payload}case CaptureUpdate:workInProgress2.flags=workInProgress2.flags&~ShouldCapture|DidCapture;case UpdateState:{var _payload=update.payload,partialState;if(typeof _payload=="function"){enterDisallowedContextReadInDEV(),partialState=_payload.call(instance,prevState,nextProps);{if(workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{_payload.call(instance,prevState,nextProps)}finally{setIsStrictModeForDevtools(!1)}}exitDisallowedContextReadInDEV()}}else partialState=_payload;return partialState==null?prevState:assign({},prevState,partialState)}case ForceUpdate:return hasForceUpdate=!0,prevState}return prevState}function processUpdateQueue(workInProgress2,props,instance,renderLanes2){var queue=workInProgress2.updateQueue;hasForceUpdate=!1,currentlyProcessingQueue=queue.shared;var firstBaseUpdate=queue.firstBaseUpdate,lastBaseUpdate=queue.lastBaseUpdate,pendingQueue=queue.shared.pending;if(pendingQueue!==null){queue.shared.pending=null;var lastPendingUpdate=pendingQueue,firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=null,lastBaseUpdate===null?firstBaseUpdate=firstPendingUpdate:lastBaseUpdate.next=firstPendingUpdate,lastBaseUpdate=lastPendingUpdate;var current2=workInProgress2.alternate;if(current2!==null){var currentQueue=current2.updateQueue,currentLastBaseUpdate=currentQueue.lastBaseUpdate;currentLastBaseUpdate!==lastBaseUpdate&&(currentLastBaseUpdate===null?currentQueue.firstBaseUpdate=firstPendingUpdate:currentLastBaseUpdate.next=firstPendingUpdate,currentQueue.lastBaseUpdate=lastPendingUpdate)}}if(firstBaseUpdate!==null){var newState=queue.baseState,newLanes=NoLanes,newBaseState=null,newFirstBaseUpdate=null,newLastBaseUpdate=null,update=firstBaseUpdate;do{var updateLane=update.lane,updateEventTime=update.eventTime;if(isSubsetOfLanes(renderLanes2,updateLane)){if(newLastBaseUpdate!==null){var _clone={eventTime:updateEventTime,lane:NoLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLastBaseUpdate=newLastBaseUpdate.next=_clone}newState=getStateFromUpdate(workInProgress2,queue,update,newState,props,instance);var callback=update.callback;if(callback!==null&&update.lane!==NoLane){workInProgress2.flags|=Callback;var effects=queue.effects;effects===null?queue.effects=[update]:effects.push(update)}}else{var clone={eventTime:updateEventTime,lane:updateLane,tag:update.tag,payload:update.payload,callback:update.callback,next:null};newLastBaseUpdate===null?(newFirstBaseUpdate=newLastBaseUpdate=clone,newBaseState=newState):newLastBaseUpdate=newLastBaseUpdate.next=clone,newLanes=mergeLanes(newLanes,updateLane)}if(update=update.next,update===null){if(pendingQueue=queue.shared.pending,pendingQueue===null)break;var _lastPendingUpdate=pendingQueue,_firstPendingUpdate=_lastPendingUpdate.next;_lastPendingUpdate.next=null,update=_firstPendingUpdate,queue.lastBaseUpdate=_lastPendingUpdate,queue.shared.pending=null}}while(!0);newLastBaseUpdate===null&&(newBaseState=newState),queue.baseState=newBaseState,queue.firstBaseUpdate=newFirstBaseUpdate,queue.lastBaseUpdate=newLastBaseUpdate;var lastInterleaved=queue.shared.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do newLanes=mergeLanes(newLanes,interleaved.lane),interleaved=interleaved.next;while(interleaved!==lastInterleaved)}else firstBaseUpdate===null&&(queue.shared.lanes=NoLanes);markSkippedUpdateLanes(newLanes),workInProgress2.lanes=newLanes,workInProgress2.memoizedState=newState}currentlyProcessingQueue=null}function callCallback(callback,context2){if(typeof callback!="function")throw new Error("Invalid argument passed as callback. Expected a function. Instead "+("received: "+callback));callback.call(context2)}function resetHasForceUpdateBeforeProcessing(){hasForceUpdate=!1}function checkHasForceUpdateAfterProcessing(){return hasForceUpdate}function commitUpdateQueue(finishedWork,finishedQueue,instance){var effects=finishedQueue.effects;if(finishedQueue.effects=null,effects!==null)for(var i2=0;i2<effects.length;i2++){var effect=effects[i2],callback=effect.callback;callback!==null&&(effect.callback=null,callCallback(callback,instance))}}var fakeInternalInstance={},emptyRefsObject=new React.Component().refs,didWarnAboutStateAssignmentForComponent,didWarnAboutUninitializedState,didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate,didWarnAboutLegacyLifecyclesAndDerivedState,didWarnAboutUndefinedDerivedState,warnOnUndefinedDerivedState,warnOnInvalidCallback,didWarnAboutDirectlyAssigningPropsToState,didWarnAboutContextTypeAndContextTypes,didWarnAboutInvalidateContextType;{didWarnAboutStateAssignmentForComponent=new Set,didWarnAboutUninitializedState=new Set,didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set,didWarnAboutLegacyLifecyclesAndDerivedState=new Set,didWarnAboutDirectlyAssigningPropsToState=new Set,didWarnAboutUndefinedDerivedState=new Set,didWarnAboutContextTypeAndContextTypes=new Set,didWarnAboutInvalidateContextType=new Set;var didWarnOnInvalidCallback=new Set;warnOnInvalidCallback=function(callback,callerName){if(!(callback===null||typeof callback=="function")){var key=callerName+"_"+callback;didWarnOnInvalidCallback.has(key)||(didWarnOnInvalidCallback.add(key),error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.",callerName,callback))}},warnOnUndefinedDerivedState=function(type,partialState){if(partialState===void 0){var componentName=getComponentNameFromType(type)||"Component";didWarnAboutUndefinedDerivedState.has(componentName)||(didWarnAboutUndefinedDerivedState.add(componentName),error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",componentName))}},Object.defineProperty(fakeInternalInstance,"_processChildContext",{enumerable:!1,value:function(){throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).")}}),Object.freeze(fakeInternalInstance)}function applyDerivedStateFromProps(workInProgress2,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress2.memoizedState,partialState=getDerivedStateFromProps(nextProps,prevState);{if(workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{partialState=getDerivedStateFromProps(nextProps,prevState)}finally{setIsStrictModeForDevtools(!1)}}warnOnUndefinedDerivedState(ctor,partialState)}var memoizedState=partialState==null?prevState:assign({},prevState,partialState);if(workInProgress2.memoizedState=memoizedState,workInProgress2.lanes===NoLanes){var updateQueue=workInProgress2.updateQueue;updateQueue.baseState=memoizedState}}var classComponentUpdater={isMounted,enqueueSetState:function(inst,payload,callback){var fiber=get(inst),eventTime=requestEventTime(),lane=requestUpdateLane(fiber),update=createUpdate(eventTime,lane);update.payload=payload,callback!=null&&(warnOnInvalidCallback(callback,"setState"),update.callback=callback),enqueueUpdate(fiber,update);var root=scheduleUpdateOnFiber(fiber,lane,eventTime);root!==null&&entangleTransitions(root,fiber,lane),markStateUpdateScheduled(fiber,lane)},enqueueReplaceState:function(inst,payload,callback){var fiber=get(inst),eventTime=requestEventTime(),lane=requestUpdateLane(fiber),update=createUpdate(eventTime,lane);update.tag=ReplaceState,update.payload=payload,callback!=null&&(warnOnInvalidCallback(callback,"replaceState"),update.callback=callback),enqueueUpdate(fiber,update);var root=scheduleUpdateOnFiber(fiber,lane,eventTime);root!==null&&entangleTransitions(root,fiber,lane),markStateUpdateScheduled(fiber,lane)},enqueueForceUpdate:function(inst,callback){var fiber=get(inst),eventTime=requestEventTime(),lane=requestUpdateLane(fiber),update=createUpdate(eventTime,lane);update.tag=ForceUpdate,callback!=null&&(warnOnInvalidCallback(callback,"forceUpdate"),update.callback=callback),enqueueUpdate(fiber,update);var root=scheduleUpdateOnFiber(fiber,lane,eventTime);root!==null&&entangleTransitions(root,fiber,lane),markForceUpdateScheduled(fiber,lane)}};function checkShouldComponentUpdate(workInProgress2,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress2.stateNode;if(typeof instance.shouldComponentUpdate=="function"){var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext);{if(workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{shouldUpdate=instance.shouldComponentUpdate(newProps,newState,nextContext)}finally{setIsStrictModeForDevtools(!1)}}shouldUpdate===void 0&&error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",getComponentNameFromType(ctor)||"Component")}return shouldUpdate}return ctor.prototype&&ctor.prototype.isPureReactComponent?!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState):!0}function checkClassInstance(workInProgress2,ctor,newProps){var instance=workInProgress2.stateNode;{var name=getComponentNameFromType(ctor)||"Component",renderPresent=instance.render;renderPresent||(ctor.prototype&&typeof ctor.prototype.render=="function"?error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?",name):error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.",name)),instance.getInitialState&&!instance.getInitialState.isReactClassApproved&&!instance.state&&error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",name),instance.getDefaultProps&&!instance.getDefaultProps.isReactClassApproved&&error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",name),instance.propTypes&&error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.",name),instance.contextType&&error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.",name),instance.contextTypes&&error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.",name),ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)&&(didWarnAboutContextTypeAndContextTypes.add(ctor),error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.",name)),typeof instance.componentShouldUpdate=="function"&&error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",name),ctor.prototype&&ctor.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate<"u"&&error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",getComponentNameFromType(ctor)||"A pure component"),typeof instance.componentDidUnmount=="function"&&error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",name),typeof instance.componentDidReceiveProps=="function"&&error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",name),typeof instance.componentWillRecieveProps=="function"&&error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",name),typeof instance.UNSAFE_componentWillRecieveProps=="function"&&error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",name);var hasMutatedProps=instance.props!==newProps;instance.props!==void 0&&hasMutatedProps&&error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",name,name),instance.defaultProps&&error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",name,name),typeof instance.getSnapshotBeforeUpdate=="function"&&typeof instance.componentDidUpdate!="function"&&!didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)&&(didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor),error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",getComponentNameFromType(ctor))),typeof instance.getDerivedStateFromProps=="function"&&error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",name),typeof instance.getDerivedStateFromError=="function"&&error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",name),typeof ctor.getSnapshotBeforeUpdate=="function"&&error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",name);var _state=instance.state;_state&&(typeof _state!="object"||isArray(_state))&&error("%s.state: must be set to an object or null",name),typeof instance.getChildContext=="function"&&typeof ctor.childContextTypes!="object"&&error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",name)}}function adoptClassInstance(workInProgress2,instance){instance.updater=classComponentUpdater,workInProgress2.stateNode=instance,set(instance,workInProgress2),instance._reactInternalInstance=fakeInternalInstance}function constructClassInstance(workInProgress2,ctor,props){var isLegacyContextConsumer=!1,unmaskedContext=emptyContextObject,context2=emptyContextObject,contextType=ctor.contextType;if("contextType"in ctor){var isValid=contextType===null||contextType!==void 0&&contextType.$$typeof===REACT_CONTEXT_TYPE&&contextType._context===void 0;if(!isValid&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum="";contextType===void 0?addendum=" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.":typeof contextType!="object"?addendum=" However, it is set to a "+typeof contextType+".":contextType.$$typeof===REACT_PROVIDER_TYPE?addendum=" Did you accidentally pass the Context.Provider instead?":contextType._context!==void 0?addendum=" Did you accidentally pass the Context.Consumer instead?":addendum=" However, it is set to an object with keys {"+Object.keys(contextType).join(", ")+"}.",error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",getComponentNameFromType(ctor)||"Component",addendum)}}if(typeof contextType=="object"&&contextType!==null)context2=readContext(contextType);else{unmaskedContext=getUnmaskedContext(workInProgress2,ctor,!0);var contextTypes=ctor.contextTypes;isLegacyContextConsumer=contextTypes!=null,context2=isLegacyContextConsumer?getMaskedContext(workInProgress2,unmaskedContext):emptyContextObject}var instance=new ctor(props,context2);if(workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{instance=new ctor(props,context2)}finally{setIsStrictModeForDevtools(!1)}}var state=workInProgress2.memoizedState=instance.state!==null&&instance.state!==void 0?instance.state:null;adoptClassInstance(workInProgress2,instance);{if(typeof ctor.getDerivedStateFromProps=="function"&&state===null){var componentName=getComponentNameFromType(ctor)||"Component";didWarnAboutUninitializedState.has(componentName)||(didWarnAboutUninitializedState.add(componentName),error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",componentName,instance.state===null?"null":"undefined",componentName))}if(typeof ctor.getDerivedStateFromProps=="function"||typeof instance.getSnapshotBeforeUpdate=="function"){var foundWillMountName=null,foundWillReceivePropsName=null,foundWillUpdateName=null;if(typeof instance.componentWillMount=="function"&&instance.componentWillMount.__suppressDeprecationWarning!==!0?foundWillMountName="componentWillMount":typeof instance.UNSAFE_componentWillMount=="function"&&(foundWillMountName="UNSAFE_componentWillMount"),typeof instance.componentWillReceiveProps=="function"&&instance.componentWillReceiveProps.__suppressDeprecationWarning!==!0?foundWillReceivePropsName="componentWillReceiveProps":typeof instance.UNSAFE_componentWillReceiveProps=="function"&&(foundWillReceivePropsName="UNSAFE_componentWillReceiveProps"),typeof instance.componentWillUpdate=="function"&&instance.componentWillUpdate.__suppressDeprecationWarning!==!0?foundWillUpdateName="componentWillUpdate":typeof instance.UNSAFE_componentWillUpdate=="function"&&(foundWillUpdateName="UNSAFE_componentWillUpdate"),foundWillMountName!==null||foundWillReceivePropsName!==null||foundWillUpdateName!==null){var _componentName=getComponentNameFromType(ctor)||"Component",newApiName=typeof ctor.getDerivedStateFromProps=="function"?"getDerivedStateFromProps()":"getSnapshotBeforeUpdate()";didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)||(didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName),error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`,_componentName,newApiName,foundWillMountName!==null?`
  `+foundWillMountName:"",foundWillReceivePropsName!==null?`
  `+foundWillReceivePropsName:"",foundWillUpdateName!==null?`
  `+foundWillUpdateName:""))}}}return isLegacyContextConsumer&&cacheContext(workInProgress2,unmaskedContext,context2),instance}function callComponentWillMount(workInProgress2,instance){var oldState=instance.state;typeof instance.componentWillMount=="function"&&instance.componentWillMount(),typeof instance.UNSAFE_componentWillMount=="function"&&instance.UNSAFE_componentWillMount(),oldState!==instance.state&&(error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",getComponentNameFromFiber(workInProgress2)||"Component"),classComponentUpdater.enqueueReplaceState(instance,instance.state,null))}function callComponentWillReceiveProps(workInProgress2,instance,newProps,nextContext){var oldState=instance.state;if(typeof instance.componentWillReceiveProps=="function"&&instance.componentWillReceiveProps(newProps,nextContext),typeof instance.UNSAFE_componentWillReceiveProps=="function"&&instance.UNSAFE_componentWillReceiveProps(newProps,nextContext),instance.state!==oldState){{var componentName=getComponentNameFromFiber(workInProgress2)||"Component";didWarnAboutStateAssignmentForComponent.has(componentName)||(didWarnAboutStateAssignmentForComponent.add(componentName),error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",componentName))}classComponentUpdater.enqueueReplaceState(instance,instance.state,null)}}function mountClassInstance(workInProgress2,ctor,newProps,renderLanes2){checkClassInstance(workInProgress2,ctor,newProps);var instance=workInProgress2.stateNode;instance.props=newProps,instance.state=workInProgress2.memoizedState,instance.refs=emptyRefsObject,initializeUpdateQueue(workInProgress2);var contextType=ctor.contextType;if(typeof contextType=="object"&&contextType!==null)instance.context=readContext(contextType);else{var unmaskedContext=getUnmaskedContext(workInProgress2,ctor,!0);instance.context=getMaskedContext(workInProgress2,unmaskedContext)}{if(instance.state===newProps){var componentName=getComponentNameFromType(ctor)||"Component";didWarnAboutDirectlyAssigningPropsToState.has(componentName)||(didWarnAboutDirectlyAssigningPropsToState.add(componentName),error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",componentName))}workInProgress2.mode&StrictLegacyMode&&ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2,instance),ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2,instance)}instance.state=workInProgress2.memoizedState;var getDerivedStateFromProps=ctor.getDerivedStateFromProps;if(typeof getDerivedStateFromProps=="function"&&(applyDerivedStateFromProps(workInProgress2,ctor,getDerivedStateFromProps,newProps),instance.state=workInProgress2.memoizedState),typeof ctor.getDerivedStateFromProps!="function"&&typeof instance.getSnapshotBeforeUpdate!="function"&&(typeof instance.UNSAFE_componentWillMount=="function"||typeof instance.componentWillMount=="function")&&(callComponentWillMount(workInProgress2,instance),processUpdateQueue(workInProgress2,newProps,instance,renderLanes2),instance.state=workInProgress2.memoizedState),typeof instance.componentDidMount=="function"){var fiberFlags=Update;fiberFlags|=LayoutStatic,(workInProgress2.mode&StrictEffectsMode)!==NoMode&&(fiberFlags|=MountLayoutDev),workInProgress2.flags|=fiberFlags}}function resumeMountClassInstance(workInProgress2,ctor,newProps,renderLanes2){var instance=workInProgress2.stateNode,oldProps=workInProgress2.memoizedProps;instance.props=oldProps;var oldContext=instance.context,contextType=ctor.contextType,nextContext=emptyContextObject;if(typeof contextType=="object"&&contextType!==null)nextContext=readContext(contextType);else{var nextLegacyUnmaskedContext=getUnmaskedContext(workInProgress2,ctor,!0);nextContext=getMaskedContext(workInProgress2,nextLegacyUnmaskedContext)}var getDerivedStateFromProps=ctor.getDerivedStateFromProps,hasNewLifecycles=typeof getDerivedStateFromProps=="function"||typeof instance.getSnapshotBeforeUpdate=="function";!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps=="function"||typeof instance.componentWillReceiveProps=="function")&&(oldProps!==newProps||oldContext!==nextContext)&&callComponentWillReceiveProps(workInProgress2,instance,newProps,nextContext),resetHasForceUpdateBeforeProcessing();var oldState=workInProgress2.memoizedState,newState=instance.state=oldState;if(processUpdateQueue(workInProgress2,newProps,instance,renderLanes2),newState=workInProgress2.memoizedState,oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()){if(typeof instance.componentDidMount=="function"){var fiberFlags=Update;fiberFlags|=LayoutStatic,(workInProgress2.mode&StrictEffectsMode)!==NoMode&&(fiberFlags|=MountLayoutDev),workInProgress2.flags|=fiberFlags}return!1}typeof getDerivedStateFromProps=="function"&&(applyDerivedStateFromProps(workInProgress2,ctor,getDerivedStateFromProps,newProps),newState=workInProgress2.memoizedState);var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress2,ctor,oldProps,newProps,oldState,newState,nextContext);if(shouldUpdate){if(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillMount=="function"||typeof instance.componentWillMount=="function")&&(typeof instance.componentWillMount=="function"&&instance.componentWillMount(),typeof instance.UNSAFE_componentWillMount=="function"&&instance.UNSAFE_componentWillMount()),typeof instance.componentDidMount=="function"){var _fiberFlags=Update;_fiberFlags|=LayoutStatic,(workInProgress2.mode&StrictEffectsMode)!==NoMode&&(_fiberFlags|=MountLayoutDev),workInProgress2.flags|=_fiberFlags}}else{if(typeof instance.componentDidMount=="function"){var _fiberFlags2=Update;_fiberFlags2|=LayoutStatic,(workInProgress2.mode&StrictEffectsMode)!==NoMode&&(_fiberFlags2|=MountLayoutDev),workInProgress2.flags|=_fiberFlags2}workInProgress2.memoizedProps=newProps,workInProgress2.memoizedState=newState}return instance.props=newProps,instance.state=newState,instance.context=nextContext,shouldUpdate}function updateClassInstance(current2,workInProgress2,ctor,newProps,renderLanes2){var instance=workInProgress2.stateNode;cloneUpdateQueue(current2,workInProgress2);var unresolvedOldProps=workInProgress2.memoizedProps,oldProps=workInProgress2.type===workInProgress2.elementType?unresolvedOldProps:resolveDefaultProps(workInProgress2.type,unresolvedOldProps);instance.props=oldProps;var unresolvedNewProps=workInProgress2.pendingProps,oldContext=instance.context,contextType=ctor.contextType,nextContext=emptyContextObject;if(typeof contextType=="object"&&contextType!==null)nextContext=readContext(contextType);else{var nextUnmaskedContext=getUnmaskedContext(workInProgress2,ctor,!0);nextContext=getMaskedContext(workInProgress2,nextUnmaskedContext)}var getDerivedStateFromProps=ctor.getDerivedStateFromProps,hasNewLifecycles=typeof getDerivedStateFromProps=="function"||typeof instance.getSnapshotBeforeUpdate=="function";!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillReceiveProps=="function"||typeof instance.componentWillReceiveProps=="function")&&(unresolvedOldProps!==unresolvedNewProps||oldContext!==nextContext)&&callComponentWillReceiveProps(workInProgress2,instance,newProps,nextContext),resetHasForceUpdateBeforeProcessing();var oldState=workInProgress2.memoizedState,newState=instance.state=oldState;if(processUpdateQueue(workInProgress2,newProps,instance,renderLanes2),newState=workInProgress2.memoizedState,unresolvedOldProps===unresolvedNewProps&&oldState===newState&&!hasContextChanged()&&!checkHasForceUpdateAfterProcessing()&&!enableLazyContextPropagation)return typeof instance.componentDidUpdate=="function"&&(unresolvedOldProps!==current2.memoizedProps||oldState!==current2.memoizedState)&&(workInProgress2.flags|=Update),typeof instance.getSnapshotBeforeUpdate=="function"&&(unresolvedOldProps!==current2.memoizedProps||oldState!==current2.memoizedState)&&(workInProgress2.flags|=Snapshot),!1;typeof getDerivedStateFromProps=="function"&&(applyDerivedStateFromProps(workInProgress2,ctor,getDerivedStateFromProps,newProps),newState=workInProgress2.memoizedState);var shouldUpdate=checkHasForceUpdateAfterProcessing()||checkShouldComponentUpdate(workInProgress2,ctor,oldProps,newProps,oldState,newState,nextContext)||enableLazyContextPropagation;return shouldUpdate?(!hasNewLifecycles&&(typeof instance.UNSAFE_componentWillUpdate=="function"||typeof instance.componentWillUpdate=="function")&&(typeof instance.componentWillUpdate=="function"&&instance.componentWillUpdate(newProps,newState,nextContext),typeof instance.UNSAFE_componentWillUpdate=="function"&&instance.UNSAFE_componentWillUpdate(newProps,newState,nextContext)),typeof instance.componentDidUpdate=="function"&&(workInProgress2.flags|=Update),typeof instance.getSnapshotBeforeUpdate=="function"&&(workInProgress2.flags|=Snapshot)):(typeof instance.componentDidUpdate=="function"&&(unresolvedOldProps!==current2.memoizedProps||oldState!==current2.memoizedState)&&(workInProgress2.flags|=Update),typeof instance.getSnapshotBeforeUpdate=="function"&&(unresolvedOldProps!==current2.memoizedProps||oldState!==current2.memoizedState)&&(workInProgress2.flags|=Snapshot),workInProgress2.memoizedProps=newProps,workInProgress2.memoizedState=newState),instance.props=newProps,instance.state=newState,instance.context=nextContext,shouldUpdate}var forkStack=[],forkStackIndex=0,treeForkProvider=null,treeForkCount=0,idStack=[],idStackIndex=0,treeContextProvider=null,treeContextId=1,treeContextOverflow="";function isForkedChild(workInProgress2){return warnIfNotHydrating(),(workInProgress2.flags&Forked)!==NoFlags}function getForksAtLevel(workInProgress2){return warnIfNotHydrating(),treeForkCount}function getTreeId(){var overflow=treeContextOverflow,idWithLeadingBit=treeContextId,id2=idWithLeadingBit&~getLeadingBit(idWithLeadingBit);return id2.toString(32)+overflow}function pushTreeFork(workInProgress2,totalChildren){warnIfNotHydrating(),forkStack[forkStackIndex++]=treeForkCount,forkStack[forkStackIndex++]=treeForkProvider,treeForkProvider=workInProgress2,treeForkCount=totalChildren}function pushTreeId(workInProgress2,totalChildren,index2){warnIfNotHydrating(),idStack[idStackIndex++]=treeContextId,idStack[idStackIndex++]=treeContextOverflow,idStack[idStackIndex++]=treeContextProvider,treeContextProvider=workInProgress2;var baseIdWithLeadingBit=treeContextId,baseOverflow=treeContextOverflow,baseLength=getBitLength(baseIdWithLeadingBit)-1,baseId=baseIdWithLeadingBit&~(1<<baseLength),slot=index2+1,length=getBitLength(totalChildren)+baseLength;if(length>30){var numberOfOverflowBits=baseLength-baseLength%5,newOverflowBits=(1<<numberOfOverflowBits)-1,newOverflow=(baseId&newOverflowBits).toString(32),restOfBaseId=baseId>>numberOfOverflowBits,restOfBaseLength=baseLength-numberOfOverflowBits,restOfLength=getBitLength(totalChildren)+restOfBaseLength,restOfNewBits=slot<<restOfBaseLength,id2=restOfNewBits|restOfBaseId,overflow=newOverflow+baseOverflow;treeContextId=1<<restOfLength|id2,treeContextOverflow=overflow}else{var newBits=slot<<baseLength,_id2=newBits|baseId,_overflow=baseOverflow;treeContextId=1<<length|_id2,treeContextOverflow=_overflow}}function pushMaterializedTreeId(workInProgress2){warnIfNotHydrating();var returnFiber=workInProgress2.return;if(returnFiber!==null){var numberOfForks=1,slotIndex=0;pushTreeFork(workInProgress2,numberOfForks),pushTreeId(workInProgress2,numberOfForks,slotIndex)}}function getBitLength(number2){return 32-clz32(number2)}function getLeadingBit(id2){return 1<<getBitLength(id2)-1}function popTreeContext(workInProgress2){for(;workInProgress2===treeForkProvider;)treeForkProvider=forkStack[--forkStackIndex],forkStack[forkStackIndex]=null,treeForkCount=forkStack[--forkStackIndex],forkStack[forkStackIndex]=null;for(;workInProgress2===treeContextProvider;)treeContextProvider=idStack[--idStackIndex],idStack[idStackIndex]=null,treeContextOverflow=idStack[--idStackIndex],idStack[idStackIndex]=null,treeContextId=idStack[--idStackIndex],idStack[idStackIndex]=null}function getSuspendedTreeContext(){return warnIfNotHydrating(),treeContextProvider!==null?{id:treeContextId,overflow:treeContextOverflow}:null}function restoreSuspendedTreeContext(workInProgress2,suspendedContext){warnIfNotHydrating(),idStack[idStackIndex++]=treeContextId,idStack[idStackIndex++]=treeContextOverflow,idStack[idStackIndex++]=treeContextProvider,treeContextId=suspendedContext.id,treeContextOverflow=suspendedContext.overflow,treeContextProvider=workInProgress2}function warnIfNotHydrating(){getIsHydrating()||error("Expected to be hydrating. This is a bug in React. Please file an issue.")}var hydrationParentFiber=null,nextHydratableInstance=null,isHydrating=!1,didSuspend=!1,hydrationErrors=null;function warnIfHydrating(){isHydrating&&error("We should not be hydrating here. This is a bug in React. Please file a bug.")}function markDidSuspendWhileHydratingDEV(){didSuspend=!0}function enterHydrationState(fiber){if(!supportsHydration)return!1;var parentInstance=fiber.stateNode.containerInfo;return nextHydratableInstance=getFirstHydratableChildWithinContainer(parentInstance),hydrationParentFiber=fiber,isHydrating=!0,hydrationErrors=null,didSuspend=!1,!0}function reenterHydrationStateFromDehydratedSuspenseInstance(fiber,suspenseInstance,treeContext){return supportsHydration?(nextHydratableInstance=getFirstHydratableChildWithinSuspenseInstance(suspenseInstance),hydrationParentFiber=fiber,isHydrating=!0,hydrationErrors=null,didSuspend=!1,treeContext!==null&&restoreSuspendedTreeContext(fiber,treeContext),!0):!1}function warnUnhydratedInstance(returnFiber,instance){switch(returnFiber.tag){case HostRoot:didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo,instance);break;case HostComponent:didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance);break;case SuspenseComponent:var suspenseState=returnFiber.memoizedState;suspenseState.dehydrated!==null&&didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated,instance);break}}function deleteHydratableInstance(returnFiber,instance){warnUnhydratedInstance(returnFiber,instance);var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance,childToDelete.return=returnFiber;var deletions=returnFiber.deletions;deletions===null?(returnFiber.deletions=[childToDelete],returnFiber.flags|=ChildDeletion):deletions.push(childToDelete)}function warnNonhydratedInstance(returnFiber,fiber){{if(didSuspend)return;switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type,props=fiber.pendingProps;didNotFindHydratableInstanceWithinContainer(parentContainer,type,props);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableTextInstanceWithinContainer(parentContainer,text);break;case SuspenseComponent:didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer);break}break}case HostComponent:{var parentType=returnFiber.type,parentProps=returnFiber.memoizedProps,parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:var _type=fiber.type,_props=fiber.pendingProps;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props);break;case HostText:var _text=fiber.pendingProps;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text);break;case SuspenseComponent:didNotFindHydratableSuspenseInstance(parentType,parentProps,parentInstance);break}break}case SuspenseComponent:{var suspenseState=returnFiber.memoizedState,_parentInstance=suspenseState.dehydrated;if(_parentInstance!==null)switch(fiber.tag){case HostComponent:var _type2=fiber.type,_props2=fiber.pendingProps;didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance,_type2,_props2);break;case HostText:var _text2=fiber.pendingProps;didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance,_text2);break;case SuspenseComponent:didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(_parentInstance);break}break}default:return}}}function insertNonHydratedInstance(returnFiber,fiber){fiber.flags=fiber.flags&~Hydrating|Placement,warnNonhydratedInstance(returnFiber,fiber)}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type,props=fiber.pendingProps,instance=canHydrateInstance(nextInstance,type,props);return instance!==null?(fiber.stateNode=instance,hydrationParentFiber=fiber,nextHydratableInstance=getFirstHydratableChild(instance),!0):!1}case HostText:{var text=fiber.pendingProps,textInstance=canHydrateTextInstance(nextInstance,text);return textInstance!==null?(fiber.stateNode=textInstance,hydrationParentFiber=fiber,nextHydratableInstance=null,!0):!1}case SuspenseComponent:{{var suspenseInstance=canHydrateSuspenseInstance(nextInstance);if(suspenseInstance!==null){var suspenseState={dehydrated:suspenseInstance,treeContext:getSuspendedTreeContext(),retryLane:OffscreenLane};fiber.memoizedState=suspenseState;var dehydratedFragment=createFiberFromDehydratedFragment(suspenseInstance);return dehydratedFragment.return=fiber,fiber.child=dehydratedFragment,hydrationParentFiber=fiber,nextHydratableInstance=null,!0}}return!1}default:return!1}}function shouldClientRenderOnMismatch(fiber){return(fiber.mode&ConcurrentMode)!==NoMode&&(fiber.flags&DidCapture)===NoFlags}function throwOnHydrationMismatch(fiber){throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.")}function tryToClaimNextHydratableInstance(fiber){if(isHydrating){var nextInstance=nextHydratableInstance;if(!nextInstance){shouldClientRenderOnMismatch(fiber)&&(warnNonhydratedInstance(hydrationParentFiber,fiber),throwOnHydrationMismatch()),insertNonHydratedInstance(hydrationParentFiber,fiber),isHydrating=!1,hydrationParentFiber=fiber;return}var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){shouldClientRenderOnMismatch(fiber)&&(warnNonhydratedInstance(hydrationParentFiber,fiber),throwOnHydrationMismatch()),nextInstance=getNextHydratableSibling(firstAttemptedInstance);var prevHydrationParentFiber=hydrationParentFiber;if(!nextInstance||!tryHydrate(fiber,nextInstance)){insertNonHydratedInstance(hydrationParentFiber,fiber),isHydrating=!1,hydrationParentFiber=fiber;return}deleteHydratableInstance(prevHydrationParentFiber,firstAttemptedInstance)}}}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){if(!supportsHydration)throw new Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");var instance=fiber.stateNode,shouldWarnIfMismatchDev=!didSuspend,updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber,shouldWarnIfMismatchDev);return fiber.updateQueue=updatePayload,updatePayload!==null}function prepareToHydrateHostTextInstance(fiber){if(!supportsHydration)throw new Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");var textInstance=fiber.stateNode,textContent=fiber.memoizedProps,shouldWarnIfMismatchDev=!didSuspend,shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber,shouldWarnIfMismatchDev);if(shouldUpdate){var returnFiber=hydrationParentFiber;if(returnFiber!==null){var isConcurrentMode=(returnFiber.mode&ConcurrentMode)!==NoMode;switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent,isConcurrentMode);break}case HostComponent:{var parentType=returnFiber.type,parentProps=returnFiber.memoizedProps,parentInstance=returnFiber.stateNode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent,isConcurrentMode);break}}}}return shouldUpdate}function prepareToHydrateHostSuspenseInstance(fiber){if(!supportsHydration)throw new Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");var suspenseState=fiber.memoizedState,suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance)throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");hydrateSuspenseInstance(suspenseInstance,fiber)}function skipPastDehydratedSuspenseInstance(fiber){if(!supportsHydration)throw new Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");var suspenseState=fiber.memoizedState,suspenseInstance=suspenseState!==null?suspenseState.dehydrated:null;if(!suspenseInstance)throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance)}function popToNextHostParent(fiber){for(var parent=fiber.return;parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot&&parent.tag!==SuspenseComponent;)parent=parent.return;hydrationParentFiber=parent}function popHydrationState(fiber){if(!supportsHydration||fiber!==hydrationParentFiber)return!1;if(!isHydrating)return popToNextHostParent(fiber),isHydrating=!0,!1;if(fiber.tag!==HostRoot&&(fiber.tag!==HostComponent||shouldDeleteUnhydratedTailInstances(fiber.type)&&!shouldSetTextContent(fiber.type,fiber.memoizedProps))){var nextInstance=nextHydratableInstance;if(nextInstance)if(shouldClientRenderOnMismatch(fiber))warnIfUnhydratedTailNodes(fiber),throwOnHydrationMismatch();else for(;nextInstance;)deleteHydratableInstance(fiber,nextInstance),nextInstance=getNextHydratableSibling(nextInstance)}return popToNextHostParent(fiber),fiber.tag===SuspenseComponent?nextHydratableInstance=skipPastDehydratedSuspenseInstance(fiber):nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null,!0}function hasUnhydratedTailNodes(){return isHydrating&&nextHydratableInstance!==null}function warnIfUnhydratedTailNodes(fiber){for(var nextInstance=nextHydratableInstance;nextInstance;)warnUnhydratedInstance(fiber,nextInstance),nextInstance=getNextHydratableSibling(nextInstance)}function resetHydrationState(){supportsHydration&&(hydrationParentFiber=null,nextHydratableInstance=null,isHydrating=!1,didSuspend=!1)}function upgradeHydrationErrorsToRecoverable(){hydrationErrors!==null&&(queueRecoverableErrors(hydrationErrors),hydrationErrors=null)}function getIsHydrating(){return isHydrating}function queueHydrationError(error2){hydrationErrors===null?hydrationErrors=[error2]:hydrationErrors.push(error2)}var didWarnAboutMaps,didWarnAboutGenerators,didWarnAboutStringRefs,ownerHasKeyUseWarning,ownerHasFunctionTypeWarning,warnForMissingKey=function(child,returnFiber){};didWarnAboutMaps=!1,didWarnAboutGenerators=!1,didWarnAboutStringRefs={},ownerHasKeyUseWarning={},ownerHasFunctionTypeWarning={},warnForMissingKey=function(child,returnFiber){if(!(child===null||typeof child!="object")&&!(!child._store||child._store.validated||child.key!=null)){if(typeof child._store!="object")throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");child._store.validated=!0;var componentName=getComponentNameFromFiber(returnFiber)||"Component";ownerHasKeyUseWarning[componentName]||(ownerHasKeyUseWarning[componentName]=!0,error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'))}};function coerceRef(returnFiber,current2,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!="function"&&typeof mixedRef!="object"){if((returnFiber.mode&StrictLegacyMode||warnAboutStringRefs)&&!(element._owner&&element._self&&element._owner.stateNode!==element._self)){var componentName=getComponentNameFromFiber(returnFiber)||"Component";didWarnAboutStringRefs[componentName]||(error('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',mixedRef),didWarnAboutStringRefs[componentName]=!0)}if(element._owner){var owner=element._owner,inst;if(owner){var ownerFiber=owner;if(ownerFiber.tag!==ClassComponent)throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");inst=ownerFiber.stateNode}if(!inst)throw new Error("Missing owner for string ref "+mixedRef+". This error is likely caused by a bug in React. Please file an issue.");var resolvedInst=inst;checkPropStringCoercion(mixedRef,"ref");var stringRef=""+mixedRef;if(current2!==null&&current2.ref!==null&&typeof current2.ref=="function"&&current2.ref._stringRef===stringRef)return current2.ref;var ref=function(value){var refs=resolvedInst.refs;refs===emptyRefsObject&&(refs=resolvedInst.refs={}),value===null?delete refs[stringRef]:refs[stringRef]=value};return ref._stringRef=stringRef,ref}else{if(typeof mixedRef!="string")throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");if(!element._owner)throw new Error("Element ref was specified as a string ("+mixedRef+`) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`)}}return mixedRef}function throwOnInvalidObjectType(returnFiber,newChild){var childString=Object.prototype.toString.call(newChild);throw new Error("Objects are not valid as a React child (found: "+(childString==="[object Object]"?"object with keys {"+Object.keys(newChild).join(", ")+"}":childString)+"). If you meant to render a collection of children, use an array instead.")}function warnOnFunctionType(returnFiber){{var componentName=getComponentNameFromFiber(returnFiber)||"Component";if(ownerHasFunctionTypeWarning[componentName])return;ownerHasFunctionTypeWarning[componentName]=!0,error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.")}}function resolveLazy(lazyType){var payload=lazyType._payload,init=lazyType._init;return init(payload)}function ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(shouldTrackSideEffects){var deletions=returnFiber.deletions;deletions===null?(returnFiber.deletions=[childToDelete],returnFiber.flags|=ChildDeletion):deletions.push(childToDelete)}}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects)return null;for(var childToDelete=currentFirstChild;childToDelete!==null;)deleteChild(returnFiber,childToDelete),childToDelete=childToDelete.sibling;return null}function mapRemainingChildren(returnFiber,currentFirstChild){for(var existingChildren=new Map,existingChild=currentFirstChild;existingChild!==null;)existingChild.key!==null?existingChildren.set(existingChild.key,existingChild):existingChildren.set(existingChild.index,existingChild),existingChild=existingChild.sibling;return existingChildren}function useFiber2(fiber,pendingProps){var clone=createWorkInProgress(fiber,pendingProps);return clone.index=0,clone.sibling=null,clone}function placeChild(newFiber,lastPlacedIndex,newIndex){if(newFiber.index=newIndex,!shouldTrackSideEffects)return newFiber.flags|=Forked,lastPlacedIndex;var current2=newFiber.alternate;if(current2!==null){var oldIndex=current2.index;return oldIndex<lastPlacedIndex?(newFiber.flags|=Placement,lastPlacedIndex):oldIndex}else return newFiber.flags|=Placement,lastPlacedIndex}function placeSingleChild(newFiber){return shouldTrackSideEffects&&newFiber.alternate===null&&(newFiber.flags|=Placement),newFiber}function updateTextNode(returnFiber,current2,textContent,lanes){if(current2===null||current2.tag!==HostText){var created=createFiberFromText(textContent,returnFiber.mode,lanes);return created.return=returnFiber,created}else{var existing=useFiber2(current2,textContent);return existing.return=returnFiber,existing}}function updateElement(returnFiber,current2,element,lanes){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE)return updateFragment2(returnFiber,current2,element.props.children,lanes,element.key);if(current2!==null&&(current2.elementType===elementType||isCompatibleFamilyForHotReloading(current2,element)||typeof elementType=="object"&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===current2.type)){var existing=useFiber2(current2,element.props);return existing.ref=coerceRef(returnFiber,current2,element),existing.return=returnFiber,existing._debugSource=element._source,existing._debugOwner=element._owner,existing}var created=createFiberFromElement(element,returnFiber.mode,lanes);return created.ref=coerceRef(returnFiber,current2,element),created.return=returnFiber,created}function updatePortal(returnFiber,current2,portal,lanes){if(current2===null||current2.tag!==HostPortal||current2.stateNode.containerInfo!==portal.containerInfo||current2.stateNode.implementation!==portal.implementation){var created=createFiberFromPortal(portal,returnFiber.mode,lanes);return created.return=returnFiber,created}else{var existing=useFiber2(current2,portal.children||[]);return existing.return=returnFiber,existing}}function updateFragment2(returnFiber,current2,fragment2,lanes,key){if(current2===null||current2.tag!==Fragment){var created=createFiberFromFragment(fragment2,returnFiber.mode,lanes,key);return created.return=returnFiber,created}else{var existing=useFiber2(current2,fragment2);return existing.return=returnFiber,existing}}function createChild(returnFiber,newChild,lanes){if(typeof newChild=="string"&&newChild!==""||typeof newChild=="number"){var created=createFiberFromText(""+newChild,returnFiber.mode,lanes);return created.return=returnFiber,created}if(typeof newChild=="object"&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _created=createFiberFromElement(newChild,returnFiber.mode,lanes);return _created.ref=coerceRef(returnFiber,null,newChild),_created.return=returnFiber,_created}case REACT_PORTAL_TYPE:{var _created2=createFiberFromPortal(newChild,returnFiber.mode,lanes);return _created2.return=returnFiber,_created2}case REACT_LAZY_TYPE:{var payload=newChild._payload,init=newChild._init;return createChild(returnFiber,init(payload),lanes)}}if(isArray(newChild)||getIteratorFn(newChild)){var _created3=createFiberFromFragment(newChild,returnFiber.mode,lanes,null);return _created3.return=returnFiber,_created3}throwOnInvalidObjectType(returnFiber,newChild)}return typeof newChild=="function"&&warnOnFunctionType(returnFiber),null}function updateSlot(returnFiber,oldFiber,newChild,lanes){var key=oldFiber!==null?oldFiber.key:null;if(typeof newChild=="string"&&newChild!==""||typeof newChild=="number")return key!==null?null:updateTextNode(returnFiber,oldFiber,""+newChild,lanes);if(typeof newChild=="object"&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return newChild.key===key?updateElement(returnFiber,oldFiber,newChild,lanes):null;case REACT_PORTAL_TYPE:return newChild.key===key?updatePortal(returnFiber,oldFiber,newChild,lanes):null;case REACT_LAZY_TYPE:{var payload=newChild._payload,init=newChild._init;return updateSlot(returnFiber,oldFiber,init(payload),lanes)}}if(isArray(newChild)||getIteratorFn(newChild))return key!==null?null:updateFragment2(returnFiber,oldFiber,newChild,lanes,null);throwOnInvalidObjectType(returnFiber,newChild)}return typeof newChild=="function"&&warnOnFunctionType(returnFiber),null}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes){if(typeof newChild=="string"&&newChild!==""||typeof newChild=="number"){var matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,""+newChild,lanes)}if(typeof newChild=="object"&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateElement(returnFiber,_matchedFiber,newChild,lanes)}case REACT_PORTAL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber2,newChild,lanes)}case REACT_LAZY_TYPE:{var payload=newChild._payload,init=newChild._init;return updateFromMap(existingChildren,returnFiber,newIdx,init(payload),lanes)}}if(isArray(newChild)||getIteratorFn(newChild)){var _matchedFiber3=existingChildren.get(newIdx)||null;return updateFragment2(returnFiber,_matchedFiber3,newChild,lanes,null)}throwOnInvalidObjectType(returnFiber,newChild)}return typeof newChild=="function"&&warnOnFunctionType(returnFiber),null}function warnOnInvalidKey(child,knownKeys,returnFiber){{if(typeof child!="object"||child===null)return knownKeys;switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child,returnFiber);var key=child.key;if(typeof key!="string")break;if(knownKeys===null){knownKeys=new Set,knownKeys.add(key);break}if(!knownKeys.has(key)){knownKeys.add(key);break}error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.",key);break;case REACT_LAZY_TYPE:{var payload=child._payload,init=child._init;warnOnInvalidKey(init(payload),knownKeys,returnFiber);break}}}return knownKeys}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes){for(var knownKeys=null,i2=0;i2<newChildren.length;i2++){var child=newChildren[i2];knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber)}for(var resultingFirstChild=null,previousNewFiber=null,oldFiber=currentFirstChild,lastPlacedIndex=0,newIdx=0,nextOldFiber=null;oldFiber!==null&&newIdx<newChildren.length;newIdx++){oldFiber.index>newIdx?(nextOldFiber=oldFiber,oldFiber=null):nextOldFiber=oldFiber.sibling;var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],lanes);if(newFiber===null){oldFiber===null&&(oldFiber=nextOldFiber);break}shouldTrackSideEffects&&oldFiber&&newFiber.alternate===null&&deleteChild(returnFiber,oldFiber),lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx),previousNewFiber===null?resultingFirstChild=newFiber:previousNewFiber.sibling=newFiber,previousNewFiber=newFiber,oldFiber=nextOldFiber}if(newIdx===newChildren.length){if(deleteRemainingChildren(returnFiber,oldFiber),getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks)}return resultingFirstChild}if(oldFiber===null){for(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],lanes);_newFiber!==null&&(lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx),previousNewFiber===null?resultingFirstChild=_newFiber:previousNewFiber.sibling=_newFiber,previousNewFiber=_newFiber)}if(getIsHydrating()){var _numberOfForks=newIdx;pushTreeFork(returnFiber,_numberOfForks)}return resultingFirstChild}for(var existingChildren=mapRemainingChildren(returnFiber,oldFiber);newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],lanes);_newFiber2!==null&&(shouldTrackSideEffects&&_newFiber2.alternate!==null&&existingChildren.delete(_newFiber2.key===null?newIdx:_newFiber2.key),lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx),previousNewFiber===null?resultingFirstChild=_newFiber2:previousNewFiber.sibling=_newFiber2,previousNewFiber=_newFiber2)}if(shouldTrackSideEffects&&existingChildren.forEach(function(child2){return deleteChild(returnFiber,child2)}),getIsHydrating()){var _numberOfForks2=newIdx;pushTreeFork(returnFiber,_numberOfForks2)}return resultingFirstChild}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,lanes){var iteratorFn=getIteratorFn(newChildrenIterable);if(typeof iteratorFn!="function")throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");{typeof Symbol=="function"&&newChildrenIterable[Symbol.toStringTag]==="Generator"&&(didWarnAboutGenerators||error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."),didWarnAboutGenerators=!0),newChildrenIterable.entries===iteratorFn&&(didWarnAboutMaps||error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."),didWarnAboutMaps=!0);var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren)for(var knownKeys=null,_step=_newChildren.next();!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys,returnFiber)}}var newChildren=iteratorFn.call(newChildrenIterable);if(newChildren==null)throw new Error("An iterable object provided no iterator.");for(var resultingFirstChild=null,previousNewFiber=null,oldFiber=currentFirstChild,lastPlacedIndex=0,newIdx=0,nextOldFiber=null,step=newChildren.next();oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){oldFiber.index>newIdx?(nextOldFiber=oldFiber,oldFiber=null):nextOldFiber=oldFiber.sibling;var newFiber=updateSlot(returnFiber,oldFiber,step.value,lanes);if(newFiber===null){oldFiber===null&&(oldFiber=nextOldFiber);break}shouldTrackSideEffects&&oldFiber&&newFiber.alternate===null&&deleteChild(returnFiber,oldFiber),lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx),previousNewFiber===null?resultingFirstChild=newFiber:previousNewFiber.sibling=newFiber,previousNewFiber=newFiber,oldFiber=nextOldFiber}if(step.done){if(deleteRemainingChildren(returnFiber,oldFiber),getIsHydrating()){var numberOfForks=newIdx;pushTreeFork(returnFiber,numberOfForks)}return resultingFirstChild}if(oldFiber===null){for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,lanes);_newFiber3!==null&&(lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx),previousNewFiber===null?resultingFirstChild=_newFiber3:previousNewFiber.sibling=_newFiber3,previousNewFiber=_newFiber3)}if(getIsHydrating()){var _numberOfForks3=newIdx;pushTreeFork(returnFiber,_numberOfForks3)}return resultingFirstChild}for(var existingChildren=mapRemainingChildren(returnFiber,oldFiber);!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,lanes);_newFiber4!==null&&(shouldTrackSideEffects&&_newFiber4.alternate!==null&&existingChildren.delete(_newFiber4.key===null?newIdx:_newFiber4.key),lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx),previousNewFiber===null?resultingFirstChild=_newFiber4:previousNewFiber.sibling=_newFiber4,previousNewFiber=_newFiber4)}if(shouldTrackSideEffects&&existingChildren.forEach(function(child2){return deleteChild(returnFiber,child2)}),getIsHydrating()){var _numberOfForks4=newIdx;pushTreeFork(returnFiber,_numberOfForks4)}return resultingFirstChild}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,lanes){if(currentFirstChild!==null&&currentFirstChild.tag===HostText){deleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber2(currentFirstChild,textContent);return existing.return=returnFiber,existing}deleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.mode,lanes);return created.return=returnFiber,created}function reconcileSingleElement(returnFiber,currentFirstChild,element,lanes){for(var key=element.key,child=currentFirstChild;child!==null;){if(child.key===key){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE){if(child.tag===Fragment){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber2(child,element.props.children);return existing.return=returnFiber,existing._debugSource=element._source,existing._debugOwner=element._owner,existing}}else if(child.elementType===elementType||isCompatibleFamilyForHotReloading(child,element)||typeof elementType=="object"&&elementType!==null&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===child.type){deleteRemainingChildren(returnFiber,child.sibling);var _existing=useFiber2(child,element.props);return _existing.ref=coerceRef(returnFiber,child,element),_existing.return=returnFiber,_existing._debugSource=element._source,_existing._debugOwner=element._owner,_existing}deleteRemainingChildren(returnFiber,child);break}else deleteChild(returnFiber,child);child=child.sibling}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.mode,lanes,element.key);return created.return=returnFiber,created}else{var _created4=createFiberFromElement(element,returnFiber.mode,lanes);return _created4.ref=coerceRef(returnFiber,currentFirstChild,element),_created4.return=returnFiber,_created4}}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,lanes){for(var key=portal.key,child=currentFirstChild;child!==null;){if(child.key===key)if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber2(child,portal.children||[]);return existing.return=returnFiber,existing}else{deleteRemainingChildren(returnFiber,child);break}else deleteChild(returnFiber,child);child=child.sibling}var created=createFiberFromPortal(portal,returnFiber.mode,lanes);return created.return=returnFiber,created}function reconcileChildFibers2(returnFiber,currentFirstChild,newChild,lanes){var isUnkeyedTopLevelFragment=typeof newChild=="object"&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null;if(isUnkeyedTopLevelFragment&&(newChild=newChild.props.children),typeof newChild=="object"&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,lanes));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,lanes));case REACT_LAZY_TYPE:{var payload=newChild._payload,init=newChild._init;return reconcileChildFibers2(returnFiber,currentFirstChild,init(payload),lanes)}}if(isArray(newChild))return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,lanes);if(getIteratorFn(newChild))return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes);throwOnInvalidObjectType(returnFiber,newChild)}return typeof newChild=="string"&&newChild!==""||typeof newChild=="number"?placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,""+newChild,lanes)):(typeof newChild=="function"&&warnOnFunctionType(returnFiber),deleteRemainingChildren(returnFiber,currentFirstChild))}return reconcileChildFibers2}var reconcileChildFibers=ChildReconciler(!0),mountChildFibers=ChildReconciler(!1);function cloneChildFibers(current2,workInProgress2){if(current2!==null&&workInProgress2.child!==current2.child)throw new Error("Resuming work not yet implemented.");if(workInProgress2.child!==null){var currentChild=workInProgress2.child,newChild=createWorkInProgress(currentChild,currentChild.pendingProps);for(workInProgress2.child=newChild,newChild.return=workInProgress2;currentChild.sibling!==null;)currentChild=currentChild.sibling,newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps),newChild.return=workInProgress2;newChild.sibling=null}}function resetChildFibers(workInProgress2,lanes){for(var child=workInProgress2.child;child!==null;)resetWorkInProgress(child,lanes),child=child.sibling}var NO_CONTEXT={},contextStackCursor$1=createCursor(NO_CONTEXT),contextFiberStackCursor=createCursor(NO_CONTEXT),rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c2){if(c2===NO_CONTEXT)throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");return c2}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance}function pushHostContainer(fiber,nextRootInstance){push(rootInstanceStackCursor,nextRootInstance,fiber),push(contextFiberStackCursor,fiber,fiber),push(contextStackCursor$1,NO_CONTEXT,fiber);var nextRootContext=getRootHostContext(nextRootInstance);pop(contextStackCursor$1,fiber),push(contextStackCursor$1,nextRootContext,fiber)}function popHostContainer(fiber){pop(contextStackCursor$1,fiber),pop(contextFiberStackCursor,fiber),pop(rootInstanceStackCursor,fiber)}function getHostContext(){var context2=requiredContext(contextStackCursor$1.current);return context2}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current),context2=requiredContext(contextStackCursor$1.current),nextContext=getChildHostContext(context2,fiber.type,rootInstance);context2!==nextContext&&(push(contextFiberStackCursor,fiber,fiber),push(contextStackCursor$1,nextContext,fiber))}function popHostContext(fiber){contextFiberStackCursor.current===fiber&&(pop(contextStackCursor$1,fiber),pop(contextFiberStackCursor,fiber))}var DefaultSuspenseContext=0,SubtreeSuspenseContextMask=1,InvisibleParentSuspenseContext=1,ForceSuspenseFallback=2,suspenseStackCursor=createCursor(DefaultSuspenseContext);function hasSuspenseContext(parentContext,flag){return(parentContext&flag)!==0}function setDefaultShallowSuspenseContext(parentContext){return parentContext&SubtreeSuspenseContextMask}function setShallowSuspenseContext(parentContext,shallowContext){return parentContext&SubtreeSuspenseContextMask|shallowContext}function addSubtreeSuspenseContext(parentContext,subtreeContext){return parentContext|subtreeContext}function pushSuspenseContext(fiber,newContext){push(suspenseStackCursor,newContext,fiber)}function popSuspenseContext(fiber){pop(suspenseStackCursor,fiber)}function shouldCaptureSuspense(workInProgress2,hasInvisibleParent){var nextState=workInProgress2.memoizedState;return nextState!==null?nextState.dehydrated!==null:(workInProgress2.memoizedProps,!0)}function findFirstSuspended(row){for(var node=row;node!==null;){if(node.tag===SuspenseComponent){var state=node.memoizedState;if(state!==null){var dehydrated=state.dehydrated;if(dehydrated===null||isSuspenseInstancePending(dehydrated)||isSuspenseInstanceFallback(dehydrated))return node}}else if(node.tag===SuspenseListComponent&&node.memoizedProps.revealOrder!==void 0){var didSuspend2=(node.flags&DidCapture)!==NoFlags;if(didSuspend2)return node}else if(node.child!==null){node.child.return=node,node=node.child;continue}if(node===row)return null;for(;node.sibling===null;){if(node.return===null||node.return===row)return null;node=node.return}node.sibling.return=node.return,node=node.sibling}return null}var NoFlags$1=0,HasEffect=1,Insertion=2,Layout=4,Passive$1=8,workInProgressSources=[];function resetWorkInProgressVersions(){for(var i2=0;i2<workInProgressSources.length;i2++){var mutableSource=workInProgressSources[i2];isPrimaryRenderer?mutableSource._workInProgressVersionPrimary=null:mutableSource._workInProgressVersionSecondary=null}workInProgressSources.length=0}function registerMutableSourceForHydration(root,mutableSource){var getVersion=mutableSource._getVersion,version2=getVersion(mutableSource._source);root.mutableSourceEagerHydrationData==null?root.mutableSourceEagerHydrationData=[mutableSource,version2]:root.mutableSourceEagerHydrationData.push(mutableSource,version2)}var ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentBatchConfig$1=ReactSharedInternals.ReactCurrentBatchConfig,didWarnAboutMismatchedHooksForComponent,didWarnUncachedGetSnapshot;didWarnAboutMismatchedHooksForComponent=new Set;var renderLanes=NoLanes,currentlyRenderingFiber$1=null,currentHook=null,workInProgressHook=null,didScheduleRenderPhaseUpdate=!1,didScheduleRenderPhaseUpdateDuringThisPass=!1,localIdCounter=0,globalClientIdCounter=0,RE_RENDER_LIMIT=25,currentHookNameInDev=null,hookTypesDev=null,hookTypesUpdateIndexDev=-1,ignorePreviousDependencies=!1;function mountHookTypesDev(){{var hookName=currentHookNameInDev;hookTypesDev===null?hookTypesDev=[hookName]:hookTypesDev.push(hookName)}}function updateHookTypesDev(){{var hookName=currentHookNameInDev;hookTypesDev!==null&&(hookTypesUpdateIndexDev++,hookTypesDev[hookTypesUpdateIndexDev]!==hookName&&warnOnHookMismatchInDev(hookName))}}function checkDepsAreArrayDev(deps){deps!=null&&!isArray(deps)&&error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",currentHookNameInDev,typeof deps)}function warnOnHookMismatchInDev(currentHookName){{var componentName=getComponentNameFromFiber(currentlyRenderingFiber$1);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)&&(didWarnAboutMismatchedHooksForComponent.add(componentName),hookTypesDev!==null)){for(var table="",secondColumnStart=30,i2=0;i2<=hookTypesUpdateIndexDev;i2++){for(var oldHookName=hookTypesDev[i2],newHookName=i2===hookTypesUpdateIndexDev?currentHookName:oldHookName,row=i2+1+". "+oldHookName;row.length<secondColumnStart;)row+=" ";row+=newHookName+`
`,table+=row}error(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`,componentName,table)}}}function throwInvalidHookError(){throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`)}function areHookInputsEqual(nextDeps,prevDeps){if(ignorePreviousDependencies)return!1;if(prevDeps===null)return error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",currentHookNameInDev),!1;nextDeps.length!==prevDeps.length&&error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`,currentHookNameInDev,"["+prevDeps.join(", ")+"]","["+nextDeps.join(", ")+"]");for(var i2=0;i2<prevDeps.length&&i2<nextDeps.length;i2++)if(!objectIs(nextDeps[i2],prevDeps[i2]))return!1;return!0}function renderWithHooks(current2,workInProgress2,Component,props,secondArg,nextRenderLanes){renderLanes=nextRenderLanes,currentlyRenderingFiber$1=workInProgress2,hookTypesDev=current2!==null?current2._debugHookTypes:null,hookTypesUpdateIndexDev=-1,ignorePreviousDependencies=current2!==null&&current2.type!==workInProgress2.type,workInProgress2.memoizedState=null,workInProgress2.updateQueue=null,workInProgress2.lanes=NoLanes,current2!==null&&current2.memoizedState!==null?ReactCurrentDispatcher$1.current=HooksDispatcherOnUpdateInDEV:hookTypesDev!==null?ReactCurrentDispatcher$1.current=HooksDispatcherOnMountWithHookTypesInDEV:ReactCurrentDispatcher$1.current=HooksDispatcherOnMountInDEV;var children=Component(props,secondArg);if(didScheduleRenderPhaseUpdateDuringThisPass){var numberOfReRenders=0;do{if(didScheduleRenderPhaseUpdateDuringThisPass=!1,localIdCounter=0,numberOfReRenders>=RE_RENDER_LIMIT)throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");numberOfReRenders+=1,ignorePreviousDependencies=!1,currentHook=null,workInProgressHook=null,workInProgress2.updateQueue=null,hookTypesUpdateIndexDev=-1,ReactCurrentDispatcher$1.current=HooksDispatcherOnRerenderInDEV,children=Component(props,secondArg)}while(didScheduleRenderPhaseUpdateDuringThisPass)}ReactCurrentDispatcher$1.current=ContextOnlyDispatcher,workInProgress2._debugHookTypes=hookTypesDev;var didRenderTooFewHooks=currentHook!==null&&currentHook.next!==null;if(renderLanes=NoLanes,currentlyRenderingFiber$1=null,currentHook=null,workInProgressHook=null,currentHookNameInDev=null,hookTypesDev=null,hookTypesUpdateIndexDev=-1,current2!==null&&(current2.flags&StaticMask)!==(workInProgress2.flags&StaticMask)&&(current2.mode&ConcurrentMode)!==NoMode&&error("Internal React error: Expected static flag was missing. Please notify the React team."),didScheduleRenderPhaseUpdate=!1,didRenderTooFewHooks)throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");return children}function checkDidRenderIdHook(){var didRenderIdHook=localIdCounter!==0;return localIdCounter=0,didRenderIdHook}function bailoutHooks(current2,workInProgress2,lanes){workInProgress2.updateQueue=current2.updateQueue,(workInProgress2.mode&StrictEffectsMode)!==NoMode?workInProgress2.flags&=~(MountPassiveDev|MountLayoutDev|Passive|Update):workInProgress2.flags&=~(Passive|Update),current2.lanes=removeLanes(current2.lanes,lanes)}function resetHooksAfterThrow(){if(ReactCurrentDispatcher$1.current=ContextOnlyDispatcher,didScheduleRenderPhaseUpdate){for(var hook=currentlyRenderingFiber$1.memoizedState;hook!==null;){var queue=hook.queue;queue!==null&&(queue.pending=null),hook=hook.next}didScheduleRenderPhaseUpdate=!1}renderLanes=NoLanes,currentlyRenderingFiber$1=null,currentHook=null,workInProgressHook=null,hookTypesDev=null,hookTypesUpdateIndexDev=-1,currentHookNameInDev=null,isUpdatingOpaqueValueInRenderPhase=!1,didScheduleRenderPhaseUpdateDuringThisPass=!1,localIdCounter=0}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return workInProgressHook===null?currentlyRenderingFiber$1.memoizedState=workInProgressHook=hook:workInProgressHook=workInProgressHook.next=hook,workInProgressHook}function updateWorkInProgressHook(){var nextCurrentHook;if(currentHook===null){var current2=currentlyRenderingFiber$1.alternate;current2!==null?nextCurrentHook=current2.memoizedState:nextCurrentHook=null}else nextCurrentHook=currentHook.next;var nextWorkInProgressHook;if(workInProgressHook===null?nextWorkInProgressHook=currentlyRenderingFiber$1.memoizedState:nextWorkInProgressHook=workInProgressHook.next,nextWorkInProgressHook!==null)workInProgressHook=nextWorkInProgressHook,nextWorkInProgressHook=workInProgressHook.next,currentHook=nextCurrentHook;else{if(nextCurrentHook===null)throw new Error("Rendered more hooks than during the previous render.");currentHook=nextCurrentHook;var newHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};workInProgressHook===null?currentlyRenderingFiber$1.memoizedState=workInProgressHook=newHook:workInProgressHook=workInProgressHook.next=newHook}return workInProgressHook}function createFunctionComponentUpdateQueue(){return{lastEffect:null,stores:null}}function basicStateReducer(state,action){return typeof action=="function"?action(state):action}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook(),initialState;init!==void 0?initialState=init(initialArg):initialState=initialArg,hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchReducerAction.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch]}function updateReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook(),queue=hook.queue;if(queue===null)throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");queue.lastRenderedReducer=reducer;var current2=currentHook,baseQueue=current2.baseQueue,pendingQueue=queue.pending;if(pendingQueue!==null){if(baseQueue!==null){var baseFirst=baseQueue.next,pendingFirst=pendingQueue.next;baseQueue.next=pendingFirst,pendingQueue.next=baseFirst}current2.baseQueue!==baseQueue&&error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."),current2.baseQueue=baseQueue=pendingQueue,queue.pending=null}if(baseQueue!==null){var first=baseQueue.next,newState=current2.baseState,newBaseState=null,newBaseQueueFirst=null,newBaseQueueLast=null,update=first;do{var updateLane=update.lane;if(isSubsetOfLanes(renderLanes,updateLane)){if(newBaseQueueLast!==null){var _clone={lane:NoLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};newBaseQueueLast=newBaseQueueLast.next=_clone}if(update.hasEagerState)newState=update.eagerState;else{var action=update.action;newState=reducer(newState,action)}}else{var clone={lane:updateLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};newBaseQueueLast===null?(newBaseQueueFirst=newBaseQueueLast=clone,newBaseState=newState):newBaseQueueLast=newBaseQueueLast.next=clone,currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,updateLane),markSkippedUpdateLanes(updateLane)}update=update.next}while(update!==null&&update!==first);newBaseQueueLast===null?newBaseState=newState:newBaseQueueLast.next=newBaseQueueFirst,objectIs(newState,hook.memoizedState)||markWorkInProgressReceivedUpdate(),hook.memoizedState=newState,hook.baseState=newBaseState,hook.baseQueue=newBaseQueueLast,queue.lastRenderedState=newState}var lastInterleaved=queue.interleaved;if(lastInterleaved!==null){var interleaved=lastInterleaved;do{var interleavedLane=interleaved.lane;currentlyRenderingFiber$1.lanes=mergeLanes(currentlyRenderingFiber$1.lanes,interleavedLane),markSkippedUpdateLanes(interleavedLane),interleaved=interleaved.next}while(interleaved!==lastInterleaved)}else baseQueue===null&&(queue.lanes=NoLanes);var dispatch=queue.dispatch;return[hook.memoizedState,dispatch]}function rerenderReducer(reducer,initialArg,init){var hook=updateWorkInProgressHook(),queue=hook.queue;if(queue===null)throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");queue.lastRenderedReducer=reducer;var dispatch=queue.dispatch,lastRenderPhaseUpdate=queue.pending,newState=hook.memoizedState;if(lastRenderPhaseUpdate!==null){queue.pending=null;var firstRenderPhaseUpdate=lastRenderPhaseUpdate.next,update=firstRenderPhaseUpdate;do{var action=update.action;newState=reducer(newState,action),update=update.next}while(update!==firstRenderPhaseUpdate);objectIs(newState,hook.memoizedState)||markWorkInProgressReceivedUpdate(),hook.memoizedState=newState,hook.baseQueue===null&&(hook.baseState=newState),queue.lastRenderedState=newState}return[newState,dispatch]}function mountMutableSource(source,getSnapshot,subscribe){}function updateMutableSource(source,getSnapshot,subscribe){}function mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1,hook=mountWorkInProgressHook(),nextSnapshot,isHydrating2=getIsHydrating();if(isHydrating2){if(getServerSnapshot===void 0)throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");nextSnapshot=getServerSnapshot(),didWarnUncachedGetSnapshot||nextSnapshot!==getServerSnapshot()&&(error("The result of getServerSnapshot should be cached to avoid an infinite loop"),didWarnUncachedGetSnapshot=!0)}else{if(nextSnapshot=getSnapshot(),!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();objectIs(nextSnapshot,cachedSnapshot)||(error("The result of getSnapshot should be cached to avoid an infinite loop"),didWarnUncachedGetSnapshot=!0)}var root=getWorkInProgressRoot();if(root===null)throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");includesBlockingLane(root,renderLanes)||pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot)}hook.memoizedState=nextSnapshot;var inst={value:nextSnapshot,getSnapshot};return hook.queue=inst,mountEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]),fiber.flags|=Passive,pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),void 0,null),nextSnapshot}function updateSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1,hook=updateWorkInProgressHook(),nextSnapshot=getSnapshot();if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();objectIs(nextSnapshot,cachedSnapshot)||(error("The result of getSnapshot should be cached to avoid an infinite loop"),didWarnUncachedGetSnapshot=!0)}var prevSnapshot=hook.memoizedState,snapshotChanged=!objectIs(prevSnapshot,nextSnapshot);snapshotChanged&&(hook.memoizedState=nextSnapshot,markWorkInProgressReceivedUpdate());var inst=hook.queue;if(updateEffect(subscribeToStore.bind(null,fiber,inst,subscribe),[subscribe]),inst.getSnapshot!==getSnapshot||snapshotChanged||workInProgressHook!==null&&workInProgressHook.memoizedState.tag&HasEffect){fiber.flags|=Passive,pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,inst,nextSnapshot,getSnapshot),void 0,null);var root=getWorkInProgressRoot();if(root===null)throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");includesBlockingLane(root,renderLanes)||pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot)}return nextSnapshot}function pushStoreConsistencyCheck(fiber,getSnapshot,renderedSnapshot){fiber.flags|=StoreConsistency;var check={getSnapshot,value:renderedSnapshot},componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null)componentUpdateQueue=createFunctionComponentUpdateQueue(),currentlyRenderingFiber$1.updateQueue=componentUpdateQueue,componentUpdateQueue.stores=[check];else{var stores=componentUpdateQueue.stores;stores===null?componentUpdateQueue.stores=[check]:stores.push(check)}}function updateStoreInstance(fiber,inst,nextSnapshot,getSnapshot){inst.value=nextSnapshot,inst.getSnapshot=getSnapshot,checkIfSnapshotChanged(inst)&&forceStoreRerender(fiber)}function subscribeToStore(fiber,inst,subscribe){var handleStoreChange=function(){checkIfSnapshotChanged(inst)&&forceStoreRerender(fiber)};return subscribe(handleStoreChange)}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot,prevValue=inst.value;try{var nextValue=latestGetSnapshot();return!objectIs(prevValue,nextValue)}catch{return!0}}function forceStoreRerender(fiber){scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp)}function mountState(initialState){var hook=mountWorkInProgressHook();typeof initialState=="function"&&(initialState=initialState()),hook.memoizedState=hook.baseState=initialState;var queue={pending:null,interleaved:null,lanes:NoLanes,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};hook.queue=queue;var dispatch=queue.dispatch=dispatchSetState.bind(null,currentlyRenderingFiber$1,queue);return[hook.memoizedState,dispatch]}function updateState(initialState){return updateReducer(basicStateReducer)}function rerenderState(initialState){return rerenderReducer(basicStateReducer)}function pushEffect(tag,create2,destroy,deps){var effect={tag,create:create2,destroy,deps,next:null},componentUpdateQueue=currentlyRenderingFiber$1.updateQueue;if(componentUpdateQueue===null)componentUpdateQueue=createFunctionComponentUpdateQueue(),currentlyRenderingFiber$1.updateQueue=componentUpdateQueue,componentUpdateQueue.lastEffect=effect.next=effect;else{var lastEffect=componentUpdateQueue.lastEffect;if(lastEffect===null)componentUpdateQueue.lastEffect=effect.next=effect;else{var firstEffect=lastEffect.next;lastEffect.next=effect,effect.next=firstEffect,componentUpdateQueue.lastEffect=effect}}return effect}function mountRef(initialValue){var hook=mountWorkInProgressHook();{var _ref2={current:initialValue};return hook.memoizedState=_ref2,_ref2}}function updateRef(initialValue){var hook=updateWorkInProgressHook();return hook.memoizedState}function mountEffectImpl(fiberFlags,hookFlags,create2,deps){var hook=mountWorkInProgressHook(),nextDeps=deps===void 0?null:deps;currentlyRenderingFiber$1.flags|=fiberFlags,hook.memoizedState=pushEffect(HasEffect|hookFlags,create2,void 0,nextDeps)}function updateEffectImpl(fiberFlags,hookFlags,create2,deps){var hook=updateWorkInProgressHook(),nextDeps=deps===void 0?null:deps,destroy=void 0;if(currentHook!==null){var prevEffect=currentHook.memoizedState;if(destroy=prevEffect.destroy,nextDeps!==null){var prevDeps=prevEffect.deps;if(areHookInputsEqual(nextDeps,prevDeps)){hook.memoizedState=pushEffect(hookFlags,create2,destroy,nextDeps);return}}}currentlyRenderingFiber$1.flags|=fiberFlags,hook.memoizedState=pushEffect(HasEffect|hookFlags,create2,destroy,nextDeps)}function mountEffect(create2,deps){return(currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode?mountEffectImpl(MountPassiveDev|Passive|PassiveStatic,Passive$1,create2,deps):mountEffectImpl(Passive|PassiveStatic,Passive$1,create2,deps)}function updateEffect(create2,deps){return updateEffectImpl(Passive,Passive$1,create2,deps)}function mountInsertionEffect(create2,deps){return mountEffectImpl(Update,Insertion,create2,deps)}function updateInsertionEffect(create2,deps){return updateEffectImpl(Update,Insertion,create2,deps)}function mountLayoutEffect(create2,deps){var fiberFlags=Update;return fiberFlags|=LayoutStatic,(currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode&&(fiberFlags|=MountLayoutDev),mountEffectImpl(fiberFlags,Layout,create2,deps)}function updateLayoutEffect(create2,deps){return updateEffectImpl(Update,Layout,create2,deps)}function imperativeHandleEffect(create2,ref){if(typeof ref=="function"){var refCallback=ref,_inst=create2();return refCallback(_inst),function(){refCallback(null)}}else if(ref!=null){var refObject=ref;refObject.hasOwnProperty("current")||error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.","an object with keys {"+Object.keys(refObject).join(", ")+"}");var _inst2=create2();return refObject.current=_inst2,function(){refObject.current=null}}}function mountImperativeHandle(ref,create2,deps){typeof create2!="function"&&error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",create2!==null?typeof create2:"null");var effectDeps=deps!=null?deps.concat([ref]):null,fiberFlags=Update;return fiberFlags|=LayoutStatic,(currentlyRenderingFiber$1.mode&StrictEffectsMode)!==NoMode&&(fiberFlags|=MountLayoutDev),mountEffectImpl(fiberFlags,Layout,imperativeHandleEffect.bind(null,create2,ref),effectDeps)}function updateImperativeHandle(ref,create2,deps){typeof create2!="function"&&error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",create2!==null?typeof create2:"null");var effectDeps=deps!=null?deps.concat([ref]):null;return updateEffectImpl(Update,Layout,imperativeHandleEffect.bind(null,create2,ref),effectDeps)}function mountDebugValue(value,formatterFn){}var updateDebugValue=mountDebugValue;function mountCallback(callback,deps){var hook=mountWorkInProgressHook(),nextDeps=deps===void 0?null:deps;return hook.memoizedState=[callback,nextDeps],callback}function updateCallback(callback,deps){var hook=updateWorkInProgressHook(),nextDeps=deps===void 0?null:deps,prevState=hook.memoizedState;if(prevState!==null&&nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps))return prevState[0]}return hook.memoizedState=[callback,nextDeps],callback}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook(),nextDeps=deps===void 0?null:deps,nextValue=nextCreate();return hook.memoizedState=[nextValue,nextDeps],nextValue}function updateMemo(nextCreate,deps){var hook=updateWorkInProgressHook(),nextDeps=deps===void 0?null:deps,prevState=hook.memoizedState;if(prevState!==null&&nextDeps!==null){var prevDeps=prevState[1];if(areHookInputsEqual(nextDeps,prevDeps))return prevState[0]}var nextValue=nextCreate();return hook.memoizedState=[nextValue,nextDeps],nextValue}function mountDeferredValue(value){var _mountState=mountState(value),prevValue=_mountState[0],setValue=_mountState[1];return mountEffect(function(){var prevTransition=ReactCurrentBatchConfig$1.transition;ReactCurrentBatchConfig$1.transition={};try{setValue(value)}finally{ReactCurrentBatchConfig$1.transition=prevTransition}},[value]),prevValue}function updateDeferredValue(value){var _updateState=updateState(),prevValue=_updateState[0],setValue=_updateState[1];return updateEffect(function(){var prevTransition=ReactCurrentBatchConfig$1.transition;ReactCurrentBatchConfig$1.transition={};try{setValue(value)}finally{ReactCurrentBatchConfig$1.transition=prevTransition}},[value]),prevValue}function rerenderDeferredValue(value){var _rerenderState=rerenderState(),prevValue=_rerenderState[0],setValue=_rerenderState[1];return updateEffect(function(){var prevTransition=ReactCurrentBatchConfig$1.transition;ReactCurrentBatchConfig$1.transition={};try{setValue(value)}finally{ReactCurrentBatchConfig$1.transition=prevTransition}},[value]),prevValue}function startTransition(setPending,callback,options){var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(higherEventPriority(previousPriority,ContinuousEventPriority)),setPending(!0);var prevTransition=ReactCurrentBatchConfig$1.transition;ReactCurrentBatchConfig$1.transition={};var currentTransition=ReactCurrentBatchConfig$1.transition;ReactCurrentBatchConfig$1.transition._updatedFibers=new Set;try{setPending(!1),callback()}finally{if(setCurrentUpdatePriority(previousPriority),ReactCurrentBatchConfig$1.transition=prevTransition,prevTransition===null&&currentTransition._updatedFibers){var updatedFibersCount=currentTransition._updatedFibers.size;updatedFibersCount>10&&warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."),currentTransition._updatedFibers.clear()}}}function mountTransition(){var _mountState2=mountState(!1),isPending=_mountState2[0],setPending=_mountState2[1],start=startTransition.bind(null,setPending),hook=mountWorkInProgressHook();return hook.memoizedState=start,[isPending,start]}function updateTransition(){var _updateState2=updateState(),isPending=_updateState2[0],hook=updateWorkInProgressHook(),start=hook.memoizedState;return[isPending,start]}function rerenderTransition(){var _rerenderState2=rerenderState(),isPending=_rerenderState2[0],hook=updateWorkInProgressHook(),start=hook.memoizedState;return[isPending,start]}var isUpdatingOpaqueValueInRenderPhase=!1;function getIsUpdatingOpaqueValueInRenderPhaseInDEV(){return isUpdatingOpaqueValueInRenderPhase}function mountId(){var hook=mountWorkInProgressHook(),root=getWorkInProgressRoot(),identifierPrefix=root.identifierPrefix,id2;if(getIsHydrating()){var treeId=getTreeId();id2=":"+identifierPrefix+"R"+treeId;var localId=localIdCounter++;localId>0&&(id2+="H"+localId.toString(32)),id2+=":"}else{var globalClientId=globalClientIdCounter++;id2=":"+identifierPrefix+"r"+globalClientId.toString(32)+":"}return hook.memoizedState=id2,id2}function updateId(){var hook=updateWorkInProgressHook(),id2=hook.memoizedState;return id2}function dispatchReducerAction(fiber,queue,action){typeof arguments[3]=="function"&&error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");var lane=requestUpdateLane(fiber),update={lane,action,hasEagerState:!1,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber))enqueueRenderPhaseUpdate(queue,update);else{enqueueUpdate$1(fiber,queue,update);var eventTime=requestEventTime(),root=scheduleUpdateOnFiber(fiber,lane,eventTime);root!==null&&entangleTransitionUpdate(root,queue,lane)}markUpdateInDevTools(fiber,lane)}function dispatchSetState(fiber,queue,action){typeof arguments[3]=="function"&&error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");var lane=requestUpdateLane(fiber),update={lane,action,hasEagerState:!1,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber))enqueueRenderPhaseUpdate(queue,update);else{enqueueUpdate$1(fiber,queue,update);var alternate=fiber.alternate;if(fiber.lanes===NoLanes&&(alternate===null||alternate.lanes===NoLanes)){var lastRenderedReducer=queue.lastRenderedReducer;if(lastRenderedReducer!==null){var prevDispatcher;prevDispatcher=ReactCurrentDispatcher$1.current,ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{var currentState=queue.lastRenderedState,eagerState=lastRenderedReducer(currentState,action);if(update.hasEagerState=!0,update.eagerState=eagerState,objectIs(eagerState,currentState))return}catch{}finally{ReactCurrentDispatcher$1.current=prevDispatcher}}}var eventTime=requestEventTime(),root=scheduleUpdateOnFiber(fiber,lane,eventTime);root!==null&&entangleTransitionUpdate(root,queue,lane)}markUpdateInDevTools(fiber,lane)}function isRenderPhaseUpdate(fiber){var alternate=fiber.alternate;return fiber===currentlyRenderingFiber$1||alternate!==null&&alternate===currentlyRenderingFiber$1}function enqueueRenderPhaseUpdate(queue,update){didScheduleRenderPhaseUpdateDuringThisPass=didScheduleRenderPhaseUpdate=!0;var pending=queue.pending;pending===null?update.next=update:(update.next=pending.next,pending.next=update),queue.pending=update}function enqueueUpdate$1(fiber,queue,update,lane){if(isInterleavedUpdate(fiber)){var interleaved=queue.interleaved;interleaved===null?(update.next=update,pushInterleavedQueue(queue)):(update.next=interleaved.next,interleaved.next=update),queue.interleaved=update}else{var pending=queue.pending;pending===null?update.next=update:(update.next=pending.next,pending.next=update),queue.pending=update}}function entangleTransitionUpdate(root,queue,lane){if(isTransitionLane(lane)){var queueLanes=queue.lanes;queueLanes=intersectLanes(queueLanes,root.pendingLanes);var newQueueLanes=mergeLanes(queueLanes,lane);queue.lanes=newQueueLanes,markRootEntangled(root,newQueueLanes)}}function markUpdateInDevTools(fiber,lane,action){markStateUpdateScheduled(fiber,lane)}var ContextOnlyDispatcher={readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useInsertionEffect:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError,useMutableSource:throwInvalidHookError,useSyncExternalStore:throwInvalidHookError,useId:throwInvalidHookError,unstable_isNewReconciler:enableNewReconciler},HooksDispatcherOnMountInDEV=null,HooksDispatcherOnMountWithHookTypesInDEV=null,HooksDispatcherOnUpdateInDEV=null,HooksDispatcherOnRerenderInDEV=null,InvalidNestedHooksDispatcherOnMountInDEV=null,InvalidNestedHooksDispatcherOnUpdateInDEV=null,InvalidNestedHooksDispatcherOnRerenderInDEV=null;{var warnInvalidContextAccess=function(){error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().")},warnInvalidHookAccess=function(){error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks")};HooksDispatcherOnMountInDEV={readContext:function(context2){return readContext(context2)},useCallback:function(callback,deps){return currentHookNameInDev="useCallback",mountHookTypesDev(),checkDepsAreArrayDev(deps),mountCallback(callback,deps)},useContext:function(context2){return currentHookNameInDev="useContext",mountHookTypesDev(),readContext(context2)},useEffect:function(create2,deps){return currentHookNameInDev="useEffect",mountHookTypesDev(),checkDepsAreArrayDev(deps),mountEffect(create2,deps)},useImperativeHandle:function(ref,create2,deps){return currentHookNameInDev="useImperativeHandle",mountHookTypesDev(),checkDepsAreArrayDev(deps),mountImperativeHandle(ref,create2,deps)},useInsertionEffect:function(create2,deps){return currentHookNameInDev="useInsertionEffect",mountHookTypesDev(),checkDepsAreArrayDev(deps),mountInsertionEffect(create2,deps)},useLayoutEffect:function(create2,deps){return currentHookNameInDev="useLayoutEffect",mountHookTypesDev(),checkDepsAreArrayDev(deps),mountLayoutEffect(create2,deps)},useMemo:function(create2,deps){currentHookNameInDev="useMemo",mountHookTypesDev(),checkDepsAreArrayDev(deps);var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create2,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer",mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){return currentHookNameInDev="useRef",mountHookTypesDev(),mountRef(initialValue)},useState:function(initialState){currentHookNameInDev="useState",mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,formatterFn){return currentHookNameInDev="useDebugValue",mountHookTypesDev(),void 0},useDeferredValue:function(value){return currentHookNameInDev="useDeferredValue",mountHookTypesDev(),mountDeferredValue(value)},useTransition:function(){return currentHookNameInDev="useTransition",mountHookTypesDev(),mountTransition()},useMutableSource:function(source,getSnapshot,subscribe){return currentHookNameInDev="useMutableSource",mountHookTypesDev(),void 0},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){return currentHookNameInDev="useSyncExternalStore",mountHookTypesDev(),mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot)},useId:function(){return currentHookNameInDev="useId",mountHookTypesDev(),mountId()},unstable_isNewReconciler:enableNewReconciler},HooksDispatcherOnMountWithHookTypesInDEV={readContext:function(context2){return readContext(context2)},useCallback:function(callback,deps){return currentHookNameInDev="useCallback",updateHookTypesDev(),mountCallback(callback,deps)},useContext:function(context2){return currentHookNameInDev="useContext",updateHookTypesDev(),readContext(context2)},useEffect:function(create2,deps){return currentHookNameInDev="useEffect",updateHookTypesDev(),mountEffect(create2,deps)},useImperativeHandle:function(ref,create2,deps){return currentHookNameInDev="useImperativeHandle",updateHookTypesDev(),mountImperativeHandle(ref,create2,deps)},useInsertionEffect:function(create2,deps){return currentHookNameInDev="useInsertionEffect",updateHookTypesDev(),mountInsertionEffect(create2,deps)},useLayoutEffect:function(create2,deps){return currentHookNameInDev="useLayoutEffect",updateHookTypesDev(),mountLayoutEffect(create2,deps)},useMemo:function(create2,deps){currentHookNameInDev="useMemo",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create2,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){return currentHookNameInDev="useRef",updateHookTypesDev(),mountRef(initialValue)},useState:function(initialState){currentHookNameInDev="useState",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,formatterFn){return currentHookNameInDev="useDebugValue",updateHookTypesDev(),void 0},useDeferredValue:function(value){return currentHookNameInDev="useDeferredValue",updateHookTypesDev(),mountDeferredValue(value)},useTransition:function(){return currentHookNameInDev="useTransition",updateHookTypesDev(),mountTransition()},useMutableSource:function(source,getSnapshot,subscribe){return currentHookNameInDev="useMutableSource",updateHookTypesDev(),void 0},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){return currentHookNameInDev="useSyncExternalStore",updateHookTypesDev(),mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot)},useId:function(){return currentHookNameInDev="useId",updateHookTypesDev(),mountId()},unstable_isNewReconciler:enableNewReconciler},HooksDispatcherOnUpdateInDEV={readContext:function(context2){return readContext(context2)},useCallback:function(callback,deps){return currentHookNameInDev="useCallback",updateHookTypesDev(),updateCallback(callback,deps)},useContext:function(context2){return currentHookNameInDev="useContext",updateHookTypesDev(),readContext(context2)},useEffect:function(create2,deps){return currentHookNameInDev="useEffect",updateHookTypesDev(),updateEffect(create2,deps)},useImperativeHandle:function(ref,create2,deps){return currentHookNameInDev="useImperativeHandle",updateHookTypesDev(),updateImperativeHandle(ref,create2,deps)},useInsertionEffect:function(create2,deps){return currentHookNameInDev="useInsertionEffect",updateHookTypesDev(),updateInsertionEffect(create2,deps)},useLayoutEffect:function(create2,deps){return currentHookNameInDev="useLayoutEffect",updateHookTypesDev(),updateLayoutEffect(create2,deps)},useMemo:function(create2,deps){currentHookNameInDev="useMemo",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create2,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){return currentHookNameInDev="useRef",updateHookTypesDev(),updateRef()},useState:function(initialState){currentHookNameInDev="useState",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,formatterFn){return currentHookNameInDev="useDebugValue",updateHookTypesDev(),updateDebugValue()},useDeferredValue:function(value){return currentHookNameInDev="useDeferredValue",updateHookTypesDev(),updateDeferredValue(value)},useTransition:function(){return currentHookNameInDev="useTransition",updateHookTypesDev(),updateTransition()},useMutableSource:function(source,getSnapshot,subscribe){return currentHookNameInDev="useMutableSource",updateHookTypesDev(),void 0},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){return currentHookNameInDev="useSyncExternalStore",updateHookTypesDev(),updateSyncExternalStore(subscribe,getSnapshot)},useId:function(){return currentHookNameInDev="useId",updateHookTypesDev(),updateId()},unstable_isNewReconciler:enableNewReconciler},HooksDispatcherOnRerenderInDEV={readContext:function(context2){return readContext(context2)},useCallback:function(callback,deps){return currentHookNameInDev="useCallback",updateHookTypesDev(),updateCallback(callback,deps)},useContext:function(context2){return currentHookNameInDev="useContext",updateHookTypesDev(),readContext(context2)},useEffect:function(create2,deps){return currentHookNameInDev="useEffect",updateHookTypesDev(),updateEffect(create2,deps)},useImperativeHandle:function(ref,create2,deps){return currentHookNameInDev="useImperativeHandle",updateHookTypesDev(),updateImperativeHandle(ref,create2,deps)},useInsertionEffect:function(create2,deps){return currentHookNameInDev="useInsertionEffect",updateHookTypesDev(),updateInsertionEffect(create2,deps)},useLayoutEffect:function(create2,deps){return currentHookNameInDev="useLayoutEffect",updateHookTypesDev(),updateLayoutEffect(create2,deps)},useMemo:function(create2,deps){currentHookNameInDev="useMemo",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return updateMemo(create2,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){return currentHookNameInDev="useRef",updateHookTypesDev(),updateRef()},useState:function(initialState){currentHookNameInDev="useState",updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,formatterFn){return currentHookNameInDev="useDebugValue",updateHookTypesDev(),updateDebugValue()},useDeferredValue:function(value){return currentHookNameInDev="useDeferredValue",updateHookTypesDev(),rerenderDeferredValue(value)},useTransition:function(){return currentHookNameInDev="useTransition",updateHookTypesDev(),rerenderTransition()},useMutableSource:function(source,getSnapshot,subscribe){return currentHookNameInDev="useMutableSource",updateHookTypesDev(),void 0},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){return currentHookNameInDev="useSyncExternalStore",updateHookTypesDev(),updateSyncExternalStore(subscribe,getSnapshot)},useId:function(){return currentHookNameInDev="useId",updateHookTypesDev(),updateId()},unstable_isNewReconciler:enableNewReconciler},InvalidNestedHooksDispatcherOnMountInDEV={readContext:function(context2){return warnInvalidContextAccess(),readContext(context2)},useCallback:function(callback,deps){return currentHookNameInDev="useCallback",warnInvalidHookAccess(),mountHookTypesDev(),mountCallback(callback,deps)},useContext:function(context2){return currentHookNameInDev="useContext",warnInvalidHookAccess(),mountHookTypesDev(),readContext(context2)},useEffect:function(create2,deps){return currentHookNameInDev="useEffect",warnInvalidHookAccess(),mountHookTypesDev(),mountEffect(create2,deps)},useImperativeHandle:function(ref,create2,deps){return currentHookNameInDev="useImperativeHandle",warnInvalidHookAccess(),mountHookTypesDev(),mountImperativeHandle(ref,create2,deps)},useInsertionEffect:function(create2,deps){return currentHookNameInDev="useInsertionEffect",warnInvalidHookAccess(),mountHookTypesDev(),mountInsertionEffect(create2,deps)},useLayoutEffect:function(create2,deps){return currentHookNameInDev="useLayoutEffect",warnInvalidHookAccess(),mountHookTypesDev(),mountLayoutEffect(create2,deps)},useMemo:function(create2,deps){currentHookNameInDev="useMemo",warnInvalidHookAccess(),mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create2,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer",warnInvalidHookAccess(),mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){return currentHookNameInDev="useRef",warnInvalidHookAccess(),mountHookTypesDev(),mountRef(initialValue)},useState:function(initialState){currentHookNameInDev="useState",warnInvalidHookAccess(),mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,formatterFn){return currentHookNameInDev="useDebugValue",warnInvalidHookAccess(),mountHookTypesDev(),void 0},useDeferredValue:function(value){return currentHookNameInDev="useDeferredValue",warnInvalidHookAccess(),mountHookTypesDev(),mountDeferredValue(value)},useTransition:function(){return currentHookNameInDev="useTransition",warnInvalidHookAccess(),mountHookTypesDev(),mountTransition()},useMutableSource:function(source,getSnapshot,subscribe){return currentHookNameInDev="useMutableSource",warnInvalidHookAccess(),mountHookTypesDev(),void 0},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){return currentHookNameInDev="useSyncExternalStore",warnInvalidHookAccess(),mountHookTypesDev(),mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot)},useId:function(){return currentHookNameInDev="useId",warnInvalidHookAccess(),mountHookTypesDev(),mountId()},unstable_isNewReconciler:enableNewReconciler},InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function(context2){return warnInvalidContextAccess(),readContext(context2)},useCallback:function(callback,deps){return currentHookNameInDev="useCallback",warnInvalidHookAccess(),updateHookTypesDev(),updateCallback(callback,deps)},useContext:function(context2){return currentHookNameInDev="useContext",warnInvalidHookAccess(),updateHookTypesDev(),readContext(context2)},useEffect:function(create2,deps){return currentHookNameInDev="useEffect",warnInvalidHookAccess(),updateHookTypesDev(),updateEffect(create2,deps)},useImperativeHandle:function(ref,create2,deps){return currentHookNameInDev="useImperativeHandle",warnInvalidHookAccess(),updateHookTypesDev(),updateImperativeHandle(ref,create2,deps)},useInsertionEffect:function(create2,deps){return currentHookNameInDev="useInsertionEffect",warnInvalidHookAccess(),updateHookTypesDev(),updateInsertionEffect(create2,deps)},useLayoutEffect:function(create2,deps){return currentHookNameInDev="useLayoutEffect",warnInvalidHookAccess(),updateHookTypesDev(),updateLayoutEffect(create2,deps)},useMemo:function(create2,deps){currentHookNameInDev="useMemo",warnInvalidHookAccess(),updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create2,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer",warnInvalidHookAccess(),updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){return currentHookNameInDev="useRef",warnInvalidHookAccess(),updateHookTypesDev(),updateRef()},useState:function(initialState){currentHookNameInDev="useState",warnInvalidHookAccess(),updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,formatterFn){return currentHookNameInDev="useDebugValue",warnInvalidHookAccess(),updateHookTypesDev(),updateDebugValue()},useDeferredValue:function(value){return currentHookNameInDev="useDeferredValue",warnInvalidHookAccess(),updateHookTypesDev(),updateDeferredValue(value)},useTransition:function(){return currentHookNameInDev="useTransition",warnInvalidHookAccess(),updateHookTypesDev(),updateTransition()},useMutableSource:function(source,getSnapshot,subscribe){return currentHookNameInDev="useMutableSource",warnInvalidHookAccess(),updateHookTypesDev(),void 0},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){return currentHookNameInDev="useSyncExternalStore",warnInvalidHookAccess(),updateHookTypesDev(),updateSyncExternalStore(subscribe,getSnapshot)},useId:function(){return currentHookNameInDev="useId",warnInvalidHookAccess(),updateHookTypesDev(),updateId()},unstable_isNewReconciler:enableNewReconciler},InvalidNestedHooksDispatcherOnRerenderInDEV={readContext:function(context2){return warnInvalidContextAccess(),readContext(context2)},useCallback:function(callback,deps){return currentHookNameInDev="useCallback",warnInvalidHookAccess(),updateHookTypesDev(),updateCallback(callback,deps)},useContext:function(context2){return currentHookNameInDev="useContext",warnInvalidHookAccess(),updateHookTypesDev(),readContext(context2)},useEffect:function(create2,deps){return currentHookNameInDev="useEffect",warnInvalidHookAccess(),updateHookTypesDev(),updateEffect(create2,deps)},useImperativeHandle:function(ref,create2,deps){return currentHookNameInDev="useImperativeHandle",warnInvalidHookAccess(),updateHookTypesDev(),updateImperativeHandle(ref,create2,deps)},useInsertionEffect:function(create2,deps){return currentHookNameInDev="useInsertionEffect",warnInvalidHookAccess(),updateHookTypesDev(),updateInsertionEffect(create2,deps)},useLayoutEffect:function(create2,deps){return currentHookNameInDev="useLayoutEffect",warnInvalidHookAccess(),updateHookTypesDev(),updateLayoutEffect(create2,deps)},useMemo:function(create2,deps){currentHookNameInDev="useMemo",warnInvalidHookAccess(),updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create2,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer",warnInvalidHookAccess(),updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){return currentHookNameInDev="useRef",warnInvalidHookAccess(),updateHookTypesDev(),updateRef()},useState:function(initialState){currentHookNameInDev="useState",warnInvalidHookAccess(),updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,formatterFn){return currentHookNameInDev="useDebugValue",warnInvalidHookAccess(),updateHookTypesDev(),updateDebugValue()},useDeferredValue:function(value){return currentHookNameInDev="useDeferredValue",warnInvalidHookAccess(),updateHookTypesDev(),rerenderDeferredValue(value)},useTransition:function(){return currentHookNameInDev="useTransition",warnInvalidHookAccess(),updateHookTypesDev(),rerenderTransition()},useMutableSource:function(source,getSnapshot,subscribe){return currentHookNameInDev="useMutableSource",warnInvalidHookAccess(),updateHookTypesDev(),void 0},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){return currentHookNameInDev="useSyncExternalStore",warnInvalidHookAccess(),updateHookTypesDev(),updateSyncExternalStore(subscribe,getSnapshot)},useId:function(){return currentHookNameInDev="useId",warnInvalidHookAccess(),updateHookTypesDev(),updateId()},unstable_isNewReconciler:enableNewReconciler}}var now$2=Scheduler.unstable_now,commitTime=0,layoutEffectStartTime=-1,profilerStartTime=-1,passiveEffectStartTime=-1,currentUpdateIsNested=!1,nestedUpdateScheduled=!1;function isCurrentUpdateNested(){return currentUpdateIsNested}function markNestedUpdateScheduled(){nestedUpdateScheduled=!0}function resetNestedUpdateFlag(){currentUpdateIsNested=!1,nestedUpdateScheduled=!1}function syncNestedUpdateFlag(){currentUpdateIsNested=nestedUpdateScheduled,nestedUpdateScheduled=!1}function getCommitTime(){return commitTime}function recordCommitTime(){commitTime=now$2()}function startProfilerTimer(fiber){profilerStartTime=now$2(),fiber.actualStartTime<0&&(fiber.actualStartTime=now$2())}function stopProfilerTimerIfRunning(fiber){profilerStartTime=-1}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(profilerStartTime>=0){var elapsedTime=now$2()-profilerStartTime;fiber.actualDuration+=elapsedTime,overrideBaseTime&&(fiber.selfBaseDuration=elapsedTime),profilerStartTime=-1}}function recordLayoutEffectDuration(fiber){if(layoutEffectStartTime>=0){var elapsedTime=now$2()-layoutEffectStartTime;layoutEffectStartTime=-1;for(var parentFiber=fiber.return;parentFiber!==null;){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=elapsedTime;return;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=elapsedTime;return}parentFiber=parentFiber.return}}}function recordPassiveEffectDuration(fiber){if(passiveEffectStartTime>=0){var elapsedTime=now$2()-passiveEffectStartTime;passiveEffectStartTime=-1;for(var parentFiber=fiber.return;parentFiber!==null;){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root!==null&&(root.passiveEffectDuration+=elapsedTime);return;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode!==null&&(parentStateNode.passiveEffectDuration+=elapsedTime);return}parentFiber=parentFiber.return}}}function startLayoutEffectTimer(){layoutEffectStartTime=now$2()}function startPassiveEffectTimer(){passiveEffectStartTime=now$2()}function transferActualDuration(fiber){for(var child=fiber.child;child;)fiber.actualDuration+=child.actualDuration,child=child.sibling}function createCapturedValue(value,source){return{value,source,stack:getStackByFiberInDevAndProd(source)}}function showErrorDialog(boundary,errorInfo){return!0}function logCapturedError(boundary,errorInfo){try{var logError=showErrorDialog(boundary,errorInfo);if(logError===!1)return;var error2=errorInfo.value,source=errorInfo.source,stack=errorInfo.stack,componentStack=stack!==null?stack:"";if(error2!=null&&error2._suppressLogging){if(boundary.tag===ClassComponent)return;console.error(error2)}var componentName=source?getComponentNameFromFiber(source):null,componentNameMessage=componentName?"The above error occurred in the <"+componentName+"> component:":"The above error occurred in one of your React components:",errorBoundaryMessage;if(boundary.tag===HostRoot)errorBoundaryMessage=`Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;else{var errorBoundaryName=getComponentNameFromFiber(boundary)||"Anonymous";errorBoundaryMessage="React will try to recreate this component tree from scratch "+("using the error boundary you provided, "+errorBoundaryName+".")}var combinedMessage=componentNameMessage+`
`+componentStack+`

`+(""+errorBoundaryMessage);console.error(combinedMessage)}catch(e2){setTimeout(function(){throw e2})}}var PossiblyWeakMap$1=typeof WeakMap=="function"?WeakMap:Map;function createRootErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);update.tag=CaptureUpdate,update.payload={element:null};var error2=errorInfo.value;return update.callback=function(){onUncaughtError(error2),logCapturedError(fiber,errorInfo)},update}function createClassErrorUpdate(fiber,errorInfo,lane){var update=createUpdate(NoTimestamp,lane);update.tag=CaptureUpdate;var getDerivedStateFromError=fiber.type.getDerivedStateFromError;if(typeof getDerivedStateFromError=="function"){var error$1=errorInfo.value;update.payload=function(){return getDerivedStateFromError(error$1)},update.callback=function(){markFailedErrorBoundaryForHotReloading(fiber),logCapturedError(fiber,errorInfo)}}var inst=fiber.stateNode;return inst!==null&&typeof inst.componentDidCatch=="function"&&(update.callback=function(){markFailedErrorBoundaryForHotReloading(fiber),logCapturedError(fiber,errorInfo),typeof getDerivedStateFromError!="function"&&markLegacyErrorBoundaryAsFailed(this);var error$12=errorInfo.value,stack=errorInfo.stack;this.componentDidCatch(error$12,{componentStack:stack!==null?stack:""}),typeof getDerivedStateFromError!="function"&&(includesSomeLane(fiber.lanes,SyncLane)||error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",getComponentNameFromFiber(fiber)||"Unknown"))}),update}function attachPingListener(root,wakeable,lanes){var pingCache=root.pingCache,threadIDs;if(pingCache===null?(pingCache=root.pingCache=new PossiblyWeakMap$1,threadIDs=new Set,pingCache.set(wakeable,threadIDs)):(threadIDs=pingCache.get(wakeable),threadIDs===void 0&&(threadIDs=new Set,pingCache.set(wakeable,threadIDs))),!threadIDs.has(lanes)){threadIDs.add(lanes);var ping=pingSuspendedRoot.bind(null,root,wakeable,lanes);isDevToolsPresent&&restorePendingUpdaters(root,lanes),wakeable.then(ping,ping)}}function attachRetryListener(suspenseBoundary,root,wakeable,lanes){var wakeables=suspenseBoundary.updateQueue;if(wakeables===null){var updateQueue=new Set;updateQueue.add(wakeable),suspenseBoundary.updateQueue=updateQueue}else wakeables.add(wakeable)}function resetSuspendedComponent(sourceFiber,rootRenderLanes){var tag=sourceFiber.tag;if((sourceFiber.mode&ConcurrentMode)===NoMode&&(tag===FunctionComponent||tag===ForwardRef||tag===SimpleMemoComponent)){var currentSource=sourceFiber.alternate;currentSource?(sourceFiber.updateQueue=currentSource.updateQueue,sourceFiber.memoizedState=currentSource.memoizedState,sourceFiber.lanes=currentSource.lanes):(sourceFiber.updateQueue=null,sourceFiber.memoizedState=null)}}function getNearestSuspenseBoundaryToCapture(returnFiber){var node=returnFiber;do{if(node.tag===SuspenseComponent&&shouldCaptureSuspense(node))return node;node=node.return}while(node!==null);return null}function markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes){if((suspenseBoundary.mode&ConcurrentMode)===NoMode){if(suspenseBoundary===returnFiber)suspenseBoundary.flags|=ShouldCapture;else{if(suspenseBoundary.flags|=DidCapture,sourceFiber.flags|=ForceUpdateForLegacySuspense,sourceFiber.flags&=~(LifecycleEffectMask|Incomplete),supportsPersistence&&enablePersistentOffscreenHostContainer){var currentSuspenseBoundary=suspenseBoundary.alternate;if(currentSuspenseBoundary===null){var offscreenFiber=suspenseBoundary.child,offscreenContainer=offscreenFiber.child;if(offscreenContainer!==null){var children=offscreenContainer.memoizedProps.children,containerProps=getOffscreenContainerProps("hidden",children);offscreenContainer.pendingProps=containerProps,offscreenContainer.memoizedProps=containerProps}}}if(sourceFiber.tag===ClassComponent){var currentSourceFiber=sourceFiber.alternate;if(currentSourceFiber===null)sourceFiber.tag=IncompleteClassComponent;else{var update=createUpdate(NoTimestamp,SyncLane);update.tag=ForceUpdate,enqueueUpdate(sourceFiber,update)}}sourceFiber.lanes=mergeLanes(sourceFiber.lanes,SyncLane)}return suspenseBoundary}return suspenseBoundary.flags|=ShouldCapture,suspenseBoundary.lanes=rootRenderLanes,suspenseBoundary}function throwException(root,returnFiber,sourceFiber,value,rootRenderLanes){if(sourceFiber.flags|=Incomplete,isDevToolsPresent&&restorePendingUpdaters(root,rootRenderLanes),value!==null&&typeof value=="object"&&typeof value.then=="function"){var wakeable=value;resetSuspendedComponent(sourceFiber);var suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(suspenseBoundary!==null){suspenseBoundary.flags&=~ForceClientRender,markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes),suspenseBoundary.mode&ConcurrentMode&&attachPingListener(root,wakeable,rootRenderLanes),attachRetryListener(suspenseBoundary,root,wakeable);return}else{if(!includesSyncLane(rootRenderLanes)){attachPingListener(root,wakeable,rootRenderLanes),renderDidSuspendDelayIfPossible();return}var uncaughtSuspenseError=new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");value=uncaughtSuspenseError}}else if(getIsHydrating()&&sourceFiber.mode&ConcurrentMode){markDidSuspendWhileHydratingDEV();var _suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(_suspenseBoundary!==null){(_suspenseBoundary.flags&ShouldCapture)===NoFlags&&(_suspenseBoundary.flags|=ForceClientRender),markSuspenseBoundaryShouldCapture(_suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes),queueHydrationError(value);return}}renderDidError(value),value=createCapturedValue(value,sourceFiber);var workInProgress2=returnFiber;do{switch(workInProgress2.tag){case HostRoot:{var _errorInfo=value;workInProgress2.flags|=ShouldCapture;var lane=pickArbitraryLane(rootRenderLanes);workInProgress2.lanes=mergeLanes(workInProgress2.lanes,lane);var update=createRootErrorUpdate(workInProgress2,_errorInfo,lane);enqueueCapturedUpdate(workInProgress2,update);return}case ClassComponent:var errorInfo=value,ctor=workInProgress2.type,instance=workInProgress2.stateNode;if((workInProgress2.flags&DidCapture)===NoFlags&&(typeof ctor.getDerivedStateFromError=="function"||instance!==null&&typeof instance.componentDidCatch=="function"&&!isAlreadyFailedLegacyErrorBoundary(instance))){workInProgress2.flags|=ShouldCapture;var _lane=pickArbitraryLane(rootRenderLanes);workInProgress2.lanes=mergeLanes(workInProgress2.lanes,_lane);var _update=createClassErrorUpdate(workInProgress2,errorInfo,_lane);enqueueCapturedUpdate(workInProgress2,_update);return}break}workInProgress2=workInProgress2.return}while(workInProgress2!==null)}function getSuspendedCache(){return null}function markUpdate(workInProgress2){workInProgress2.flags|=Update}function markRef(workInProgress2){workInProgress2.flags|=Ref,workInProgress2.flags|=RefStatic}function hadNoMutationsEffects(current2,completedWork){var didBailout=current2!==null&&current2.child===completedWork.child;if(didBailout)return!0;if((completedWork.flags&ChildDeletion)!==NoFlags)return!1;for(var child=completedWork.child;child!==null;){if((child.flags&MutationMask)!==NoFlags||(child.subtreeFlags&MutationMask)!==NoFlags)return!1;child=child.sibling}return!0}var appendAllChildren,updateHostContainer,updateHostComponent,updateHostText;if(supportsMutation)appendAllChildren=function(parent,workInProgress2,needsVisibilityToggle,isHidden){for(var node=workInProgress2.child;node!==null;){if(node.tag===HostComponent||node.tag===HostText)appendInitialChild(parent,node.stateNode);else if(node.tag!==HostPortal){if(node.child!==null){node.child.return=node,node=node.child;continue}}if(node===workInProgress2)return;for(;node.sibling===null;){if(node.return===null||node.return===workInProgress2)return;node=node.return}node.sibling.return=node.return,node=node.sibling}},updateHostContainer=function(current2,workInProgress2){},updateHostComponent=function(current2,workInProgress2,type,newProps,rootContainerInstance){var oldProps=current2.memoizedProps;if(oldProps!==newProps){var instance=workInProgress2.stateNode,currentHostContext=getHostContext(),updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);workInProgress2.updateQueue=updatePayload,updatePayload&&markUpdate(workInProgress2)}},updateHostText=function(current2,workInProgress2,oldText,newText){oldText!==newText&&markUpdate(workInProgress2)};else if(supportsPersistence){appendAllChildren=function(parent,workInProgress2,needsVisibilityToggle,isHidden){for(var node=workInProgress2.child;node!==null;){if(node.tag===HostComponent){var instance=node.stateNode;if(needsVisibilityToggle&&isHidden){var props=node.memoizedProps,type=node.type;instance=cloneHiddenInstance(instance,type,props,node)}appendInitialChild(parent,instance)}else if(node.tag===HostText){var _instance=node.stateNode;if(needsVisibilityToggle&&isHidden){var text=node.memoizedProps;_instance=cloneHiddenTextInstance(_instance,text,node)}appendInitialChild(parent,_instance)}else if(node.tag!==HostPortal){if(node.tag===OffscreenComponent&&node.memoizedState!==null){var child=node.child;child!==null&&(child.return=node),appendAllChildren(parent,node,!0,!0)}else if(node.child!==null){node.child.return=node,node=node.child;continue}}if(node=node,node===workInProgress2)return;for(;node.sibling===null;){if(node.return===null||node.return===workInProgress2)return;node=node.return}node.sibling.return=node.return,node=node.sibling}};var appendAllChildrenToContainer=function(containerChildSet,workInProgress2,needsVisibilityToggle,isHidden){for(var node=workInProgress2.child;node!==null;){if(node.tag===HostComponent){var instance=node.stateNode;if(needsVisibilityToggle&&isHidden){var props=node.memoizedProps,type=node.type;instance=cloneHiddenInstance(instance,type,props,node)}appendChildToContainerChildSet(containerChildSet,instance)}else if(node.tag===HostText){var _instance2=node.stateNode;if(needsVisibilityToggle&&isHidden){var text=node.memoizedProps;_instance2=cloneHiddenTextInstance(_instance2,text,node)}appendChildToContainerChildSet(containerChildSet,_instance2)}else if(node.tag!==HostPortal){if(node.tag===OffscreenComponent&&node.memoizedState!==null){var child=node.child;child!==null&&(child.return=node),appendAllChildrenToContainer(containerChildSet,node,!0,!0)}else if(node.child!==null){node.child.return=node,node=node.child;continue}}if(node=node,node===workInProgress2)return;for(;node.sibling===null;){if(node.return===null||node.return===workInProgress2)return;node=node.return}node.sibling.return=node.return,node=node.sibling}};updateHostContainer=function(current2,workInProgress2){var portalOrRoot=workInProgress2.stateNode,childrenUnchanged=hadNoMutationsEffects(current2,workInProgress2);if(!childrenUnchanged){var container=portalOrRoot.containerInfo,newChildSet=createContainerChildSet(container);appendAllChildrenToContainer(newChildSet,workInProgress2,!1,!1),portalOrRoot.pendingChildren=newChildSet,markUpdate(workInProgress2),finalizeContainerChildren(container,newChildSet)}},updateHostComponent=function(current2,workInProgress2,type,newProps,rootContainerInstance){var currentInstance=current2.stateNode,oldProps=current2.memoizedProps,childrenUnchanged=hadNoMutationsEffects(current2,workInProgress2);if(childrenUnchanged&&oldProps===newProps){workInProgress2.stateNode=currentInstance;return}var recyclableInstance=workInProgress2.stateNode,currentHostContext=getHostContext(),updatePayload=null;if(oldProps!==newProps&&(updatePayload=prepareUpdate(recyclableInstance,type,oldProps,newProps,rootContainerInstance,currentHostContext)),childrenUnchanged&&updatePayload===null){workInProgress2.stateNode=currentInstance;return}var newInstance=cloneInstance(currentInstance,updatePayload,type,oldProps,newProps,workInProgress2,childrenUnchanged,recyclableInstance);finalizeInitialChildren(newInstance,type,newProps,rootContainerInstance,currentHostContext)&&markUpdate(workInProgress2),workInProgress2.stateNode=newInstance,childrenUnchanged?markUpdate(workInProgress2):appendAllChildren(newInstance,workInProgress2,!1,!1)},updateHostText=function(current2,workInProgress2,oldText,newText){if(oldText!==newText){var rootContainerInstance=getRootHostContainer(),currentHostContext=getHostContext();workInProgress2.stateNode=createTextInstance(newText,rootContainerInstance,currentHostContext,workInProgress2),markUpdate(workInProgress2)}else workInProgress2.stateNode=current2.stateNode}}else updateHostContainer=function(current2,workInProgress2){},updateHostComponent=function(current2,workInProgress2,type,newProps,rootContainerInstance){},updateHostText=function(current2,workInProgress2,oldText,newText){};function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){if(!getIsHydrating())switch(renderState.tailMode){case"hidden":{for(var tailNode=renderState.tail,lastTailNode=null;tailNode!==null;)tailNode.alternate!==null&&(lastTailNode=tailNode),tailNode=tailNode.sibling;lastTailNode===null?renderState.tail=null:lastTailNode.sibling=null;break}case"collapsed":{for(var _tailNode=renderState.tail,_lastTailNode=null;_tailNode!==null;)_tailNode.alternate!==null&&(_lastTailNode=_tailNode),_tailNode=_tailNode.sibling;_lastTailNode===null?!hasRenderedATailFallback&&renderState.tail!==null?renderState.tail.sibling=null:renderState.tail=null:_lastTailNode.sibling=null;break}}}function bubbleProperties(completedWork){var didBailout=completedWork.alternate!==null&&completedWork.alternate.child===completedWork.child,newChildLanes=NoLanes,subtreeFlags=NoFlags;if(didBailout){if((completedWork.mode&ProfileMode)!==NoMode){for(var _treeBaseDuration=completedWork.selfBaseDuration,_child2=completedWork.child;_child2!==null;)newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child2.lanes,_child2.childLanes)),subtreeFlags|=_child2.subtreeFlags&StaticMask,subtreeFlags|=_child2.flags&StaticMask,_treeBaseDuration+=_child2.treeBaseDuration,_child2=_child2.sibling;completedWork.treeBaseDuration=_treeBaseDuration}else for(var _child3=completedWork.child;_child3!==null;)newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child3.lanes,_child3.childLanes)),subtreeFlags|=_child3.subtreeFlags&StaticMask,subtreeFlags|=_child3.flags&StaticMask,_child3.return=completedWork,_child3=_child3.sibling;completedWork.subtreeFlags|=subtreeFlags}else{if((completedWork.mode&ProfileMode)!==NoMode){for(var actualDuration=completedWork.actualDuration,treeBaseDuration=completedWork.selfBaseDuration,child=completedWork.child;child!==null;)newChildLanes=mergeLanes(newChildLanes,mergeLanes(child.lanes,child.childLanes)),subtreeFlags|=child.subtreeFlags,subtreeFlags|=child.flags,actualDuration+=child.actualDuration,treeBaseDuration+=child.treeBaseDuration,child=child.sibling;completedWork.actualDuration=actualDuration,completedWork.treeBaseDuration=treeBaseDuration}else for(var _child=completedWork.child;_child!==null;)newChildLanes=mergeLanes(newChildLanes,mergeLanes(_child.lanes,_child.childLanes)),subtreeFlags|=_child.subtreeFlags,subtreeFlags|=_child.flags,_child.return=completedWork,_child=_child.sibling;completedWork.subtreeFlags|=subtreeFlags}return completedWork.childLanes=newChildLanes,didBailout}function completeWork(current2,workInProgress2,renderLanes2){var newProps=workInProgress2.pendingProps;switch(popTreeContext(workInProgress2),workInProgress2.tag){case IndeterminateComponent:case LazyComponent:case SimpleMemoComponent:case FunctionComponent:case ForwardRef:case Fragment:case Mode:case Profiler:case ContextConsumer:case MemoComponent:return bubbleProperties(workInProgress2),null;case ClassComponent:{var Component=workInProgress2.type;return isContextProvider(Component)&&popContext(workInProgress2),bubbleProperties(workInProgress2),null}case HostRoot:{var fiberRoot=workInProgress2.stateNode;if(popHostContainer(workInProgress2),popTopLevelContextObject(workInProgress2),resetWorkInProgressVersions(),fiberRoot.pendingContext&&(fiberRoot.context=fiberRoot.pendingContext,fiberRoot.pendingContext=null),current2===null||current2.child===null){var wasHydrated=popHydrationState(workInProgress2);if(wasHydrated)markUpdate(workInProgress2);else if(current2!==null){var prevState=current2.memoizedState;(!prevState.isDehydrated||(workInProgress2.flags&ForceClientRender)!==NoFlags)&&(workInProgress2.flags|=Snapshot,upgradeHydrationErrorsToRecoverable())}}return updateHostContainer(current2,workInProgress2),bubbleProperties(workInProgress2),null}case HostComponent:{popHostContext(workInProgress2);var rootContainerInstance=getRootHostContainer(),type=workInProgress2.type;if(current2!==null&&workInProgress2.stateNode!=null)updateHostComponent(current2,workInProgress2,type,newProps,rootContainerInstance),current2.ref!==workInProgress2.ref&&markRef(workInProgress2);else{if(!newProps){if(workInProgress2.stateNode===null)throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");return bubbleProperties(workInProgress2),null}var currentHostContext=getHostContext(),_wasHydrated=popHydrationState(workInProgress2);if(_wasHydrated)prepareToHydrateHostInstance(workInProgress2,rootContainerInstance,currentHostContext)&&markUpdate(workInProgress2);else{var instance=createInstance(type,newProps,rootContainerInstance,currentHostContext,workInProgress2);appendAllChildren(instance,workInProgress2,!1,!1),workInProgress2.stateNode=instance,finalizeInitialChildren(instance,type,newProps,rootContainerInstance,currentHostContext)&&markUpdate(workInProgress2)}workInProgress2.ref!==null&&markRef(workInProgress2)}return bubbleProperties(workInProgress2),null}case HostText:{var newText=newProps;if(current2&&workInProgress2.stateNode!=null){var oldText=current2.memoizedProps;updateHostText(current2,workInProgress2,oldText,newText)}else{if(typeof newText!="string"&&workInProgress2.stateNode===null)throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");var _rootContainerInstance=getRootHostContainer(),_currentHostContext=getHostContext(),_wasHydrated2=popHydrationState(workInProgress2);_wasHydrated2?prepareToHydrateHostTextInstance(workInProgress2)&&markUpdate(workInProgress2):workInProgress2.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext,workInProgress2)}return bubbleProperties(workInProgress2),null}case SuspenseComponent:{popSuspenseContext(workInProgress2);var nextState=workInProgress2.memoizedState;{if(hasUnhydratedTailNodes()&&(workInProgress2.mode&ConcurrentMode)!==NoMode&&(workInProgress2.flags&DidCapture)===NoFlags)return warnIfUnhydratedTailNodes(workInProgress2),resetHydrationState(),workInProgress2.flags|=ForceClientRender|Incomplete|ShouldCapture,workInProgress2;if(nextState!==null&&nextState.dehydrated!==null){var _wasHydrated3=popHydrationState(workInProgress2);if(current2===null){if(!_wasHydrated3)throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");if(prepareToHydrateHostSuspenseInstance(workInProgress2),bubbleProperties(workInProgress2),(workInProgress2.mode&ProfileMode)!==NoMode){var isTimedOutSuspense=nextState!==null;if(isTimedOutSuspense){var primaryChildFragment=workInProgress2.child;primaryChildFragment!==null&&(workInProgress2.treeBaseDuration-=primaryChildFragment.treeBaseDuration)}}return null}else{if(resetHydrationState(),(workInProgress2.flags&DidCapture)===NoFlags&&(workInProgress2.memoizedState=null),workInProgress2.flags|=Update,bubbleProperties(workInProgress2),(workInProgress2.mode&ProfileMode)!==NoMode){var _isTimedOutSuspense=nextState!==null;if(_isTimedOutSuspense){var _primaryChildFragment=workInProgress2.child;_primaryChildFragment!==null&&(workInProgress2.treeBaseDuration-=_primaryChildFragment.treeBaseDuration)}}return null}}upgradeHydrationErrorsToRecoverable()}if((workInProgress2.flags&DidCapture)!==NoFlags)return workInProgress2.lanes=renderLanes2,(workInProgress2.mode&ProfileMode)!==NoMode&&transferActualDuration(workInProgress2),workInProgress2;var nextDidTimeout=nextState!==null,prevDidTimeout=!1;if(current2===null)popHydrationState(workInProgress2);else{var _prevState=current2.memoizedState;prevDidTimeout=_prevState!==null}if(nextDidTimeout&&!prevDidTimeout){var _offscreenFiber=workInProgress2.child;if(_offscreenFiber.flags|=Visibility,(workInProgress2.mode&ConcurrentMode)!==NoMode){var hasInvisibleChildContext=current2===null&&(workInProgress2.memoizedProps.unstable_avoidThisFallback!==!0||!enableSuspenseAvoidThisFallback);hasInvisibleChildContext||hasSuspenseContext(suspenseStackCursor.current,InvisibleParentSuspenseContext)?renderDidSuspend():renderDidSuspendDelayIfPossible()}}var wakeables=workInProgress2.updateQueue;if(wakeables!==null&&(workInProgress2.flags|=Update),bubbleProperties(workInProgress2),(workInProgress2.mode&ProfileMode)!==NoMode&&nextDidTimeout){var _primaryChildFragment2=workInProgress2.child;_primaryChildFragment2!==null&&(workInProgress2.treeBaseDuration-=_primaryChildFragment2.treeBaseDuration)}return null}case HostPortal:return popHostContainer(workInProgress2),updateHostContainer(current2,workInProgress2),current2===null&&preparePortalMount(workInProgress2.stateNode.containerInfo),bubbleProperties(workInProgress2),null;case ContextProvider:var context2=workInProgress2.type._context;return popProvider(context2,workInProgress2),bubbleProperties(workInProgress2),null;case IncompleteClassComponent:{var _Component=workInProgress2.type;return isContextProvider(_Component)&&popContext(workInProgress2),bubbleProperties(workInProgress2),null}case SuspenseListComponent:{popSuspenseContext(workInProgress2);var renderState=workInProgress2.memoizedState;if(renderState===null)return bubbleProperties(workInProgress2),null;var didSuspendAlready=(workInProgress2.flags&DidCapture)!==NoFlags,renderedTail=renderState.rendering;if(renderedTail===null)if(didSuspendAlready)cutOffTailIfNeeded(renderState,!1);else{var cannotBeSuspended=renderHasNotSuspendedYet()&&(current2===null||(current2.flags&DidCapture)===NoFlags);if(!cannotBeSuspended)for(var row=workInProgress2.child;row!==null;){var suspended=findFirstSuspended(row);if(suspended!==null){didSuspendAlready=!0,workInProgress2.flags|=DidCapture,cutOffTailIfNeeded(renderState,!1);var newThenables=suspended.updateQueue;return newThenables!==null&&(workInProgress2.updateQueue=newThenables,workInProgress2.flags|=Update),workInProgress2.subtreeFlags=NoFlags,resetChildFibers(workInProgress2,renderLanes2),pushSuspenseContext(workInProgress2,setShallowSuspenseContext(suspenseStackCursor.current,ForceSuspenseFallback)),workInProgress2.child}row=row.sibling}renderState.tail!==null&&now$1()>getRenderTargetTime()&&(workInProgress2.flags|=DidCapture,didSuspendAlready=!0,cutOffTailIfNeeded(renderState,!1),workInProgress2.lanes=SomeRetryLane)}else{if(!didSuspendAlready){var _suspended=findFirstSuspended(renderedTail);if(_suspended!==null){workInProgress2.flags|=DidCapture,didSuspendAlready=!0;var _newThenables=_suspended.updateQueue;if(_newThenables!==null&&(workInProgress2.updateQueue=_newThenables,workInProgress2.flags|=Update),cutOffTailIfNeeded(renderState,!0),renderState.tail===null&&renderState.tailMode==="hidden"&&!renderedTail.alternate&&!getIsHydrating())return bubbleProperties(workInProgress2),null}else now$1()*2-renderState.renderingStartTime>getRenderTargetTime()&&renderLanes2!==OffscreenLane&&(workInProgress2.flags|=DidCapture,didSuspendAlready=!0,cutOffTailIfNeeded(renderState,!1),workInProgress2.lanes=SomeRetryLane)}if(renderState.isBackwards)renderedTail.sibling=workInProgress2.child,workInProgress2.child=renderedTail;else{var previousSibling=renderState.last;previousSibling!==null?previousSibling.sibling=renderedTail:workInProgress2.child=renderedTail,renderState.last=renderedTail}}if(renderState.tail!==null){var next=renderState.tail;renderState.rendering=next,renderState.tail=next.sibling,renderState.renderingStartTime=now$1(),next.sibling=null;var suspenseContext=suspenseStackCursor.current;return didSuspendAlready?suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback):suspenseContext=setDefaultShallowSuspenseContext(suspenseContext),pushSuspenseContext(workInProgress2,suspenseContext),next}return bubbleProperties(workInProgress2),null}case ScopeComponent:break;case OffscreenComponent:case LegacyHiddenComponent:{popRenderLanes(workInProgress2);var _nextState=workInProgress2.memoizedState,nextIsHidden=_nextState!==null;if(current2!==null){var _prevState2=current2.memoizedState,prevIsHidden=_prevState2!==null;prevIsHidden!==nextIsHidden&&!enableLegacyHidden&&(workInProgress2.flags|=Visibility)}return!nextIsHidden||(workInProgress2.mode&ConcurrentMode)===NoMode?bubbleProperties(workInProgress2):includesSomeLane(subtreeRenderLanes,OffscreenLane)&&(bubbleProperties(workInProgress2),supportsMutation&&workInProgress2.subtreeFlags&(Placement|Update)&&(workInProgress2.flags|=Visibility)),null}case CacheComponent:return null;case TracingMarkerComponent:return null}throw new Error("Unknown unit of work tag ("+workInProgress2.tag+"). This error is likely caused by a bug in React. Please file an issue.")}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner,didReceiveUpdate=!1,didWarnAboutBadClass,didWarnAboutModulePatternComponent,didWarnAboutContextTypeOnFunctionComponent,didWarnAboutGetDerivedStateOnFunctionComponent,didWarnAboutFunctionRefs,didWarnAboutReassigningProps,didWarnAboutRevealOrder,didWarnAboutTailOptions;didWarnAboutBadClass={},didWarnAboutModulePatternComponent={},didWarnAboutContextTypeOnFunctionComponent={},didWarnAboutGetDerivedStateOnFunctionComponent={},didWarnAboutFunctionRefs={},didWarnAboutReassigningProps=!1,didWarnAboutRevealOrder={},didWarnAboutTailOptions={};function reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2){current2===null?workInProgress2.child=mountChildFibers(workInProgress2,null,nextChildren,renderLanes2):workInProgress2.child=reconcileChildFibers(workInProgress2,current2.child,nextChildren,renderLanes2)}function forceUnmountCurrentAndReconcile(current2,workInProgress2,nextChildren,renderLanes2){workInProgress2.child=reconcileChildFibers(workInProgress2,current2.child,null,renderLanes2),workInProgress2.child=reconcileChildFibers(workInProgress2,null,nextChildren,renderLanes2)}function updateForwardRef(current2,workInProgress2,Component,nextProps,renderLanes2){if(workInProgress2.type!==workInProgress2.elementType){var innerPropTypes=Component.propTypes;innerPropTypes&&checkPropTypes(innerPropTypes,nextProps,"prop",getComponentNameFromType(Component))}var render=Component.render,ref=workInProgress2.ref,nextChildren,hasId;prepareToReadContext(workInProgress2,renderLanes2),markComponentRenderStarted(workInProgress2);{if(ReactCurrentOwner$1.current=workInProgress2,setIsRendering(!0),nextChildren=renderWithHooks(current2,workInProgress2,render,nextProps,ref,renderLanes2),hasId=checkDidRenderIdHook(),workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{nextChildren=renderWithHooks(current2,workInProgress2,render,nextProps,ref,renderLanes2),hasId=checkDidRenderIdHook()}finally{setIsStrictModeForDevtools(!1)}}setIsRendering(!1)}return markComponentRenderStopped(),current2!==null&&!didReceiveUpdate?(bailoutHooks(current2,workInProgress2,renderLanes2),bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2)):(getIsHydrating()&&hasId&&pushMaterializedTreeId(workInProgress2),workInProgress2.flags|=PerformedWork,reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child)}function updateMemoComponent(current2,workInProgress2,Component,nextProps,renderLanes2){if(current2===null){var type=Component.type;if(isSimpleFunctionComponent(type)&&Component.compare===null&&Component.defaultProps===void 0){var resolvedType=type;return resolvedType=resolveFunctionForHotReloading(type),workInProgress2.tag=SimpleMemoComponent,workInProgress2.type=resolvedType,validateFunctionComponentInDev(workInProgress2,type),updateSimpleMemoComponent(current2,workInProgress2,resolvedType,nextProps,renderLanes2)}{var innerPropTypes=type.propTypes;innerPropTypes&&checkPropTypes(innerPropTypes,nextProps,"prop",getComponentNameFromType(type))}var child=createFiberFromTypeAndProps(Component.type,null,nextProps,workInProgress2,workInProgress2.mode,renderLanes2);return child.ref=workInProgress2.ref,child.return=workInProgress2,workInProgress2.child=child,child}{var _type=Component.type,_innerPropTypes=_type.propTypes;_innerPropTypes&&checkPropTypes(_innerPropTypes,nextProps,"prop",getComponentNameFromType(_type))}var currentChild=current2.child,hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current2,renderLanes2);if(!hasScheduledUpdateOrContext){var prevProps=currentChild.memoizedProps,compare=Component.compare;if(compare=compare!==null?compare:shallowEqual,compare(prevProps,nextProps)&&current2.ref===workInProgress2.ref)return bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2)}workInProgress2.flags|=PerformedWork;var newChild=createWorkInProgress(currentChild,nextProps);return newChild.ref=workInProgress2.ref,newChild.return=workInProgress2,workInProgress2.child=newChild,newChild}function updateSimpleMemoComponent(current2,workInProgress2,Component,nextProps,renderLanes2){if(workInProgress2.type!==workInProgress2.elementType){var outerMemoType=workInProgress2.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){var lazyComponent=outerMemoType,payload=lazyComponent._payload,init=lazyComponent._init;try{outerMemoType=init(payload)}catch{outerMemoType=null}var outerPropTypes=outerMemoType&&outerMemoType.propTypes;outerPropTypes&&checkPropTypes(outerPropTypes,nextProps,"prop",getComponentNameFromType(outerMemoType))}}if(current2!==null){var prevProps=current2.memoizedProps;if(shallowEqual(prevProps,nextProps)&&current2.ref===workInProgress2.ref&&workInProgress2.type===current2.type)if(didReceiveUpdate=!1,checkScheduledUpdateOrContext(current2,renderLanes2))(current2.flags&ForceUpdateForLegacySuspense)!==NoFlags&&(didReceiveUpdate=!0);else return workInProgress2.lanes=current2.lanes,bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2)}return updateFunctionComponent(current2,workInProgress2,Component,nextProps,renderLanes2)}function updateOffscreenComponent(current2,workInProgress2,renderLanes2){var nextProps=workInProgress2.pendingProps,nextChildren=nextProps.children,prevState=current2!==null?current2.memoizedState:null;if(nextProps.mode==="hidden"||enableLegacyHidden)if((workInProgress2.mode&ConcurrentMode)===NoMode){var nextState={baseLanes:NoLanes,cachePool:null};workInProgress2.memoizedState=nextState,pushRenderLanes(workInProgress2,renderLanes2)}else if(includesSomeLane(renderLanes2,OffscreenLane)){var _nextState2={baseLanes:NoLanes,cachePool:null};workInProgress2.memoizedState=_nextState2;var subtreeRenderLanes2=prevState!==null?prevState.baseLanes:renderLanes2;pushRenderLanes(workInProgress2,subtreeRenderLanes2)}else{var spawnedCachePool=null,nextBaseLanes;if(prevState!==null){var prevBaseLanes=prevState.baseLanes;nextBaseLanes=mergeLanes(prevBaseLanes,renderLanes2)}else nextBaseLanes=renderLanes2;workInProgress2.lanes=workInProgress2.childLanes=OffscreenLane;var _nextState={baseLanes:nextBaseLanes,cachePool:spawnedCachePool};return workInProgress2.memoizedState=_nextState,workInProgress2.updateQueue=null,pushRenderLanes(workInProgress2,nextBaseLanes),null}else{var _subtreeRenderLanes;prevState!==null?(_subtreeRenderLanes=mergeLanes(prevState.baseLanes,renderLanes2),workInProgress2.memoizedState=null):_subtreeRenderLanes=renderLanes2,pushRenderLanes(workInProgress2,_subtreeRenderLanes)}return reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child}function updateFragment(current2,workInProgress2,renderLanes2){var nextChildren=workInProgress2.pendingProps;return reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child}function updateMode(current2,workInProgress2,renderLanes2){var nextChildren=workInProgress2.pendingProps.children;return reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child}function updateProfiler(current2,workInProgress2,renderLanes2){{workInProgress2.flags|=Update;{var stateNode=workInProgress2.stateNode;stateNode.effectDuration=0,stateNode.passiveEffectDuration=0}}var nextProps=workInProgress2.pendingProps,nextChildren=nextProps.children;return reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child}function markRef$1(current2,workInProgress2){var ref=workInProgress2.ref;(current2===null&&ref!==null||current2!==null&&current2.ref!==ref)&&(workInProgress2.flags|=Ref,workInProgress2.flags|=RefStatic)}function updateFunctionComponent(current2,workInProgress2,Component,nextProps,renderLanes2){if(workInProgress2.type!==workInProgress2.elementType){var innerPropTypes=Component.propTypes;innerPropTypes&&checkPropTypes(innerPropTypes,nextProps,"prop",getComponentNameFromType(Component))}var context2;{var unmaskedContext=getUnmaskedContext(workInProgress2,Component,!0);context2=getMaskedContext(workInProgress2,unmaskedContext)}var nextChildren,hasId;prepareToReadContext(workInProgress2,renderLanes2),markComponentRenderStarted(workInProgress2);{if(ReactCurrentOwner$1.current=workInProgress2,setIsRendering(!0),nextChildren=renderWithHooks(current2,workInProgress2,Component,nextProps,context2,renderLanes2),hasId=checkDidRenderIdHook(),workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{nextChildren=renderWithHooks(current2,workInProgress2,Component,nextProps,context2,renderLanes2),hasId=checkDidRenderIdHook()}finally{setIsStrictModeForDevtools(!1)}}setIsRendering(!1)}return markComponentRenderStopped(),current2!==null&&!didReceiveUpdate?(bailoutHooks(current2,workInProgress2,renderLanes2),bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2)):(getIsHydrating()&&hasId&&pushMaterializedTreeId(workInProgress2),workInProgress2.flags|=PerformedWork,reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child)}function updateClassComponent(current2,workInProgress2,Component,nextProps,renderLanes2){{switch(shouldError(workInProgress2)){case!1:{var _instance=workInProgress2.stateNode,ctor=workInProgress2.type,tempInstance=new ctor(workInProgress2.memoizedProps,_instance.context),state=tempInstance.state;_instance.updater.enqueueSetState(_instance,state,null);break}case!0:{workInProgress2.flags|=DidCapture,workInProgress2.flags|=ShouldCapture;var error$1=new Error("Simulated error coming from DevTools"),lane=pickArbitraryLane(renderLanes2);workInProgress2.lanes=mergeLanes(workInProgress2.lanes,lane);var update=createClassErrorUpdate(workInProgress2,createCapturedValue(error$1,workInProgress2),lane);enqueueCapturedUpdate(workInProgress2,update);break}}if(workInProgress2.type!==workInProgress2.elementType){var innerPropTypes=Component.propTypes;innerPropTypes&&checkPropTypes(innerPropTypes,nextProps,"prop",getComponentNameFromType(Component))}}var hasContext;isContextProvider(Component)?(hasContext=!0,pushContextProvider(workInProgress2)):hasContext=!1,prepareToReadContext(workInProgress2,renderLanes2);var instance=workInProgress2.stateNode,shouldUpdate;instance===null?(current2!==null&&(current2.alternate=null,workInProgress2.alternate=null,workInProgress2.flags|=Placement),constructClassInstance(workInProgress2,Component,nextProps),mountClassInstance(workInProgress2,Component,nextProps,renderLanes2),shouldUpdate=!0):current2===null?shouldUpdate=resumeMountClassInstance(workInProgress2,Component,nextProps,renderLanes2):shouldUpdate=updateClassInstance(current2,workInProgress2,Component,nextProps,renderLanes2);var nextUnitOfWork=finishClassComponent(current2,workInProgress2,Component,shouldUpdate,hasContext,renderLanes2);{var inst=workInProgress2.stateNode;shouldUpdate&&inst.props!==nextProps&&(didWarnAboutReassigningProps||error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",getComponentNameFromFiber(workInProgress2)||"a component"),didWarnAboutReassigningProps=!0)}return nextUnitOfWork}function finishClassComponent(current2,workInProgress2,Component,shouldUpdate,hasContext,renderLanes2){markRef$1(current2,workInProgress2);var didCaptureError=(workInProgress2.flags&DidCapture)!==NoFlags;if(!shouldUpdate&&!didCaptureError)return hasContext&&invalidateContextProvider(workInProgress2,Component,!1),bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2);var instance=workInProgress2.stateNode;ReactCurrentOwner$1.current=workInProgress2;var nextChildren;if(didCaptureError&&typeof Component.getDerivedStateFromError!="function")nextChildren=null,stopProfilerTimerIfRunning();else{markComponentRenderStarted(workInProgress2);{if(setIsRendering(!0),nextChildren=instance.render(),workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{instance.render()}finally{setIsStrictModeForDevtools(!1)}}setIsRendering(!1)}markComponentRenderStopped()}return workInProgress2.flags|=PerformedWork,current2!==null&&didCaptureError?forceUnmountCurrentAndReconcile(current2,workInProgress2,nextChildren,renderLanes2):reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.memoizedState=instance.state,hasContext&&invalidateContextProvider(workInProgress2,Component,!0),workInProgress2.child}function pushHostRootContext(workInProgress2){var root=workInProgress2.stateNode;root.pendingContext?pushTopLevelContextObject(workInProgress2,root.pendingContext,root.pendingContext!==root.context):root.context&&pushTopLevelContextObject(workInProgress2,root.context,!1),pushHostContainer(workInProgress2,root.containerInfo)}function updateHostRoot(current2,workInProgress2,renderLanes2){if(pushHostRootContext(workInProgress2),current2===null)throw new Error("Should have a current fiber. This is a bug in React.");var nextProps=workInProgress2.pendingProps,prevState=workInProgress2.memoizedState,prevChildren=prevState.element;cloneUpdateQueue(current2,workInProgress2),processUpdateQueue(workInProgress2,nextProps,null,renderLanes2);var nextState=workInProgress2.memoizedState;workInProgress2.stateNode;var nextChildren=nextState.element;if(supportsHydration&&prevState.isDehydrated){var overrideState={element:nextChildren,isDehydrated:!1,cache:nextState.cache,transitions:nextState.transitions},updateQueue=workInProgress2.updateQueue;if(updateQueue.baseState=overrideState,workInProgress2.memoizedState=overrideState,workInProgress2.flags&ForceClientRender){var recoverableError=new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering.");return mountHostRootWithoutHydrating(current2,workInProgress2,nextChildren,renderLanes2,recoverableError)}else if(nextChildren!==prevChildren){var _recoverableError=new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering.");return mountHostRootWithoutHydrating(current2,workInProgress2,nextChildren,renderLanes2,_recoverableError)}else{enterHydrationState(workInProgress2);var child=mountChildFibers(workInProgress2,null,nextChildren,renderLanes2);workInProgress2.child=child;for(var node=child;node;)node.flags=node.flags&~Placement|Hydrating,node=node.sibling}}else{if(resetHydrationState(),nextChildren===prevChildren)return bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2);reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2)}return workInProgress2.child}function mountHostRootWithoutHydrating(current2,workInProgress2,nextChildren,renderLanes2,recoverableError){return resetHydrationState(),queueHydrationError(recoverableError),workInProgress2.flags|=ForceClientRender,reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child}function updateHostComponent$1(current2,workInProgress2,renderLanes2){pushHostContext(workInProgress2),current2===null&&tryToClaimNextHydratableInstance(workInProgress2);var type=workInProgress2.type,nextProps=workInProgress2.pendingProps,prevProps=current2!==null?current2.memoizedProps:null,nextChildren=nextProps.children,isDirectTextChild=shouldSetTextContent(type,nextProps);return isDirectTextChild?nextChildren=null:prevProps!==null&&shouldSetTextContent(type,prevProps)&&(workInProgress2.flags|=ContentReset),markRef$1(current2,workInProgress2),reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child}function updateHostText$1(current2,workInProgress2){return current2===null&&tryToClaimNextHydratableInstance(workInProgress2),null}function mountLazyComponent(_current,workInProgress2,elementType,renderLanes2){_current!==null&&(_current.alternate=null,workInProgress2.alternate=null,workInProgress2.flags|=Placement);var props=workInProgress2.pendingProps,lazyComponent=elementType,payload=lazyComponent._payload,init=lazyComponent._init,Component=init(payload);workInProgress2.type=Component;var resolvedTag=workInProgress2.tag=resolveLazyComponentTag(Component),resolvedProps=resolveDefaultProps(Component,props),child;switch(resolvedTag){case FunctionComponent:return validateFunctionComponentInDev(workInProgress2,Component),workInProgress2.type=Component=resolveFunctionForHotReloading(Component),child=updateFunctionComponent(null,workInProgress2,Component,resolvedProps,renderLanes2),child;case ClassComponent:return workInProgress2.type=Component=resolveClassForHotReloading(Component),child=updateClassComponent(null,workInProgress2,Component,resolvedProps,renderLanes2),child;case ForwardRef:return workInProgress2.type=Component=resolveForwardRefForHotReloading(Component),child=updateForwardRef(null,workInProgress2,Component,resolvedProps,renderLanes2),child;case MemoComponent:{if(workInProgress2.type!==workInProgress2.elementType){var outerPropTypes=Component.propTypes;outerPropTypes&&checkPropTypes(outerPropTypes,resolvedProps,"prop",getComponentNameFromType(Component))}return child=updateMemoComponent(null,workInProgress2,Component,resolveDefaultProps(Component.type,resolvedProps),renderLanes2),child}}var hint="";throw Component!==null&&typeof Component=="object"&&Component.$$typeof===REACT_LAZY_TYPE&&(hint=" Did you wrap a component in React.lazy() more than once?"),new Error("Element type is invalid. Received a promise that resolves to: "+Component+". "+("Lazy element type must resolve to a class or function."+hint))}function mountIncompleteClassComponent(_current,workInProgress2,Component,nextProps,renderLanes2){_current!==null&&(_current.alternate=null,workInProgress2.alternate=null,workInProgress2.flags|=Placement),workInProgress2.tag=ClassComponent;var hasContext;return isContextProvider(Component)?(hasContext=!0,pushContextProvider(workInProgress2)):hasContext=!1,prepareToReadContext(workInProgress2,renderLanes2),constructClassInstance(workInProgress2,Component,nextProps),mountClassInstance(workInProgress2,Component,nextProps,renderLanes2),finishClassComponent(null,workInProgress2,Component,!0,hasContext,renderLanes2)}function mountIndeterminateComponent(_current,workInProgress2,Component,renderLanes2){_current!==null&&(_current.alternate=null,workInProgress2.alternate=null,workInProgress2.flags|=Placement);var props=workInProgress2.pendingProps,context2;{var unmaskedContext=getUnmaskedContext(workInProgress2,Component,!1);context2=getMaskedContext(workInProgress2,unmaskedContext)}prepareToReadContext(workInProgress2,renderLanes2);var value,hasId;markComponentRenderStarted(workInProgress2);{if(Component.prototype&&typeof Component.prototype.render=="function"){var componentName=getComponentNameFromType(Component)||"Unknown";didWarnAboutBadClass[componentName]||(error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",componentName,componentName),didWarnAboutBadClass[componentName]=!0)}workInProgress2.mode&StrictLegacyMode&&ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2,null),setIsRendering(!0),ReactCurrentOwner$1.current=workInProgress2,value=renderWithHooks(null,workInProgress2,Component,props,context2,renderLanes2),hasId=checkDidRenderIdHook(),setIsRendering(!1)}if(markComponentRenderStopped(),workInProgress2.flags|=PerformedWork,typeof value=="object"&&value!==null&&typeof value.render=="function"&&value.$$typeof===void 0){var _componentName=getComponentNameFromType(Component)||"Unknown";didWarnAboutModulePatternComponent[_componentName]||(error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",_componentName,_componentName,_componentName),didWarnAboutModulePatternComponent[_componentName]=!0)}if(typeof value=="object"&&value!==null&&typeof value.render=="function"&&value.$$typeof===void 0){{var _componentName2=getComponentNameFromType(Component)||"Unknown";didWarnAboutModulePatternComponent[_componentName2]||(error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",_componentName2,_componentName2,_componentName2),didWarnAboutModulePatternComponent[_componentName2]=!0)}workInProgress2.tag=ClassComponent,workInProgress2.memoizedState=null,workInProgress2.updateQueue=null;var hasContext=!1;return isContextProvider(Component)?(hasContext=!0,pushContextProvider(workInProgress2)):hasContext=!1,workInProgress2.memoizedState=value.state!==null&&value.state!==void 0?value.state:null,initializeUpdateQueue(workInProgress2),adoptClassInstance(workInProgress2,value),mountClassInstance(workInProgress2,Component,props,renderLanes2),finishClassComponent(null,workInProgress2,Component,!0,hasContext,renderLanes2)}else{if(workInProgress2.tag=FunctionComponent,workInProgress2.mode&StrictLegacyMode){setIsStrictModeForDevtools(!0);try{value=renderWithHooks(null,workInProgress2,Component,props,context2,renderLanes2),hasId=checkDidRenderIdHook()}finally{setIsStrictModeForDevtools(!1)}}return getIsHydrating()&&hasId&&pushMaterializedTreeId(workInProgress2),reconcileChildren(null,workInProgress2,value,renderLanes2),validateFunctionComponentInDev(workInProgress2,Component),workInProgress2.child}}function validateFunctionComponentInDev(workInProgress2,Component){{if(Component&&Component.childContextTypes&&error("%s(...): childContextTypes cannot be defined on a function component.",Component.displayName||Component.name||"Component"),workInProgress2.ref!==null){var info="",ownerName=getCurrentFiberOwnerNameInDevOrNull();ownerName&&(info+=`

Check the render method of \``+ownerName+"`.");var warningKey=ownerName||"",debugSource=workInProgress2._debugSource;debugSource&&(warningKey=debugSource.fileName+":"+debugSource.lineNumber),didWarnAboutFunctionRefs[warningKey]||(didWarnAboutFunctionRefs[warningKey]=!0,error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s",info))}if(typeof Component.getDerivedStateFromProps=="function"){var _componentName3=getComponentNameFromType(Component)||"Unknown";didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]||(error("%s: Function components do not support getDerivedStateFromProps.",_componentName3),didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]=!0)}if(typeof Component.contextType=="object"&&Component.contextType!==null){var _componentName4=getComponentNameFromType(Component)||"Unknown";didWarnAboutContextTypeOnFunctionComponent[_componentName4]||(error("%s: Function components do not support contextType.",_componentName4),didWarnAboutContextTypeOnFunctionComponent[_componentName4]=!0)}}}var SUSPENDED_MARKER={dehydrated:null,treeContext:null,retryLane:NoLane};function mountSuspenseOffscreenState(renderLanes2){return{baseLanes:renderLanes2,cachePool:getSuspendedCache()}}function updateSuspenseOffscreenState(prevOffscreenState,renderLanes2){var cachePool=null;return{baseLanes:mergeLanes(prevOffscreenState.baseLanes,renderLanes2),cachePool}}function shouldRemainOnFallback(suspenseContext,current2,workInProgress2,renderLanes2){if(current2!==null){var suspenseState=current2.memoizedState;if(suspenseState===null)return!1}return hasSuspenseContext(suspenseContext,ForceSuspenseFallback)}function getRemainingWorkInPrimaryTree(current2,renderLanes2){return removeLanes(current2.childLanes,renderLanes2)}function updateSuspenseComponent(current2,workInProgress2,renderLanes2){var nextProps=workInProgress2.pendingProps;shouldSuspend(workInProgress2)&&(workInProgress2.flags|=DidCapture);var suspenseContext=suspenseStackCursor.current,showFallback=!1,didSuspend2=(workInProgress2.flags&DidCapture)!==NoFlags;if(didSuspend2||shouldRemainOnFallback(suspenseContext,current2)?(showFallback=!0,workInProgress2.flags&=~DidCapture):(current2===null||current2.memoizedState!==null)&&(suspenseContext=addSubtreeSuspenseContext(suspenseContext,InvisibleParentSuspenseContext)),suspenseContext=setDefaultShallowSuspenseContext(suspenseContext),pushSuspenseContext(workInProgress2,suspenseContext),current2===null){tryToClaimNextHydratableInstance(workInProgress2);{var suspenseState=workInProgress2.memoizedState;if(suspenseState!==null){var dehydrated=suspenseState.dehydrated;if(dehydrated!==null)return mountDehydratedSuspenseComponent(workInProgress2,dehydrated)}}var nextPrimaryChildren=nextProps.children,nextFallbackChildren=nextProps.fallback;if(showFallback){var fallbackFragment=mountSuspenseFallbackChildren(workInProgress2,nextPrimaryChildren,nextFallbackChildren,renderLanes2),primaryChildFragment=workInProgress2.child;return primaryChildFragment.memoizedState=mountSuspenseOffscreenState(renderLanes2),workInProgress2.memoizedState=SUSPENDED_MARKER,fallbackFragment}else return mountSuspensePrimaryChildren(workInProgress2,nextPrimaryChildren)}else{var prevState=current2.memoizedState;if(prevState!==null){{var _dehydrated=prevState.dehydrated;if(_dehydrated!==null)if(didSuspend2){if(workInProgress2.flags&ForceClientRender)return workInProgress2.flags&=~ForceClientRender,retrySuspenseComponentWithoutHydrating(current2,workInProgress2,renderLanes2,new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));if(workInProgress2.memoizedState!==null)return workInProgress2.child=current2.child,workInProgress2.flags|=DidCapture,null;var _nextPrimaryChildren=nextProps.children,_nextFallbackChildren=nextProps.fallback,fallbackChildFragment=mountSuspenseFallbackAfterRetryWithoutHydrating(current2,workInProgress2,_nextPrimaryChildren,_nextFallbackChildren,renderLanes2),_primaryChildFragment2=workInProgress2.child;return _primaryChildFragment2.memoizedState=mountSuspenseOffscreenState(renderLanes2),workInProgress2.memoizedState=SUSPENDED_MARKER,fallbackChildFragment}else return updateDehydratedSuspenseComponent(current2,workInProgress2,_dehydrated,prevState,renderLanes2)}if(showFallback){var _nextFallbackChildren2=nextProps.fallback,_nextPrimaryChildren2=nextProps.children,_fallbackChildFragment=updateSuspenseFallbackChildren(current2,workInProgress2,_nextPrimaryChildren2,_nextFallbackChildren2,renderLanes2),_primaryChildFragment3=workInProgress2.child,prevOffscreenState=current2.child.memoizedState;return _primaryChildFragment3.memoizedState=prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes2):updateSuspenseOffscreenState(prevOffscreenState,renderLanes2),_primaryChildFragment3.childLanes=getRemainingWorkInPrimaryTree(current2,renderLanes2),workInProgress2.memoizedState=SUSPENDED_MARKER,_fallbackChildFragment}else{var _nextPrimaryChildren3=nextProps.children,_primaryChildFragment4=updateSuspensePrimaryChildren(current2,workInProgress2,_nextPrimaryChildren3,renderLanes2);return workInProgress2.memoizedState=null,_primaryChildFragment4}}else if(showFallback){var _nextFallbackChildren3=nextProps.fallback,_nextPrimaryChildren4=nextProps.children,_fallbackChildFragment2=updateSuspenseFallbackChildren(current2,workInProgress2,_nextPrimaryChildren4,_nextFallbackChildren3,renderLanes2),_primaryChildFragment5=workInProgress2.child,_prevOffscreenState=current2.child.memoizedState;return _primaryChildFragment5.memoizedState=_prevOffscreenState===null?mountSuspenseOffscreenState(renderLanes2):updateSuspenseOffscreenState(_prevOffscreenState,renderLanes2),_primaryChildFragment5.childLanes=getRemainingWorkInPrimaryTree(current2,renderLanes2),workInProgress2.memoizedState=SUSPENDED_MARKER,_fallbackChildFragment2}else{var _nextPrimaryChildren5=nextProps.children,_primaryChildFragment6=updateSuspensePrimaryChildren(current2,workInProgress2,_nextPrimaryChildren5,renderLanes2);return workInProgress2.memoizedState=null,_primaryChildFragment6}}}function mountSuspensePrimaryChildren(workInProgress2,primaryChildren,renderLanes2){var mode=workInProgress2.mode,primaryChildProps={mode:"visible",children:primaryChildren},primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode);return primaryChildFragment.return=workInProgress2,workInProgress2.child=primaryChildFragment,primaryChildFragment}function mountSuspenseFallbackChildren(workInProgress2,primaryChildren,fallbackChildren,renderLanes2){var mode=workInProgress2.mode,progressedPrimaryFragment=workInProgress2.child,primaryChildProps={mode:"hidden",children:primaryChildren},primaryChildFragment,fallbackChildFragment;return(mode&ConcurrentMode)===NoMode&&progressedPrimaryFragment!==null?(primaryChildFragment=progressedPrimaryFragment,primaryChildFragment.childLanes=NoLanes,primaryChildFragment.pendingProps=primaryChildProps,workInProgress2.mode&ProfileMode&&(primaryChildFragment.actualDuration=0,primaryChildFragment.actualStartTime=-1,primaryChildFragment.selfBaseDuration=0,primaryChildFragment.treeBaseDuration=0),fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes2,null)):(primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,mode),fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes2,null)),primaryChildFragment.return=workInProgress2,fallbackChildFragment.return=workInProgress2,primaryChildFragment.sibling=fallbackChildFragment,workInProgress2.child=primaryChildFragment,fallbackChildFragment}function mountWorkInProgressOffscreenFiber(offscreenProps,mode,renderLanes2){return createFiberFromOffscreen(offscreenProps,mode,NoLanes,null)}function updateWorkInProgressOffscreenFiber(current2,offscreenProps){return createWorkInProgress(current2,offscreenProps)}function updateSuspensePrimaryChildren(current2,workInProgress2,primaryChildren,renderLanes2){var currentPrimaryChildFragment=current2.child,currentFallbackChildFragment=currentPrimaryChildFragment.sibling,primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,{mode:"visible",children:primaryChildren});if((workInProgress2.mode&ConcurrentMode)===NoMode&&(primaryChildFragment.lanes=renderLanes2),primaryChildFragment.return=workInProgress2,primaryChildFragment.sibling=null,currentFallbackChildFragment!==null){var deletions=workInProgress2.deletions;deletions===null?(workInProgress2.deletions=[currentFallbackChildFragment],workInProgress2.flags|=ChildDeletion):deletions.push(currentFallbackChildFragment)}return workInProgress2.child=primaryChildFragment,primaryChildFragment}function updateSuspenseFallbackChildren(current2,workInProgress2,primaryChildren,fallbackChildren,renderLanes2){var mode=workInProgress2.mode,currentPrimaryChildFragment=current2.child,currentFallbackChildFragment=currentPrimaryChildFragment.sibling,primaryChildProps={mode:"hidden",children:primaryChildren},primaryChildFragment;if((mode&ConcurrentMode)===NoMode&&workInProgress2.child!==currentPrimaryChildFragment){var progressedPrimaryFragment=workInProgress2.child;primaryChildFragment=progressedPrimaryFragment,primaryChildFragment.childLanes=NoLanes,primaryChildFragment.pendingProps=primaryChildProps,workInProgress2.mode&ProfileMode&&(primaryChildFragment.actualDuration=0,primaryChildFragment.actualStartTime=-1,primaryChildFragment.selfBaseDuration=currentPrimaryChildFragment.selfBaseDuration,primaryChildFragment.treeBaseDuration=currentPrimaryChildFragment.treeBaseDuration),workInProgress2.deletions=null}else primaryChildFragment=updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment,primaryChildProps),primaryChildFragment.subtreeFlags=currentPrimaryChildFragment.subtreeFlags&StaticMask;var fallbackChildFragment;return currentFallbackChildFragment!==null?fallbackChildFragment=createWorkInProgress(currentFallbackChildFragment,fallbackChildren):(fallbackChildFragment=createFiberFromFragment(fallbackChildren,mode,renderLanes2,null),fallbackChildFragment.flags|=Placement),fallbackChildFragment.return=workInProgress2,primaryChildFragment.return=workInProgress2,primaryChildFragment.sibling=fallbackChildFragment,workInProgress2.child=primaryChildFragment,fallbackChildFragment}function retrySuspenseComponentWithoutHydrating(current2,workInProgress2,renderLanes2,recoverableError){recoverableError!==null&&queueHydrationError(recoverableError),reconcileChildFibers(workInProgress2,current2.child,null,renderLanes2);var nextProps=workInProgress2.pendingProps,primaryChildren=nextProps.children,primaryChildFragment=mountSuspensePrimaryChildren(workInProgress2,primaryChildren);return primaryChildFragment.flags|=Placement,workInProgress2.memoizedState=null,primaryChildFragment}function mountSuspenseFallbackAfterRetryWithoutHydrating(current2,workInProgress2,primaryChildren,fallbackChildren,renderLanes2){var fiberMode=workInProgress2.mode,primaryChildProps={mode:"visible",children:primaryChildren},primaryChildFragment=mountWorkInProgressOffscreenFiber(primaryChildProps,fiberMode),fallbackChildFragment=createFiberFromFragment(fallbackChildren,fiberMode,renderLanes2,null);return fallbackChildFragment.flags|=Placement,primaryChildFragment.return=workInProgress2,fallbackChildFragment.return=workInProgress2,primaryChildFragment.sibling=fallbackChildFragment,workInProgress2.child=primaryChildFragment,(workInProgress2.mode&ConcurrentMode)!==NoMode&&reconcileChildFibers(workInProgress2,current2.child,null,renderLanes2),fallbackChildFragment}function mountDehydratedSuspenseComponent(workInProgress2,suspenseInstance,renderLanes2){return(workInProgress2.mode&ConcurrentMode)===NoMode?(error("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."),workInProgress2.lanes=SyncLane):isSuspenseInstanceFallback(suspenseInstance)?workInProgress2.lanes=DefaultHydrationLane:workInProgress2.lanes=OffscreenLane,null}function updateDehydratedSuspenseComponent(current2,workInProgress2,suspenseInstance,suspenseState,renderLanes2){if(warnIfHydrating(),(workInProgress2.mode&ConcurrentMode)===NoMode)return retrySuspenseComponentWithoutHydrating(current2,workInProgress2,renderLanes2,null);if(isSuspenseInstanceFallback(suspenseInstance))return retrySuspenseComponentWithoutHydrating(current2,workInProgress2,renderLanes2,new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."));var hasContextChanged2=includesSomeLane(renderLanes2,current2.childLanes);if(didReceiveUpdate||hasContextChanged2){var root=getWorkInProgressRoot();if(root!==null){var attemptHydrationAtLane=getBumpedLaneForHydration(root,renderLanes2);if(attemptHydrationAtLane!==NoLane&&attemptHydrationAtLane!==suspenseState.retryLane){suspenseState.retryLane=attemptHydrationAtLane;var eventTime=NoTimestamp;scheduleUpdateOnFiber(current2,attemptHydrationAtLane,eventTime)}}return renderDidSuspendDelayIfPossible(),retrySuspenseComponentWithoutHydrating(current2,workInProgress2,renderLanes2,new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."))}else if(isSuspenseInstancePending(suspenseInstance)){workInProgress2.flags|=DidCapture,workInProgress2.child=current2.child;var retry=retryDehydratedSuspenseBoundary.bind(null,current2);return registerSuspenseInstanceRetry(suspenseInstance,retry),null}else{reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2,suspenseInstance,suspenseState.treeContext);var nextProps=workInProgress2.pendingProps,primaryChildren=nextProps.children,primaryChildFragment=mountSuspensePrimaryChildren(workInProgress2,primaryChildren);return primaryChildFragment.flags|=Hydrating,primaryChildFragment}}function scheduleSuspenseWorkOnFiber(fiber,renderLanes2,propagationRoot){fiber.lanes=mergeLanes(fiber.lanes,renderLanes2);var alternate=fiber.alternate;alternate!==null&&(alternate.lanes=mergeLanes(alternate.lanes,renderLanes2)),scheduleContextWorkOnParentPath(fiber.return,renderLanes2,propagationRoot)}function propagateSuspenseContextChange(workInProgress2,firstChild,renderLanes2){for(var node=firstChild;node!==null;){if(node.tag===SuspenseComponent){var state=node.memoizedState;state!==null&&scheduleSuspenseWorkOnFiber(node,renderLanes2,workInProgress2)}else if(node.tag===SuspenseListComponent)scheduleSuspenseWorkOnFiber(node,renderLanes2,workInProgress2);else if(node.child!==null){node.child.return=node,node=node.child;continue}if(node===workInProgress2)return;for(;node.sibling===null;){if(node.return===null||node.return===workInProgress2)return;node=node.return}node.sibling.return=node.return,node=node.sibling}}function findLastContentRow(firstChild){for(var row=firstChild,lastContentRow=null;row!==null;){var currentRow=row.alternate;currentRow!==null&&findFirstSuspended(currentRow)===null&&(lastContentRow=row),row=row.sibling}return lastContentRow}function validateRevealOrder(revealOrder){if(revealOrder!==void 0&&revealOrder!=="forwards"&&revealOrder!=="backwards"&&revealOrder!=="together"&&!didWarnAboutRevealOrder[revealOrder])if(didWarnAboutRevealOrder[revealOrder]=!0,typeof revealOrder=="string")switch(revealOrder.toLowerCase()){case"together":case"forwards":case"backwards":{error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',revealOrder,revealOrder.toLowerCase());break}case"forward":case"backward":{error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',revealOrder,revealOrder.toLowerCase());break}default:error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',revealOrder);break}else error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',revealOrder)}function validateTailOptions(tailMode,revealOrder){tailMode!==void 0&&!didWarnAboutTailOptions[tailMode]&&(tailMode!=="collapsed"&&tailMode!=="hidden"?(didWarnAboutTailOptions[tailMode]=!0,error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',tailMode)):revealOrder!=="forwards"&&revealOrder!=="backwards"&&(didWarnAboutTailOptions[tailMode]=!0,error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',tailMode)))}function validateSuspenseListNestedChild(childSlot,index2){{var isAnArray=isArray(childSlot),isIterable=!isAnArray&&typeof getIteratorFn(childSlot)=="function";if(isAnArray||isIterable){var type=isAnArray?"array":"iterable";return error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",type,index2,type),!1}}return!0}function validateSuspenseListChildren(children,revealOrder){if((revealOrder==="forwards"||revealOrder==="backwards")&&children!==void 0&&children!==null&&children!==!1)if(isArray(children)){for(var i2=0;i2<children.length;i2++)if(!validateSuspenseListNestedChild(children[i2],i2))return}else{var iteratorFn=getIteratorFn(children);if(typeof iteratorFn=="function"){var childrenIterator=iteratorFn.call(children);if(childrenIterator)for(var step=childrenIterator.next(),_i=0;!step.done;step=childrenIterator.next()){if(!validateSuspenseListNestedChild(step.value,_i))return;_i++}}else error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',revealOrder)}}function initSuspenseListRenderState(workInProgress2,isBackwards,tail,lastContentRow,tailMode){var renderState=workInProgress2.memoizedState;renderState===null?workInProgress2.memoizedState={isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail,tailMode}:(renderState.isBackwards=isBackwards,renderState.rendering=null,renderState.renderingStartTime=0,renderState.last=lastContentRow,renderState.tail=tail,renderState.tailMode=tailMode)}function updateSuspenseListComponent(current2,workInProgress2,renderLanes2){var nextProps=workInProgress2.pendingProps,revealOrder=nextProps.revealOrder,tailMode=nextProps.tail,newChildren=nextProps.children;validateRevealOrder(revealOrder),validateTailOptions(tailMode,revealOrder),validateSuspenseListChildren(newChildren,revealOrder),reconcileChildren(current2,workInProgress2,newChildren,renderLanes2);var suspenseContext=suspenseStackCursor.current,shouldForceFallback=hasSuspenseContext(suspenseContext,ForceSuspenseFallback);if(shouldForceFallback)suspenseContext=setShallowSuspenseContext(suspenseContext,ForceSuspenseFallback),workInProgress2.flags|=DidCapture;else{var didSuspendBefore=current2!==null&&(current2.flags&DidCapture)!==NoFlags;didSuspendBefore&&propagateSuspenseContextChange(workInProgress2,workInProgress2.child,renderLanes2),suspenseContext=setDefaultShallowSuspenseContext(suspenseContext)}if(pushSuspenseContext(workInProgress2,suspenseContext),(workInProgress2.mode&ConcurrentMode)===NoMode)workInProgress2.memoizedState=null;else switch(revealOrder){case"forwards":{var lastContentRow=findLastContentRow(workInProgress2.child),tail;lastContentRow===null?(tail=workInProgress2.child,workInProgress2.child=null):(tail=lastContentRow.sibling,lastContentRow.sibling=null),initSuspenseListRenderState(workInProgress2,!1,tail,lastContentRow,tailMode);break}case"backwards":{var _tail=null,row=workInProgress2.child;for(workInProgress2.child=null;row!==null;){var currentRow=row.alternate;if(currentRow!==null&&findFirstSuspended(currentRow)===null){workInProgress2.child=row;break}var nextRow=row.sibling;row.sibling=_tail,_tail=row,row=nextRow}initSuspenseListRenderState(workInProgress2,!0,_tail,null,tailMode);break}case"together":{initSuspenseListRenderState(workInProgress2,!1,null,null,void 0);break}default:workInProgress2.memoizedState=null}return workInProgress2.child}function updatePortalComponent(current2,workInProgress2,renderLanes2){pushHostContainer(workInProgress2,workInProgress2.stateNode.containerInfo);var nextChildren=workInProgress2.pendingProps;return current2===null?workInProgress2.child=reconcileChildFibers(workInProgress2,null,nextChildren,renderLanes2):reconcileChildren(current2,workInProgress2,nextChildren,renderLanes2),workInProgress2.child}var hasWarnedAboutUsingNoValuePropOnContextProvider=!1;function updateContextProvider(current2,workInProgress2,renderLanes2){var providerType=workInProgress2.type,context2=providerType._context,newProps=workInProgress2.pendingProps,oldProps=workInProgress2.memoizedProps,newValue=newProps.value;{"value"in newProps||hasWarnedAboutUsingNoValuePropOnContextProvider||(hasWarnedAboutUsingNoValuePropOnContextProvider=!0,error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));var providerPropTypes=workInProgress2.type.propTypes;providerPropTypes&&checkPropTypes(providerPropTypes,newProps,"prop","Context.Provider")}if(pushProvider(workInProgress2,context2,newValue),oldProps!==null){var oldValue=oldProps.value;if(objectIs(oldValue,newValue)){if(oldProps.children===newProps.children&&!hasContextChanged())return bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2)}else propagateContextChange(workInProgress2,context2,renderLanes2)}var newChildren=newProps.children;return reconcileChildren(current2,workInProgress2,newChildren,renderLanes2),workInProgress2.child}var hasWarnedAboutUsingContextAsConsumer=!1;function updateContextConsumer(current2,workInProgress2,renderLanes2){var context2=workInProgress2.type;context2._context===void 0?context2!==context2.Consumer&&(hasWarnedAboutUsingContextAsConsumer||(hasWarnedAboutUsingContextAsConsumer=!0,error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))):context2=context2._context;var newProps=workInProgress2.pendingProps,render=newProps.children;typeof render!="function"&&error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."),prepareToReadContext(workInProgress2,renderLanes2);var newValue=readContext(context2);markComponentRenderStarted(workInProgress2);var newChildren;return ReactCurrentOwner$1.current=workInProgress2,setIsRendering(!0),newChildren=render(newValue),setIsRendering(!1),markComponentRenderStopped(),workInProgress2.flags|=PerformedWork,reconcileChildren(current2,workInProgress2,newChildren,renderLanes2),workInProgress2.child}function markWorkInProgressReceivedUpdate(){didReceiveUpdate=!0}function bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2){return current2!==null&&(workInProgress2.dependencies=current2.dependencies),stopProfilerTimerIfRunning(),markSkippedUpdateLanes(workInProgress2.lanes),includesSomeLane(renderLanes2,workInProgress2.childLanes)?(cloneChildFibers(current2,workInProgress2),workInProgress2.child):null}function remountFiber(current2,oldWorkInProgress,newWorkInProgress){{var returnFiber=oldWorkInProgress.return;if(returnFiber===null)throw new Error("Cannot swap the root fiber.");if(current2.alternate=null,oldWorkInProgress.alternate=null,newWorkInProgress.index=oldWorkInProgress.index,newWorkInProgress.sibling=oldWorkInProgress.sibling,newWorkInProgress.return=oldWorkInProgress.return,newWorkInProgress.ref=oldWorkInProgress.ref,oldWorkInProgress===returnFiber.child)returnFiber.child=newWorkInProgress;else{var prevSibling=returnFiber.child;if(prevSibling===null)throw new Error("Expected parent to have a child.");for(;prevSibling.sibling!==oldWorkInProgress;)if(prevSibling=prevSibling.sibling,prevSibling===null)throw new Error("Expected to find the previous sibling.");prevSibling.sibling=newWorkInProgress}var deletions=returnFiber.deletions;return deletions===null?(returnFiber.deletions=[current2],returnFiber.flags|=ChildDeletion):deletions.push(current2),newWorkInProgress.flags|=Placement,newWorkInProgress}}function checkScheduledUpdateOrContext(current2,renderLanes2){var updateLanes=current2.lanes;return!!includesSomeLane(updateLanes,renderLanes2)}function attemptEarlyBailoutIfNoScheduledUpdate(current2,workInProgress2,renderLanes2){switch(workInProgress2.tag){case HostRoot:pushHostRootContext(workInProgress2),workInProgress2.stateNode,resetHydrationState();break;case HostComponent:pushHostContext(workInProgress2);break;case ClassComponent:{var Component=workInProgress2.type;isContextProvider(Component)&&pushContextProvider(workInProgress2);break}case HostPortal:pushHostContainer(workInProgress2,workInProgress2.stateNode.containerInfo);break;case ContextProvider:{var newValue=workInProgress2.memoizedProps.value,context2=workInProgress2.type._context;pushProvider(workInProgress2,context2,newValue);break}case Profiler:{var hasChildWork=includesSomeLane(renderLanes2,workInProgress2.childLanes);hasChildWork&&(workInProgress2.flags|=Update);{var stateNode=workInProgress2.stateNode;stateNode.effectDuration=0,stateNode.passiveEffectDuration=0}}break;case SuspenseComponent:{var state=workInProgress2.memoizedState;if(state!==null){if(state.dehydrated!==null)return pushSuspenseContext(workInProgress2,setDefaultShallowSuspenseContext(suspenseStackCursor.current)),workInProgress2.flags|=DidCapture,null;var primaryChildFragment=workInProgress2.child,primaryChildLanes=primaryChildFragment.childLanes;if(includesSomeLane(renderLanes2,primaryChildLanes))return updateSuspenseComponent(current2,workInProgress2,renderLanes2);pushSuspenseContext(workInProgress2,setDefaultShallowSuspenseContext(suspenseStackCursor.current));var child=bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2);return child!==null?child.sibling:null}else pushSuspenseContext(workInProgress2,setDefaultShallowSuspenseContext(suspenseStackCursor.current));break}case SuspenseListComponent:{var didSuspendBefore=(current2.flags&DidCapture)!==NoFlags,_hasChildWork=includesSomeLane(renderLanes2,workInProgress2.childLanes);if(didSuspendBefore){if(_hasChildWork)return updateSuspenseListComponent(current2,workInProgress2,renderLanes2);workInProgress2.flags|=DidCapture}var renderState=workInProgress2.memoizedState;if(renderState!==null&&(renderState.rendering=null,renderState.tail=null,renderState.lastEffect=null),pushSuspenseContext(workInProgress2,suspenseStackCursor.current),_hasChildWork)break;return null}case OffscreenComponent:case LegacyHiddenComponent:return workInProgress2.lanes=NoLanes,updateOffscreenComponent(current2,workInProgress2,renderLanes2)}return bailoutOnAlreadyFinishedWork(current2,workInProgress2,renderLanes2)}function beginWork(current2,workInProgress2,renderLanes2){if(workInProgress2._debugNeedsRemount&&current2!==null)return remountFiber(current2,workInProgress2,createFiberFromTypeAndProps(workInProgress2.type,workInProgress2.key,workInProgress2.pendingProps,workInProgress2._debugOwner||null,workInProgress2.mode,workInProgress2.lanes));if(current2!==null){var oldProps=current2.memoizedProps,newProps=workInProgress2.pendingProps;if(oldProps!==newProps||hasContextChanged()||workInProgress2.type!==current2.type)didReceiveUpdate=!0;else{var hasScheduledUpdateOrContext=checkScheduledUpdateOrContext(current2,renderLanes2);if(!hasScheduledUpdateOrContext&&(workInProgress2.flags&DidCapture)===NoFlags)return didReceiveUpdate=!1,attemptEarlyBailoutIfNoScheduledUpdate(current2,workInProgress2,renderLanes2);(current2.flags&ForceUpdateForLegacySuspense)!==NoFlags?didReceiveUpdate=!0:didReceiveUpdate=!1}}else if(didReceiveUpdate=!1,getIsHydrating()&&isForkedChild(workInProgress2)){var slotIndex=workInProgress2.index,numberOfForks=getForksAtLevel();pushTreeId(workInProgress2,numberOfForks,slotIndex)}switch(workInProgress2.lanes=NoLanes,workInProgress2.tag){case IndeterminateComponent:return mountIndeterminateComponent(current2,workInProgress2,workInProgress2.type,renderLanes2);case LazyComponent:{var elementType=workInProgress2.elementType;return mountLazyComponent(current2,workInProgress2,elementType,renderLanes2)}case FunctionComponent:{var Component=workInProgress2.type,unresolvedProps=workInProgress2.pendingProps,resolvedProps=workInProgress2.elementType===Component?unresolvedProps:resolveDefaultProps(Component,unresolvedProps);return updateFunctionComponent(current2,workInProgress2,Component,resolvedProps,renderLanes2)}case ClassComponent:{var _Component=workInProgress2.type,_unresolvedProps=workInProgress2.pendingProps,_resolvedProps=workInProgress2.elementType===_Component?_unresolvedProps:resolveDefaultProps(_Component,_unresolvedProps);return updateClassComponent(current2,workInProgress2,_Component,_resolvedProps,renderLanes2)}case HostRoot:return updateHostRoot(current2,workInProgress2,renderLanes2);case HostComponent:return updateHostComponent$1(current2,workInProgress2,renderLanes2);case HostText:return updateHostText$1(current2,workInProgress2);case SuspenseComponent:return updateSuspenseComponent(current2,workInProgress2,renderLanes2);case HostPortal:return updatePortalComponent(current2,workInProgress2,renderLanes2);case ForwardRef:{var type=workInProgress2.type,_unresolvedProps2=workInProgress2.pendingProps,_resolvedProps2=workInProgress2.elementType===type?_unresolvedProps2:resolveDefaultProps(type,_unresolvedProps2);return updateForwardRef(current2,workInProgress2,type,_resolvedProps2,renderLanes2)}case Fragment:return updateFragment(current2,workInProgress2,renderLanes2);case Mode:return updateMode(current2,workInProgress2,renderLanes2);case Profiler:return updateProfiler(current2,workInProgress2,renderLanes2);case ContextProvider:return updateContextProvider(current2,workInProgress2,renderLanes2);case ContextConsumer:return updateContextConsumer(current2,workInProgress2,renderLanes2);case MemoComponent:{var _type2=workInProgress2.type,_unresolvedProps3=workInProgress2.pendingProps,_resolvedProps3=resolveDefaultProps(_type2,_unresolvedProps3);if(workInProgress2.type!==workInProgress2.elementType){var outerPropTypes=_type2.propTypes;outerPropTypes&&checkPropTypes(outerPropTypes,_resolvedProps3,"prop",getComponentNameFromType(_type2))}return _resolvedProps3=resolveDefaultProps(_type2.type,_resolvedProps3),updateMemoComponent(current2,workInProgress2,_type2,_resolvedProps3,renderLanes2)}case SimpleMemoComponent:return updateSimpleMemoComponent(current2,workInProgress2,workInProgress2.type,workInProgress2.pendingProps,renderLanes2);case IncompleteClassComponent:{var _Component2=workInProgress2.type,_unresolvedProps4=workInProgress2.pendingProps,_resolvedProps4=workInProgress2.elementType===_Component2?_unresolvedProps4:resolveDefaultProps(_Component2,_unresolvedProps4);return mountIncompleteClassComponent(current2,workInProgress2,_Component2,_resolvedProps4,renderLanes2)}case SuspenseListComponent:return updateSuspenseListComponent(current2,workInProgress2,renderLanes2);case ScopeComponent:break;case OffscreenComponent:return updateOffscreenComponent(current2,workInProgress2,renderLanes2)}throw new Error("Unknown unit of work tag ("+workInProgress2.tag+"). This error is likely caused by a bug in React. Please file an issue.")}function unwindWork(current2,workInProgress2,renderLanes2){switch(popTreeContext(workInProgress2),workInProgress2.tag){case ClassComponent:{var Component=workInProgress2.type;isContextProvider(Component)&&popContext(workInProgress2);var flags=workInProgress2.flags;return flags&ShouldCapture?(workInProgress2.flags=flags&~ShouldCapture|DidCapture,(workInProgress2.mode&ProfileMode)!==NoMode&&transferActualDuration(workInProgress2),workInProgress2):null}case HostRoot:{popHostContainer(workInProgress2),popTopLevelContextObject(workInProgress2),resetWorkInProgressVersions();var _flags=workInProgress2.flags;return(_flags&ShouldCapture)!==NoFlags&&(_flags&DidCapture)===NoFlags?(workInProgress2.flags=_flags&~ShouldCapture|DidCapture,workInProgress2):null}case HostComponent:return popHostContext(workInProgress2),null;case SuspenseComponent:{popSuspenseContext(workInProgress2);{var suspenseState=workInProgress2.memoizedState;if(suspenseState!==null&&suspenseState.dehydrated!==null){if(workInProgress2.alternate===null)throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");resetHydrationState()}}var _flags2=workInProgress2.flags;return _flags2&ShouldCapture?(workInProgress2.flags=_flags2&~ShouldCapture|DidCapture,(workInProgress2.mode&ProfileMode)!==NoMode&&transferActualDuration(workInProgress2),workInProgress2):null}case SuspenseListComponent:return popSuspenseContext(workInProgress2),null;case HostPortal:return popHostContainer(workInProgress2),null;case ContextProvider:var context2=workInProgress2.type._context;return popProvider(context2,workInProgress2),null;case OffscreenComponent:case LegacyHiddenComponent:return popRenderLanes(workInProgress2),null;case CacheComponent:return null;default:return null}}function unwindInterruptedWork(current2,interruptedWork,renderLanes2){switch(popTreeContext(interruptedWork),interruptedWork.tag){case ClassComponent:{var childContextTypes=interruptedWork.type.childContextTypes;childContextTypes!=null&&popContext(interruptedWork);break}case HostRoot:{popHostContainer(interruptedWork),popTopLevelContextObject(interruptedWork),resetWorkInProgressVersions();break}case HostComponent:{popHostContext(interruptedWork);break}case HostPortal:popHostContainer(interruptedWork);break;case SuspenseComponent:popSuspenseContext(interruptedWork);break;case SuspenseListComponent:popSuspenseContext(interruptedWork);break;case ContextProvider:var context2=interruptedWork.type._context;popProvider(context2,interruptedWork);break;case OffscreenComponent:case LegacyHiddenComponent:popRenderLanes(interruptedWork);break}}function invokeGuardedCallbackProd(name,func,context2,a2,b2,c2,d2,e2,f2){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context2,funcArgs)}catch(error2){this.onError(error2)}}var invokeGuardedCallbackImpl=invokeGuardedCallbackProd;if(typeof window<"u"&&typeof window.dispatchEvent=="function"&&typeof document<"u"&&typeof document.createEvent=="function"){var fakeNode=document.createElement("react");invokeGuardedCallbackImpl=function(name,func,context2,a2,b2,c2,d2,e2,f2){if(typeof document>"u"||document===null)throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");var evt=document.createEvent("Event"),didCall=!1,didError=!0,windowEvent=window.event,windowEventDescriptor=Object.getOwnPropertyDescriptor(window,"event");function restoreAfterDispatch(){fakeNode.removeEventListener(evtType,callCallback2,!1),typeof window.event<"u"&&window.hasOwnProperty("event")&&(window.event=windowEvent)}var funcArgs=Array.prototype.slice.call(arguments,3);function callCallback2(){didCall=!0,restoreAfterDispatch(),func.apply(context2,funcArgs),didError=!1}var error2,didSetError=!1,isCrossOriginError=!1;function handleWindowError(event){if(error2=event.error,didSetError=!0,error2===null&&event.colno===0&&event.lineno===0&&(isCrossOriginError=!0),event.defaultPrevented&&error2!=null&&typeof error2=="object")try{error2._suppressLogging=!0}catch{}}var evtType="react-"+(name||"invokeguardedcallback");if(window.addEventListener("error",handleWindowError),fakeNode.addEventListener(evtType,callCallback2,!1),evt.initEvent(evtType,!1,!1),fakeNode.dispatchEvent(evt),windowEventDescriptor&&Object.defineProperty(window,"event",windowEventDescriptor),didCall&&didError&&(didSetError?isCrossOriginError&&(error2=new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")):error2=new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`),this.onError(error2)),window.removeEventListener("error",handleWindowError),!didCall)return restoreAfterDispatch(),invokeGuardedCallbackProd.apply(this,arguments)}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl,hasError=!1,caughtError=null,reporter={onError:function(error2){hasError=!0,caughtError=error2}};function invokeGuardedCallback(name,func,context2,a2,b2,c2,d2,e2,f2){hasError=!1,caughtError=null,invokeGuardedCallbackImpl$1.apply(reporter,arguments)}function hasCaughtError(){return hasError}function clearCaughtError(){if(hasError){var error2=caughtError;return hasError=!1,caughtError=null,error2}else throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.")}var didWarnAboutUndefinedSnapshotBeforeUpdate=null;didWarnAboutUndefinedSnapshotBeforeUpdate=new Set;var offscreenSubtreeIsHidden=!1,offscreenSubtreeWasHidden=!1,PossiblyWeakSet=typeof WeakSet=="function"?WeakSet:Set,nextEffect=null,inProgressLanes=null,inProgressRoot=null;function reportUncaughtErrorInDEV(error2){invokeGuardedCallback(null,function(){throw error2}),clearCaughtError()}var callComponentWillUnmountWithTimer=function(current2,instance){if(instance.props=current2.memoizedProps,instance.state=current2.memoizedState,current2.mode&ProfileMode)try{startLayoutEffectTimer(),instance.componentWillUnmount()}finally{recordLayoutEffectDuration(current2)}else instance.componentWillUnmount()};function safelyCallCommitHookLayoutEffectListMount(current2,nearestMountedAncestor){try{commitHookEffectListMount(Layout,current2)}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(current2,nearestMountedAncestor,error2)}}function safelyCallComponentWillUnmount(current2,nearestMountedAncestor,instance){try{callComponentWillUnmountWithTimer(current2,instance)}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(current2,nearestMountedAncestor,error2)}}function safelyCallComponentDidMount(current2,nearestMountedAncestor,instance){try{instance.componentDidMount()}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(current2,nearestMountedAncestor,error2)}}function safelyAttachRef(current2,nearestMountedAncestor){try{commitAttachRef(current2)}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(current2,nearestMountedAncestor,error2)}}function safelyDetachRef(current2,nearestMountedAncestor){var ref=current2.ref;if(ref!==null)if(typeof ref=="function"){var retVal;try{if(enableProfilerTimer&&enableProfilerCommitHooks&&current2.mode&ProfileMode)try{startLayoutEffectTimer(),retVal=ref(null)}finally{recordLayoutEffectDuration(current2)}else retVal=ref(null)}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(current2,nearestMountedAncestor,error2)}typeof retVal=="function"&&error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.",getComponentNameFromFiber(current2))}else ref.current=null}function safelyCallDestroy(current2,nearestMountedAncestor,destroy){try{destroy()}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(current2,nearestMountedAncestor,error2)}}var shouldFireAfterActiveInstanceBlur=!1;function commitBeforeMutationEffects(root,firstChild){prepareForCommit(root.containerInfo),nextEffect=firstChild,commitBeforeMutationEffects_begin();var shouldFire=shouldFireAfterActiveInstanceBlur;return shouldFireAfterActiveInstanceBlur=!1,shouldFire}function commitBeforeMutationEffects_begin(){for(;nextEffect!==null;){var fiber=nextEffect,child=fiber.child;(fiber.subtreeFlags&BeforeMutationMask)!==NoFlags&&child!==null?(ensureCorrectReturnPointer(child,fiber),nextEffect=child):commitBeforeMutationEffects_complete()}}function commitBeforeMutationEffects_complete(){for(;nextEffect!==null;){var fiber=nextEffect;setCurrentFiber(fiber);try{commitBeforeMutationEffectsOnFiber(fiber)}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(fiber,fiber.return,error2)}resetCurrentFiber();var sibling=fiber.sibling;if(sibling!==null){ensureCorrectReturnPointer(sibling,fiber.return),nextEffect=sibling;return}nextEffect=fiber.return}}function commitBeforeMutationEffectsOnFiber(finishedWork){var current2=finishedWork.alternate,flags=finishedWork.flags;if((flags&Snapshot)!==NoFlags){switch(setCurrentFiber(finishedWork),finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:break;case ClassComponent:{if(current2!==null){var prevProps=current2.memoizedProps,prevState=current2.memoizedState,instance=finishedWork.stateNode;finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps&&(instance.props!==finishedWork.memoizedProps&&error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance"),instance.state!==finishedWork.memoizedState&&error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance"));var snapshot=instance.getSnapshotBeforeUpdate(finishedWork.elementType===finishedWork.type?prevProps:resolveDefaultProps(finishedWork.type,prevProps),prevState);{var didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;snapshot===void 0&&!didWarnSet.has(finishedWork.type)&&(didWarnSet.add(finishedWork.type),error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",getComponentNameFromFiber(finishedWork)))}instance.__reactInternalSnapshotBeforeUpdate=snapshot}break}case HostRoot:{if(supportsMutation){var root=finishedWork.stateNode;clearContainer(root.containerInfo)}break}case HostComponent:case HostText:case HostPortal:case IncompleteClassComponent:break;default:throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.")}resetCurrentFiber()}}function commitHookEffectListUnmount(flags,finishedWork,nearestMountedAncestor){var updateQueue=finishedWork.updateQueue,lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next,effect=firstEffect;do{if((effect.tag&flags)===flags){var destroy=effect.destroy;effect.destroy=void 0,destroy!==void 0&&((flags&Passive$1)!==NoFlags$1?markComponentPassiveEffectUnmountStarted(finishedWork):(flags&Layout)!==NoFlags$1&&markComponentLayoutEffectUnmountStarted(finishedWork),safelyCallDestroy(finishedWork,nearestMountedAncestor,destroy),(flags&Passive$1)!==NoFlags$1?markComponentPassiveEffectUnmountStopped():(flags&Layout)!==NoFlags$1&&markComponentLayoutEffectUnmountStopped())}effect=effect.next}while(effect!==firstEffect)}}function commitHookEffectListMount(flags,finishedWork){var updateQueue=finishedWork.updateQueue,lastEffect=updateQueue!==null?updateQueue.lastEffect:null;if(lastEffect!==null){var firstEffect=lastEffect.next,effect=firstEffect;do{if((effect.tag&flags)===flags){(flags&Passive$1)!==NoFlags$1?markComponentPassiveEffectMountStarted(finishedWork):(flags&Layout)!==NoFlags$1&&markComponentLayoutEffectMountStarted(finishedWork);var create2=effect.create;effect.destroy=create2(),(flags&Passive$1)!==NoFlags$1?markComponentPassiveEffectMountStopped():(flags&Layout)!==NoFlags$1&&markComponentLayoutEffectMountStopped();{var destroy=effect.destroy;if(destroy!==void 0&&typeof destroy!="function"){var hookName=void 0;(effect.tag&Layout)!==NoFlags?hookName="useLayoutEffect":(effect.tag&Insertion)!==NoFlags?hookName="useInsertionEffect":hookName="useEffect";var addendum=void 0;destroy===null?addendum=" You returned null. If your effect does not require clean up, return undefined (or nothing).":typeof destroy.then=="function"?addendum=`

It looks like you wrote `+hookName+`(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

`+hookName+`(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching`:addendum=" You returned: "+destroy,error("%s must not return anything besides a function, which is used for clean-up.%s",hookName,addendum)}}}effect=effect.next}while(effect!==firstEffect)}}function commitPassiveEffectDurations(finishedRoot,finishedWork){if((finishedWork.flags&Update)!==NoFlags)switch(finishedWork.tag){case Profiler:{var passiveEffectDuration=finishedWork.stateNode.passiveEffectDuration,_finishedWork$memoize=finishedWork.memoizedProps,id2=_finishedWork$memoize.id,onPostCommit=_finishedWork$memoize.onPostCommit,commitTime2=getCommitTime(),phase=finishedWork.alternate===null?"mount":"update";isCurrentUpdateNested()&&(phase="nested-update"),typeof onPostCommit=="function"&&onPostCommit(id2,phase,passiveEffectDuration,commitTime2);var parentFiber=finishedWork.return;outer:for(;parentFiber!==null;){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.passiveEffectDuration+=passiveEffectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.passiveEffectDuration+=passiveEffectDuration;break outer}parentFiber=parentFiber.return}break}}}function commitLayoutEffectOnFiber(finishedRoot,current2,finishedWork,committedLanes){if((finishedWork.flags&LayoutMask)!==NoFlags)switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(!offscreenSubtreeWasHidden)if(finishedWork.mode&ProfileMode)try{startLayoutEffectTimer(),commitHookEffectListMount(Layout|HasEffect,finishedWork)}finally{recordLayoutEffectDuration(finishedWork)}else commitHookEffectListMount(Layout|HasEffect,finishedWork);break}case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.flags&Update&&!offscreenSubtreeWasHidden)if(current2===null)if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps&&(instance.props!==finishedWork.memoizedProps&&error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance"),instance.state!==finishedWork.memoizedState&&error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance")),finishedWork.mode&ProfileMode)try{startLayoutEffectTimer(),instance.componentDidMount()}finally{recordLayoutEffectDuration(finishedWork)}else instance.componentDidMount();else{var prevProps=finishedWork.elementType===finishedWork.type?current2.memoizedProps:resolveDefaultProps(finishedWork.type,current2.memoizedProps),prevState=current2.memoizedState;if(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps&&(instance.props!==finishedWork.memoizedProps&&error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance"),instance.state!==finishedWork.memoizedState&&error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance")),finishedWork.mode&ProfileMode)try{startLayoutEffectTimer(),instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate)}finally{recordLayoutEffectDuration(finishedWork)}else instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate)}var updateQueue=finishedWork.updateQueue;updateQueue!==null&&(finishedWork.type===finishedWork.elementType&&!didWarnAboutReassigningProps&&(instance.props!==finishedWork.memoizedProps&&error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance"),instance.state!==finishedWork.memoizedState&&error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",getComponentNameFromFiber(finishedWork)||"instance")),commitUpdateQueue(finishedWork,updateQueue,instance));break}case HostRoot:{var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=null;if(finishedWork.child!==null)switch(finishedWork.child.tag){case HostComponent:_instance=getPublicInstance(finishedWork.child.stateNode);break;case ClassComponent:_instance=finishedWork.child.stateNode;break}commitUpdateQueue(finishedWork,_updateQueue,_instance)}break}case HostComponent:{var _instance2=finishedWork.stateNode;if(current2===null&&finishedWork.flags&Update){var type=finishedWork.type,props=finishedWork.memoizedProps;commitMount(_instance2,type,props,finishedWork)}break}case HostText:break;case HostPortal:break;case Profiler:{{var _finishedWork$memoize2=finishedWork.memoizedProps,onCommit=_finishedWork$memoize2.onCommit,onRender=_finishedWork$memoize2.onRender,effectDuration=finishedWork.stateNode.effectDuration,commitTime2=getCommitTime(),phase=current2===null?"mount":"update";isCurrentUpdateNested()&&(phase="nested-update"),typeof onRender=="function"&&onRender(finishedWork.memoizedProps.id,phase,finishedWork.actualDuration,finishedWork.treeBaseDuration,finishedWork.actualStartTime,commitTime2);{typeof onCommit=="function"&&onCommit(finishedWork.memoizedProps.id,phase,effectDuration,commitTime2),enqueuePendingPassiveProfilerEffect(finishedWork);var parentFiber=finishedWork.return;outer:for(;parentFiber!==null;){switch(parentFiber.tag){case HostRoot:var root=parentFiber.stateNode;root.effectDuration+=effectDuration;break outer;case Profiler:var parentStateNode=parentFiber.stateNode;parentStateNode.effectDuration+=effectDuration;break outer}parentFiber=parentFiber.return}}}break}case SuspenseComponent:{commitSuspenseHydrationCallbacks(finishedRoot,finishedWork);break}case SuspenseListComponent:case IncompleteClassComponent:case ScopeComponent:case OffscreenComponent:case LegacyHiddenComponent:break;default:throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.")}offscreenSubtreeWasHidden||finishedWork.flags&Ref&&commitAttachRef(finishedWork)}function reappearLayoutEffectsOnFiber(node){switch(node.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(node.mode&ProfileMode)try{startLayoutEffectTimer(),safelyCallCommitHookLayoutEffectListMount(node,node.return)}finally{recordLayoutEffectDuration(node)}else safelyCallCommitHookLayoutEffectListMount(node,node.return);break}case ClassComponent:{var instance=node.stateNode;typeof instance.componentDidMount=="function"&&safelyCallComponentDidMount(node,node.return,instance),safelyAttachRef(node,node.return);break}case HostComponent:{safelyAttachRef(node,node.return);break}}}function hideOrUnhideAllChildren(finishedWork,isHidden){var hostSubtreeRoot=null;if(supportsMutation)for(var node=finishedWork;;){if(node.tag===HostComponent){if(hostSubtreeRoot===null){hostSubtreeRoot=node;var instance=node.stateNode;isHidden?hideInstance(instance):unhideInstance(node.stateNode,node.memoizedProps)}}else if(node.tag===HostText){if(hostSubtreeRoot===null){var _instance3=node.stateNode;isHidden?hideTextInstance(_instance3):unhideTextInstance(_instance3,node.memoizedProps)}}else if(!((node.tag===OffscreenComponent||node.tag===LegacyHiddenComponent)&&node.memoizedState!==null&&node!==finishedWork)){if(node.child!==null){node.child.return=node,node=node.child;continue}}if(node===finishedWork)return;for(;node.sibling===null;){if(node.return===null||node.return===finishedWork)return;hostSubtreeRoot===node&&(hostSubtreeRoot=null),node=node.return}hostSubtreeRoot===node&&(hostSubtreeRoot=null),node.sibling.return=node.return,node=node.sibling}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode,instanceToUse;switch(finishedWork.tag){case HostComponent:instanceToUse=getPublicInstance(instance);break;default:instanceToUse=instance}if(typeof ref=="function"){var retVal;if(finishedWork.mode&ProfileMode)try{startLayoutEffectTimer(),retVal=ref(instanceToUse)}finally{recordLayoutEffectDuration(finishedWork)}else retVal=ref(instanceToUse);typeof retVal=="function"&&error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.",getComponentNameFromFiber(finishedWork))}else ref.hasOwnProperty("current")||error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",getComponentNameFromFiber(finishedWork)),ref.current=instanceToUse}}function commitDetachRef(current2){var currentRef=current2.ref;if(currentRef!==null)if(typeof currentRef=="function")if(current2.mode&ProfileMode)try{startLayoutEffectTimer(),currentRef(null)}finally{recordLayoutEffectDuration(current2)}else currentRef(null);else currentRef.current=null}function commitUnmount(finishedRoot,current2,nearestMountedAncestor){switch(onCommitUnmount(current2),current2.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{var updateQueue=current2.updateQueue;if(updateQueue!==null){var lastEffect=updateQueue.lastEffect;if(lastEffect!==null){var firstEffect=lastEffect.next,effect=firstEffect;do{var _effect=effect,destroy=_effect.destroy,tag=_effect.tag;destroy!==void 0&&((tag&Insertion)!==NoFlags$1?safelyCallDestroy(current2,nearestMountedAncestor,destroy):(tag&Layout)!==NoFlags$1&&(markComponentLayoutEffectUnmountStarted(current2),current2.mode&ProfileMode?(startLayoutEffectTimer(),safelyCallDestroy(current2,nearestMountedAncestor,destroy),recordLayoutEffectDuration(current2)):safelyCallDestroy(current2,nearestMountedAncestor,destroy),markComponentLayoutEffectUnmountStopped())),effect=effect.next}while(effect!==firstEffect)}}return}case ClassComponent:{safelyDetachRef(current2,nearestMountedAncestor);var instance=current2.stateNode;typeof instance.componentWillUnmount=="function"&&safelyCallComponentWillUnmount(current2,nearestMountedAncestor,instance);return}case HostComponent:{safelyDetachRef(current2,nearestMountedAncestor);return}case HostPortal:{supportsMutation?unmountHostComponents(finishedRoot,current2,nearestMountedAncestor):supportsPersistence&&emptyPortalContainer(current2);return}case DehydratedFragment:return;case ScopeComponent:return}}function commitNestedUnmounts(finishedRoot,root,nearestMountedAncestor){for(var node=root;;){if(commitUnmount(finishedRoot,node,nearestMountedAncestor),node.child!==null&&(!supportsMutation||node.tag!==HostPortal)){node.child.return=node,node=node.child;continue}if(node===root)return;for(;node.sibling===null;){if(node.return===null||node.return===root)return;node=node.return}node.sibling.return=node.return,node=node.sibling}}function detachFiberMutation(fiber){var alternate=fiber.alternate;alternate!==null&&(alternate.return=null),fiber.return=null}function detachFiberAfterEffects(fiber){var alternate=fiber.alternate;alternate!==null&&(fiber.alternate=null,detachFiberAfterEffects(alternate));{if(fiber.child=null,fiber.deletions=null,fiber.sibling=null,fiber.tag===HostComponent){var hostInstance=fiber.stateNode;hostInstance!==null&&detachDeletedInstance(hostInstance)}fiber.stateNode=null,fiber._debugOwner=null,fiber.return=null,fiber.dependencies=null,fiber.memoizedProps=null,fiber.memoizedState=null,fiber.pendingProps=null,fiber.stateNode=null,fiber.updateQueue=null}}function emptyPortalContainer(current2){if(supportsPersistence){var portal=current2.stateNode,containerInfo=portal.containerInfo,emptyChildSet=createContainerChildSet(containerInfo);replaceContainerChildren(containerInfo,emptyChildSet)}}function commitContainer(finishedWork){if(supportsPersistence){switch(finishedWork.tag){case ClassComponent:case HostComponent:case HostText:return;case HostRoot:case HostPortal:{var portalOrRoot=finishedWork.stateNode,containerInfo=portalOrRoot.containerInfo,pendingChildren=portalOrRoot.pendingChildren;replaceContainerChildren(containerInfo,pendingChildren);return}}throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.")}}function getHostParentFiber(fiber){for(var parent=fiber.return;parent!==null;){if(isHostParent(parent))return parent;parent=parent.return}throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.")}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal}function getHostSibling(fiber){var node=fiber;siblings:for(;;){for(;node.sibling===null;){if(node.return===null||isHostParent(node.return))return null;node=node.return}for(node.sibling.return=node.return,node=node.sibling;node.tag!==HostComponent&&node.tag!==HostText&&node.tag!==DehydratedFragment;){if(node.flags&Placement||node.child===null||node.tag===HostPortal)continue siblings;node.child.return=node,node=node.child}if(!(node.flags&Placement))return node.stateNode}}function commitPlacement(finishedWork){if(supportsMutation){var parentFiber=getHostParentFiber(finishedWork);switch(parentFiber.tag){case HostComponent:{var parent=parentFiber.stateNode;parentFiber.flags&ContentReset&&(resetTextContent(parent),parentFiber.flags&=~ContentReset);var before=getHostSibling(finishedWork);insertOrAppendPlacementNode(finishedWork,before,parent);break}case HostRoot:case HostPortal:{var _parent=parentFiber.stateNode.containerInfo,_before=getHostSibling(finishedWork);insertOrAppendPlacementNodeIntoContainer(finishedWork,_before,_parent);break}default:throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.")}}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag,isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;before?insertInContainerBefore(parent,stateNode,before):appendChildToContainer(parent,stateNode)}else if(tag!==HostPortal){var child=node.child;if(child!==null){insertOrAppendPlacementNodeIntoContainer(child,before,parent);for(var sibling=child.sibling;sibling!==null;)insertOrAppendPlacementNodeIntoContainer(sibling,before,parent),sibling=sibling.sibling}}}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag,isHost=tag===HostComponent||tag===HostText;if(isHost){var stateNode=node.stateNode;before?insertBefore(parent,stateNode,before):appendChild(parent,stateNode)}else if(tag!==HostPortal){var child=node.child;if(child!==null){insertOrAppendPlacementNode(child,before,parent);for(var sibling=child.sibling;sibling!==null;)insertOrAppendPlacementNode(sibling,before,parent),sibling=sibling.sibling}}}function unmountHostComponents(finishedRoot,current2,nearestMountedAncestor){for(var node=current2,currentParentIsValid=!1,currentParent,currentParentIsContainer;;){if(!currentParentIsValid){var parent=node.return;findParent:for(;;){if(parent===null)throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");var parentStateNode=parent.stateNode;switch(parent.tag){case HostComponent:currentParent=parentStateNode,currentParentIsContainer=!1;break findParent;case HostRoot:currentParent=parentStateNode.containerInfo,currentParentIsContainer=!0;break findParent;case HostPortal:currentParent=parentStateNode.containerInfo,currentParentIsContainer=!0;break findParent}parent=parent.return}currentParentIsValid=!0}if(node.tag===HostComponent||node.tag===HostText)commitNestedUnmounts(finishedRoot,node,nearestMountedAncestor),currentParentIsContainer?removeChildFromContainer(currentParent,node.stateNode):removeChild(currentParent,node.stateNode);else if(node.tag===DehydratedFragment)currentParentIsContainer?clearSuspenseBoundaryFromContainer(currentParent,node.stateNode):clearSuspenseBoundary(currentParent,node.stateNode);else if(node.tag===HostPortal){if(node.child!==null){currentParent=node.stateNode.containerInfo,currentParentIsContainer=!0,node.child.return=node,node=node.child;continue}}else if(commitUnmount(finishedRoot,node,nearestMountedAncestor),node.child!==null){node.child.return=node,node=node.child;continue}if(node===current2)return;for(;node.sibling===null;){if(node.return===null||node.return===current2)return;node=node.return,node.tag===HostPortal&&(currentParentIsValid=!1)}node.sibling.return=node.return,node=node.sibling}}function commitDeletion(finishedRoot,current2,nearestMountedAncestor){supportsMutation?unmountHostComponents(finishedRoot,current2,nearestMountedAncestor):commitNestedUnmounts(finishedRoot,current2,nearestMountedAncestor),detachFiberMutation(current2)}function commitWork(current2,finishedWork){if(!supportsMutation){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(commitHookEffectListUnmount(Insertion|HasEffect,finishedWork,finishedWork.return),commitHookEffectListMount(Insertion|HasEffect,finishedWork),finishedWork.mode&ProfileMode)try{startLayoutEffectTimer(),commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return)}finally{recordLayoutEffectDuration(finishedWork)}else commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);return}case Profiler:return;case SuspenseComponent:{commitSuspenseCallback(finishedWork),attachSuspenseRetryListeners(finishedWork);return}case SuspenseListComponent:{attachSuspenseRetryListeners(finishedWork);return}case HostRoot:{if(supportsHydration&&current2!==null){var prevRootState=current2.memoizedState;if(prevRootState.isDehydrated){var root=finishedWork.stateNode;commitHydratedContainer(root.containerInfo)}}break}case OffscreenComponent:case LegacyHiddenComponent:return}commitContainer(finishedWork);return}switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(commitHookEffectListUnmount(Insertion|HasEffect,finishedWork,finishedWork.return),commitHookEffectListMount(Insertion|HasEffect,finishedWork),finishedWork.mode&ProfileMode)try{startLayoutEffectTimer(),commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return)}finally{recordLayoutEffectDuration(finishedWork)}else commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);return}case ClassComponent:return;case HostComponent:{var instance=finishedWork.stateNode;if(instance!=null){var newProps=finishedWork.memoizedProps,oldProps=current2!==null?current2.memoizedProps:newProps,type=finishedWork.type,updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null,updatePayload!==null&&commitUpdate(instance,updatePayload,type,oldProps,newProps,finishedWork)}return}case HostText:{if(finishedWork.stateNode===null)throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");var textInstance=finishedWork.stateNode,newText=finishedWork.memoizedProps,oldText=current2!==null?current2.memoizedProps:newText;commitTextUpdate(textInstance,oldText,newText);return}case HostRoot:{if(supportsHydration&&current2!==null){var _prevRootState=current2.memoizedState;if(_prevRootState.isDehydrated){var _root=finishedWork.stateNode;commitHydratedContainer(_root.containerInfo)}}return}case Profiler:return;case SuspenseComponent:{commitSuspenseCallback(finishedWork),attachSuspenseRetryListeners(finishedWork);return}case SuspenseListComponent:{attachSuspenseRetryListeners(finishedWork);return}case IncompleteClassComponent:return}throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.")}function commitSuspenseCallback(finishedWork){finishedWork.memoizedState}function commitSuspenseHydrationCallbacks(finishedRoot,finishedWork){if(supportsHydration){var newState=finishedWork.memoizedState;if(newState===null){var current2=finishedWork.alternate;if(current2!==null){var prevState=current2.memoizedState;if(prevState!==null){var suspenseInstance=prevState.dehydrated;suspenseInstance!==null&&commitHydratedSuspenseInstance(suspenseInstance)}}}}}function attachSuspenseRetryListeners(finishedWork){var wakeables=finishedWork.updateQueue;if(wakeables!==null){finishedWork.updateQueue=null;var retryCache=finishedWork.stateNode;retryCache===null&&(retryCache=finishedWork.stateNode=new PossiblyWeakSet),wakeables.forEach(function(wakeable){var retry=resolveRetryWakeable.bind(null,finishedWork,wakeable);if(!retryCache.has(wakeable)){if(retryCache.add(wakeable),isDevToolsPresent)if(inProgressLanes!==null&&inProgressRoot!==null)restorePendingUpdaters(inProgressRoot,inProgressLanes);else throw Error("Expected finished root and lanes to be set. This is a bug in React.");wakeable.then(retry,retry)}})}}function commitResetTextContent(current2){supportsMutation&&resetTextContent(current2.stateNode)}function commitMutationEffects(root,firstChild,committedLanes){inProgressLanes=committedLanes,inProgressRoot=root,nextEffect=firstChild,commitMutationEffects_begin(root,committedLanes),inProgressLanes=null,inProgressRoot=null}function commitMutationEffects_begin(root,lanes){for(;nextEffect!==null;){var fiber=nextEffect,deletions=fiber.deletions;if(deletions!==null)for(var i2=0;i2<deletions.length;i2++){var childToDelete=deletions[i2];try{commitDeletion(root,childToDelete,fiber)}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(childToDelete,fiber,error2)}}var child=fiber.child;(fiber.subtreeFlags&MutationMask)!==NoFlags&&child!==null?(ensureCorrectReturnPointer(child,fiber),nextEffect=child):commitMutationEffects_complete(root,lanes)}}function commitMutationEffects_complete(root,lanes){for(;nextEffect!==null;){var fiber=nextEffect;setCurrentFiber(fiber);try{commitMutationEffectsOnFiber(fiber,root,lanes)}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(fiber,fiber.return,error2)}resetCurrentFiber();var sibling=fiber.sibling;if(sibling!==null){ensureCorrectReturnPointer(sibling,fiber.return),nextEffect=sibling;return}nextEffect=fiber.return}}function commitMutationEffectsOnFiber(finishedWork,root,lanes){var flags=finishedWork.flags;if(flags&ContentReset&&commitResetTextContent(finishedWork),flags&Ref){var current2=finishedWork.alternate;current2!==null&&commitDetachRef(current2)}if(flags&Visibility)switch(finishedWork.tag){case SuspenseComponent:{var newState=finishedWork.memoizedState,isHidden=newState!==null;if(isHidden){var _current=finishedWork.alternate,wasHidden=_current!==null&&_current.memoizedState!==null;wasHidden||markCommitTimeOfFallback()}break}case OffscreenComponent:{var _newState=finishedWork.memoizedState,_isHidden=_newState!==null,_current2=finishedWork.alternate,_wasHidden=_current2!==null&&_current2.memoizedState!==null,offscreenBoundary=finishedWork;supportsMutation&&hideOrUnhideAllChildren(offscreenBoundary,_isHidden);{if(_isHidden&&!_wasHidden&&(offscreenBoundary.mode&ConcurrentMode)!==NoMode){nextEffect=offscreenBoundary;for(var offscreenChild=offscreenBoundary.child;offscreenChild!==null;)nextEffect=offscreenChild,disappearLayoutEffects_begin(offscreenChild),offscreenChild=offscreenChild.sibling}break}}}var primaryFlags=flags&(Placement|Update|Hydrating);switch(primaryFlags){case Placement:{commitPlacement(finishedWork),finishedWork.flags&=~Placement;break}case PlacementAndUpdate:{commitPlacement(finishedWork),finishedWork.flags&=~Placement;var _current3=finishedWork.alternate;commitWork(_current3,finishedWork);break}case Hydrating:{finishedWork.flags&=~Hydrating;break}case HydratingAndUpdate:{finishedWork.flags&=~Hydrating;var _current4=finishedWork.alternate;commitWork(_current4,finishedWork);break}case Update:{var _current5=finishedWork.alternate;commitWork(_current5,finishedWork);break}}}function commitLayoutEffects(finishedWork,root,committedLanes){inProgressLanes=committedLanes,inProgressRoot=root,nextEffect=finishedWork,commitLayoutEffects_begin(finishedWork,root,committedLanes),inProgressLanes=null,inProgressRoot=null}function commitLayoutEffects_begin(subtreeRoot,root,committedLanes){for(var isModernRoot=(subtreeRoot.mode&ConcurrentMode)!==NoMode;nextEffect!==null;){var fiber=nextEffect,firstChild=fiber.child;if(fiber.tag===OffscreenComponent&&isModernRoot){var isHidden=fiber.memoizedState!==null,newOffscreenSubtreeIsHidden=isHidden||offscreenSubtreeIsHidden;if(newOffscreenSubtreeIsHidden){commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue}else{var current2=fiber.alternate,wasHidden=current2!==null&&current2.memoizedState!==null,newOffscreenSubtreeWasHidden=wasHidden||offscreenSubtreeWasHidden,prevOffscreenSubtreeIsHidden=offscreenSubtreeIsHidden,prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeIsHidden=newOffscreenSubtreeIsHidden,offscreenSubtreeWasHidden=newOffscreenSubtreeWasHidden,offscreenSubtreeWasHidden&&!prevOffscreenSubtreeWasHidden&&(nextEffect=fiber,reappearLayoutEffects_begin(fiber));for(var child=firstChild;child!==null;)nextEffect=child,commitLayoutEffects_begin(child,root,committedLanes),child=child.sibling;nextEffect=fiber,offscreenSubtreeIsHidden=prevOffscreenSubtreeIsHidden,offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden,commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes);continue}}(fiber.subtreeFlags&LayoutMask)!==NoFlags&&firstChild!==null?(ensureCorrectReturnPointer(firstChild,fiber),nextEffect=firstChild):commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes)}}function commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes){for(;nextEffect!==null;){var fiber=nextEffect;if((fiber.flags&LayoutMask)!==NoFlags){var current2=fiber.alternate;setCurrentFiber(fiber);try{commitLayoutEffectOnFiber(root,current2,fiber,committedLanes)}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(fiber,fiber.return,error2)}resetCurrentFiber()}if(fiber===subtreeRoot){nextEffect=null;return}var sibling=fiber.sibling;if(sibling!==null){ensureCorrectReturnPointer(sibling,fiber.return),nextEffect=sibling;return}nextEffect=fiber.return}}function disappearLayoutEffects_begin(subtreeRoot){for(;nextEffect!==null;){var fiber=nextEffect,firstChild=fiber.child;switch(fiber.tag){case FunctionComponent:case ForwardRef:case MemoComponent:case SimpleMemoComponent:{if(fiber.mode&ProfileMode)try{startLayoutEffectTimer(),commitHookEffectListUnmount(Layout,fiber,fiber.return)}finally{recordLayoutEffectDuration(fiber)}else commitHookEffectListUnmount(Layout,fiber,fiber.return);break}case ClassComponent:{safelyDetachRef(fiber,fiber.return);var instance=fiber.stateNode;typeof instance.componentWillUnmount=="function"&&safelyCallComponentWillUnmount(fiber,fiber.return,instance);break}case HostComponent:{safelyDetachRef(fiber,fiber.return);break}case OffscreenComponent:{var isHidden=fiber.memoizedState!==null;if(isHidden){disappearLayoutEffects_complete(subtreeRoot);continue}break}}firstChild!==null?(firstChild.return=fiber,nextEffect=firstChild):disappearLayoutEffects_complete(subtreeRoot)}}function disappearLayoutEffects_complete(subtreeRoot){for(;nextEffect!==null;){var fiber=nextEffect;if(fiber===subtreeRoot){nextEffect=null;return}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return,nextEffect=sibling;return}nextEffect=fiber.return}}function reappearLayoutEffects_begin(subtreeRoot){for(;nextEffect!==null;){var fiber=nextEffect,firstChild=fiber.child;if(fiber.tag===OffscreenComponent){var isHidden=fiber.memoizedState!==null;if(isHidden){reappearLayoutEffects_complete(subtreeRoot);continue}}firstChild!==null?(firstChild.return=fiber,nextEffect=firstChild):reappearLayoutEffects_complete(subtreeRoot)}}function reappearLayoutEffects_complete(subtreeRoot){for(;nextEffect!==null;){var fiber=nextEffect;setCurrentFiber(fiber);try{reappearLayoutEffectsOnFiber(fiber)}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(fiber,fiber.return,error2)}if(resetCurrentFiber(),fiber===subtreeRoot){nextEffect=null;return}var sibling=fiber.sibling;if(sibling!==null){sibling.return=fiber.return,nextEffect=sibling;return}nextEffect=fiber.return}}function commitPassiveMountEffects(root,finishedWork){nextEffect=finishedWork,commitPassiveMountEffects_begin(finishedWork,root)}function commitPassiveMountEffects_begin(subtreeRoot,root){for(;nextEffect!==null;){var fiber=nextEffect,firstChild=fiber.child;(fiber.subtreeFlags&PassiveMask)!==NoFlags&&firstChild!==null?(ensureCorrectReturnPointer(firstChild,fiber),nextEffect=firstChild):commitPassiveMountEffects_complete(subtreeRoot,root)}}function commitPassiveMountEffects_complete(subtreeRoot,root){for(;nextEffect!==null;){var fiber=nextEffect;if((fiber.flags&Passive)!==NoFlags){setCurrentFiber(fiber);try{commitPassiveMountOnFiber(root,fiber)}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(fiber,fiber.return,error2)}resetCurrentFiber()}if(fiber===subtreeRoot){nextEffect=null;return}var sibling=fiber.sibling;if(sibling!==null){ensureCorrectReturnPointer(sibling,fiber.return),nextEffect=sibling;return}nextEffect=fiber.return}}function commitPassiveMountOnFiber(finishedRoot,finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{if(finishedWork.mode&ProfileMode){startPassiveEffectTimer();try{commitHookEffectListMount(Passive$1|HasEffect,finishedWork)}finally{recordPassiveEffectDuration(finishedWork)}}else commitHookEffectListMount(Passive$1|HasEffect,finishedWork);break}}}function commitPassiveUnmountEffects(firstChild){nextEffect=firstChild,commitPassiveUnmountEffects_begin()}function commitPassiveUnmountEffects_begin(){for(;nextEffect!==null;){var fiber=nextEffect,child=fiber.child;if((nextEffect.flags&ChildDeletion)!==NoFlags){var deletions=fiber.deletions;if(deletions!==null){for(var i2=0;i2<deletions.length;i2++){var fiberToDelete=deletions[i2];nextEffect=fiberToDelete,commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete,fiber)}{var previousFiber=fiber.alternate;if(previousFiber!==null){var detachedChild=previousFiber.child;if(detachedChild!==null){previousFiber.child=null;do{var detachedSibling=detachedChild.sibling;detachedChild.sibling=null,detachedChild=detachedSibling}while(detachedChild!==null)}}}nextEffect=fiber}}(fiber.subtreeFlags&PassiveMask)!==NoFlags&&child!==null?(ensureCorrectReturnPointer(child,fiber),nextEffect=child):commitPassiveUnmountEffects_complete()}}function commitPassiveUnmountEffects_complete(){for(;nextEffect!==null;){var fiber=nextEffect;(fiber.flags&Passive)!==NoFlags&&(setCurrentFiber(fiber),commitPassiveUnmountOnFiber(fiber),resetCurrentFiber());var sibling=fiber.sibling;if(sibling!==null){ensureCorrectReturnPointer(sibling,fiber.return),nextEffect=sibling;return}nextEffect=fiber.return}}function commitPassiveUnmountOnFiber(finishedWork){switch(finishedWork.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{finishedWork.mode&ProfileMode?(startPassiveEffectTimer(),commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return),recordPassiveEffectDuration(finishedWork)):commitHookEffectListUnmount(Passive$1|HasEffect,finishedWork,finishedWork.return);break}}}function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot,nearestMountedAncestor){for(;nextEffect!==null;){var fiber=nextEffect;setCurrentFiber(fiber),commitPassiveUnmountInsideDeletedTreeOnFiber(fiber,nearestMountedAncestor),resetCurrentFiber();var child=fiber.child;child!==null?(ensureCorrectReturnPointer(child,fiber),nextEffect=child):commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot)}}function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot){for(;nextEffect!==null;){var fiber=nextEffect,sibling=fiber.sibling,returnFiber=fiber.return;if(detachFiberAfterEffects(fiber),fiber===deletedSubtreeRoot){nextEffect=null;return}if(sibling!==null){ensureCorrectReturnPointer(sibling,returnFiber),nextEffect=sibling;return}nextEffect=returnFiber}}function commitPassiveUnmountInsideDeletedTreeOnFiber(current2,nearestMountedAncestor){switch(current2.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{current2.mode&ProfileMode?(startPassiveEffectTimer(),commitHookEffectListUnmount(Passive$1,current2,nearestMountedAncestor),recordPassiveEffectDuration(current2)):commitHookEffectListUnmount(Passive$1,current2,nearestMountedAncestor);break}}}var didWarnWrongReturnPointer=!1;function ensureCorrectReturnPointer(fiber,expectedReturnFiber){!didWarnWrongReturnPointer&&fiber.return!==expectedReturnFiber&&(didWarnWrongReturnPointer=!0,error("Internal React error: Return pointer is inconsistent with parent.")),fiber.return=expectedReturnFiber}function invokeLayoutEffectMountInDEV(fiber){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Layout|HasEffect,fiber)}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(fiber,fiber.return,error2)}break}case ClassComponent:{var instance=fiber.stateNode;try{instance.componentDidMount()}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(fiber,fiber.return,error2)}break}}}function invokePassiveEffectMountInDEV(fiber){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListMount(Passive$1|HasEffect,fiber)}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(fiber,fiber.return,error2)}break}}}function invokeLayoutEffectUnmountInDEV(fiber){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{try{commitHookEffectListUnmount(Layout|HasEffect,fiber,fiber.return)}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(fiber,fiber.return,error2)}break}case ClassComponent:{var instance=fiber.stateNode;typeof instance.componentWillUnmount=="function"&&safelyCallComponentWillUnmount(fiber,fiber.return,instance);break}}}function invokePassiveEffectUnmountInDEV(fiber){switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:try{commitHookEffectListUnmount(Passive$1|HasEffect,fiber,fiber.return)}catch(error2){reportUncaughtErrorInDEV(error2),captureCommitPhaseError(fiber,fiber.return,error2)}}}var COMPONENT_TYPE=0,HAS_PSEUDO_CLASS_TYPE=1,ROLE_TYPE=2,TEST_NAME_TYPE=3,TEXT_TYPE=4;if(typeof Symbol=="function"&&Symbol.for){var symbolFor=Symbol.for;COMPONENT_TYPE=symbolFor("selector.component"),HAS_PSEUDO_CLASS_TYPE=symbolFor("selector.has_pseudo_class"),ROLE_TYPE=symbolFor("selector.role"),TEST_NAME_TYPE=symbolFor("selector.test_id"),TEXT_TYPE=symbolFor("selector.text")}function createComponentSelector(component){return{$$typeof:COMPONENT_TYPE,value:component}}function createHasPseudoClassSelector(selectors){return{$$typeof:HAS_PSEUDO_CLASS_TYPE,value:selectors}}function createRoleSelector(role){return{$$typeof:ROLE_TYPE,value:role}}function createTextSelector(text){return{$$typeof:TEXT_TYPE,value:text}}function createTestNameSelector(id2){return{$$typeof:TEST_NAME_TYPE,value:id2}}function findFiberRootForHostRoot(hostRoot){var maybeFiber=getInstanceFromNode(hostRoot);if(maybeFiber!=null){if(typeof maybeFiber.memoizedProps["data-testname"]!="string")throw new Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");return maybeFiber}else{var fiberRoot=findFiberRoot(hostRoot);if(fiberRoot===null)throw new Error("Could not find React container within specified host subtree.");return fiberRoot.stateNode.current}}function matchSelector(fiber,selector){switch(selector.$$typeof){case COMPONENT_TYPE:if(fiber.type===selector.value)return!0;break;case HAS_PSEUDO_CLASS_TYPE:return hasMatchingPaths(fiber,selector.value);case ROLE_TYPE:if(fiber.tag===HostComponent){var node=fiber.stateNode;if(matchAccessibilityRole(node,selector.value))return!0}break;case TEXT_TYPE:if(fiber.tag===HostComponent||fiber.tag===HostText){var textContent=getTextContent(fiber);if(textContent!==null&&textContent.indexOf(selector.value)>=0)return!0}break;case TEST_NAME_TYPE:if(fiber.tag===HostComponent){var dataTestID=fiber.memoizedProps["data-testname"];if(typeof dataTestID=="string"&&dataTestID.toLowerCase()===selector.value.toLowerCase())return!0}break;default:throw new Error("Invalid selector type specified.")}return!1}function selectorToString(selector){switch(selector.$$typeof){case COMPONENT_TYPE:var displayName=getComponentNameFromType(selector.value)||"Unknown";return"<"+displayName+">";case HAS_PSEUDO_CLASS_TYPE:return":has("+(selectorToString(selector)||"")+")";case ROLE_TYPE:return'[role="'+selector.value+'"]';case TEXT_TYPE:return'"'+selector.value+'"';case TEST_NAME_TYPE:return'[data-testname="'+selector.value+'"]';default:throw new Error("Invalid selector type specified.")}}function findPaths(root,selectors){for(var matchingFibers=[],stack=[root,0],index2=0;index2<stack.length;){var fiber=stack[index2++],selectorIndex=stack[index2++],selector=selectors[selectorIndex];if(!(fiber.tag===HostComponent&&isHiddenSubtree(fiber))){for(;selector!=null&&matchSelector(fiber,selector);)selectorIndex++,selector=selectors[selectorIndex];if(selectorIndex===selectors.length)matchingFibers.push(fiber);else for(var child=fiber.child;child!==null;)stack.push(child,selectorIndex),child=child.sibling}}return matchingFibers}function hasMatchingPaths(root,selectors){for(var stack=[root,0],index2=0;index2<stack.length;){var fiber=stack[index2++],selectorIndex=stack[index2++],selector=selectors[selectorIndex];if(!(fiber.tag===HostComponent&&isHiddenSubtree(fiber))){for(;selector!=null&&matchSelector(fiber,selector);)selectorIndex++,selector=selectors[selectorIndex];if(selectorIndex===selectors.length)return!0;for(var child=fiber.child;child!==null;)stack.push(child,selectorIndex),child=child.sibling}}return!1}function findAllNodes(hostRoot,selectors){if(!supportsTestSelectors)throw new Error("Test selector API is not supported by this renderer.");for(var root=findFiberRootForHostRoot(hostRoot),matchingFibers=findPaths(root,selectors),instanceRoots=[],stack=Array.from(matchingFibers),index2=0;index2<stack.length;){var node=stack[index2++];if(node.tag===HostComponent){if(isHiddenSubtree(node))continue;instanceRoots.push(node.stateNode)}else for(var child=node.child;child!==null;)stack.push(child),child=child.sibling}return instanceRoots}function getFindAllNodesFailureDescription(hostRoot,selectors){if(!supportsTestSelectors)throw new Error("Test selector API is not supported by this renderer.");for(var root=findFiberRootForHostRoot(hostRoot),maxSelectorIndex=0,matchedNames=[],stack=[root,0],index2=0;index2<stack.length;){var fiber=stack[index2++],selectorIndex=stack[index2++],selector=selectors[selectorIndex];if(!(fiber.tag===HostComponent&&isHiddenSubtree(fiber))&&(matchSelector(fiber,selector)&&(matchedNames.push(selectorToString(selector)),selectorIndex++,selectorIndex>maxSelectorIndex&&(maxSelectorIndex=selectorIndex)),selectorIndex<selectors.length))for(var child=fiber.child;child!==null;)stack.push(child,selectorIndex),child=child.sibling}if(maxSelectorIndex<selectors.length){for(var unmatchedNames=[],i2=maxSelectorIndex;i2<selectors.length;i2++)unmatchedNames.push(selectorToString(selectors[i2]));return`findAllNodes was able to match part of the selector:
`+("  "+matchedNames.join(" > ")+`

`)+`No matching component was found for:
`+("  "+unmatchedNames.join(" > "))}return null}function findBoundingRects(hostRoot,selectors){if(!supportsTestSelectors)throw new Error("Test selector API is not supported by this renderer.");for(var instanceRoots=findAllNodes(hostRoot,selectors),boundingRects=[],i2=0;i2<instanceRoots.length;i2++)boundingRects.push(getBoundingRect(instanceRoots[i2]));for(var _i=boundingRects.length-1;_i>0;_i--)for(var targetRect=boundingRects[_i],targetLeft=targetRect.x,targetRight=targetLeft+targetRect.width,targetTop=targetRect.y,targetBottom=targetTop+targetRect.height,j2=_i-1;j2>=0;j2--)if(_i!==j2){var otherRect=boundingRects[j2],otherLeft=otherRect.x,otherRight=otherLeft+otherRect.width,otherTop=otherRect.y,otherBottom=otherTop+otherRect.height;if(targetLeft>=otherLeft&&targetTop>=otherTop&&targetRight<=otherRight&&targetBottom<=otherBottom){boundingRects.splice(_i,1);break}else if(targetLeft===otherLeft&&targetRect.width===otherRect.width&&!(otherBottom<targetTop)&&!(otherTop>targetBottom)){otherTop>targetTop&&(otherRect.height+=otherTop-targetTop,otherRect.y=targetTop),otherBottom<targetBottom&&(otherRect.height=targetBottom-otherTop),boundingRects.splice(_i,1);break}else if(targetTop===otherTop&&targetRect.height===otherRect.height&&!(otherRight<targetLeft)&&!(otherLeft>targetRight)){otherLeft>targetLeft&&(otherRect.width+=otherLeft-targetLeft,otherRect.x=targetLeft),otherRight<targetRight&&(otherRect.width=targetRight-otherLeft),boundingRects.splice(_i,1);break}}return boundingRects}function focusWithin(hostRoot,selectors){if(!supportsTestSelectors)throw new Error("Test selector API is not supported by this renderer.");for(var root=findFiberRootForHostRoot(hostRoot),matchingFibers=findPaths(root,selectors),stack=Array.from(matchingFibers),index2=0;index2<stack.length;){var fiber=stack[index2++];if(!isHiddenSubtree(fiber)){if(fiber.tag===HostComponent){var node=fiber.stateNode;if(setFocusIfFocusable(node))return!0}for(var child=fiber.child;child!==null;)stack.push(child),child=child.sibling}}return!1}var commitHooks=[];function onCommitRoot$1(){supportsTestSelectors&&commitHooks.forEach(function(commitHook){return commitHook()})}function observeVisibleRects(hostRoot,selectors,callback,options){if(!supportsTestSelectors)throw new Error("Test selector API is not supported by this renderer.");var instanceRoots=findAllNodes(hostRoot,selectors),_setupIntersectionObs=setupIntersectionObserver(instanceRoots,callback,options),disconnect=_setupIntersectionObs.disconnect,observe=_setupIntersectionObs.observe,unobserve=_setupIntersectionObs.unobserve,commitHook=function(){var nextInstanceRoots=findAllNodes(hostRoot,selectors);instanceRoots.forEach(function(target){nextInstanceRoots.indexOf(target)<0&&unobserve(target)}),nextInstanceRoots.forEach(function(target){instanceRoots.indexOf(target)<0&&observe(target)})};return commitHooks.push(commitHook),{disconnect:function(){var index2=commitHooks.indexOf(commitHook);index2>=0&&commitHooks.splice(index2,1),disconnect()}}}var ReactCurrentActQueue=ReactSharedInternals.ReactCurrentActQueue;function isLegacyActEnvironment(fiber){{var isReactActEnvironmentGlobal=typeof IS_REACT_ACT_ENVIRONMENT<"u"?IS_REACT_ACT_ENVIRONMENT:void 0,jestIsDefined=typeof jest<"u";return warnsIfNotActing&&jestIsDefined&&isReactActEnvironmentGlobal!==!1}}function isConcurrentActEnvironment(){{var isReactActEnvironmentGlobal=typeof IS_REACT_ACT_ENVIRONMENT<"u"?IS_REACT_ACT_ENVIRONMENT:void 0;return!isReactActEnvironmentGlobal&&ReactCurrentActQueue.current!==null&&error("The current testing environment is not configured to support act(...)"),isReactActEnvironmentGlobal}}var ceil=Math.ceil,ReactCurrentDispatcher$2=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner,ReactCurrentBatchConfig$2=ReactSharedInternals.ReactCurrentBatchConfig,ReactCurrentActQueue$1=ReactSharedInternals.ReactCurrentActQueue,NoContext=0,BatchedContext=1,RenderContext=2,CommitContext=4,RootInProgress=0,RootFatalErrored=1,RootErrored=2,RootSuspended=3,RootSuspendedWithDelay=4,RootCompleted=5,RootDidNotComplete=6,executionContext=NoContext,workInProgressRoot=null,workInProgress=null,workInProgressRootRenderLanes=NoLanes,subtreeRenderLanes=NoLanes,subtreeRenderLanesCursor=createCursor(NoLanes),workInProgressRootExitStatus=RootInProgress,workInProgressRootFatalError=null,workInProgressRootSkippedLanes=NoLanes,workInProgressRootInterleavedUpdatedLanes=NoLanes,workInProgressRootPingedLanes=NoLanes,workInProgressRootConcurrentErrors=null,workInProgressRootRecoverableErrors=null,globalMostRecentFallbackTime=0,FALLBACK_THROTTLE_MS=500,workInProgressRootRenderTargetTime=1/0,RENDER_TIMEOUT_MS=500;function resetRenderTimer(){workInProgressRootRenderTargetTime=now$1()+RENDER_TIMEOUT_MS}function getRenderTargetTime(){return workInProgressRootRenderTargetTime}var hasUncaughtError=!1,firstUncaughtError=null,legacyErrorBoundariesThatAlreadyFailed=null,rootDoesHavePassiveEffects=!1,rootWithPendingPassiveEffects=null,pendingPassiveEffectsLanes=NoLanes,pendingPassiveProfilerEffects=[],NESTED_UPDATE_LIMIT=50,nestedUpdateCount=0,rootWithNestedUpdates=null,NESTED_PASSIVE_UPDATE_LIMIT=50,nestedPassiveUpdateCount=0,currentEventTime=NoTimestamp,currentEventTransitionLane=NoLanes;function getWorkInProgressRoot(){return workInProgressRoot}function requestEventTime(){return(executionContext&(RenderContext|CommitContext))!==NoContext?now$1():(currentEventTime!==NoTimestamp||(currentEventTime=now$1()),currentEventTime)}function requestUpdateLane(fiber){var mode=fiber.mode;if((mode&ConcurrentMode)===NoMode)return SyncLane;if((executionContext&RenderContext)!==NoContext&&workInProgressRootRenderLanes!==NoLanes)return pickArbitraryLane(workInProgressRootRenderLanes);var isTransition=requestCurrentTransition()!==NoTransition;if(isTransition){if(ReactCurrentBatchConfig$2.transition!==null){var transition=ReactCurrentBatchConfig$2.transition;transition._updatedFibers||(transition._updatedFibers=new Set),transition._updatedFibers.add(fiber)}return currentEventTransitionLane===NoLane&&(currentEventTransitionLane=claimNextTransitionLane()),currentEventTransitionLane}var updateLane=getCurrentUpdatePriority();if(updateLane!==NoLane)return updateLane;var eventLane=getCurrentEventPriority();return eventLane}function requestRetryLane(fiber){var mode=fiber.mode;return(mode&ConcurrentMode)===NoMode?SyncLane:claimNextRetryLane()}function scheduleUpdateOnFiber(fiber,lane,eventTime){checkForNestedUpdates();var root=markUpdateLaneFromFiberToRoot(fiber,lane);return root===null?null:(markRootUpdated(root,lane,eventTime),(executionContext&RenderContext)!==NoLanes&&root===workInProgressRoot?warnAboutRenderPhaseUpdatesInDEV(fiber):(isDevToolsPresent&&addFiberToLanesMap(root,fiber,lane),warnIfUpdatesNotWrappedWithActDEV(fiber),root===workInProgressRoot&&((executionContext&RenderContext)===NoContext&&(workInProgressRootInterleavedUpdatedLanes=mergeLanes(workInProgressRootInterleavedUpdatedLanes,lane)),workInProgressRootExitStatus===RootSuspendedWithDelay&&markRootSuspended$1(root,workInProgressRootRenderLanes)),ensureRootIsScheduled(root,eventTime),lane===SyncLane&&executionContext===NoContext&&(fiber.mode&ConcurrentMode)===NoMode&&!ReactCurrentActQueue$1.isBatchingLegacy&&(resetRenderTimer(),flushSyncCallbacksOnlyInLegacyMode())),root)}function scheduleInitialHydrationOnRoot(root,lane,eventTime){var current2=root.current;current2.lanes=lane,markRootUpdated(root,lane,eventTime),ensureRootIsScheduled(root,eventTime)}function markUpdateLaneFromFiberToRoot(sourceFiber,lane){sourceFiber.lanes=mergeLanes(sourceFiber.lanes,lane);var alternate=sourceFiber.alternate;alternate!==null&&(alternate.lanes=mergeLanes(alternate.lanes,lane)),alternate===null&&(sourceFiber.flags&(Placement|Hydrating))!==NoFlags&&warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);for(var node=sourceFiber,parent=sourceFiber.return;parent!==null;)parent.childLanes=mergeLanes(parent.childLanes,lane),alternate=parent.alternate,alternate!==null?alternate.childLanes=mergeLanes(alternate.childLanes,lane):(parent.flags&(Placement|Hydrating))!==NoFlags&&warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber),node=parent,parent=parent.return;if(node.tag===HostRoot){var root=node.stateNode;return root}else return null}function isInterleavedUpdate(fiber,lane){return workInProgressRoot!==null&&(fiber.mode&ConcurrentMode)!==NoMode&&(executionContext&RenderContext)===NoContext}function ensureRootIsScheduled(root,currentTime){var existingCallbackNode=root.callbackNode;markStarvedLanesAsExpired(root,currentTime);var nextLanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(nextLanes===NoLanes){existingCallbackNode!==null&&cancelCallback$1(existingCallbackNode),root.callbackNode=null,root.callbackPriority=NoLane;return}var newCallbackPriority=getHighestPriorityLane(nextLanes),existingCallbackPriority=root.callbackPriority;if(existingCallbackPriority===newCallbackPriority&&!(ReactCurrentActQueue$1.current!==null&&existingCallbackNode!==fakeActCallbackNode)){existingCallbackNode==null&&existingCallbackPriority!==SyncLane&&error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");return}existingCallbackNode!=null&&cancelCallback$1(existingCallbackNode);var newCallbackNode;if(newCallbackPriority===SyncLane)root.tag===LegacyRoot?(ReactCurrentActQueue$1.isBatchingLegacy!==null&&(ReactCurrentActQueue$1.didScheduleLegacyUpdate=!0),scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null,root))):scheduleSyncCallback(performSyncWorkOnRoot.bind(null,root)),supportsMicrotasks?ReactCurrentActQueue$1.current!==null?ReactCurrentActQueue$1.current.push(flushSyncCallbacks):scheduleMicrotask(function(){executionContext===NoContext&&flushSyncCallbacks()}):scheduleCallback$1(ImmediatePriority,flushSyncCallbacks),newCallbackNode=null;else{var schedulerPriorityLevel;switch(lanesToEventPriority(nextLanes)){case DiscreteEventPriority:schedulerPriorityLevel=ImmediatePriority;break;case ContinuousEventPriority:schedulerPriorityLevel=UserBlockingPriority;break;case DefaultEventPriority:schedulerPriorityLevel=NormalPriority;break;case IdleEventPriority:schedulerPriorityLevel=IdlePriority;break;default:schedulerPriorityLevel=NormalPriority;break}newCallbackNode=scheduleCallback$1(schedulerPriorityLevel,performConcurrentWorkOnRoot.bind(null,root))}root.callbackPriority=newCallbackPriority,root.callbackNode=newCallbackNode}function performConcurrentWorkOnRoot(root,didTimeout){if(resetNestedUpdateFlag(),currentEventTime=NoTimestamp,currentEventTransitionLane=NoLanes,(executionContext&(RenderContext|CommitContext))!==NoContext)throw new Error("Should not already be working.");var originalCallbackNode=root.callbackNode,didFlushPassiveEffects=flushPassiveEffects();if(didFlushPassiveEffects&&root.callbackNode!==originalCallbackNode)return null;var lanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:NoLanes);if(lanes===NoLanes)return null;var shouldTimeSlice=!includesBlockingLane(root,lanes)&&!includesExpiredLane(root,lanes)&&!didTimeout,exitStatus=shouldTimeSlice?renderRootConcurrent(root,lanes):renderRootSync(root,lanes);if(exitStatus!==RootInProgress){if(exitStatus===RootErrored){var errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);errorRetryLanes!==NoLanes&&(lanes=errorRetryLanes,exitStatus=recoverFromConcurrentError(root,errorRetryLanes))}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;throw prepareFreshStack(root,NoLanes),markRootSuspended$1(root,lanes),ensureRootIsScheduled(root,now$1()),fatalError}if(exitStatus===RootDidNotComplete)markRootSuspended$1(root,lanes);else{var renderWasConcurrent=!includesBlockingLane(root,lanes),finishedWork=root.current.alternate;if(renderWasConcurrent&&!isRenderConsistentWithExternalStores(finishedWork)){if(exitStatus=renderRootSync(root,lanes),exitStatus===RootErrored){var _errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);_errorRetryLanes!==NoLanes&&(lanes=_errorRetryLanes,exitStatus=recoverFromConcurrentError(root,_errorRetryLanes))}if(exitStatus===RootFatalErrored){var _fatalError=workInProgressRootFatalError;throw prepareFreshStack(root,NoLanes),markRootSuspended$1(root,lanes),ensureRootIsScheduled(root,now$1()),_fatalError}}root.finishedWork=finishedWork,root.finishedLanes=lanes,finishConcurrentRender(root,exitStatus,lanes)}}return ensureRootIsScheduled(root,now$1()),root.callbackNode===originalCallbackNode?performConcurrentWorkOnRoot.bind(null,root):null}function recoverFromConcurrentError(root,errorRetryLanes){var errorsFromFirstAttempt=workInProgressRootConcurrentErrors;if(isRootDehydrated(root)){var rootWorkInProgress=prepareFreshStack(root,errorRetryLanes);rootWorkInProgress.flags|=ForceClientRender,errorHydratingContainer(root.containerInfo)}var exitStatus=renderRootSync(root,errorRetryLanes);if(exitStatus!==RootErrored){var errorsFromSecondAttempt=workInProgressRootRecoverableErrors;workInProgressRootRecoverableErrors=errorsFromFirstAttempt,errorsFromSecondAttempt!==null&&queueRecoverableErrors(errorsFromSecondAttempt)}return exitStatus}function queueRecoverableErrors(errors){workInProgressRootRecoverableErrors===null?workInProgressRootRecoverableErrors=errors:workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors,errors)}function finishConcurrentRender(root,exitStatus,lanes){switch(exitStatus){case RootInProgress:case RootFatalErrored:throw new Error("Root did not complete. This is a bug in React.");case RootErrored:{commitRoot(root,workInProgressRootRecoverableErrors);break}case RootSuspended:{if(markRootSuspended$1(root,lanes),includesOnlyRetries(lanes)&&!shouldForceFlushFallbacksInDEV()){var msUntilTimeout=globalMostRecentFallbackTime+FALLBACK_THROTTLE_MS-now$1();if(msUntilTimeout>10){var nextLanes=getNextLanes(root,NoLanes);if(nextLanes!==NoLanes)break;var suspendedLanes=root.suspendedLanes;if(!isSubsetOfLanes(suspendedLanes,lanes)){requestEventTime(),markRootPinged(root,suspendedLanes);break}root.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors),msUntilTimeout);break}}commitRoot(root,workInProgressRootRecoverableErrors);break}case RootSuspendedWithDelay:{if(markRootSuspended$1(root,lanes),includesOnlyTransitions(lanes))break;if(!shouldForceFlushFallbacksInDEV()){var mostRecentEventTime=getMostRecentEventTime(root,lanes),eventTimeMs=mostRecentEventTime,timeElapsedMs=now$1()-eventTimeMs,_msUntilTimeout=jnd(timeElapsedMs)-timeElapsedMs;if(_msUntilTimeout>10){root.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors),_msUntilTimeout);break}}commitRoot(root,workInProgressRootRecoverableErrors);break}case RootCompleted:{commitRoot(root,workInProgressRootRecoverableErrors);break}default:throw new Error("Unknown root exit status.")}}function isRenderConsistentWithExternalStores(finishedWork){for(var node=finishedWork;;){if(node.flags&StoreConsistency){var updateQueue=node.updateQueue;if(updateQueue!==null){var checks=updateQueue.stores;if(checks!==null)for(var i2=0;i2<checks.length;i2++){var check=checks[i2],getSnapshot=check.getSnapshot,renderedValue=check.value;try{if(!objectIs(getSnapshot(),renderedValue))return!1}catch{return!1}}}}var child=node.child;if(node.subtreeFlags&StoreConsistency&&child!==null){child.return=node,node=child;continue}if(node===finishedWork)return!0;for(;node.sibling===null;){if(node.return===null||node.return===finishedWork)return!0;node=node.return}node.sibling.return=node.return,node=node.sibling}return!0}function markRootSuspended$1(root,suspendedLanes){suspendedLanes=removeLanes(suspendedLanes,workInProgressRootPingedLanes),suspendedLanes=removeLanes(suspendedLanes,workInProgressRootInterleavedUpdatedLanes),markRootSuspended(root,suspendedLanes)}function performSyncWorkOnRoot(root){if(syncNestedUpdateFlag(),(executionContext&(RenderContext|CommitContext))!==NoContext)throw new Error("Should not already be working.");flushPassiveEffects();var lanes=getNextLanes(root,NoLanes);if(!includesSomeLane(lanes,SyncLane))return ensureRootIsScheduled(root,now$1()),null;var exitStatus=renderRootSync(root,lanes);if(root.tag!==LegacyRoot&&exitStatus===RootErrored){var errorRetryLanes=getLanesToRetrySynchronouslyOnError(root);errorRetryLanes!==NoLanes&&(lanes=errorRetryLanes,exitStatus=recoverFromConcurrentError(root,errorRetryLanes))}if(exitStatus===RootFatalErrored){var fatalError=workInProgressRootFatalError;throw prepareFreshStack(root,NoLanes),markRootSuspended$1(root,lanes),ensureRootIsScheduled(root,now$1()),fatalError}if(exitStatus===RootDidNotComplete)throw new Error("Root did not complete. This is a bug in React.");var finishedWork=root.current.alternate;return root.finishedWork=finishedWork,root.finishedLanes=lanes,commitRoot(root,workInProgressRootRecoverableErrors),ensureRootIsScheduled(root,now$1()),null}function flushRoot(root,lanes){lanes!==NoLanes&&(markRootEntangled(root,mergeLanes(lanes,SyncLane)),ensureRootIsScheduled(root,now$1()),(executionContext&(RenderContext|CommitContext))===NoContext&&(resetRenderTimer(),flushSyncCallbacks()))}function deferredUpdates(fn){var previousPriority=getCurrentUpdatePriority(),prevTransition=ReactCurrentBatchConfig$2.transition;try{return ReactCurrentBatchConfig$2.transition=null,setCurrentUpdatePriority(DefaultEventPriority),fn()}finally{setCurrentUpdatePriority(previousPriority),ReactCurrentBatchConfig$2.transition=prevTransition}}function batchedUpdates(fn,a2){var prevExecutionContext=executionContext;executionContext|=BatchedContext;try{return fn(a2)}finally{executionContext=prevExecutionContext,executionContext===NoContext&&!ReactCurrentActQueue$1.isBatchingLegacy&&(resetRenderTimer(),flushSyncCallbacksOnlyInLegacyMode())}}function discreteUpdates(fn,a2,b2,c2,d2){var previousPriority=getCurrentUpdatePriority(),prevTransition=ReactCurrentBatchConfig$2.transition;try{return ReactCurrentBatchConfig$2.transition=null,setCurrentUpdatePriority(DiscreteEventPriority),fn(a2,b2,c2,d2)}finally{setCurrentUpdatePriority(previousPriority),ReactCurrentBatchConfig$2.transition=prevTransition,executionContext===NoContext&&resetRenderTimer()}}function flushSync(fn){rootWithPendingPassiveEffects!==null&&rootWithPendingPassiveEffects.tag===LegacyRoot&&(executionContext&(RenderContext|CommitContext))===NoContext&&flushPassiveEffects();var prevExecutionContext=executionContext;executionContext|=BatchedContext;var prevTransition=ReactCurrentBatchConfig$2.transition,previousPriority=getCurrentUpdatePriority();try{return ReactCurrentBatchConfig$2.transition=null,setCurrentUpdatePriority(DiscreteEventPriority),fn?fn():void 0}finally{setCurrentUpdatePriority(previousPriority),ReactCurrentBatchConfig$2.transition=prevTransition,executionContext=prevExecutionContext,(executionContext&(RenderContext|CommitContext))===NoContext&&flushSyncCallbacks()}}function isAlreadyRendering(){return(executionContext&(RenderContext|CommitContext))!==NoContext}function flushControlled(fn){var prevExecutionContext=executionContext;executionContext|=BatchedContext;var prevTransition=ReactCurrentBatchConfig$2.transition,previousPriority=getCurrentUpdatePriority();try{ReactCurrentBatchConfig$2.transition=null,setCurrentUpdatePriority(DiscreteEventPriority),fn()}finally{setCurrentUpdatePriority(previousPriority),ReactCurrentBatchConfig$2.transition=prevTransition,executionContext=prevExecutionContext,executionContext===NoContext&&(resetRenderTimer(),flushSyncCallbacks())}}function pushRenderLanes(fiber,lanes){push(subtreeRenderLanesCursor,subtreeRenderLanes,fiber),subtreeRenderLanes=mergeLanes(subtreeRenderLanes,lanes)}function popRenderLanes(fiber){subtreeRenderLanes=subtreeRenderLanesCursor.current,pop(subtreeRenderLanesCursor,fiber)}function prepareFreshStack(root,lanes){root.finishedWork=null,root.finishedLanes=NoLanes;var timeoutHandle=root.timeoutHandle;if(timeoutHandle!==noTimeout&&(root.timeoutHandle=noTimeout,cancelTimeout(timeoutHandle)),workInProgress!==null)for(var interruptedWork=workInProgress.return;interruptedWork!==null;){var current2=interruptedWork.alternate;unwindInterruptedWork(current2,interruptedWork),interruptedWork=interruptedWork.return}workInProgressRoot=root;var rootWorkInProgress=createWorkInProgress(root.current,null);return workInProgress=rootWorkInProgress,workInProgressRootRenderLanes=subtreeRenderLanes=lanes,workInProgressRootExitStatus=RootInProgress,workInProgressRootFatalError=null,workInProgressRootSkippedLanes=NoLanes,workInProgressRootInterleavedUpdatedLanes=NoLanes,workInProgressRootPingedLanes=NoLanes,workInProgressRootConcurrentErrors=null,workInProgressRootRecoverableErrors=null,enqueueInterleavedUpdates(),ReactStrictModeWarnings.discardPendingWarnings(),rootWorkInProgress}function handleError(root,thrownValue){do{var erroredWork=workInProgress;try{if(resetContextDependencies(),resetHooksAfterThrow(),resetCurrentFiber(),ReactCurrentOwner$2.current=null,erroredWork===null||erroredWork.return===null){workInProgressRootExitStatus=RootFatalErrored,workInProgressRootFatalError=thrownValue,workInProgress=null;return}if(enableProfilerTimer&&erroredWork.mode&ProfileMode&&stopProfilerTimerIfRunningAndRecordDelta(erroredWork,!0),enableSchedulingProfiler)if(markComponentRenderStopped(),thrownValue!==null&&typeof thrownValue=="object"&&typeof thrownValue.then=="function"){var wakeable=thrownValue;markComponentSuspended(erroredWork,wakeable,workInProgressRootRenderLanes)}else markComponentErrored(erroredWork,thrownValue,workInProgressRootRenderLanes);throwException(root,erroredWork.return,erroredWork,thrownValue,workInProgressRootRenderLanes),completeUnitOfWork(erroredWork)}catch(yetAnotherThrownValue){thrownValue=yetAnotherThrownValue,workInProgress===erroredWork&&erroredWork!==null?(erroredWork=erroredWork.return,workInProgress=erroredWork):erroredWork=workInProgress;continue}return}while(!0)}function pushDispatcher(){var prevDispatcher=ReactCurrentDispatcher$2.current;return ReactCurrentDispatcher$2.current=ContextOnlyDispatcher,prevDispatcher===null?ContextOnlyDispatcher:prevDispatcher}function popDispatcher(prevDispatcher){ReactCurrentDispatcher$2.current=prevDispatcher}function markCommitTimeOfFallback(){globalMostRecentFallbackTime=now$1()}function markSkippedUpdateLanes(lane){workInProgressRootSkippedLanes=mergeLanes(lane,workInProgressRootSkippedLanes)}function renderDidSuspend(){workInProgressRootExitStatus===RootInProgress&&(workInProgressRootExitStatus=RootSuspended)}function renderDidSuspendDelayIfPossible(){(workInProgressRootExitStatus===RootInProgress||workInProgressRootExitStatus===RootSuspended||workInProgressRootExitStatus===RootErrored)&&(workInProgressRootExitStatus=RootSuspendedWithDelay),workInProgressRoot!==null&&(includesNonIdleWork(workInProgressRootSkippedLanes)||includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))&&markRootSuspended$1(workInProgressRoot,workInProgressRootRenderLanes)}function renderDidError(error2){workInProgressRootExitStatus!==RootSuspendedWithDelay&&(workInProgressRootExitStatus=RootErrored),workInProgressRootConcurrentErrors===null?workInProgressRootConcurrentErrors=[error2]:workInProgressRootConcurrentErrors.push(error2)}function renderHasNotSuspendedYet(){return workInProgressRootExitStatus===RootInProgress}function renderRootSync(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();if(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;memoizedUpdaters.size>0&&(restorePendingUpdaters(root,workInProgressRootRenderLanes),memoizedUpdaters.clear()),movePendingFibersToMemoized(root,lanes)}prepareFreshStack(root,lanes)}markRenderStarted(lanes);do try{workLoopSync();break}catch(thrownValue){handleError(root,thrownValue)}while(!0);if(resetContextDependencies(),executionContext=prevExecutionContext,popDispatcher(prevDispatcher),workInProgress!==null)throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");return markRenderStopped(),workInProgressRoot=null,workInProgressRootRenderLanes=NoLanes,workInProgressRootExitStatus}function workLoopSync(){for(;workInProgress!==null;)performUnitOfWork(workInProgress)}function renderRootConcurrent(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();if(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;memoizedUpdaters.size>0&&(restorePendingUpdaters(root,workInProgressRootRenderLanes),memoizedUpdaters.clear()),movePendingFibersToMemoized(root,lanes)}resetRenderTimer(),prepareFreshStack(root,lanes)}markRenderStarted(lanes);do try{workLoopConcurrent();break}catch(thrownValue){handleError(root,thrownValue)}while(!0);return resetContextDependencies(),popDispatcher(prevDispatcher),executionContext=prevExecutionContext,workInProgress!==null?(markRenderYielded(),RootInProgress):(markRenderStopped(),workInProgressRoot=null,workInProgressRootRenderLanes=NoLanes,workInProgressRootExitStatus)}function workLoopConcurrent(){for(;workInProgress!==null&&!shouldYield();)performUnitOfWork(workInProgress)}function performUnitOfWork(unitOfWork){var current2=unitOfWork.alternate;setCurrentFiber(unitOfWork);var next;(unitOfWork.mode&ProfileMode)!==NoMode?(startProfilerTimer(unitOfWork),next=beginWork$1(current2,unitOfWork,subtreeRenderLanes),stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,!0)):next=beginWork$1(current2,unitOfWork,subtreeRenderLanes),resetCurrentFiber(),unitOfWork.memoizedProps=unitOfWork.pendingProps,next===null?completeUnitOfWork(unitOfWork):workInProgress=next,ReactCurrentOwner$2.current=null}function completeUnitOfWork(unitOfWork){var completedWork=unitOfWork;do{var current2=completedWork.alternate,returnFiber=completedWork.return;if((completedWork.flags&Incomplete)===NoFlags){setCurrentFiber(completedWork);var next=void 0;if((completedWork.mode&ProfileMode)===NoMode?next=completeWork(current2,completedWork,subtreeRenderLanes):(startProfilerTimer(completedWork),next=completeWork(current2,completedWork,subtreeRenderLanes),stopProfilerTimerIfRunningAndRecordDelta(completedWork,!1)),resetCurrentFiber(),next!==null){workInProgress=next;return}}else{var _next=unwindWork(current2,completedWork);if(_next!==null){_next.flags&=HostEffectMask,workInProgress=_next;return}if((completedWork.mode&ProfileMode)!==NoMode){stopProfilerTimerIfRunningAndRecordDelta(completedWork,!1);for(var actualDuration=completedWork.actualDuration,child=completedWork.child;child!==null;)actualDuration+=child.actualDuration,child=child.sibling;completedWork.actualDuration=actualDuration}if(returnFiber!==null)returnFiber.flags|=Incomplete,returnFiber.subtreeFlags=NoFlags,returnFiber.deletions=null;else{workInProgressRootExitStatus=RootDidNotComplete,workInProgress=null;return}}var siblingFiber=completedWork.sibling;if(siblingFiber!==null){workInProgress=siblingFiber;return}completedWork=returnFiber,workInProgress=completedWork}while(completedWork!==null);workInProgressRootExitStatus===RootInProgress&&(workInProgressRootExitStatus=RootCompleted)}function commitRoot(root,recoverableErrors){var previousUpdateLanePriority=getCurrentUpdatePriority(),prevTransition=ReactCurrentBatchConfig$2.transition;try{ReactCurrentBatchConfig$2.transition=null,setCurrentUpdatePriority(DiscreteEventPriority),commitRootImpl(root,recoverableErrors,previousUpdateLanePriority)}finally{ReactCurrentBatchConfig$2.transition=prevTransition,setCurrentUpdatePriority(previousUpdateLanePriority)}return null}function commitRootImpl(root,recoverableErrors,renderPriorityLevel){do flushPassiveEffects();while(rootWithPendingPassiveEffects!==null);if(flushRenderPhaseStrictModeWarningsInDEV(),(executionContext&(RenderContext|CommitContext))!==NoContext)throw new Error("Should not already be working.");var finishedWork=root.finishedWork,lanes=root.finishedLanes;if(markCommitStarted(lanes),finishedWork===null)return markCommitStopped(),null;if(lanes===NoLanes&&error("root.finishedLanes should not be empty during a commit. This is a bug in React."),root.finishedWork=null,root.finishedLanes=NoLanes,finishedWork===root.current)throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");root.callbackNode=null,root.callbackPriority=NoLane;var remainingLanes=mergeLanes(finishedWork.lanes,finishedWork.childLanes);markRootFinished(root,remainingLanes),root===workInProgressRoot&&(workInProgressRoot=null,workInProgress=null,workInProgressRootRenderLanes=NoLanes),((finishedWork.subtreeFlags&PassiveMask)!==NoFlags||(finishedWork.flags&PassiveMask)!==NoFlags)&&(rootDoesHavePassiveEffects||(rootDoesHavePassiveEffects=!0,scheduleCallback$1(NormalPriority,function(){return flushPassiveEffects(),null})));var subtreeHasEffects=(finishedWork.subtreeFlags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags,rootHasEffect=(finishedWork.flags&(BeforeMutationMask|MutationMask|LayoutMask|PassiveMask))!==NoFlags;if(subtreeHasEffects||rootHasEffect){var prevTransition=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition=null;var previousPriority=getCurrentUpdatePriority();setCurrentUpdatePriority(DiscreteEventPriority);var prevExecutionContext=executionContext;executionContext|=CommitContext,ReactCurrentOwner$2.current=null,commitBeforeMutationEffects(root,finishedWork),recordCommitTime(),commitMutationEffects(root,finishedWork,lanes),resetAfterCommit(root.containerInfo),root.current=finishedWork,markLayoutEffectsStarted(lanes),commitLayoutEffects(finishedWork,root,lanes),markLayoutEffectsStopped(),requestPaint(),executionContext=prevExecutionContext,setCurrentUpdatePriority(previousPriority),ReactCurrentBatchConfig$2.transition=prevTransition}else root.current=finishedWork,recordCommitTime();var rootDidHavePassiveEffects=rootDoesHavePassiveEffects;if(rootDoesHavePassiveEffects&&(rootDoesHavePassiveEffects=!1,rootWithPendingPassiveEffects=root,pendingPassiveEffectsLanes=lanes),remainingLanes=root.pendingLanes,remainingLanes===NoLanes&&(legacyErrorBoundariesThatAlreadyFailed=null),rootDidHavePassiveEffects||commitDoubleInvokeEffectsInDEV(root.current,!1),onCommitRoot(finishedWork.stateNode,renderPriorityLevel),isDevToolsPresent&&root.memoizedUpdaters.clear(),onCommitRoot$1(),ensureRootIsScheduled(root,now$1()),recoverableErrors!==null)for(var onRecoverableError=root.onRecoverableError,i2=0;i2<recoverableErrors.length;i2++){var recoverableError=recoverableErrors[i2];onRecoverableError(recoverableError)}if(hasUncaughtError){hasUncaughtError=!1;var error$1=firstUncaughtError;throw firstUncaughtError=null,error$1}return includesSomeLane(pendingPassiveEffectsLanes,SyncLane)&&root.tag!==LegacyRoot&&flushPassiveEffects(),remainingLanes=root.pendingLanes,includesSomeLane(remainingLanes,SyncLane)?(markNestedUpdateScheduled(),root===rootWithNestedUpdates?nestedUpdateCount++:(nestedUpdateCount=0,rootWithNestedUpdates=root)):nestedUpdateCount=0,flushSyncCallbacks(),markCommitStopped(),null}function flushPassiveEffects(){if(rootWithPendingPassiveEffects!==null){var renderPriority=lanesToEventPriority(pendingPassiveEffectsLanes),priority=lowerEventPriority(DefaultEventPriority,renderPriority),prevTransition=ReactCurrentBatchConfig$2.transition,previousPriority=getCurrentUpdatePriority();try{return ReactCurrentBatchConfig$2.transition=null,setCurrentUpdatePriority(priority),flushPassiveEffectsImpl()}finally{setCurrentUpdatePriority(previousPriority),ReactCurrentBatchConfig$2.transition=prevTransition}}return!1}function enqueuePendingPassiveProfilerEffect(fiber){pendingPassiveProfilerEffects.push(fiber),rootDoesHavePassiveEffects||(rootDoesHavePassiveEffects=!0,scheduleCallback$1(NormalPriority,function(){return flushPassiveEffects(),null}))}function flushPassiveEffectsImpl(){if(rootWithPendingPassiveEffects===null)return!1;var root=rootWithPendingPassiveEffects,lanes=pendingPassiveEffectsLanes;if(rootWithPendingPassiveEffects=null,pendingPassiveEffectsLanes=NoLanes,(executionContext&(RenderContext|CommitContext))!==NoContext)throw new Error("Cannot flush passive effects while already rendering.");markPassiveEffectsStarted(lanes);var prevExecutionContext=executionContext;executionContext|=CommitContext,commitPassiveUnmountEffects(root.current),commitPassiveMountEffects(root,root.current);{var profilerEffects=pendingPassiveProfilerEffects;pendingPassiveProfilerEffects=[];for(var i2=0;i2<profilerEffects.length;i2++){var _fiber=profilerEffects[i2];commitPassiveEffectDurations(root,_fiber)}}markPassiveEffectsStopped(),commitDoubleInvokeEffectsInDEV(root.current,!0),executionContext=prevExecutionContext,flushSyncCallbacks(),nestedPassiveUpdateCount=rootWithPendingPassiveEffects===null?0:nestedPassiveUpdateCount+1,onPostCommitRoot(root);{var stateNode=root.current.stateNode;stateNode.effectDuration=0,stateNode.passiveEffectDuration=0}return!0}function isAlreadyFailedLegacyErrorBoundary(instance){return legacyErrorBoundariesThatAlreadyFailed!==null&&legacyErrorBoundariesThatAlreadyFailed.has(instance)}function markLegacyErrorBoundaryAsFailed(instance){legacyErrorBoundariesThatAlreadyFailed===null?legacyErrorBoundariesThatAlreadyFailed=new Set([instance]):legacyErrorBoundariesThatAlreadyFailed.add(instance)}function prepareToThrowUncaughtError(error2){hasUncaughtError||(hasUncaughtError=!0,firstUncaughtError=error2)}var onUncaughtError=prepareToThrowUncaughtError;function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error2){var errorInfo=createCapturedValue(error2,sourceFiber),update=createRootErrorUpdate(rootFiber,errorInfo,SyncLane);enqueueUpdate(rootFiber,update);var eventTime=requestEventTime(),root=markUpdateLaneFromFiberToRoot(rootFiber,SyncLane);root!==null&&(markRootUpdated(root,SyncLane,eventTime),ensureRootIsScheduled(root,eventTime))}function captureCommitPhaseError(sourceFiber,nearestMountedAncestor,error$1){if(sourceFiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error$1);return}var fiber=null;for(fiber=nearestMountedAncestor;fiber!==null;){if(fiber.tag===HostRoot){captureCommitPhaseErrorOnRoot(fiber,sourceFiber,error$1);return}else if(fiber.tag===ClassComponent){var ctor=fiber.type,instance=fiber.stateNode;if(typeof ctor.getDerivedStateFromError=="function"||typeof instance.componentDidCatch=="function"&&!isAlreadyFailedLegacyErrorBoundary(instance)){var errorInfo=createCapturedValue(error$1,sourceFiber),update=createClassErrorUpdate(fiber,errorInfo,SyncLane);enqueueUpdate(fiber,update);var eventTime=requestEventTime(),root=markUpdateLaneFromFiberToRoot(fiber,SyncLane);root!==null&&(markRootUpdated(root,SyncLane,eventTime),ensureRootIsScheduled(root,eventTime));return}}fiber=fiber.return}error(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`,error$1)}function pingSuspendedRoot(root,wakeable,pingedLanes){var pingCache=root.pingCache;pingCache!==null&&pingCache.delete(wakeable);var eventTime=requestEventTime();markRootPinged(root,pingedLanes),warnIfSuspenseResolutionNotWrappedWithActDEV(root),workInProgressRoot===root&&isSubsetOfLanes(workInProgressRootRenderLanes,pingedLanes)&&(workInProgressRootExitStatus===RootSuspendedWithDelay||workInProgressRootExitStatus===RootSuspended&&includesOnlyRetries(workInProgressRootRenderLanes)&&now$1()-globalMostRecentFallbackTime<FALLBACK_THROTTLE_MS?prepareFreshStack(root,NoLanes):workInProgressRootPingedLanes=mergeLanes(workInProgressRootPingedLanes,pingedLanes)),ensureRootIsScheduled(root,eventTime)}function retryTimedOutBoundary(boundaryFiber,retryLane){retryLane===NoLane&&(retryLane=requestRetryLane(boundaryFiber));var eventTime=requestEventTime(),root=markUpdateLaneFromFiberToRoot(boundaryFiber,retryLane);root!==null&&(markRootUpdated(root,retryLane,eventTime),ensureRootIsScheduled(root,eventTime))}function retryDehydratedSuspenseBoundary(boundaryFiber){var suspenseState=boundaryFiber.memoizedState,retryLane=NoLane;suspenseState!==null&&(retryLane=suspenseState.retryLane),retryTimedOutBoundary(boundaryFiber,retryLane)}function resolveRetryWakeable(boundaryFiber,wakeable){var retryLane=NoLane,retryCache;switch(boundaryFiber.tag){case SuspenseComponent:retryCache=boundaryFiber.stateNode;var suspenseState=boundaryFiber.memoizedState;suspenseState!==null&&(retryLane=suspenseState.retryLane);break;case SuspenseListComponent:retryCache=boundaryFiber.stateNode;break;default:throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.")}retryCache!==null&&retryCache.delete(wakeable),retryTimedOutBoundary(boundaryFiber,retryLane)}function jnd(timeElapsed){return timeElapsed<120?120:timeElapsed<480?480:timeElapsed<1080?1080:timeElapsed<1920?1920:timeElapsed<3e3?3e3:timeElapsed<4320?4320:ceil(timeElapsed/1960)*1960}function checkForNestedUpdates(){if(nestedUpdateCount>NESTED_UPDATE_LIMIT)throw nestedUpdateCount=0,rootWithNestedUpdates=null,new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");nestedPassiveUpdateCount>NESTED_PASSIVE_UPDATE_LIMIT&&(nestedPassiveUpdateCount=0,error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."))}function flushRenderPhaseStrictModeWarningsInDEV(){ReactStrictModeWarnings.flushLegacyContextWarning(),ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings()}function commitDoubleInvokeEffectsInDEV(fiber,hasPassiveEffects){setCurrentFiber(fiber),invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectUnmountInDEV),hasPassiveEffects&&invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectUnmountInDEV),invokeEffectsInDev(fiber,MountLayoutDev,invokeLayoutEffectMountInDEV),hasPassiveEffects&&invokeEffectsInDev(fiber,MountPassiveDev,invokePassiveEffectMountInDEV),resetCurrentFiber()}function invokeEffectsInDev(firstChild,fiberFlags,invokeEffectFn){for(var current2=firstChild,subtreeRoot=null;current2!==null;){var primarySubtreeFlag=current2.subtreeFlags&fiberFlags;current2!==subtreeRoot&&current2.child!==null&&primarySubtreeFlag!==NoFlags?current2=current2.child:((current2.flags&fiberFlags)!==NoFlags&&invokeEffectFn(current2),current2.sibling!==null?current2=current2.sibling:current2=subtreeRoot=current2.return)}}var didWarnStateUpdateForNotYetMountedComponent=null;function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber){{if((executionContext&RenderContext)!==NoContext||!(fiber.mode&ConcurrentMode))return;var tag=fiber.tag;if(tag!==IndeterminateComponent&&tag!==HostRoot&&tag!==ClassComponent&&tag!==FunctionComponent&&tag!==ForwardRef&&tag!==MemoComponent&&tag!==SimpleMemoComponent)return;var componentName=getComponentNameFromFiber(fiber)||"ReactComponent";if(didWarnStateUpdateForNotYetMountedComponent!==null){if(didWarnStateUpdateForNotYetMountedComponent.has(componentName))return;didWarnStateUpdateForNotYetMountedComponent.add(componentName)}else didWarnStateUpdateForNotYetMountedComponent=new Set([componentName]);var previousFiber=current;try{setCurrentFiber(fiber),error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.")}finally{previousFiber?setCurrentFiber(fiber):resetCurrentFiber()}}}var beginWork$1;{var dummyFiber=null;beginWork$1=function(current2,unitOfWork,lanes){var originalWorkInProgressCopy=assignFiberPropertiesInDEV(dummyFiber,unitOfWork);try{return beginWork(current2,unitOfWork,lanes)}catch(originalError){if(originalError!==null&&typeof originalError=="object"&&typeof originalError.then=="function")throw originalError;if(resetContextDependencies(),resetHooksAfterThrow(),unwindInterruptedWork(current2,unitOfWork),assignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy),unitOfWork.mode&ProfileMode&&startProfilerTimer(unitOfWork),invokeGuardedCallback(null,beginWork,null,current2,unitOfWork,lanes),hasCaughtError()){var replayError=clearCaughtError();typeof replayError=="object"&&replayError!==null&&replayError._suppressLogging&&typeof originalError=="object"&&originalError!==null&&!originalError._suppressLogging&&(originalError._suppressLogging=!0)}throw originalError}}}var didWarnAboutUpdateInRender=!1,didWarnAboutUpdateInRenderForAnotherComponent;didWarnAboutUpdateInRenderForAnotherComponent=new Set;function warnAboutRenderPhaseUpdatesInDEV(fiber){if(isRendering&&!getIsUpdatingOpaqueValueInRenderPhaseInDEV())switch(fiber.tag){case FunctionComponent:case ForwardRef:case SimpleMemoComponent:{var renderingComponentName=workInProgress&&getComponentNameFromFiber(workInProgress)||"Unknown",dedupeKey=renderingComponentName;if(!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)){didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);var setStateComponentName=getComponentNameFromFiber(fiber)||"Unknown";error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render",setStateComponentName,renderingComponentName,renderingComponentName)}break}case ClassComponent:{didWarnAboutUpdateInRender||(error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."),didWarnAboutUpdateInRender=!0);break}}}function restorePendingUpdaters(root,lanes){if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;memoizedUpdaters.forEach(function(schedulingFiber){addFiberToLanesMap(root,schedulingFiber,lanes)})}}var fakeActCallbackNode={};function scheduleCallback$1(priorityLevel,callback){{var actQueue=ReactCurrentActQueue$1.current;return actQueue!==null?(actQueue.push(callback),fakeActCallbackNode):scheduleCallback(priorityLevel,callback)}}function cancelCallback$1(callbackNode){if(callbackNode!==fakeActCallbackNode)return cancelCallback(callbackNode)}function shouldForceFlushFallbacksInDEV(){return ReactCurrentActQueue$1.current!==null}function warnIfUpdatesNotWrappedWithActDEV(fiber){{if(fiber.mode&ConcurrentMode){if(!isConcurrentActEnvironment())return}else if(!isLegacyActEnvironment()||executionContext!==NoContext||fiber.tag!==FunctionComponent&&fiber.tag!==ForwardRef&&fiber.tag!==SimpleMemoComponent)return;if(ReactCurrentActQueue$1.current===null){var previousFiber=current;try{setCurrentFiber(fiber),error(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`,getComponentNameFromFiber(fiber))}finally{previousFiber?setCurrentFiber(fiber):resetCurrentFiber()}}}}function warnIfSuspenseResolutionNotWrappedWithActDEV(root){root.tag!==LegacyRoot&&isConcurrentActEnvironment()&&ReactCurrentActQueue$1.current===null&&error(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`)}var resolveFamily=null,failedBoundaries=null,setRefreshHandler=function(handler){resolveFamily=handler};function resolveFunctionForHotReloading(type){{if(resolveFamily===null)return type;var family=resolveFamily(type);return family===void 0?type:family.current}}function resolveClassForHotReloading(type){return resolveFunctionForHotReloading(type)}function resolveForwardRefForHotReloading(type){{if(resolveFamily===null)return type;var family=resolveFamily(type);if(family===void 0){if(type!=null&&typeof type.render=="function"){var currentRender=resolveFunctionForHotReloading(type.render);if(type.render!==currentRender){var syntheticType={$$typeof:REACT_FORWARD_REF_TYPE,render:currentRender};return type.displayName!==void 0&&(syntheticType.displayName=type.displayName),syntheticType}}return type}return family.current}}function isCompatibleFamilyForHotReloading(fiber,element){{if(resolveFamily===null)return!1;var prevType=fiber.elementType,nextType=element.type,needsCompareFamilies=!1,$$typeofNextType=typeof nextType=="object"&&nextType!==null?nextType.$$typeof:null;switch(fiber.tag){case ClassComponent:{typeof nextType=="function"&&(needsCompareFamilies=!0);break}case FunctionComponent:{(typeof nextType=="function"||$$typeofNextType===REACT_LAZY_TYPE)&&(needsCompareFamilies=!0);break}case ForwardRef:{($$typeofNextType===REACT_FORWARD_REF_TYPE||$$typeofNextType===REACT_LAZY_TYPE)&&(needsCompareFamilies=!0);break}case MemoComponent:case SimpleMemoComponent:{($$typeofNextType===REACT_MEMO_TYPE||$$typeofNextType===REACT_LAZY_TYPE)&&(needsCompareFamilies=!0);break}default:return!1}if(needsCompareFamilies){var prevFamily=resolveFamily(prevType);if(prevFamily!==void 0&&prevFamily===resolveFamily(nextType))return!0}return!1}}function markFailedErrorBoundaryForHotReloading(fiber){{if(resolveFamily===null||typeof WeakSet!="function")return;failedBoundaries===null&&(failedBoundaries=new WeakSet),failedBoundaries.add(fiber)}}var scheduleRefresh=function(root,update){{if(resolveFamily===null)return;var staleFamilies=update.staleFamilies,updatedFamilies=update.updatedFamilies;flushPassiveEffects(),flushSync(function(){scheduleFibersWithFamiliesRecursively(root.current,updatedFamilies,staleFamilies)})}},scheduleRoot=function(root,element){{if(root.context!==emptyContextObject)return;flushPassiveEffects(),flushSync(function(){updateContainer(element,root,null,null)})}};function scheduleFibersWithFamiliesRecursively(fiber,updatedFamilies,staleFamilies){{var alternate=fiber.alternate,child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type,candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break}if(resolveFamily===null)throw new Error("Expected resolveFamily to be set during hot reload.");var needsRender=!1,needsRemount=!1;if(candidateType!==null){var family=resolveFamily(candidateType);family!==void 0&&(staleFamilies.has(family)?needsRemount=!0:updatedFamilies.has(family)&&(tag===ClassComponent?needsRemount=!0:needsRender=!0))}failedBoundaries!==null&&(failedBoundaries.has(fiber)||alternate!==null&&failedBoundaries.has(alternate))&&(needsRemount=!0),needsRemount&&(fiber._debugNeedsRemount=!0),(needsRemount||needsRender)&&scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp),child!==null&&!needsRemount&&scheduleFibersWithFamiliesRecursively(child,updatedFamilies,staleFamilies),sibling!==null&&scheduleFibersWithFamiliesRecursively(sibling,updatedFamilies,staleFamilies)}}var findHostInstancesForRefresh=function(root,families){{var hostInstances=new Set,types2=new Set(families.map(function(family){return family.current}));return findHostInstancesForMatchingFibersRecursively(root.current,types2,hostInstances),hostInstances}};function findHostInstancesForMatchingFibersRecursively(fiber,types2,hostInstances){{var child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type,candidateType=null;switch(tag){case FunctionComponent:case SimpleMemoComponent:case ClassComponent:candidateType=type;break;case ForwardRef:candidateType=type.render;break}var didMatch=!1;candidateType!==null&&types2.has(candidateType)&&(didMatch=!0),didMatch?findHostInstancesForFiberShallowly(fiber,hostInstances):child!==null&&findHostInstancesForMatchingFibersRecursively(child,types2,hostInstances),sibling!==null&&findHostInstancesForMatchingFibersRecursively(sibling,types2,hostInstances)}}function findHostInstancesForFiberShallowly(fiber,hostInstances){{var foundHostInstances=findChildHostInstancesForFiberShallowly(fiber,hostInstances);if(foundHostInstances)return;for(var node=fiber;;){switch(node.tag){case HostComponent:hostInstances.add(node.stateNode);return;case HostPortal:hostInstances.add(node.stateNode.containerInfo);return;case HostRoot:hostInstances.add(node.stateNode.containerInfo);return}if(node.return===null)throw new Error("Expected to reach root first.");node=node.return}}}function findChildHostInstancesForFiberShallowly(fiber,hostInstances){for(var node=fiber,foundHostInstances=!1;;){if(node.tag===HostComponent)foundHostInstances=!0,hostInstances.add(node.stateNode);else if(node.child!==null){node.child.return=node,node=node.child;continue}if(node===fiber)return foundHostInstances;for(;node.sibling===null;){if(node.return===null||node.return===fiber)return foundHostInstances;node=node.return}node.sibling.return=node.return,node=node.sibling}return!1}var hasBadMapPolyfill;{hasBadMapPolyfill=!1;try{var nonExtensibleObject=Object.preventExtensions({})}catch{hasBadMapPolyfill=!0}}function FiberNode(tag,pendingProps,key,mode){this.tag=tag,this.key=key,this.elementType=null,this.type=null,this.stateNode=null,this.return=null,this.child=null,this.sibling=null,this.index=0,this.ref=null,this.pendingProps=pendingProps,this.memoizedProps=null,this.updateQueue=null,this.memoizedState=null,this.dependencies=null,this.mode=mode,this.flags=NoFlags,this.subtreeFlags=NoFlags,this.deletions=null,this.lanes=NoLanes,this.childLanes=NoLanes,this.alternate=null,this.actualDuration=Number.NaN,this.actualStartTime=Number.NaN,this.selfBaseDuration=Number.NaN,this.treeBaseDuration=Number.NaN,this.actualDuration=0,this.actualStartTime=-1,this.selfBaseDuration=0,this.treeBaseDuration=0,this._debugSource=null,this._debugOwner=null,this._debugNeedsRemount=!1,this._debugHookTypes=null,!hasBadMapPolyfill&&typeof Object.preventExtensions=="function"&&Object.preventExtensions(this)}var createFiber=function(tag,pendingProps,key,mode){return new FiberNode(tag,pendingProps,key,mode)};function shouldConstruct$1(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent)}function isSimpleFunctionComponent(type){return typeof type=="function"&&!shouldConstruct$1(type)&&type.defaultProps===void 0}function resolveLazyComponentTag(Component){if(typeof Component=="function")return shouldConstruct$1(Component)?ClassComponent:FunctionComponent;if(Component!=null){var $$typeof=Component.$$typeof;if($$typeof===REACT_FORWARD_REF_TYPE)return ForwardRef;if($$typeof===REACT_MEMO_TYPE)return MemoComponent}return IndeterminateComponent}function createWorkInProgress(current2,pendingProps){var workInProgress2=current2.alternate;workInProgress2===null?(workInProgress2=createFiber(current2.tag,pendingProps,current2.key,current2.mode),workInProgress2.elementType=current2.elementType,workInProgress2.type=current2.type,workInProgress2.stateNode=current2.stateNode,workInProgress2._debugSource=current2._debugSource,workInProgress2._debugOwner=current2._debugOwner,workInProgress2._debugHookTypes=current2._debugHookTypes,workInProgress2.alternate=current2,current2.alternate=workInProgress2):(workInProgress2.pendingProps=pendingProps,workInProgress2.type=current2.type,workInProgress2.flags=NoFlags,workInProgress2.subtreeFlags=NoFlags,workInProgress2.deletions=null,workInProgress2.actualDuration=0,workInProgress2.actualStartTime=-1),workInProgress2.flags=current2.flags&StaticMask,workInProgress2.childLanes=current2.childLanes,workInProgress2.lanes=current2.lanes,workInProgress2.child=current2.child,workInProgress2.memoizedProps=current2.memoizedProps,workInProgress2.memoizedState=current2.memoizedState,workInProgress2.updateQueue=current2.updateQueue;var currentDependencies=current2.dependencies;switch(workInProgress2.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext},workInProgress2.sibling=current2.sibling,workInProgress2.index=current2.index,workInProgress2.ref=current2.ref,workInProgress2.selfBaseDuration=current2.selfBaseDuration,workInProgress2.treeBaseDuration=current2.treeBaseDuration,workInProgress2._debugNeedsRemount=current2._debugNeedsRemount,workInProgress2.tag){case IndeterminateComponent:case FunctionComponent:case SimpleMemoComponent:workInProgress2.type=resolveFunctionForHotReloading(current2.type);break;case ClassComponent:workInProgress2.type=resolveClassForHotReloading(current2.type);break;case ForwardRef:workInProgress2.type=resolveForwardRefForHotReloading(current2.type);break}return workInProgress2}function resetWorkInProgress(workInProgress2,renderLanes2){workInProgress2.flags&=StaticMask|Placement;var current2=workInProgress2.alternate;if(current2===null)workInProgress2.childLanes=NoLanes,workInProgress2.lanes=renderLanes2,workInProgress2.child=null,workInProgress2.subtreeFlags=NoFlags,workInProgress2.memoizedProps=null,workInProgress2.memoizedState=null,workInProgress2.updateQueue=null,workInProgress2.dependencies=null,workInProgress2.stateNode=null,workInProgress2.selfBaseDuration=0,workInProgress2.treeBaseDuration=0;else{workInProgress2.childLanes=current2.childLanes,workInProgress2.lanes=current2.lanes,workInProgress2.child=current2.child,workInProgress2.subtreeFlags=NoFlags,workInProgress2.deletions=null,workInProgress2.memoizedProps=current2.memoizedProps,workInProgress2.memoizedState=current2.memoizedState,workInProgress2.updateQueue=current2.updateQueue,workInProgress2.type=current2.type;var currentDependencies=current2.dependencies;workInProgress2.dependencies=currentDependencies===null?null:{lanes:currentDependencies.lanes,firstContext:currentDependencies.firstContext},workInProgress2.selfBaseDuration=current2.selfBaseDuration,workInProgress2.treeBaseDuration=current2.treeBaseDuration}return workInProgress2}function createHostRootFiber(tag,isStrictMode,concurrentUpdatesByDefaultOverride){var mode;return tag===ConcurrentRoot?(mode=ConcurrentMode,isStrictMode===!0&&(mode|=StrictLegacyMode,mode|=StrictEffectsMode)):mode=NoMode,isDevToolsPresent&&(mode|=ProfileMode),createFiber(HostRoot,null,null,mode)}function createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes){var fiberTag=IndeterminateComponent,resolvedType=type;if(typeof type=="function")shouldConstruct$1(type)?(fiberTag=ClassComponent,resolvedType=resolveClassForHotReloading(resolvedType)):resolvedType=resolveFunctionForHotReloading(resolvedType);else if(typeof type=="string")fiberTag=HostComponent;else getTag:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,mode,lanes,key);case REACT_STRICT_MODE_TYPE:fiberTag=Mode,mode|=StrictLegacyMode,(mode&ConcurrentMode)!==NoMode&&(mode|=StrictEffectsMode);break;case REACT_PROFILER_TYPE:return createFiberFromProfiler(pendingProps,mode,lanes,key);case REACT_SUSPENSE_TYPE:return createFiberFromSuspense(pendingProps,mode,lanes,key);case REACT_SUSPENSE_LIST_TYPE:return createFiberFromSuspenseList(pendingProps,mode,lanes,key);case REACT_OFFSCREEN_TYPE:return createFiberFromOffscreen(pendingProps,mode,lanes,key);case REACT_LEGACY_HIDDEN_TYPE:case REACT_SCOPE_TYPE:case REACT_CACHE_TYPE:case REACT_TRACING_MARKER_TYPE:case REACT_DEBUG_TRACING_MODE_TYPE:default:{if(typeof type=="object"&&type!==null)switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=ContextProvider;break getTag;case REACT_CONTEXT_TYPE:fiberTag=ContextConsumer;break getTag;case REACT_FORWARD_REF_TYPE:fiberTag=ForwardRef,resolvedType=resolveForwardRefForHotReloading(resolvedType);break getTag;case REACT_MEMO_TYPE:fiberTag=MemoComponent;break getTag;case REACT_LAZY_TYPE:fiberTag=LazyComponent,resolvedType=null;break getTag}var info="";{(type===void 0||typeof type=="object"&&type!==null&&Object.keys(type).length===0)&&(info+=" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");var ownerName=owner?getComponentNameFromFiber(owner):null;ownerName&&(info+=`

Check the render method of \``+ownerName+"`.")}throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) "+("but got: "+(type==null?type:typeof type)+"."+info))}}var fiber=createFiber(fiberTag,pendingProps,key,mode);return fiber.elementType=type,fiber.type=resolvedType,fiber.lanes=lanes,fiber._debugOwner=owner,fiber}function createFiberFromElement(element,mode,lanes){var owner=null;owner=element._owner;var type=element.type,key=element.key,pendingProps=element.props,fiber=createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes);return fiber._debugSource=element._source,fiber._debugOwner=element._owner,fiber}function createFiberFromFragment(elements,mode,lanes,key){var fiber=createFiber(Fragment,elements,key,mode);return fiber.lanes=lanes,fiber}function createFiberFromProfiler(pendingProps,mode,lanes,key){typeof pendingProps.id!="string"&&error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',typeof pendingProps.id);var fiber=createFiber(Profiler,pendingProps,key,mode|ProfileMode);return fiber.elementType=REACT_PROFILER_TYPE,fiber.lanes=lanes,fiber.stateNode={effectDuration:0,passiveEffectDuration:0},fiber}function createFiberFromSuspense(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseComponent,pendingProps,key,mode);return fiber.elementType=REACT_SUSPENSE_TYPE,fiber.lanes=lanes,fiber}function createFiberFromSuspenseList(pendingProps,mode,lanes,key){var fiber=createFiber(SuspenseListComponent,pendingProps,key,mode);return fiber.elementType=REACT_SUSPENSE_LIST_TYPE,fiber.lanes=lanes,fiber}function createFiberFromOffscreen(pendingProps,mode,lanes,key){var fiber=createFiber(OffscreenComponent,pendingProps,key,mode);fiber.elementType=REACT_OFFSCREEN_TYPE,fiber.lanes=lanes;var primaryChildInstance={};return fiber.stateNode=primaryChildInstance,fiber}function createFiberFromText(content,mode,lanes){var fiber=createFiber(HostText,content,null,mode);return fiber.lanes=lanes,fiber}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,null,NoMode);return fiber.elementType="DELETED",fiber}function createFiberFromDehydratedFragment(dehydratedNode){var fiber=createFiber(DehydratedFragment,null,null,NoMode);return fiber.stateNode=dehydratedNode,fiber}function createFiberFromPortal(portal,mode,lanes){var pendingProps=portal.children!==null?portal.children:[],fiber=createFiber(HostPortal,pendingProps,portal.key,mode);return fiber.lanes=lanes,fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,implementation:portal.implementation},fiber}function assignFiberPropertiesInDEV(target,source){return target===null&&(target=createFiber(IndeterminateComponent,null,null,NoMode)),target.tag=source.tag,target.key=source.key,target.elementType=source.elementType,target.type=source.type,target.stateNode=source.stateNode,target.return=source.return,target.child=source.child,target.sibling=source.sibling,target.index=source.index,target.ref=source.ref,target.pendingProps=source.pendingProps,target.memoizedProps=source.memoizedProps,target.updateQueue=source.updateQueue,target.memoizedState=source.memoizedState,target.dependencies=source.dependencies,target.mode=source.mode,target.flags=source.flags,target.subtreeFlags=source.subtreeFlags,target.deletions=source.deletions,target.lanes=source.lanes,target.childLanes=source.childLanes,target.alternate=source.alternate,target.actualDuration=source.actualDuration,target.actualStartTime=source.actualStartTime,target.selfBaseDuration=source.selfBaseDuration,target.treeBaseDuration=source.treeBaseDuration,target._debugSource=source._debugSource,target._debugOwner=source._debugOwner,target._debugNeedsRemount=source._debugNeedsRemount,target._debugHookTypes=source._debugHookTypes,target}function FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError){this.tag=tag,this.containerInfo=containerInfo,this.pendingChildren=null,this.current=null,this.pingCache=null,this.finishedWork=null,this.timeoutHandle=noTimeout,this.context=null,this.pendingContext=null,this.callbackNode=null,this.callbackPriority=NoLane,this.eventTimes=createLaneMap(NoLanes),this.expirationTimes=createLaneMap(NoTimestamp),this.pendingLanes=NoLanes,this.suspendedLanes=NoLanes,this.pingedLanes=NoLanes,this.expiredLanes=NoLanes,this.mutableReadLanes=NoLanes,this.finishedLanes=NoLanes,this.entangledLanes=NoLanes,this.entanglements=createLaneMap(NoLanes),this.identifierPrefix=identifierPrefix,this.onRecoverableError=onRecoverableError,supportsHydration&&(this.mutableSourceEagerHydrationData=null),this.effectDuration=0,this.passiveEffectDuration=0;{this.memoizedUpdaters=new Set;for(var pendingUpdatersLaneMap=this.pendingUpdatersLaneMap=[],_i=0;_i<TotalLanes;_i++)pendingUpdatersLaneMap.push(new Set)}switch(tag){case ConcurrentRoot:this._debugRootType=hydrate?"hydrateRoot()":"createRoot()";break;case LegacyRoot:this._debugRootType=hydrate?"hydrate()":"render()";break}}function createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var root=new FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError),uninitializedFiber=createHostRootFiber(tag,isStrictMode);root.current=uninitializedFiber,uninitializedFiber.stateNode=root;{var _initialState={element:initialChildren,isDehydrated:hydrate,cache:null,transitions:null};uninitializedFiber.memoizedState=_initialState}return initializeUpdateQueue(uninitializedFiber),root}var ReactVersion="18.0.0-fc46dba67-20220329";function createPortal(children,containerInfo,implementation){var key=arguments.length>3&&arguments[3]!==void 0?arguments[3]:null;return checkKeyStringCoercion(key),{$$typeof:REACT_PORTAL_TYPE,key:key==null?null:""+key,children,containerInfo,implementation}}var didWarnAboutNestedUpdates,didWarnAboutFindNodeInStrictMode;didWarnAboutNestedUpdates=!1,didWarnAboutFindNodeInStrictMode={};function getContextForSubtree(parentComponent){if(!parentComponent)return emptyContextObject;var fiber=get(parentComponent),parentContext=findCurrentUnmaskedContext(fiber);if(fiber.tag===ClassComponent){var Component=fiber.type;if(isContextProvider(Component))return processChildContext(fiber,Component,parentContext)}return parentContext}function findHostInstance(component){var fiber=get(component);if(fiber===void 0){if(typeof component.render=="function")throw new Error("Unable to find node on an unmounted component.");var keys2=Object.keys(component).join(",");throw new Error("Argument appears to not be a ReactComponent. Keys: "+keys2)}var hostFiber=findCurrentHostFiber(fiber);return hostFiber===null?null:hostFiber.stateNode}function findHostInstanceWithWarning(component,methodName){{var fiber=get(component);if(fiber===void 0){if(typeof component.render=="function")throw new Error("Unable to find node on an unmounted component.");var keys2=Object.keys(component).join(",");throw new Error("Argument appears to not be a ReactComponent. Keys: "+keys2)}var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null)return null;if(hostFiber.mode&StrictLegacyMode){var componentName=getComponentNameFromFiber(fiber)||"Component";if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=!0;var previousFiber=current;try{setCurrentFiber(hostFiber),fiber.mode&StrictLegacyMode?error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node",methodName,methodName,componentName):error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node",methodName,methodName,componentName)}finally{previousFiber?setCurrentFiber(previousFiber):resetCurrentFiber()}}}return hostFiber.stateNode}}function createContainer(containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=!1,initialChildren=null;return createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError)}function createHydrationContainer(initialChildren,callback,containerInfo,tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){var hydrate=!0,root=createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);root.context=getContextForSubtree(null);var current2=root.current,eventTime=requestEventTime(),lane=requestUpdateLane(current2),update=createUpdate(eventTime,lane);return update.callback=callback??null,enqueueUpdate(current2,update),scheduleInitialHydrationOnRoot(root,lane,eventTime),root}function updateContainer(element,container,parentComponent,callback){onScheduleRoot(container,element);var current$1=container.current,eventTime=requestEventTime(),lane=requestUpdateLane(current$1);markRenderScheduled(lane);var context2=getContextForSubtree(parentComponent);container.context===null?container.context=context2:container.pendingContext=context2,isRendering&&current!==null&&!didWarnAboutNestedUpdates&&(didWarnAboutNestedUpdates=!0,error(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`,getComponentNameFromFiber(current)||"Unknown"));var update=createUpdate(eventTime,lane);update.payload={element},callback=callback===void 0?null:callback,callback!==null&&(typeof callback!="function"&&error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.",callback),update.callback=callback),enqueueUpdate(current$1,update);var root=scheduleUpdateOnFiber(current$1,lane,eventTime);return root!==null&&entangleTransitions(root,current$1,lane),lane}function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child)return null;switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode}}function attemptSynchronousHydration(fiber){switch(fiber.tag){case HostRoot:var root=fiber.stateNode;if(isRootDehydrated(root)){var lanes=getHighestPriorityPendingLanes(root);flushRoot(root,lanes)}break;case SuspenseComponent:var eventTime=requestEventTime();flushSync(function(){return scheduleUpdateOnFiber(fiber,SyncLane,eventTime)});var retryLane=SyncLane;markRetryLaneIfNotHydrated(fiber,retryLane);break}}function markRetryLaneImpl(fiber,retryLane){var suspenseState=fiber.memoizedState;suspenseState!==null&&suspenseState.dehydrated!==null&&(suspenseState.retryLane=higherPriorityLane(suspenseState.retryLane,retryLane))}function markRetryLaneIfNotHydrated(fiber,retryLane){markRetryLaneImpl(fiber,retryLane);var alternate=fiber.alternate;alternate&&markRetryLaneImpl(alternate,retryLane)}function attemptContinuousHydration(fiber){if(fiber.tag===SuspenseComponent){var eventTime=requestEventTime(),lane=SelectiveHydrationLane;scheduleUpdateOnFiber(fiber,lane,eventTime),markRetryLaneIfNotHydrated(fiber,lane)}}function attemptHydrationAtCurrentPriority(fiber){if(fiber.tag===SuspenseComponent){var eventTime=requestEventTime(),lane=requestUpdateLane(fiber);scheduleUpdateOnFiber(fiber,lane,eventTime),markRetryLaneIfNotHydrated(fiber,lane)}}function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);return hostFiber===null?null:hostFiber.stateNode}var shouldErrorImpl=function(fiber){return null};function shouldError(fiber){return shouldErrorImpl(fiber)}var shouldSuspendImpl=function(fiber){return!1};function shouldSuspend(fiber){return shouldSuspendImpl(fiber)}var overrideHookState=null,overrideHookStateDeletePath=null,overrideHookStateRenamePath=null,overrideProps=null,overridePropsDeletePath=null,overridePropsRenamePath=null,scheduleUpdate=null,setErrorHandler=null,setSuspenseHandler=null;{var copyWithDeleteImpl=function(obj,path2,index2){var key=path2[index2],updated=isArray(obj)?obj.slice():assign({},obj);return index2+1===path2.length?(isArray(updated)?updated.splice(key,1):delete updated[key],updated):(updated[key]=copyWithDeleteImpl(obj[key],path2,index2+1),updated)},copyWithDelete=function(obj,path2){return copyWithDeleteImpl(obj,path2,0)},copyWithRenameImpl=function(obj,oldPath,newPath,index2){var oldKey=oldPath[index2],updated=isArray(obj)?obj.slice():assign({},obj);if(index2+1===oldPath.length){var newKey=newPath[index2];updated[newKey]=updated[oldKey],isArray(updated)?updated.splice(oldKey,1):delete updated[oldKey]}else updated[oldKey]=copyWithRenameImpl(obj[oldKey],oldPath,newPath,index2+1);return updated},copyWithRename=function(obj,oldPath,newPath){if(oldPath.length!==newPath.length){warn("copyWithRename() expects paths of the same length");return}else for(var i2=0;i2<newPath.length-1;i2++)if(oldPath[i2]!==newPath[i2]){warn("copyWithRename() expects paths to be the same except for the deepest key");return}return copyWithRenameImpl(obj,oldPath,newPath,0)},copyWithSetImpl=function(obj,path2,index2,value){if(index2>=path2.length)return value;var key=path2[index2],updated=isArray(obj)?obj.slice():assign({},obj);return updated[key]=copyWithSetImpl(obj[key],path2,index2+1,value),updated},copyWithSet=function(obj,path2,value){return copyWithSetImpl(obj,path2,0,value)},findHook=function(fiber,id2){for(var currentHook2=fiber.memoizedState;currentHook2!==null&&id2>0;)currentHook2=currentHook2.next,id2--;return currentHook2};overrideHookState=function(fiber,id2,path2,value){var hook=findHook(fiber,id2);if(hook!==null){var newState=copyWithSet(hook.memoizedState,path2,value);hook.memoizedState=newState,hook.baseState=newState,fiber.memoizedProps=assign({},fiber.memoizedProps),scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp)}},overrideHookStateDeletePath=function(fiber,id2,path2){var hook=findHook(fiber,id2);if(hook!==null){var newState=copyWithDelete(hook.memoizedState,path2);hook.memoizedState=newState,hook.baseState=newState,fiber.memoizedProps=assign({},fiber.memoizedProps),scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp)}},overrideHookStateRenamePath=function(fiber,id2,oldPath,newPath){var hook=findHook(fiber,id2);if(hook!==null){var newState=copyWithRename(hook.memoizedState,oldPath,newPath);hook.memoizedState=newState,hook.baseState=newState,fiber.memoizedProps=assign({},fiber.memoizedProps),scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp)}},overrideProps=function(fiber,path2,value){fiber.pendingProps=copyWithSet(fiber.memoizedProps,path2,value),fiber.alternate&&(fiber.alternate.pendingProps=fiber.pendingProps),scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp)},overridePropsDeletePath=function(fiber,path2){fiber.pendingProps=copyWithDelete(fiber.memoizedProps,path2),fiber.alternate&&(fiber.alternate.pendingProps=fiber.pendingProps),scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp)},overridePropsRenamePath=function(fiber,oldPath,newPath){fiber.pendingProps=copyWithRename(fiber.memoizedProps,oldPath,newPath),fiber.alternate&&(fiber.alternate.pendingProps=fiber.pendingProps),scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp)},scheduleUpdate=function(fiber){scheduleUpdateOnFiber(fiber,SyncLane,NoTimestamp)},setErrorHandler=function(newShouldErrorImpl){shouldErrorImpl=newShouldErrorImpl},setSuspenseHandler=function(newShouldSuspendImpl){shouldSuspendImpl=newShouldSuspendImpl}}function findHostInstanceByFiber(fiber){var hostFiber=findCurrentHostFiber(fiber);return hostFiber===null?null:hostFiber.stateNode}function emptyFindFiberByHostInstance(instance){return null}function getCurrentFiberForDevTools(){return current}function injectIntoDevTools(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance,ReactCurrentDispatcher3=ReactSharedInternals.ReactCurrentDispatcher;return injectInternals({bundleType:devToolsConfig.bundleType,version:devToolsConfig.version,rendererPackageName:devToolsConfig.rendererPackageName,rendererConfig:devToolsConfig.rendererConfig,overrideHookState,overrideHookStateDeletePath,overrideHookStateRenamePath,overrideProps,overridePropsDeletePath,overridePropsRenamePath,setErrorHandler,setSuspenseHandler,scheduleUpdate,currentDispatcherRef:ReactCurrentDispatcher3,findHostInstanceByFiber,findFiberByHostInstance:findFiberByHostInstance||emptyFindFiberByHostInstance,findHostInstancesForRefresh,scheduleRefresh,scheduleRoot,setRefreshHandler,getCurrentFiber:getCurrentFiberForDevTools,reconcilerVersion:ReactVersion})}return exports.attemptContinuousHydration=attemptContinuousHydration,exports.attemptHydrationAtCurrentPriority=attemptHydrationAtCurrentPriority,exports.attemptSynchronousHydration=attemptSynchronousHydration,exports.batchedUpdates=batchedUpdates,exports.createComponentSelector=createComponentSelector,exports.createContainer=createContainer,exports.createHasPseudoClassSelector=createHasPseudoClassSelector,exports.createHydrationContainer=createHydrationContainer,exports.createPortal=createPortal,exports.createRoleSelector=createRoleSelector,exports.createTestNameSelector=createTestNameSelector,exports.createTextSelector=createTextSelector,exports.deferredUpdates=deferredUpdates,exports.discreteUpdates=discreteUpdates,exports.findAllNodes=findAllNodes,exports.findBoundingRects=findBoundingRects,exports.findHostInstance=findHostInstance,exports.findHostInstanceWithNoPortals=findHostInstanceWithNoPortals,exports.findHostInstanceWithWarning=findHostInstanceWithWarning,exports.flushControlled=flushControlled,exports.flushPassiveEffects=flushPassiveEffects,exports.flushSync=flushSync,exports.focusWithin=focusWithin,exports.getCurrentUpdatePriority=getCurrentUpdatePriority,exports.getFindAllNodesFailureDescription=getFindAllNodesFailureDescription,exports.getPublicRootInstance=getPublicRootInstance,exports.injectIntoDevTools=injectIntoDevTools,exports.isAlreadyRendering=isAlreadyRendering,exports.observeVisibleRects=observeVisibleRects,exports.registerMutableSourceForHydration=registerMutableSourceForHydration,exports.runWithPriority=runWithPriority,exports.shouldError=shouldError,exports.shouldSuspend=shouldSuspend,exports.updateContainer=updateContainer,exports};var reactReconciler_developmentExports=reactReconciler_development.exports;reactReconciler.exports=reactReconciler_developmentExports;var reactReconcilerExports=reactReconciler.exports;const Reconciler=getDefaultExportFromCjs(reactReconcilerExports),isPromise=promise=>typeof promise=="object"&&typeof promise.then=="function",globalCache=[];function shallowEqualArrays(arrA,arrB,equal=(a2,b2)=>a2===b2){if(arrA===arrB)return!0;if(!arrA||!arrB)return!1;const len=arrA.length;if(arrB.length!==len)return!1;for(let i2=0;i2<len;i2++)if(!equal(arrA[i2],arrB[i2]))return!1;return!0}function query(fn,keys2=null,preload2=!1,config={}){keys2===null&&(keys2=[fn]);for(const entry2 of globalCache)if(shallowEqualArrays(keys2,entry2.keys,entry2.equal)){if(preload2)return;if(Object.prototype.hasOwnProperty.call(entry2,"error"))throw entry2.error;if(Object.prototype.hasOwnProperty.call(entry2,"response"))return config.lifespan&&config.lifespan>0&&(entry2.timeout&&clearTimeout(entry2.timeout),entry2.timeout=setTimeout(entry2.remove,config.lifespan)),entry2.response;if(!preload2)throw entry2.promise}const entry={keys:keys2,equal:config.equal,remove:()=>{const index=globalCache.indexOf(entry);index!==-1&&globalCache.splice(index,1)},promise:(isPromise(fn)?fn:fn(...keys2)).then(response=>{entry.response=response,config.lifespan&&config.lifespan>0&&(entry.timeout=setTimeout(entry.remove,config.lifespan))}).catch(error=>entry.error=error)};if(globalCache.push(entry),!preload2)throw entry.promise}const suspend=(fn,keys2,config)=>query(fn,keys2,!1,config),preload=(fn,keys2,config)=>void query(fn,keys2,!0,config),clear=keys2=>{if(keys2===void 0||keys2.length===0)globalCache.splice(0,globalCache.length);else{const entry=globalCache.find(entry2=>shallowEqualArrays(keys2,entry2.keys,entry2.equal));entry&&entry.remove()}},catalogue={},extend=objects=>void Object.assign(catalogue,objects);function createRenderer(_roots,_getEventPriority){function createInstance(type,{args=[],attach:attach2,...props},root){let name=`${type[0].toUpperCase()}${type.slice(1)}`,instance;if(type==="primitive"){if(props.object===void 0)throw new Error("R3F: Primitives without 'object' are invalid!");const object=props.object;instance=prepare(object,{type,root,attach:attach2,primitive:!0})}else{const target=catalogue[name];if(!target)throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(!Array.isArray(args))throw new Error("R3F: The args prop must be an array!");instance=prepare(new target(...args),{type,root,attach:attach2,memoizedProps:{args}})}return instance.__r3f.attach===void 0&&(instance instanceof BufferGeometry?instance.__r3f.attach="geometry":instance instanceof Material&&(instance.__r3f.attach="material")),name!=="inject"&&applyProps$1(instance,props),instance}function appendChild(parentInstance,child){let added=!1;if(child){var _child$__r3f,_parentInstance$__r3f;(_child$__r3f=child.__r3f)!=null&&_child$__r3f.attach?attach(parentInstance,child,child.__r3f.attach):child.isObject3D&&parentInstance.isObject3D&&(parentInstance.add(child),added=!0),added||(_parentInstance$__r3f=parentInstance.__r3f)==null||_parentInstance$__r3f.objects.push(child),child.__r3f||prepare(child,{}),child.__r3f.parent=parentInstance,updateInstance(child),invalidateInstance(child)}}function insertBefore(parentInstance,child,beforeChild){let added=!1;if(child){var _child$__r3f2,_parentInstance$__r3f2;if((_child$__r3f2=child.__r3f)!=null&&_child$__r3f2.attach)attach(parentInstance,child,child.__r3f.attach);else if(child.isObject3D&&parentInstance.isObject3D){child.parent=parentInstance,child.dispatchEvent({type:"added"});const restSiblings=parentInstance.children.filter(sibling=>sibling!==child),index=restSiblings.indexOf(beforeChild);parentInstance.children=[...restSiblings.slice(0,index),child,...restSiblings.slice(index)],added=!0}added||(_parentInstance$__r3f2=parentInstance.__r3f)==null||_parentInstance$__r3f2.objects.push(child),child.__r3f||prepare(child,{}),child.__r3f.parent=parentInstance,updateInstance(child),invalidateInstance(child)}}function removeRecursive(array,parent,dispose2=!1){array&&[...array].forEach(child=>removeChild(parent,child,dispose2))}function removeChild(parentInstance,child,dispose2){if(child){var _parentInstance$__r3f3,_child$__r3f3,_child$__r3f5;if(child.__r3f&&(child.__r3f.parent=null),(_parentInstance$__r3f3=parentInstance.__r3f)!=null&&_parentInstance$__r3f3.objects&&(parentInstance.__r3f.objects=parentInstance.__r3f.objects.filter(x2=>x2!==child)),(_child$__r3f3=child.__r3f)!=null&&_child$__r3f3.attach)detach(parentInstance,child,child.__r3f.attach);else if(child.isObject3D&&parentInstance.isObject3D){var _child$__r3f4;parentInstance.remove(child),(_child$__r3f4=child.__r3f)!=null&&_child$__r3f4.root&&removeInteractivity(child.__r3f.root,child)}const isPrimitive=(_child$__r3f5=child.__r3f)==null?void 0:_child$__r3f5.primitive,shouldDispose=!isPrimitive&&(dispose2===void 0?child.dispose!==null:dispose2);if(!isPrimitive){var _child$__r3f6;removeRecursive((_child$__r3f6=child.__r3f)==null?void 0:_child$__r3f6.objects,child,shouldDispose),removeRecursive(child.children,child,shouldDispose)}if(delete child.__r3f,shouldDispose&&child.dispose&&child.type!=="Scene"){const callback=()=>{try{child.dispose()}catch{}};typeof IS_REACT_ACT_ENVIRONMENT>"u"?schedulerExports.unstable_scheduleCallback(schedulerExports.unstable_IdlePriority,callback):callback()}invalidateInstance(parentInstance)}}function switchInstance(instance,type,newProps,fiber){var _instance$__r3f;const parent=(_instance$__r3f=instance.__r3f)==null?void 0:_instance$__r3f.parent;if(!parent)return;const newInstance=createInstance(type,newProps,instance.__r3f.root);if(instance.children){for(const child of instance.children)child.__r3f&&appendChild(newInstance,child);instance.children=instance.children.filter(child=>!child.__r3f)}instance.__r3f.objects.forEach(child=>appendChild(newInstance,child)),instance.__r3f.objects=[],instance.__r3f.autoRemovedBeforeAppend||removeChild(parent,instance),newInstance.parent&&(newInstance.__r3f.autoRemovedBeforeAppend=!0),appendChild(parent,newInstance),newInstance.raycast&&newInstance.__r3f.eventCount&&newInstance.__r3f.root.getState().internal.interaction.push(newInstance),[fiber,fiber.alternate].forEach(fiber2=>{fiber2!==null&&(fiber2.stateNode=newInstance,fiber2.ref&&(typeof fiber2.ref=="function"?fiber2.ref(newInstance):fiber2.ref.current=newInstance))})}const handleTextInstance=()=>console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");return{reconciler:Reconciler({createInstance,removeChild,appendChild,appendInitialChild:appendChild,insertBefore,supportsMutation:!0,isPrimaryRenderer:!1,supportsPersistence:!1,supportsHydration:!1,noTimeout:-1,appendChildToContainer:(container,child)=>{if(!child)return;const scene2=container.getState().scene;scene2.__r3f&&(scene2.__r3f.root=container,appendChild(scene2,child))},removeChildFromContainer:(container,child)=>{child&&removeChild(container.getState().scene,child)},insertInContainerBefore:(container,child,beforeChild)=>{if(!child||!beforeChild)return;const scene2=container.getState().scene;scene2.__r3f&&insertBefore(scene2,child,beforeChild)},getRootHostContext:()=>null,getChildHostContext:parentHostContext=>parentHostContext,finalizeInitialChildren(instance){var _instance$__r3f2;return!!((_instance$__r3f2=instance==null?void 0:instance.__r3f)!=null?_instance$__r3f2:{}).handlers},prepareUpdate(instance,_type,oldProps,newProps){var _instance$__r3f3;if(((_instance$__r3f3=instance==null?void 0:instance.__r3f)!=null?_instance$__r3f3:{}).primitive&&newProps.object&&newProps.object!==instance)return[!0];{const{args:argsNew=[],children:cN,...restNew}=newProps,{args:argsOld=[],children:cO,...restOld}=oldProps;if(!Array.isArray(argsNew))throw new Error("R3F: the args prop must be an array!");if(argsNew.some((value,index)=>value!==argsOld[index]))return[!0];const diff=diffProps(instance,restNew,restOld,!0);return diff.changes.length?[!1,diff]:null}},commitUpdate(instance,[reconstruct,diff],type,_oldProps,newProps,fiber){reconstruct?switchInstance(instance,type,newProps,fiber):applyProps$1(instance,diff)},commitMount(instance,_type,_props,_int){var _instance$__r3f4;const localState=(_instance$__r3f4=instance.__r3f)!=null?_instance$__r3f4:{};instance.raycast&&localState.handlers&&localState.eventCount&&instance.__r3f.root.getState().internal.interaction.push(instance)},getPublicInstance:instance=>instance,prepareForCommit:()=>null,preparePortalMount:container=>prepare(container.getState().scene),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance(instance){var _instance$__r3f5;const{attach:type,parent}=(_instance$__r3f5=instance.__r3f)!=null?_instance$__r3f5:{};type&&parent&&detach(parent,instance,type),instance.isObject3D&&(instance.visible=!1),invalidateInstance(instance)},unhideInstance(instance,props){var _instance$__r3f6;const{attach:type,parent}=(_instance$__r3f6=instance.__r3f)!=null?_instance$__r3f6:{};type&&parent&&attach(parent,instance,type),(instance.isObject3D&&props.visible==null||props.visible)&&(instance.visible=!0),invalidateInstance(instance)},createTextInstance:handleTextInstance,hideTextInstance:handleTextInstance,unhideTextInstance:handleTextInstance,getCurrentEventPriority:()=>_getEventPriority?_getEventPriority():constantsExports.DefaultEventPriority,beforeActiveInstanceBlur:()=>{},afterActiveInstanceBlur:()=>{},detachDeletedInstance:()=>{},now:typeof performance<"u"&&is.fun(performance.now)?performance.now:is.fun(Date.now)?Date.now:()=>0,scheduleTimeout:is.fun(setTimeout)?setTimeout:void 0,cancelTimeout:is.fun(clearTimeout)?clearTimeout:void 0}),applyProps:applyProps$1}}var _window$document,_window$navigator;const hasColorSpace=object=>"colorSpace"in object||"outputColorSpace"in object,getColorManagement=()=>{var _ColorManagement;return(_ColorManagement=catalogue.ColorManagement)!=null?_ColorManagement:null},isOrthographicCamera=def=>def&&def.isOrthographicCamera,isRef=obj=>obj&&obj.hasOwnProperty("current"),useIsomorphicLayoutEffect=typeof window<"u"&&((_window$document=window.document)!=null&&_window$document.createElement||((_window$navigator=window.navigator)==null?void 0:_window$navigator.product)==="ReactNative")?reactExports.useLayoutEffect:reactExports.useEffect;function useMutableCallback(fn){const ref=reactExports.useRef(fn);return useIsomorphicLayoutEffect(()=>void(ref.current=fn),[fn]),ref}function Block({set}){return useIsomorphicLayoutEffect(()=>(set(new Promise(()=>null)),()=>set(!1)),[set]),null}class ErrorBoundary extends reactExports.Component{constructor(...args){super(...args),this.state={error:!1}}componentDidCatch(err){this.props.set(err)}render(){return this.state.error?null:this.props.children}}ErrorBoundary.getDerivedStateFromError=()=>({error:!0});const DEFAULT="__default",DEFAULTS=new Map,isDiffSet=def=>def&&!!def.memoized&&!!def.changes;function calculateDpr(dpr){var _window$devicePixelRa;const target=typeof window<"u"?(_window$devicePixelRa=window.devicePixelRatio)!=null?_window$devicePixelRa:2:1;return Array.isArray(dpr)?Math.min(Math.max(dpr[0],target),dpr[1]):dpr}const getRootState=obj=>{var _r3f;return(_r3f=obj.__r3f)==null?void 0:_r3f.root.getState()},is={obj:a2=>a2===Object(a2)&&!is.arr(a2)&&typeof a2!="function",fun:a2=>typeof a2=="function",str:a2=>typeof a2=="string",num:a2=>typeof a2=="number",boo:a2=>typeof a2=="boolean",und:a2=>a2===void 0,arr:a2=>Array.isArray(a2),equ(a2,b2,{arrays="shallow",objects="reference",strict=!0}={}){if(typeof a2!=typeof b2||!!a2!=!!b2)return!1;if(is.str(a2)||is.num(a2))return a2===b2;const isObj=is.obj(a2);if(isObj&&objects==="reference")return a2===b2;const isArr=is.arr(a2);if(isArr&&arrays==="reference")return a2===b2;if((isArr||isObj)&&a2===b2)return!0;let i2;for(i2 in a2)if(!(i2 in b2))return!1;if(isObj&&arrays==="shallow"&&objects==="shallow"){for(i2 in strict?b2:a2)if(!is.equ(a2[i2],b2[i2],{strict,objects:"reference"}))return!1}else for(i2 in strict?b2:a2)if(a2[i2]!==b2[i2])return!1;if(is.und(i2)){if(isArr&&a2.length===0&&b2.length===0||isObj&&Object.keys(a2).length===0&&Object.keys(b2).length===0)return!0;if(a2!==b2)return!1}return!0}};function buildGraph(object){const data={nodes:{},materials:{}};return object&&object.traverse(obj=>{obj.name&&(data.nodes[obj.name]=obj),obj.material&&!data.materials[obj.material.name]&&(data.materials[obj.material.name]=obj.material)}),data}function dispose(obj){obj.dispose&&obj.type!=="Scene"&&obj.dispose();for(const p2 in obj)p2.dispose==null||p2.dispose(),delete obj[p2]}function prepare(object,state){const instance=object;return instance.__r3f={type:"",root:null,previousAttach:null,memoizedProps:{},eventCount:0,handlers:{},objects:[],parent:null,...state},object}function resolve(instance,key){let target=instance;if(key.includes("-")){const entries=key.split("-"),last=entries.pop();return target=entries.reduce((acc,key2)=>acc[key2],instance),{target,key:last}}else return{target,key}}const INDEX_REGEX=/-\d+$/;function attach(parent,child,type){if(is.str(type)){if(INDEX_REGEX.test(type)){const root=type.replace(INDEX_REGEX,""),{target:target2,key:key2}=resolve(parent,root);Array.isArray(target2[key2])||(target2[key2]=[])}const{target,key}=resolve(parent,type);child.__r3f.previousAttach=target[key],target[key]=child}else child.__r3f.previousAttach=type(parent,child)}function detach(parent,child,type){var _child$__r3f,_child$__r3f2;if(is.str(type)){const{target,key}=resolve(parent,type),previous=child.__r3f.previousAttach;previous===void 0?delete target[key]:target[key]=previous}else(_child$__r3f=child.__r3f)==null||_child$__r3f.previousAttach==null||_child$__r3f.previousAttach(parent,child);(_child$__r3f2=child.__r3f)==null||delete _child$__r3f2.previousAttach}function diffProps(instance,{children:cN,key:kN,ref:rN,...props},{children:cP,key:kP,ref:rP,...previous}={},remove=!1){var _instance$__r3f;const localState=(_instance$__r3f=instance==null?void 0:instance.__r3f)!=null?_instance$__r3f:{},entries=Object.entries(props),changes=[];if(remove){const previousKeys=Object.keys(previous);for(let i2=0;i2<previousKeys.length;i2++)props.hasOwnProperty(previousKeys[i2])||entries.unshift([previousKeys[i2],DEFAULT+"remove"])}entries.forEach(([key,value])=>{var _instance$__r3f2;if((_instance$__r3f2=instance.__r3f)!=null&&_instance$__r3f2.primitive&&key==="object"||is.equ(value,previous[key]))return;if(/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key))return changes.push([key,value,!0,[]]);let entries2=[];key.includes("-")&&(entries2=key.split("-")),changes.push([key,value,!1,entries2]);for(const prop in props){const value2=props[prop];prop.startsWith(`${key}-`)&&changes.push([prop,value2,!1,prop.split("-")])}});const memoized={...props};return localState.memoizedProps&&localState.memoizedProps.args&&(memoized.args=localState.memoizedProps.args),localState.memoizedProps&&localState.memoizedProps.attach&&(memoized.attach=localState.memoizedProps.attach),{memoized,changes}}const __DEV__=typeof process<"u"&&!0;function applyProps$1(instance,data){var _instance$__r3f3,_root$getState,_instance$__r3f4;const localState=(_instance$__r3f3=instance.__r3f)!=null?_instance$__r3f3:{},root=localState.root,rootState=(_root$getState=root==null||root.getState==null?void 0:root.getState())!=null?_root$getState:{},{memoized,changes}=isDiffSet(data)?data:diffProps(instance,data),prevHandlers=localState.eventCount;instance.__r3f&&(instance.__r3f.memoizedProps=memoized);for(let i2=0;i2<changes.length;i2++){let[key,value,isEvent,keys2]=changes[i2];if(hasColorSpace(instance)){const SRGBColorSpace2="srgb",LinearSRGBColorSpace2="srgb-linear";key==="encoding"?(key="colorSpace",value=value===3001?SRGBColorSpace2:LinearSRGBColorSpace2):key==="outputEncoding"&&(key="outputColorSpace",value=value===3001?SRGBColorSpace2:LinearSRGBColorSpace2)}let currentInstance=instance,targetProp=currentInstance[key];if(keys2.length&&(targetProp=keys2.reduce((acc,key2)=>acc[key2],instance),!(targetProp&&targetProp.set))){const[name,...reverseEntries]=keys2.reverse();currentInstance=reverseEntries.reverse().reduce((acc,key2)=>acc[key2],instance),key=name}if(value===DEFAULT+"remove")if(currentInstance.constructor){let ctor=DEFAULTS.get(currentInstance.constructor);ctor||(ctor=new currentInstance.constructor,DEFAULTS.set(currentInstance.constructor,ctor)),value=ctor[key]}else value=0;if(isEvent)value?localState.handlers[key]=value:delete localState.handlers[key],localState.eventCount=Object.keys(localState.handlers).length;else if(targetProp&&targetProp.set&&(targetProp.copy||targetProp instanceof Layers)){if(Array.isArray(value))targetProp.fromArray?targetProp.fromArray(value):targetProp.set(...value);else if(targetProp.copy&&value&&value.constructor&&(__DEV__?targetProp.constructor.name===value.constructor.name:targetProp.constructor===value.constructor))targetProp.copy(value);else if(value!==void 0){const isColor=targetProp instanceof Color;!isColor&&targetProp.setScalar?targetProp.setScalar(value):targetProp instanceof Layers&&value instanceof Layers?targetProp.mask=value.mask:targetProp.set(value),!getColorManagement()&&!rootState.linear&&isColor&&targetProp.convertSRGBToLinear()}}else if(currentInstance[key]=value,currentInstance[key]instanceof Texture&&currentInstance[key].format===RGBAFormat&&currentInstance[key].type===UnsignedByteType){const texture=currentInstance[key];hasColorSpace(texture)&&hasColorSpace(rootState.gl)?texture.colorSpace=rootState.gl.outputColorSpace:texture.encoding=rootState.gl.outputEncoding}invalidateInstance(instance)}if(localState.parent&&rootState.internal&&instance.raycast&&prevHandlers!==localState.eventCount){const index=rootState.internal.interaction.indexOf(instance);index>-1&&rootState.internal.interaction.splice(index,1),localState.eventCount&&rootState.internal.interaction.push(instance)}return!(changes.length===1&&changes[0][0]==="onUpdate")&&changes.length&&(_instance$__r3f4=instance.__r3f)!=null&&_instance$__r3f4.parent&&updateInstance(instance),instance}function invalidateInstance(instance){var _instance$__r3f5,_instance$__r3f5$root;const state=(_instance$__r3f5=instance.__r3f)==null||(_instance$__r3f5$root=_instance$__r3f5.root)==null||_instance$__r3f5$root.getState==null?void 0:_instance$__r3f5$root.getState();state&&state.internal.frames===0&&state.invalidate()}function updateInstance(instance){instance.onUpdate==null||instance.onUpdate(instance)}function updateCamera(camera,size){camera.manual||(isOrthographicCamera(camera)?(camera.left=size.width/-2,camera.right=size.width/2,camera.top=size.height/2,camera.bottom=size.height/-2):camera.aspect=size.width/size.height,camera.updateProjectionMatrix(),camera.updateMatrixWorld())}function makeId(event){return(event.eventObject||event.object).uuid+"/"+event.index+event.instanceId}function getEventPriority(){var _globalScope$event;const globalScope=typeof self<"u"&&self||typeof window<"u"&&window;if(!globalScope)return constantsExports.DefaultEventPriority;switch((_globalScope$event=globalScope.event)==null?void 0:_globalScope$event.type){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return constantsExports.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return constantsExports.ContinuousEventPriority;default:return constantsExports.DefaultEventPriority}}function releaseInternalPointerCapture(capturedMap,obj,captures,pointerId){const captureData=captures.get(obj);captureData&&(captures.delete(obj),captures.size===0&&(capturedMap.delete(pointerId),captureData.target.releasePointerCapture(pointerId)))}function removeInteractivity(store,object){const{internal}=store.getState();internal.interaction=internal.interaction.filter(o2=>o2!==object),internal.initialHits=internal.initialHits.filter(o2=>o2!==object),internal.hovered.forEach((value,key)=>{(value.eventObject===object||value.object===object)&&internal.hovered.delete(key)}),internal.capturedMap.forEach((captures,pointerId)=>{releaseInternalPointerCapture(internal.capturedMap,object,captures,pointerId)})}function createEvents(store){function calculateDistance(event){const{internal}=store.getState(),dx=event.offsetX-internal.initialClick[0],dy=event.offsetY-internal.initialClick[1];return Math.round(Math.sqrt(dx*dx+dy*dy))}function filterPointerEvents(objects){return objects.filter(obj=>["Move","Over","Enter","Out","Leave"].some(name=>{var _r3f;return(_r3f=obj.__r3f)==null?void 0:_r3f.handlers["onPointer"+name]}))}function intersect(event,filter2){const state=store.getState(),duplicates=new Set,intersections=[],eventsObjects=filter2?filter2(state.internal.interaction):state.internal.interaction;for(let i2=0;i2<eventsObjects.length;i2++){const state2=getRootState(eventsObjects[i2]);state2&&(state2.raycaster.camera=void 0)}state.previousRoot||state.events.compute==null||state.events.compute(event,state);function handleRaycast(obj){const state2=getRootState(obj);if(!state2||!state2.events.enabled||state2.raycaster.camera===null)return[];if(state2.raycaster.camera===void 0){var _state$previousRoot;state2.events.compute==null||state2.events.compute(event,state2,(_state$previousRoot=state2.previousRoot)==null?void 0:_state$previousRoot.getState()),state2.raycaster.camera===void 0&&(state2.raycaster.camera=null)}return state2.raycaster.camera?state2.raycaster.intersectObject(obj,!0):[]}let hits=eventsObjects.flatMap(handleRaycast).sort((a2,b2)=>{const aState=getRootState(a2.object),bState=getRootState(b2.object);return!aState||!bState?a2.distance-b2.distance:bState.events.priority-aState.events.priority||a2.distance-b2.distance}).filter(item=>{const id2=makeId(item);return duplicates.has(id2)?!1:(duplicates.add(id2),!0)});state.events.filter&&(hits=state.events.filter(hits,state));for(const hit of hits){let eventObject=hit.object;for(;eventObject;){var _r3f2;(_r3f2=eventObject.__r3f)!=null&&_r3f2.eventCount&&intersections.push({...hit,eventObject}),eventObject=eventObject.parent}}if("pointerId"in event&&state.internal.capturedMap.has(event.pointerId))for(let captureData of state.internal.capturedMap.get(event.pointerId).values())duplicates.has(makeId(captureData.intersection))||intersections.push(captureData.intersection);return intersections}function handleIntersects(intersections,event,delta,callback){const rootState=store.getState();if(intersections.length){const localState={stopped:!1};for(const hit of intersections){const state=getRootState(hit.object)||rootState,{raycaster,pointer,camera,internal}=state,unprojectedPoint=new Vector3(pointer.x,pointer.y,0).unproject(camera),hasPointerCapture=id2=>{var _internal$capturedMap,_internal$capturedMap2;return(_internal$capturedMap=(_internal$capturedMap2=internal.capturedMap.get(id2))==null?void 0:_internal$capturedMap2.has(hit.eventObject))!=null?_internal$capturedMap:!1},setPointerCapture=id2=>{const captureData={intersection:hit,target:event.target};internal.capturedMap.has(id2)?internal.capturedMap.get(id2).set(hit.eventObject,captureData):internal.capturedMap.set(id2,new Map([[hit.eventObject,captureData]])),event.target.setPointerCapture(id2)},releasePointerCapture=id2=>{const captures=internal.capturedMap.get(id2);captures&&releaseInternalPointerCapture(internal.capturedMap,hit.eventObject,captures,id2)};let extractEventProps={};for(let prop in event){let property=event[prop];typeof property!="function"&&(extractEventProps[prop]=property)}let raycastEvent={...hit,...extractEventProps,pointer,intersections,stopped:localState.stopped,delta,unprojectedPoint,ray:raycaster.ray,camera,stopPropagation(){const capturesForPointer="pointerId"in event&&internal.capturedMap.get(event.pointerId);if((!capturesForPointer||capturesForPointer.has(hit.eventObject))&&(raycastEvent.stopped=localState.stopped=!0,internal.hovered.size&&Array.from(internal.hovered.values()).find(i2=>i2.eventObject===hit.eventObject))){const higher=intersections.slice(0,intersections.indexOf(hit));cancelPointer([...higher,hit])}},target:{hasPointerCapture,setPointerCapture,releasePointerCapture},currentTarget:{hasPointerCapture,setPointerCapture,releasePointerCapture},nativeEvent:event};if(callback(raycastEvent),localState.stopped===!0)break}}return intersections}function cancelPointer(intersections){const{internal}=store.getState();for(const hoveredObj of internal.hovered.values())if(!intersections.length||!intersections.find(hit=>hit.object===hoveredObj.object&&hit.index===hoveredObj.index&&hit.instanceId===hoveredObj.instanceId)){const instance=hoveredObj.eventObject.__r3f,handlers=instance==null?void 0:instance.handlers;if(internal.hovered.delete(makeId(hoveredObj)),instance!=null&&instance.eventCount){const data={...hoveredObj,intersections};handlers.onPointerOut==null||handlers.onPointerOut(data),handlers.onPointerLeave==null||handlers.onPointerLeave(data)}}}function pointerMissed(event,objects){for(let i2=0;i2<objects.length;i2++){const instance=objects[i2].__r3f;instance==null||instance.handlers.onPointerMissed==null||instance.handlers.onPointerMissed(event)}}function handlePointer(name){switch(name){case"onPointerLeave":case"onPointerCancel":return()=>cancelPointer([]);case"onLostPointerCapture":return event=>{const{internal}=store.getState();"pointerId"in event&&internal.capturedMap.has(event.pointerId)&&requestAnimationFrame(()=>{internal.capturedMap.has(event.pointerId)&&(internal.capturedMap.delete(event.pointerId),cancelPointer([]))})}}return function(event){const{onPointerMissed,internal}=store.getState();internal.lastEvent.current=event;const isPointerMove=name==="onPointerMove",isClickEvent=name==="onClick"||name==="onContextMenu"||name==="onDoubleClick",hits=intersect(event,isPointerMove?filterPointerEvents:void 0),delta=isClickEvent?calculateDistance(event):0;name==="onPointerDown"&&(internal.initialClick=[event.offsetX,event.offsetY],internal.initialHits=hits.map(hit=>hit.eventObject)),isClickEvent&&!hits.length&&delta<=2&&(pointerMissed(event,internal.interaction),onPointerMissed&&onPointerMissed(event)),isPointerMove&&cancelPointer(hits);function onIntersect(data){const eventObject=data.eventObject,instance=eventObject.__r3f,handlers=instance==null?void 0:instance.handlers;if(instance!=null&&instance.eventCount)if(isPointerMove){if(handlers.onPointerOver||handlers.onPointerEnter||handlers.onPointerOut||handlers.onPointerLeave){const id2=makeId(data),hoveredItem=internal.hovered.get(id2);hoveredItem?hoveredItem.stopped&&data.stopPropagation():(internal.hovered.set(id2,data),handlers.onPointerOver==null||handlers.onPointerOver(data),handlers.onPointerEnter==null||handlers.onPointerEnter(data))}handlers.onPointerMove==null||handlers.onPointerMove(data)}else{const handler=handlers[name];handler?(!isClickEvent||internal.initialHits.includes(eventObject))&&(pointerMissed(event,internal.interaction.filter(object=>!internal.initialHits.includes(object))),handler(data)):isClickEvent&&internal.initialHits.includes(eventObject)&&pointerMissed(event,internal.interaction.filter(object=>!internal.initialHits.includes(object)))}}handleIntersects(hits,event,delta,onIntersect)}}return{handlePointer}}const isRenderer=def=>!!(def!=null&&def.render),context=reactExports.createContext(null),createStore=(invalidate2,advance2)=>{const rootState=create((set,get)=>{const position=new Vector3,defaultTarget=new Vector3,tempTarget=new Vector3;function getCurrentViewport(camera=get().camera,target=defaultTarget,size=get().size){const{width,height,top,left}=size,aspect2=width/height;target instanceof Vector3?tempTarget.copy(target):tempTarget.set(...target);const distance2=camera.getWorldPosition(position).distanceTo(tempTarget);if(isOrthographicCamera(camera))return{width:width/camera.zoom,height:height/camera.zoom,top,left,factor:1,distance:distance2,aspect:aspect2};{const fov2=camera.fov*Math.PI/180,h2=2*Math.tan(fov2/2)*distance2,w2=h2*(width/height);return{width:w2,height:h2,top,left,factor:width/w2,distance:distance2,aspect:aspect2}}}let performanceTimeout;const setPerformanceCurrent=current=>set(state2=>({performance:{...state2.performance,current}})),pointer=new Vector2;return{set,get,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},xr:null,scene:null,invalidate:(frames=1)=>invalidate2(get(),frames),advance:(timestamp,runGlobalEffects)=>advance2(timestamp,runGlobalEffects,get()),legacy:!1,linear:!1,flat:!1,controls:null,clock:new Clock,pointer,mouse:pointer,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const state2=get();performanceTimeout&&clearTimeout(performanceTimeout),state2.performance.current!==state2.performance.min&&setPerformanceCurrent(state2.performance.min),performanceTimeout=setTimeout(()=>setPerformanceCurrent(get().performance.max),state2.performance.debounce)}},size:{width:0,height:0,top:0,left:0,updateStyle:!1},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport},setEvents:events=>set(state2=>({...state2,events:{...state2.events,...events}})),setSize:(width,height,updateStyle,top,left)=>{const camera=get().camera,size={width,height,top:top||0,left:left||0,updateStyle};set(state2=>({size,viewport:{...state2.viewport,...getCurrentViewport(camera,defaultTarget,size)}}))},setDpr:dpr=>set(state2=>{const resolved=calculateDpr(dpr);return{viewport:{...state2.viewport,dpr:resolved,initialDpr:state2.viewport.initialDpr||resolved}}}),setFrameloop:(frameloop="always")=>{const clock=get().clock;clock.stop(),clock.elapsedTime=0,frameloop!=="never"&&(clock.start(),clock.elapsedTime=0),set(()=>({frameloop}))},previousRoot:void 0,internal:{active:!1,priority:0,frames:0,lastEvent:reactExports.createRef(),interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:(ref,priority,store)=>{const internal=get().internal;return internal.priority=internal.priority+(priority>0?1:0),internal.subscribers.push({ref,priority,store}),internal.subscribers=internal.subscribers.sort((a2,b2)=>a2.priority-b2.priority),()=>{const internal2=get().internal;internal2!=null&&internal2.subscribers&&(internal2.priority=internal2.priority-(priority>0?1:0),internal2.subscribers=internal2.subscribers.filter(s2=>s2.ref!==ref))}}}}}),state=rootState.getState();let oldSize=state.size,oldDpr=state.viewport.dpr,oldCamera=state.camera;return rootState.subscribe(()=>{const{camera,size,viewport,gl,set}=rootState.getState();if(size.width!==oldSize.width||size.height!==oldSize.height||viewport.dpr!==oldDpr){var _size$updateStyle;oldSize=size,oldDpr=viewport.dpr,updateCamera(camera,size),gl.setPixelRatio(viewport.dpr);const updateStyle=(_size$updateStyle=size.updateStyle)!=null?_size$updateStyle:typeof HTMLCanvasElement<"u"&&gl.domElement instanceof HTMLCanvasElement;gl.setSize(size.width,size.height,updateStyle)}camera!==oldCamera&&(oldCamera=camera,set(state2=>({viewport:{...state2.viewport,...state2.viewport.getCurrentViewport(camera)}})))}),rootState.subscribe(state2=>invalidate2(state2)),rootState};let i$2,globalEffects=new Set,globalAfterEffects=new Set,globalTailEffects=new Set;function run(effects,timestamp){if(effects.size)for(const{callback}of effects.values())callback(timestamp)}function flushGlobalEffects(type,timestamp){switch(type){case"before":return run(globalEffects,timestamp);case"after":return run(globalAfterEffects,timestamp);case"tail":return run(globalTailEffects,timestamp)}}let subscribers,subscription;function render$1(timestamp,state,frame2){let delta=state.clock.getDelta();for(state.frameloop==="never"&&typeof timestamp=="number"&&(delta=timestamp-state.clock.elapsedTime,state.clock.oldTime=state.clock.elapsedTime,state.clock.elapsedTime=timestamp),subscribers=state.internal.subscribers,i$2=0;i$2<subscribers.length;i$2++)subscription=subscribers[i$2],subscription.ref.current(subscription.store.getState(),delta,frame2);return!state.internal.priority&&state.gl.render&&state.gl.render(state.scene,state.camera),state.internal.frames=Math.max(0,state.internal.frames-1),state.frameloop==="always"?1:state.internal.frames}function createLoop(roots2){let running=!1,repeat,frame2,state;function loop(timestamp){frame2=requestAnimationFrame(loop),running=!0,repeat=0,flushGlobalEffects("before",timestamp);for(const root of roots2.values()){var _state$gl$xr;state=root.store.getState(),state.internal.active&&(state.frameloop==="always"||state.internal.frames>0)&&!((_state$gl$xr=state.gl.xr)!=null&&_state$gl$xr.isPresenting)&&(repeat+=render$1(timestamp,state))}if(flushGlobalEffects("after",timestamp),repeat===0)return flushGlobalEffects("tail",timestamp),running=!1,cancelAnimationFrame(frame2)}function invalidate2(state2,frames=1){var _state$gl$xr2;if(!state2)return roots2.forEach(root=>invalidate2(root.store.getState()),frames);(_state$gl$xr2=state2.gl.xr)!=null&&_state$gl$xr2.isPresenting||!state2.internal.active||state2.frameloop==="never"||(state2.internal.frames=Math.min(60,state2.internal.frames+frames),running||(running=!0,requestAnimationFrame(loop)))}function advance2(timestamp,runGlobalEffects=!0,state2,frame3){if(runGlobalEffects&&flushGlobalEffects("before",timestamp),state2)render$1(timestamp,state2,frame3);else for(const root of roots2.values())render$1(timestamp,root.store.getState());runGlobalEffects&&flushGlobalEffects("after",timestamp)}return{loop,invalidate:invalidate2,advance:advance2}}function useStore(){const store=reactExports.useContext(context);if(!store)throw new Error("R3F: Hooks can only be used within the Canvas component!");return store}function useThree(selector=state=>state,equalityFn){return useStore()(selector,equalityFn)}function useFrame(callback,renderPriority=0){const store=useStore(),subscribe=store.getState().internal.subscribe,ref=useMutableCallback(callback);return useIsomorphicLayoutEffect(()=>subscribe(ref,renderPriority,store),[renderPriority,subscribe,store]),null}const memoizedLoaders=new WeakMap;function loadingFn(extensions2,onProgress){return function(Proto,...input){let loader=memoizedLoaders.get(Proto);return loader||(loader=new Proto,memoizedLoaders.set(Proto,loader)),extensions2&&extensions2(loader),Promise.all(input.map(input2=>new Promise((res,reject)=>loader.load(input2,data=>{data.scene&&Object.assign(data,buildGraph(data.scene)),res(data)},onProgress,error=>reject(new Error(`Could not load ${input2}: ${error==null?void 0:error.message}`)))))).finally(()=>loader.dispose==null?void 0:loader.dispose())}}function useLoader(Proto,input,extensions2,onProgress){const keys2=Array.isArray(input)?input:[input],results=suspend(loadingFn(extensions2,onProgress),[Proto,...keys2],{equal:is.equ});return Array.isArray(input)?results:results[0]}useLoader.preload=function(Proto,input,extensions2){const keys2=Array.isArray(input)?input:[input];return preload(loadingFn(extensions2),[Proto,...keys2])};useLoader.clear=function(Proto,input){const keys2=Array.isArray(input)?input:[input];return clear([Proto,...keys2])};const roots=new Map,{invalidate,advance}=createLoop(roots),{reconciler,applyProps}=createRenderer(roots,getEventPriority),shallowLoose={objects:"shallow",strict:!1},createRendererInstance=(gl,canvas)=>{const customRenderer=typeof gl=="function"?gl(canvas):gl;return isRenderer(customRenderer)?customRenderer:new WebGLRenderer({powerPreference:"high-performance",canvas,antialias:!0,alpha:!0,...gl})};function computeInitialSize(canvas,defaultSize){const defaultStyle=typeof HTMLCanvasElement<"u"&&canvas instanceof HTMLCanvasElement;if(defaultSize){const{width,height,top,left,updateStyle=defaultStyle}=defaultSize;return{width,height,top,left,updateStyle}}else if(typeof HTMLCanvasElement<"u"&&canvas instanceof HTMLCanvasElement&&canvas.parentElement){const{width,height,top,left}=canvas.parentElement.getBoundingClientRect();return{width,height,top,left,updateStyle:defaultStyle}}else if(typeof OffscreenCanvas<"u"&&canvas instanceof OffscreenCanvas)return{width:canvas.width,height:canvas.height,top:0,left:0,updateStyle:defaultStyle};return{width:0,height:0,top:0,left:0}}function createRoot(canvas){const prevRoot=roots.get(canvas),prevFiber=prevRoot==null?void 0:prevRoot.fiber,prevStore=prevRoot==null?void 0:prevRoot.store;prevRoot&&console.warn("R3F.createRoot should only be called once!");const logRecoverableError=typeof reportError=="function"?reportError:console.error,store=prevStore||createStore(invalidate,advance),fiber=prevFiber||reconciler.createContainer(store,constantsExports.ConcurrentRoot,null,!1,null,"",logRecoverableError,null);prevRoot||roots.set(canvas,{fiber,store});let onCreated,configured=!1,lastCamera;return{configure(props={}){let{gl:glConfig,size:propsSize,scene:sceneOptions,events,onCreated:onCreatedCallback,shadows=!1,linear=!1,flat=!1,legacy=!1,orthographic=!1,frameloop="always",dpr=[1,2],performance:performance2,raycaster:raycastOptions,camera:cameraOptions,onPointerMissed}=props,state=store.getState(),gl=state.gl;state.gl||state.set({gl:gl=createRendererInstance(glConfig,canvas)});let raycaster=state.raycaster;raycaster||state.set({raycaster:raycaster=new Raycaster});const{params,...options}=raycastOptions||{};if(is.equ(options,raycaster,shallowLoose)||applyProps(raycaster,{...options}),is.equ(params,raycaster.params,shallowLoose)||applyProps(raycaster,{params:{...raycaster.params,...params}}),!state.camera||state.camera===lastCamera&&!is.equ(lastCamera,cameraOptions,shallowLoose)){lastCamera=cameraOptions;const isCamera=cameraOptions instanceof Camera,camera=isCamera?cameraOptions:orthographic?new OrthographicCamera(0,0,0,0,.1,1e3):new PerspectiveCamera$1(75,0,.1,1e3);isCamera||(camera.position.z=5,cameraOptions&&applyProps(camera,cameraOptions),!state.camera&&!(cameraOptions!=null&&cameraOptions.rotation)&&camera.lookAt(0,0,0)),state.set({camera}),raycaster.camera=camera}if(!state.scene){let scene2;sceneOptions instanceof Scene$1?scene2=sceneOptions:(scene2=new Scene$1,sceneOptions&&applyProps(scene2,sceneOptions)),state.set({scene:prepare(scene2)})}if(!state.xr){var _gl$xr;const handleXRFrame=(timestamp,frame2)=>{const state2=store.getState();state2.frameloop!=="never"&&advance(timestamp,!0,state2,frame2)},handleSessionChange=()=>{const state2=store.getState();state2.gl.xr.enabled=state2.gl.xr.isPresenting,state2.gl.xr.setAnimationLoop(state2.gl.xr.isPresenting?handleXRFrame:null),state2.gl.xr.isPresenting||invalidate(state2)},xr={connect(){const gl2=store.getState().gl;gl2.xr.addEventListener("sessionstart",handleSessionChange),gl2.xr.addEventListener("sessionend",handleSessionChange)},disconnect(){const gl2=store.getState().gl;gl2.xr.removeEventListener("sessionstart",handleSessionChange),gl2.xr.removeEventListener("sessionend",handleSessionChange)}};typeof((_gl$xr=gl.xr)==null?void 0:_gl$xr.addEventListener)=="function"&&xr.connect(),state.set({xr})}if(gl.shadowMap){const oldEnabled=gl.shadowMap.enabled,oldType=gl.shadowMap.type;if(gl.shadowMap.enabled=!!shadows,is.boo(shadows))gl.shadowMap.type=PCFSoftShadowMap;else if(is.str(shadows)){var _types$shadows;const types2={basic:BasicShadowMap,percentage:PCFShadowMap,soft:PCFSoftShadowMap,variance:VSMShadowMap};gl.shadowMap.type=(_types$shadows=types2[shadows])!=null?_types$shadows:PCFSoftShadowMap}else is.obj(shadows)&&Object.assign(gl.shadowMap,shadows);(oldEnabled!==gl.shadowMap.enabled||oldType!==gl.shadowMap.type)&&(gl.shadowMap.needsUpdate=!0)}const ColorManagement2=getColorManagement();ColorManagement2&&("enabled"in ColorManagement2?ColorManagement2.enabled=!legacy:"legacyMode"in ColorManagement2&&(ColorManagement2.legacyMode=legacy)),applyProps(gl,{outputEncoding:linear?3e3:3001,toneMapping:flat?NoToneMapping:ACESFilmicToneMapping}),state.legacy!==legacy&&state.set(()=>({legacy})),state.linear!==linear&&state.set(()=>({linear})),state.flat!==flat&&state.set(()=>({flat})),glConfig&&!is.fun(glConfig)&&!isRenderer(glConfig)&&!is.equ(glConfig,gl,shallowLoose)&&applyProps(gl,glConfig),events&&!state.events.handlers&&state.set({events:events(store)});const size=computeInitialSize(canvas,propsSize);return is.equ(size,state.size,shallowLoose)||state.setSize(size.width,size.height,size.updateStyle,size.top,size.left),dpr&&state.viewport.dpr!==calculateDpr(dpr)&&state.setDpr(dpr),state.frameloop!==frameloop&&state.setFrameloop(frameloop),state.onPointerMissed||state.set({onPointerMissed}),performance2&&!is.equ(performance2,state.performance,shallowLoose)&&state.set(state2=>({performance:{...state2.performance,...performance2}})),onCreated=onCreatedCallback,configured=!0,this},render(children){return configured||this.configure(),reconciler.updateContainer(reactExports.createElement(Provider,{store,children,onCreated,rootElement:canvas}),fiber,null,()=>{}),store},unmount(){unmountComponentAtNode(canvas)}}}function Provider({store,children,onCreated,rootElement}){return useIsomorphicLayoutEffect(()=>{const state=store.getState();state.set(state2=>({internal:{...state2.internal,active:!0}})),onCreated&&onCreated(state),store.getState().events.connected||state.events.connect==null||state.events.connect(rootElement)},[]),reactExports.createElement(context.Provider,{value:store},children)}function unmountComponentAtNode(canvas,callback){const root=roots.get(canvas),fiber=root==null?void 0:root.fiber;if(fiber){const state=root==null?void 0:root.store.getState();state&&(state.internal.active=!1),reconciler.updateContainer(null,fiber,null,()=>{state&&setTimeout(()=>{try{var _state$gl,_state$gl$renderLists,_state$gl2,_state$gl3;state.events.disconnect==null||state.events.disconnect(),(_state$gl=state.gl)==null||(_state$gl$renderLists=_state$gl.renderLists)==null||_state$gl$renderLists.dispose==null||_state$gl$renderLists.dispose(),(_state$gl2=state.gl)==null||_state$gl2.forceContextLoss==null||_state$gl2.forceContextLoss(),(_state$gl3=state.gl)!=null&&_state$gl3.xr&&state.xr.disconnect(),dispose(state),roots.delete(canvas),callback&&callback(canvas)}catch{}},500)})}}reconciler.injectIntoDevTools({bundleType:1,rendererPackageName:"@react-three/fiber",version:reactExports.version});function debounce(func,wait,immediate){var timeout,args,context2,timestamp,result;wait==null&&(wait=100);function later(){var last=Date.now()-timestamp;last<wait&&last>=0?timeout=setTimeout(later,wait-last):(timeout=null,immediate||(result=func.apply(context2,args),context2=args=null))}var debounced=function(){context2=this,args=arguments,timestamp=Date.now();var callNow=immediate&&!timeout;return timeout||(timeout=setTimeout(later,wait)),callNow&&(result=func.apply(context2,args),context2=args=null),result};return debounced.clear=function(){timeout&&(clearTimeout(timeout),timeout=null)},debounced.flush=function(){timeout&&(result=func.apply(context2,args),context2=args=null,clearTimeout(timeout),timeout=null)},debounced}debounce.debounce=debounce;var debounce_1=debounce;const createDebounce=getDefaultExportFromCjs(debounce_1);function useMeasure(_temp){let{debounce:debounce2,scroll,polyfill:polyfill2,offsetSize}=_temp===void 0?{debounce:0,scroll:!1,offsetSize:!1}:_temp;const ResizeObserver2=polyfill2||(typeof window>"u"?class{}:window.ResizeObserver);if(!ResizeObserver2)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[bounds,set]=reactExports.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),state=reactExports.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:bounds}),scrollDebounce=debounce2?typeof debounce2=="number"?debounce2:debounce2.scroll:null,resizeDebounce=debounce2?typeof debounce2=="number"?debounce2:debounce2.resize:null,mounted=reactExports.useRef(!1);reactExports.useEffect(()=>(mounted.current=!0,()=>void(mounted.current=!1)));const[forceRefresh,resizeChange,scrollChange]=reactExports.useMemo(()=>{const callback=()=>{if(!state.current.element)return;const{left,top,width,height,bottom,right,x:x2,y:y2}=state.current.element.getBoundingClientRect(),size={left,top,width,height,bottom,right,x:x2,y:y2};state.current.element instanceof HTMLElement&&offsetSize&&(size.height=state.current.element.offsetHeight,size.width=state.current.element.offsetWidth),Object.freeze(size),mounted.current&&!areBoundsEqual(state.current.lastBounds,size)&&set(state.current.lastBounds=size)};return[callback,resizeDebounce?createDebounce(callback,resizeDebounce):callback,scrollDebounce?createDebounce(callback,scrollDebounce):callback]},[set,offsetSize,scrollDebounce,resizeDebounce]);function removeListeners(){state.current.scrollContainers&&(state.current.scrollContainers.forEach(element=>element.removeEventListener("scroll",scrollChange,!0)),state.current.scrollContainers=null),state.current.resizeObserver&&(state.current.resizeObserver.disconnect(),state.current.resizeObserver=null)}function addListeners(){state.current.element&&(state.current.resizeObserver=new ResizeObserver2(scrollChange),state.current.resizeObserver.observe(state.current.element),scroll&&state.current.scrollContainers&&state.current.scrollContainers.forEach(scrollContainer=>scrollContainer.addEventListener("scroll",scrollChange,{capture:!0,passive:!0})))}const ref=node=>{!node||node===state.current.element||(removeListeners(),state.current.element=node,state.current.scrollContainers=findScrollContainers(node),addListeners())};return useOnWindowScroll(scrollChange,!!scroll),useOnWindowResize(resizeChange),reactExports.useEffect(()=>{removeListeners(),addListeners()},[scroll,scrollChange,resizeChange]),reactExports.useEffect(()=>removeListeners,[]),[ref,bounds,forceRefresh]}function useOnWindowResize(onWindowResize){reactExports.useEffect(()=>{const cb=onWindowResize;return window.addEventListener("resize",cb),()=>void window.removeEventListener("resize",cb)},[onWindowResize])}function useOnWindowScroll(onScroll,enabled){reactExports.useEffect(()=>{if(enabled){const cb=onScroll;return window.addEventListener("scroll",cb,{capture:!0,passive:!0}),()=>void window.removeEventListener("scroll",cb,!0)}},[onScroll,enabled])}function findScrollContainers(element){const result=[];if(!element||element===document.body)return result;const{overflow,overflowX,overflowY}=window.getComputedStyle(element);return[overflow,overflowX,overflowY].some(prop=>prop==="auto"||prop==="scroll")&&result.push(element),[...result,...findScrollContainers(element.parentElement)]}const keys=["x","y","top","bottom","left","right","width","height"],areBoundsEqual=(a2,b2)=>keys.every(key=>a2[key]===b2[key]);var __defProp$1=Object.defineProperty,__defProps=Object.defineProperties,__getOwnPropDescs=Object.getOwnPropertyDescriptors,__getOwnPropSymbols=Object.getOwnPropertySymbols,__hasOwnProp=Object.prototype.hasOwnProperty,__propIsEnum=Object.prototype.propertyIsEnumerable,__defNormalProp$1=(obj,key,value)=>key in obj?__defProp$1(obj,key,{enumerable:!0,configurable:!0,writable:!0,value}):obj[key]=value,__spreadValues=(a2,b2)=>{for(var prop in b2||(b2={}))__hasOwnProp.call(b2,prop)&&__defNormalProp$1(a2,prop,b2[prop]);if(__getOwnPropSymbols)for(var prop of __getOwnPropSymbols(b2))__propIsEnum.call(b2,prop)&&__defNormalProp$1(a2,prop,b2[prop]);return a2},__spreadProps=(a2,b2)=>__defProps(a2,__getOwnPropDescs(b2));function traverseFiber(fiber,ascending,selector){if(!fiber)return;if(selector(fiber)===!0)return fiber;let child=ascending?fiber.return:fiber.child;for(;child;){const match=traverseFiber(child,ascending,selector);if(match)return match;child=ascending?null:child.sibling}}function wrapContext(context2){try{return Object.defineProperties(context2,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return context2}}const FiberContext=wrapContext(reactExports.createContext(null));class FiberProvider extends reactExports.Component{render(){return reactExports.createElement(FiberContext.Provider,{value:this._reactInternals},this.props.children)}}const{ReactCurrentOwner,ReactCurrentDispatcher}=reactExports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;function useFiber(){const root=reactExports.useContext(FiberContext);if(root===null)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const id2=reactExports.useId();return reactExports.useMemo(()=>{for(const maybeFiber of[ReactCurrentOwner==null?void 0:ReactCurrentOwner.current,root,root==null?void 0:root.alternate]){if(!maybeFiber)continue;const fiber2=traverseFiber(maybeFiber,!1,node=>{let state=node.memoizedState;for(;state;){if(state.memoizedState===id2)return!0;state=state.next}});if(fiber2)return fiber2}},[root,id2])}function useContextMap(){var _a2,_b2;const fiber=useFiber(),[contextMap]=reactExports.useState(()=>new Map);contextMap.clear();let node=fiber;for(;node;){const context2=(_a2=node.type)==null?void 0:_a2._context;context2&&context2!==FiberContext&&!contextMap.has(context2)&&contextMap.set(context2,(_b2=ReactCurrentDispatcher==null?void 0:ReactCurrentDispatcher.current)==null?void 0:_b2.readContext(wrapContext(context2))),node=node.return}return contextMap}function useContextBridge(){const contextMap=useContextMap();return reactExports.useMemo(()=>Array.from(contextMap.keys()).reduce((Prev,context2)=>props=>reactExports.createElement(Prev,null,reactExports.createElement(context2.Provider,__spreadProps(__spreadValues({},props),{value:contextMap.get(context2)}))),props=>reactExports.createElement(FiberProvider,__spreadValues({},props))),[contextMap])}const DOM_EVENTS={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function createPointerEvents(store){const{handlePointer}=createEvents(store);return{priority:1,enabled:!0,compute(event,state,previous){state.pointer.set(event.offsetX/state.size.width*2-1,-(event.offsetY/state.size.height)*2+1),state.raycaster.setFromCamera(state.pointer,state.camera)},connected:void 0,handlers:Object.keys(DOM_EVENTS).reduce((acc,key)=>({...acc,[key]:handlePointer(key)}),{}),update:()=>{var _internal$lastEvent;const{events,internal}=store.getState();(_internal$lastEvent=internal.lastEvent)!=null&&_internal$lastEvent.current&&events.handlers&&events.handlers.onPointerMove(internal.lastEvent.current)},connect:target=>{var _events$handlers;const{set,events}=store.getState();events.disconnect==null||events.disconnect(),set(state=>({events:{...state.events,connected:target}})),Object.entries((_events$handlers=events.handlers)!=null?_events$handlers:[]).forEach(([name,event])=>{const[eventName,passive]=DOM_EVENTS[name];target.addEventListener(eventName,event,{passive})})},disconnect:()=>{const{set,events}=store.getState();if(events.connected){var _events$handlers2;Object.entries((_events$handlers2=events.handlers)!=null?_events$handlers2:[]).forEach(([name,event])=>{if(events&&events.connected instanceof HTMLElement){const[eventName]=DOM_EVENTS[name];events.connected.removeEventListener(eventName,event)}}),set(state=>({events:{...state.events,connected:void 0}}))}}}}const CanvasImpl=reactExports.forwardRef(function({children,fallback,resize,style,gl,events=createPointerEvents,eventSource,eventPrefix,shadows,linear,flat,legacy,orthographic,frameloop,dpr,performance:performance2,raycaster,camera,scene:scene2,onPointerMissed,onCreated,...props},forwardedRef){reactExports.useMemo(()=>extend(THREE),[]);const Bridge=useContextBridge(),[containerRef,containerRect]=useMeasure({scroll:!0,debounce:{scroll:50,resize:0},...resize}),canvasRef=reactExports.useRef(null),divRef=reactExports.useRef(null);reactExports.useImperativeHandle(forwardedRef,()=>canvasRef.current);const handlePointerMissed=useMutableCallback(onPointerMissed),[block,setBlock]=reactExports.useState(!1),[error,setError]=reactExports.useState(!1);if(block)throw block;if(error)throw error;const root=reactExports.useRef(null);useIsomorphicLayoutEffect(()=>{const canvas=canvasRef.current;containerRect.width>0&&containerRect.height>0&&canvas&&(root.current||(root.current=createRoot(canvas)),root.current.configure({gl,events,shadows,linear,flat,legacy,orthographic,frameloop,dpr,performance:performance2,raycaster,camera,scene:scene2,size:containerRect,onPointerMissed:(...args)=>handlePointerMissed.current==null?void 0:handlePointerMissed.current(...args),onCreated:state=>{state.events.connect==null||state.events.connect(eventSource?isRef(eventSource)?eventSource.current:eventSource:divRef.current),eventPrefix&&state.setEvents({compute:(event,state2)=>{const x2=event[eventPrefix+"X"],y2=event[eventPrefix+"Y"];state2.pointer.set(x2/state2.size.width*2-1,-(y2/state2.size.height)*2+1),state2.raycaster.setFromCamera(state2.pointer,state2.camera)}}),onCreated==null||onCreated(state)}}),root.current.render(reactExports.createElement(Bridge,null,reactExports.createElement(ErrorBoundary,{set:setError},reactExports.createElement(reactExports.Suspense,{fallback:reactExports.createElement(Block,{set:setBlock})},children)))))}),reactExports.useEffect(()=>{const canvas=canvasRef.current;if(canvas)return()=>unmountComponentAtNode(canvas)},[]);const pointerEvents=eventSource?"none":"auto";return reactExports.createElement("div",_extends({ref:divRef,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents,...style}},props),reactExports.createElement("div",{ref:containerRef,style:{width:"100%",height:"100%"}},reactExports.createElement("canvas",{ref:canvasRef,style:{display:"block"}},fallback)))}),Canvas2=reactExports.forwardRef(function(props,ref){return reactExports.createElement(FiberProvider,null,reactExports.createElement(CanvasImpl,_extends({},props,{ref})))}),v1=new Vector3,v2=new Vector3,v3=new Vector3;function defaultCalculatePosition(el,camera,size){const objectPos=v1.setFromMatrixPosition(el.matrixWorld);objectPos.project(camera);const widthHalf=size.width/2,heightHalf=size.height/2;return[objectPos.x*widthHalf+widthHalf,-(objectPos.y*heightHalf)+heightHalf]}function isObjectBehindCamera(el,camera){const objectPos=v1.setFromMatrixPosition(el.matrixWorld),cameraPos=v2.setFromMatrixPosition(camera.matrixWorld),deltaCamObj=objectPos.sub(cameraPos),camDir=camera.getWorldDirection(v3);return deltaCamObj.angleTo(camDir)>Math.PI/2}function isObjectVisible(el,camera,raycaster,occlude){const elPos=v1.setFromMatrixPosition(el.matrixWorld),screenPos=elPos.clone();screenPos.project(camera),raycaster.setFromCamera(screenPos,camera);const intersects2=raycaster.intersectObjects(occlude,!0);if(intersects2.length){const intersectionDistance=intersects2[0].distance;return elPos.distanceTo(raycaster.ray.origin)<intersectionDistance}return!0}function objectScale(el,camera){if(camera instanceof OrthographicCamera)return camera.zoom;if(camera instanceof PerspectiveCamera$1){const objectPos=v1.setFromMatrixPosition(el.matrixWorld),cameraPos=v2.setFromMatrixPosition(camera.matrixWorld),vFOV=camera.fov*Math.PI/180,dist=objectPos.distanceTo(cameraPos);return 1/(2*Math.tan(vFOV/2)*dist)}else return 1}function objectZIndex(el,camera,zIndexRange){if(camera instanceof PerspectiveCamera$1||camera instanceof OrthographicCamera){const objectPos=v1.setFromMatrixPosition(el.matrixWorld),cameraPos=v2.setFromMatrixPosition(camera.matrixWorld),dist=objectPos.distanceTo(cameraPos),A=(zIndexRange[1]-zIndexRange[0])/(camera.far-camera.near),B=zIndexRange[1]-A*camera.far;return Math.round(A*dist+B)}}const epsilon=value=>Math.abs(value)<1e-10?0:value;function getCSSMatrix(matrix,multipliers,prepend=""){let matrix3d="matrix3d(";for(let i2=0;i2!==16;i2++)matrix3d+=epsilon(multipliers[i2]*matrix.elements[i2])+(i2!==15?",":")");return prepend+matrix3d}const getCameraCSSMatrix=(multipliers=>matrix=>getCSSMatrix(matrix,multipliers))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),getObjectCSSMatrix=(scaleMultipliers=>(matrix,factor)=>getCSSMatrix(matrix,scaleMultipliers(factor),"translate(-50%,-50%)"))(f2=>[1/f2,1/f2,1/f2,1,-1/f2,-1/f2,-1/f2,-1,1/f2,1/f2,1/f2,1,1,1,1,1]);function isRefObject(ref){return ref&&typeof ref=="object"&&"current"in ref}const Html=reactExports.forwardRef(({children,eps=.001,style,className,prepend,center,fullscreen,portal,distanceFactor,sprite=!1,transform=!1,occlude,onOcclude,castShadow,receiveShadow,material,geometry,zIndexRange=[16777271,0],calculatePosition=defaultCalculatePosition,as="div",wrapperClass,pointerEvents="auto",...props},ref)=>{const{gl,camera,scene:scene2,size,raycaster,events,viewport}=useThree(),[el]=reactExports.useState(()=>document.createElement(as)),root=reactExports.useRef(),group=reactExports.useRef(null),oldZoom=reactExports.useRef(0),oldPosition=reactExports.useRef([0,0]),transformOuterRef=reactExports.useRef(null),transformInnerRef=reactExports.useRef(null),target=(portal==null?void 0:portal.current)||events.connected||gl.domElement.parentNode,occlusionMeshRef=reactExports.useRef(null),isMeshSizeSet=reactExports.useRef(!1),isRayCastOcclusion=reactExports.useMemo(()=>occlude&&occlude!=="blending"||Array.isArray(occlude)&&occlude.length&&isRefObject(occlude[0]),[occlude]);reactExports.useLayoutEffect(()=>{const el2=gl.domElement;occlude&&occlude==="blending"?(el2.style.zIndex=`${Math.floor(zIndexRange[0]/2)}`,el2.style.position="absolute",el2.style.pointerEvents="none"):(el2.style.zIndex=null,el2.style.position=null,el2.style.pointerEvents=null)},[occlude]),reactExports.useLayoutEffect(()=>{if(group.current){const currentRoot=root.current=createRoot$1(el);if(scene2.updateMatrixWorld(),transform)el.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const vec=calculatePosition(group.current,camera,size);el.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${vec[0]}px,${vec[1]}px,0);transform-origin:0 0;`}return target&&(prepend?target.prepend(el):target.appendChild(el)),()=>{target&&target.removeChild(el),currentRoot.unmount()}}},[target,transform]),reactExports.useLayoutEffect(()=>{wrapperClass&&(el.className=wrapperClass)},[wrapperClass]);const styles=reactExports.useMemo(()=>transform?{position:"absolute",top:0,left:0,width:size.width,height:size.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:center?"translate3d(-50%,-50%,0)":"none",...fullscreen&&{top:-size.height/2,left:-size.width/2,width:size.width,height:size.height},...style},[style,center,fullscreen,size,transform]),transformInnerStyles=reactExports.useMemo(()=>({position:"absolute",pointerEvents}),[pointerEvents]);reactExports.useLayoutEffect(()=>{if(isMeshSizeSet.current=!1,transform){var _root$current;(_root$current=root.current)==null||_root$current.render(reactExports.createElement("div",{ref:transformOuterRef,style:styles},reactExports.createElement("div",{ref:transformInnerRef,style:transformInnerStyles},reactExports.createElement("div",{ref,className,style,children}))))}else{var _root$current2;(_root$current2=root.current)==null||_root$current2.render(reactExports.createElement("div",{ref,style:styles,className,children}))}});const visible=reactExports.useRef(!0);useFrame(gl2=>{if(group.current){camera.updateMatrixWorld(),group.current.updateWorldMatrix(!0,!1);const vec=transform?oldPosition.current:calculatePosition(group.current,camera,size);if(transform||Math.abs(oldZoom.current-camera.zoom)>eps||Math.abs(oldPosition.current[0]-vec[0])>eps||Math.abs(oldPosition.current[1]-vec[1])>eps){const isBehindCamera=isObjectBehindCamera(group.current,camera);let raytraceTarget=!1;isRayCastOcclusion&&(Array.isArray(occlude)?raytraceTarget=occlude.map(item=>item.current):occlude!=="blending"&&(raytraceTarget=[scene2]));const previouslyVisible=visible.current;if(raytraceTarget){const isvisible=isObjectVisible(group.current,camera,raycaster,raytraceTarget);visible.current=isvisible&&!isBehindCamera}else visible.current=!isBehindCamera;previouslyVisible!==visible.current&&(onOcclude?onOcclude(!visible.current):el.style.display=visible.current?"block":"none");const halfRange=Math.floor(zIndexRange[0]/2),zRange=occlude?isRayCastOcclusion?[zIndexRange[0],halfRange]:[halfRange-1,0]:zIndexRange;if(el.style.zIndex=`${objectZIndex(group.current,camera,zRange)}`,transform){const[widthHalf,heightHalf]=[size.width/2,size.height/2],fov2=camera.projectionMatrix.elements[5]*heightHalf,{isOrthographicCamera:isOrthographicCamera2,top,left,bottom,right}=camera,cameraMatrix=getCameraCSSMatrix(camera.matrixWorldInverse),cameraTransform=isOrthographicCamera2?`scale(${fov2})translate(${epsilon(-(right+left)/2)}px,${epsilon((top+bottom)/2)}px)`:`translateZ(${fov2}px)`;let matrix=group.current.matrixWorld;sprite&&(matrix=camera.matrixWorldInverse.clone().transpose().copyPosition(matrix).scale(group.current.scale),matrix.elements[3]=matrix.elements[7]=matrix.elements[11]=0,matrix.elements[15]=1),el.style.width=size.width+"px",el.style.height=size.height+"px",el.style.perspective=isOrthographicCamera2?"":`${fov2}px`,transformOuterRef.current&&transformInnerRef.current&&(transformOuterRef.current.style.transform=`${cameraTransform}${cameraMatrix}translate(${widthHalf}px,${heightHalf}px)`,transformInnerRef.current.style.transform=getObjectCSSMatrix(matrix,1/((distanceFactor||10)/400)))}else{const scale2=distanceFactor===void 0?1:objectScale(group.current,camera)*distanceFactor;el.style.transform=`translate3d(${vec[0]}px,${vec[1]}px,0) scale(${scale2})`}oldPosition.current=vec,oldZoom.current=camera.zoom}}if(!isRayCastOcclusion&&occlusionMeshRef.current&&!isMeshSizeSet.current)if(transform){if(transformOuterRef.current){const el2=transformOuterRef.current.children[0];if(el2!=null&&el2.clientWidth&&el2!=null&&el2.clientHeight){const{isOrthographicCamera:isOrthographicCamera2}=camera;if(isOrthographicCamera2||geometry)props.scale&&(Array.isArray(props.scale)?props.scale instanceof Vector3?occlusionMeshRef.current.scale.copy(props.scale.clone().divideScalar(1)):occlusionMeshRef.current.scale.set(1/props.scale[0],1/props.scale[1],1/props.scale[2]):occlusionMeshRef.current.scale.setScalar(1/props.scale));else{const ratio=(distanceFactor||10)/400,w2=el2.clientWidth*ratio,h2=el2.clientHeight*ratio;occlusionMeshRef.current.scale.set(w2,h2,1)}isMeshSizeSet.current=!0}}}else{const ele=el.children[0];if(ele!=null&&ele.clientWidth&&ele!=null&&ele.clientHeight){const ratio=1/viewport.factor,w2=ele.clientWidth*ratio,h2=ele.clientHeight*ratio;occlusionMeshRef.current.scale.set(w2,h2,1),isMeshSizeSet.current=!0}occlusionMeshRef.current.lookAt(gl2.camera.position)}});const shaders=reactExports.useMemo(()=>({vertexShader:transform?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[transform]);return reactExports.createElement("group",_extends({},props,{ref:group}),occlude&&!isRayCastOcclusion&&reactExports.createElement("mesh",{castShadow,receiveShadow,ref:occlusionMeshRef},geometry||reactExports.createElement("planeGeometry",null),material||reactExports.createElement("shaderMaterial",{side:DoubleSide,vertexShader:shaders.vertexShader,fragmentShader:shaders.fragmentShader})))});let saveLastTotalLoaded=0;const useProgress=create(set=>(DefaultLoadingManager.onStart=(item,loaded,total)=>{set({active:!0,item,loaded,total,progress:(loaded-saveLastTotalLoaded)/(total-saveLastTotalLoaded)*100})},DefaultLoadingManager.onLoad=()=>{set({active:!1})},DefaultLoadingManager.onError=item=>set(state=>({errors:[...state.errors,item]})),DefaultLoadingManager.onProgress=(item,loaded,total)=>{loaded===total&&(saveLastTotalLoaded=total),set({active:!0,item,loaded,total,progress:(loaded-saveLastTotalLoaded)/(total-saveLastTotalLoaded)*100||100})},{errors:[],active:!1,progress:0,item:"",loaded:0,total:0}));function mergeRefs(refs){return function(value){refs.forEach(function(ref){typeof ref=="function"?ref(value):ref!=null&&(ref.current=value)})}}function toTrianglesDrawMode(geometry,drawMode){if(drawMode===TrianglesDrawMode)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),geometry;if(drawMode===TriangleFanDrawMode||drawMode===TriangleStripDrawMode){let index=geometry.getIndex();if(index===null){const indices=[],position=geometry.getAttribute("position");if(position!==void 0){for(let i2=0;i2<position.count;i2++)indices.push(i2);geometry.setIndex(indices),index=geometry.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),geometry}const numberOfTriangles=index.count-2,newIndices=[];if(index)if(drawMode===TriangleFanDrawMode)for(let i2=1;i2<=numberOfTriangles;i2++)newIndices.push(index.getX(0)),newIndices.push(index.getX(i2)),newIndices.push(index.getX(i2+1));else for(let i2=0;i2<numberOfTriangles;i2++)i2%2===0?(newIndices.push(index.getX(i2)),newIndices.push(index.getX(i2+1)),newIndices.push(index.getX(i2+2))):(newIndices.push(index.getX(i2+2)),newIndices.push(index.getX(i2+1)),newIndices.push(index.getX(i2)));newIndices.length/3!==numberOfTriangles&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const newGeometry=geometry.clone();return newGeometry.setIndex(newIndices),newGeometry.clearGroups(),newGeometry}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",drawMode),geometry}const version=parseInt(REVISION.replace(/\D+/g,""));var u8=Uint8Array,u16=Uint16Array,u32=Uint32Array,fleb=new u8([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),fdeb=new u8([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),clim=new u8([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),freb=function(eb,start){for(var b2=new u16(31),i2=0;i2<31;++i2)b2[i2]=start+=1<<eb[i2-1];for(var r2=new u32(b2[30]),i2=1;i2<30;++i2)for(var j2=b2[i2];j2<b2[i2+1];++j2)r2[j2]=j2-b2[i2]<<5|i2;return[b2,r2]},_a=freb(fleb,2),fl=_a[0],revfl=_a[1];fl[28]=258,revfl[258]=28;var _b=freb(fdeb,0),fd=_b[0],rev=new u16(32768);for(var i$1=0;i$1<32768;++i$1){var x$2=(i$1&43690)>>>1|(i$1&21845)<<1;x$2=(x$2&52428)>>>2|(x$2&13107)<<2,x$2=(x$2&61680)>>>4|(x$2&3855)<<4,rev[i$1]=((x$2&65280)>>>8|(x$2&255)<<8)>>>1}var hMap=function(cd,mb,r2){for(var s2=cd.length,i2=0,l2=new u16(mb);i2<s2;++i2)++l2[cd[i2]-1];var le=new u16(mb);for(i2=0;i2<mb;++i2)le[i2]=le[i2-1]+l2[i2-1]<<1;var co;if(r2){co=new u16(1<<mb);var rvb=15-mb;for(i2=0;i2<s2;++i2)if(cd[i2])for(var sv=i2<<4|cd[i2],r_1=mb-cd[i2],v4=le[cd[i2]-1]++<<r_1,m2=v4|(1<<r_1)-1;v4<=m2;++v4)co[rev[v4]>>>rvb]=sv}else for(co=new u16(s2),i2=0;i2<s2;++i2)cd[i2]&&(co[i2]=rev[le[cd[i2]-1]++]>>>15-cd[i2]);return co},flt=new u8(288);for(var i$1=0;i$1<144;++i$1)flt[i$1]=8;for(var i$1=144;i$1<256;++i$1)flt[i$1]=9;for(var i$1=256;i$1<280;++i$1)flt[i$1]=7;for(var i$1=280;i$1<288;++i$1)flt[i$1]=8;var fdt=new u8(32);for(var i$1=0;i$1<32;++i$1)fdt[i$1]=5;var flrm=hMap(flt,9,1),fdrm=hMap(fdt,5,1),max=function(a2){for(var m2=a2[0],i2=1;i2<a2.length;++i2)a2[i2]>m2&&(m2=a2[i2]);return m2},bits=function(d2,p2,m2){var o2=p2/8|0;return(d2[o2]|d2[o2+1]<<8)>>(p2&7)&m2},bits16=function(d2,p2){var o2=p2/8|0;return(d2[o2]|d2[o2+1]<<8|d2[o2+2]<<16)>>(p2&7)},shft=function(p2){return(p2/8|0)+(p2&7&&1)},slc=function(v4,s2,e2){(s2==null||s2<0)&&(s2=0),(e2==null||e2>v4.length)&&(e2=v4.length);var n=new(v4 instanceof u16?u16:v4 instanceof u32?u32:u8)(e2-s2);return n.set(v4.subarray(s2,e2)),n},inflt=function(dat,buf,st){var sl=dat.length;if(!sl||st&&!st.l&&sl<5)return buf||new u8(0);var noBuf=!buf||st,noSt=!st||st.i;st||(st={}),buf||(buf=new u8(sl*3));var cbuf=function(l3){var bl=buf.length;if(l3>bl){var nbuf=new u8(Math.max(bl*2,l3));nbuf.set(buf),buf=nbuf}},final=st.f||0,pos=st.p||0,bt=st.b||0,lm=st.l,dm=st.d,lbt=st.m,dbt=st.n,tbts=sl*8;do{if(!lm){st.f=final=bits(dat,pos,1);var type=bits(dat,pos+1,3);if(pos+=3,type)if(type==1)lm=flrm,dm=fdrm,lbt=9,dbt=5;else if(type==2){var hLit=bits(dat,pos,31)+257,hcLen=bits(dat,pos+10,15)+4,tl=hLit+bits(dat,pos+5,31)+1;pos+=14;for(var ldt=new u8(tl),clt=new u8(19),i2=0;i2<hcLen;++i2)clt[clim[i2]]=bits(dat,pos+i2*3,7);pos+=hcLen*3;for(var clb=max(clt),clbmsk=(1<<clb)-1,clm=hMap(clt,clb,1),i2=0;i2<tl;){var r2=clm[bits(dat,pos,clbmsk)];pos+=r2&15;var s2=r2>>>4;if(s2<16)ldt[i2++]=s2;else{var c2=0,n=0;for(s2==16?(n=3+bits(dat,pos,3),pos+=2,c2=ldt[i2-1]):s2==17?(n=3+bits(dat,pos,7),pos+=3):s2==18&&(n=11+bits(dat,pos,127),pos+=7);n--;)ldt[i2++]=c2}}var lt=ldt.subarray(0,hLit),dt=ldt.subarray(hLit);lbt=max(lt),dbt=max(dt),lm=hMap(lt,lbt,1),dm=hMap(dt,dbt,1)}else throw"invalid block type";else{var s2=shft(pos)+4,l2=dat[s2-4]|dat[s2-3]<<8,t2=s2+l2;if(t2>sl){if(noSt)throw"unexpected EOF";break}noBuf&&cbuf(bt+l2),buf.set(dat.subarray(s2,t2),bt),st.b=bt+=l2,st.p=pos=t2*8;continue}if(pos>tbts){if(noSt)throw"unexpected EOF";break}}noBuf&&cbuf(bt+131072);for(var lms=(1<<lbt)-1,dms=(1<<dbt)-1,lpos=pos;;lpos=pos){var c2=lm[bits16(dat,pos)&lms],sym=c2>>>4;if(pos+=c2&15,pos>tbts){if(noSt)throw"unexpected EOF";break}if(!c2)throw"invalid length/literal";if(sym<256)buf[bt++]=sym;else if(sym==256){lpos=pos,lm=null;break}else{var add=sym-254;if(sym>264){var i2=sym-257,b2=fleb[i2];add=bits(dat,pos,(1<<b2)-1)+fl[i2],pos+=b2}var d2=dm[bits16(dat,pos)&dms],dsym=d2>>>4;if(!d2)throw"invalid distance";pos+=d2&15;var dt=fd[dsym];if(dsym>3){var b2=fdeb[dsym];dt+=bits16(dat,pos)&(1<<b2)-1,pos+=b2}if(pos>tbts){if(noSt)throw"unexpected EOF";break}noBuf&&cbuf(bt+131072);for(var end=bt+add;bt<end;bt+=4)buf[bt]=buf[bt-dt],buf[bt+1]=buf[bt+1-dt],buf[bt+2]=buf[bt+2-dt],buf[bt+3]=buf[bt+3-dt];bt=end}}st.l=lm,st.p=lpos,st.b=bt,lm&&(final=1,st.m=lbt,st.d=dm,st.n=dbt)}while(!final);return bt==buf.length?buf:slc(buf,0,bt)},et=new u8(0),zlv=function(d2){if((d2[0]&15)!=8||d2[0]>>>4>7||(d2[0]<<8|d2[1])%31)throw"invalid zlib data";if(d2[1]&32)throw"invalid zlib data: preset dictionaries not supported"};function unzlibSync(data,out){return inflt((zlv(data),data.subarray(2,-4)),out)}var td=typeof TextDecoder<"u"&&new TextDecoder,tds=0;try{td.decode(et,{stream:!0}),tds=1}catch{}var __defProp=Object.defineProperty,__defNormalProp=(obj,key,value)=>key in obj?__defProp(obj,key,{enumerable:!0,configurable:!0,writable:!0,value}):obj[key]=value,__publicField=(obj,key,value)=>(__defNormalProp(obj,typeof key!="symbol"?key+"":key,value),value);const _ray=new Ray,_plane=new Plane,TILT_LIMIT=Math.cos(70*(Math.PI/180)),moduloWrapAround=(offset,capacity)=>(offset%capacity+capacity)%capacity;let OrbitControls$1=class extends EventDispatcher{constructor(object,domElement){super(),__publicField(this,"object"),__publicField(this,"domElement"),__publicField(this,"enabled",!0),__publicField(this,"target",new Vector3),__publicField(this,"minDistance",0),__publicField(this,"maxDistance",1/0),__publicField(this,"minZoom",0),__publicField(this,"maxZoom",1/0),__publicField(this,"minPolarAngle",0),__publicField(this,"maxPolarAngle",Math.PI),__publicField(this,"minAzimuthAngle",-1/0),__publicField(this,"maxAzimuthAngle",1/0),__publicField(this,"enableDamping",!1),__publicField(this,"dampingFactor",.05),__publicField(this,"enableZoom",!0),__publicField(this,"zoomSpeed",1),__publicField(this,"enableRotate",!0),__publicField(this,"rotateSpeed",1),__publicField(this,"enablePan",!0),__publicField(this,"panSpeed",1),__publicField(this,"screenSpacePanning",!0),__publicField(this,"keyPanSpeed",7),__publicField(this,"zoomToCursor",!1),__publicField(this,"autoRotate",!1),__publicField(this,"autoRotateSpeed",2),__publicField(this,"reverseOrbit",!1),__publicField(this,"reverseHorizontalOrbit",!1),__publicField(this,"reverseVerticalOrbit",!1),__publicField(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),__publicField(this,"mouseButtons",{LEFT:MOUSE.ROTATE,MIDDLE:MOUSE.DOLLY,RIGHT:MOUSE.PAN}),__publicField(this,"touches",{ONE:TOUCH.ROTATE,TWO:TOUCH.DOLLY_PAN}),__publicField(this,"target0"),__publicField(this,"position0"),__publicField(this,"zoom0"),__publicField(this,"_domElementKeyEvents",null),__publicField(this,"getPolarAngle"),__publicField(this,"getAzimuthalAngle"),__publicField(this,"setPolarAngle"),__publicField(this,"setAzimuthalAngle"),__publicField(this,"getDistance"),__publicField(this,"listenToKeyEvents"),__publicField(this,"stopListenToKeyEvents"),__publicField(this,"saveState"),__publicField(this,"reset"),__publicField(this,"update"),__publicField(this,"connect"),__publicField(this,"dispose"),this.object=object,this.domElement=domElement,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>spherical.phi,this.getAzimuthalAngle=()=>spherical.theta,this.setPolarAngle=value=>{let phi=moduloWrapAround(value,2*Math.PI),currentPhi=spherical.phi;currentPhi<0&&(currentPhi+=2*Math.PI),phi<0&&(phi+=2*Math.PI);let phiDist=Math.abs(phi-currentPhi);2*Math.PI-phiDist<phiDist&&(phi<currentPhi?phi+=2*Math.PI:currentPhi+=2*Math.PI),sphericalDelta.phi=phi-currentPhi,scope.update()},this.setAzimuthalAngle=value=>{let theta=moduloWrapAround(value,2*Math.PI),currentTheta=spherical.theta;currentTheta<0&&(currentTheta+=2*Math.PI),theta<0&&(theta+=2*Math.PI);let thetaDist=Math.abs(theta-currentTheta);2*Math.PI-thetaDist<thetaDist&&(theta<currentTheta?theta+=2*Math.PI:currentTheta+=2*Math.PI),sphericalDelta.theta=theta-currentTheta,scope.update()},this.getDistance=()=>scope.object.position.distanceTo(scope.target),this.listenToKeyEvents=domElement2=>{domElement2.addEventListener("keydown",onKeyDown),this._domElementKeyEvents=domElement2},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",onKeyDown),this._domElementKeyEvents=null},this.saveState=()=>{scope.target0.copy(scope.target),scope.position0.copy(scope.object.position),scope.zoom0=scope.object.zoom},this.reset=()=>{scope.target.copy(scope.target0),scope.object.position.copy(scope.position0),scope.object.zoom=scope.zoom0,scope.object.updateProjectionMatrix(),scope.dispatchEvent(changeEvent),scope.update(),state=STATE.NONE},this.update=(()=>{const offset=new Vector3,up=new Vector3(0,1,0),quat=new Quaternion().setFromUnitVectors(object.up,up),quatInverse=quat.clone().invert(),lastPosition=new Vector3,lastQuaternion=new Quaternion,twoPI=2*Math.PI;return function(){const position=scope.object.position;quat.setFromUnitVectors(object.up,up),quatInverse.copy(quat).invert(),offset.copy(position).sub(scope.target),offset.applyQuaternion(quat),spherical.setFromVector3(offset),scope.autoRotate&&state===STATE.NONE&&rotateLeft(getAutoRotationAngle()),scope.enableDamping?(spherical.theta+=sphericalDelta.theta*scope.dampingFactor,spherical.phi+=sphericalDelta.phi*scope.dampingFactor):(spherical.theta+=sphericalDelta.theta,spherical.phi+=sphericalDelta.phi);let min=scope.minAzimuthAngle,max2=scope.maxAzimuthAngle;isFinite(min)&&isFinite(max2)&&(min<-Math.PI?min+=twoPI:min>Math.PI&&(min-=twoPI),max2<-Math.PI?max2+=twoPI:max2>Math.PI&&(max2-=twoPI),min<=max2?spherical.theta=Math.max(min,Math.min(max2,spherical.theta)):spherical.theta=spherical.theta>(min+max2)/2?Math.max(min,spherical.theta):Math.min(max2,spherical.theta)),spherical.phi=Math.max(scope.minPolarAngle,Math.min(scope.maxPolarAngle,spherical.phi)),spherical.makeSafe(),scope.enableDamping===!0?scope.target.addScaledVector(panOffset,scope.dampingFactor):scope.target.add(panOffset),scope.zoomToCursor&&performCursorZoom||scope.object.isOrthographicCamera?spherical.radius=clampDistance(spherical.radius):spherical.radius=clampDistance(spherical.radius*scale2),offset.setFromSpherical(spherical),offset.applyQuaternion(quatInverse),position.copy(scope.target).add(offset),scope.object.lookAt(scope.target),scope.enableDamping===!0?(sphericalDelta.theta*=1-scope.dampingFactor,sphericalDelta.phi*=1-scope.dampingFactor,panOffset.multiplyScalar(1-scope.dampingFactor)):(sphericalDelta.set(0,0,0),panOffset.set(0,0,0));let zoomChanged=!1;if(scope.zoomToCursor&&performCursorZoom){let newRadius=null;if(scope.object instanceof PerspectiveCamera$1&&scope.object.isPerspectiveCamera){const prevRadius=offset.length();newRadius=clampDistance(prevRadius*scale2);const radiusDelta=prevRadius-newRadius;scope.object.position.addScaledVector(dollyDirection,radiusDelta),scope.object.updateMatrixWorld()}else if(scope.object.isOrthographicCamera){const mouseBefore=new Vector3(mouse.x,mouse.y,0);mouseBefore.unproject(scope.object),scope.object.zoom=Math.max(scope.minZoom,Math.min(scope.maxZoom,scope.object.zoom/scale2)),scope.object.updateProjectionMatrix(),zoomChanged=!0;const mouseAfter=new Vector3(mouse.x,mouse.y,0);mouseAfter.unproject(scope.object),scope.object.position.sub(mouseAfter).add(mouseBefore),scope.object.updateMatrixWorld(),newRadius=offset.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),scope.zoomToCursor=!1;newRadius!==null&&(scope.screenSpacePanning?scope.target.set(0,0,-1).transformDirection(scope.object.matrix).multiplyScalar(newRadius).add(scope.object.position):(_ray.origin.copy(scope.object.position),_ray.direction.set(0,0,-1).transformDirection(scope.object.matrix),Math.abs(scope.object.up.dot(_ray.direction))<TILT_LIMIT?object.lookAt(scope.target):(_plane.setFromNormalAndCoplanarPoint(scope.object.up,scope.target),_ray.intersectPlane(_plane,scope.target))))}else scope.object instanceof OrthographicCamera&&scope.object.isOrthographicCamera&&(scope.object.zoom=Math.max(scope.minZoom,Math.min(scope.maxZoom,scope.object.zoom/scale2)),scope.object.updateProjectionMatrix(),zoomChanged=!0);return scale2=1,performCursorZoom=!1,zoomChanged||lastPosition.distanceToSquared(scope.object.position)>EPS||8*(1-lastQuaternion.dot(scope.object.quaternion))>EPS?(scope.dispatchEvent(changeEvent),lastPosition.copy(scope.object.position),lastQuaternion.copy(scope.object.quaternion),zoomChanged=!1,!0):!1}})(),this.connect=domElement2=>{domElement2===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),scope.domElement=domElement2,scope.domElement.style.touchAction="none",scope.domElement.addEventListener("contextmenu",onContextMenu),scope.domElement.addEventListener("pointerdown",onPointerDown),scope.domElement.addEventListener("pointercancel",onPointerCancel),scope.domElement.addEventListener("wheel",onMouseWheel)},this.dispose=()=>{var _a2,_b2,_c,_d,_e,_f;(_a2=scope.domElement)==null||_a2.removeEventListener("contextmenu",onContextMenu),(_b2=scope.domElement)==null||_b2.removeEventListener("pointerdown",onPointerDown),(_c=scope.domElement)==null||_c.removeEventListener("pointercancel",onPointerCancel),(_d=scope.domElement)==null||_d.removeEventListener("wheel",onMouseWheel),(_e=scope.domElement)==null||_e.ownerDocument.removeEventListener("pointermove",onPointerMove),(_f=scope.domElement)==null||_f.ownerDocument.removeEventListener("pointerup",onPointerUp),scope._domElementKeyEvents!==null&&scope._domElementKeyEvents.removeEventListener("keydown",onKeyDown)};const scope=this,changeEvent={type:"change"},startEvent={type:"start"},endEvent={type:"end"},STATE={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let state=STATE.NONE;const EPS=1e-6,spherical=new Spherical,sphericalDelta=new Spherical;let scale2=1;const panOffset=new Vector3,rotateStart=new Vector2,rotateEnd=new Vector2,rotateDelta=new Vector2,panStart=new Vector2,panEnd=new Vector2,panDelta=new Vector2,dollyStart=new Vector2,dollyEnd=new Vector2,dollyDelta=new Vector2,dollyDirection=new Vector3,mouse=new Vector2;let performCursorZoom=!1;const pointers=[],pointerPositions={};function getAutoRotationAngle(){return 2*Math.PI/60/60*scope.autoRotateSpeed}function getZoomScale(){return Math.pow(.95,scope.zoomSpeed)}function rotateLeft(angle){scope.reverseOrbit||scope.reverseHorizontalOrbit?sphericalDelta.theta+=angle:sphericalDelta.theta-=angle}function rotateUp(angle){scope.reverseOrbit||scope.reverseVerticalOrbit?sphericalDelta.phi+=angle:sphericalDelta.phi-=angle}const panLeft=(()=>{const v4=new Vector3;return function(distance2,objectMatrix){v4.setFromMatrixColumn(objectMatrix,0),v4.multiplyScalar(-distance2),panOffset.add(v4)}})(),panUp=(()=>{const v4=new Vector3;return function(distance2,objectMatrix){scope.screenSpacePanning===!0?v4.setFromMatrixColumn(objectMatrix,1):(v4.setFromMatrixColumn(objectMatrix,0),v4.crossVectors(scope.object.up,v4)),v4.multiplyScalar(distance2),panOffset.add(v4)}})(),pan=(()=>{const offset=new Vector3;return function(deltaX,deltaY){const element=scope.domElement;if(element&&scope.object instanceof PerspectiveCamera$1&&scope.object.isPerspectiveCamera){const position=scope.object.position;offset.copy(position).sub(scope.target);let targetDistance=offset.length();targetDistance*=Math.tan(scope.object.fov/2*Math.PI/180),panLeft(2*deltaX*targetDistance/element.clientHeight,scope.object.matrix),panUp(2*deltaY*targetDistance/element.clientHeight,scope.object.matrix)}else element&&scope.object instanceof OrthographicCamera&&scope.object.isOrthographicCamera?(panLeft(deltaX*(scope.object.right-scope.object.left)/scope.object.zoom/element.clientWidth,scope.object.matrix),panUp(deltaY*(scope.object.top-scope.object.bottom)/scope.object.zoom/element.clientHeight,scope.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),scope.enablePan=!1)}})();function dollyOut(dollyScale){scope.object instanceof PerspectiveCamera$1&&scope.object.isPerspectiveCamera||scope.object instanceof OrthographicCamera&&scope.object.isOrthographicCamera?scale2/=dollyScale:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),scope.enableZoom=!1)}function dollyIn(dollyScale){scope.object instanceof PerspectiveCamera$1&&scope.object.isPerspectiveCamera||scope.object instanceof OrthographicCamera&&scope.object.isOrthographicCamera?scale2*=dollyScale:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),scope.enableZoom=!1)}function updateMouseParameters(event){if(!scope.zoomToCursor||!scope.domElement)return;performCursorZoom=!0;const rect=scope.domElement.getBoundingClientRect(),x2=event.clientX-rect.left,y2=event.clientY-rect.top,w2=rect.width,h2=rect.height;mouse.x=x2/w2*2-1,mouse.y=-(y2/h2)*2+1,dollyDirection.set(mouse.x,mouse.y,1).unproject(scope.object).sub(scope.object.position).normalize()}function clampDistance(dist){return Math.max(scope.minDistance,Math.min(scope.maxDistance,dist))}function handleMouseDownRotate(event){rotateStart.set(event.clientX,event.clientY)}function handleMouseDownDolly(event){updateMouseParameters(event),dollyStart.set(event.clientX,event.clientY)}function handleMouseDownPan(event){panStart.set(event.clientX,event.clientY)}function handleMouseMoveRotate(event){rotateEnd.set(event.clientX,event.clientY),rotateDelta.subVectors(rotateEnd,rotateStart).multiplyScalar(scope.rotateSpeed);const element=scope.domElement;element&&(rotateLeft(2*Math.PI*rotateDelta.x/element.clientHeight),rotateUp(2*Math.PI*rotateDelta.y/element.clientHeight)),rotateStart.copy(rotateEnd),scope.update()}function handleMouseMoveDolly(event){dollyEnd.set(event.clientX,event.clientY),dollyDelta.subVectors(dollyEnd,dollyStart),dollyDelta.y>0?dollyOut(getZoomScale()):dollyDelta.y<0&&dollyIn(getZoomScale()),dollyStart.copy(dollyEnd),scope.update()}function handleMouseMovePan(event){panEnd.set(event.clientX,event.clientY),panDelta.subVectors(panEnd,panStart).multiplyScalar(scope.panSpeed),pan(panDelta.x,panDelta.y),panStart.copy(panEnd),scope.update()}function handleMouseWheel(event){updateMouseParameters(event),event.deltaY<0?dollyIn(getZoomScale()):event.deltaY>0&&dollyOut(getZoomScale()),scope.update()}function handleKeyDown(event){let needsUpdate=!1;switch(event.code){case scope.keys.UP:pan(0,scope.keyPanSpeed),needsUpdate=!0;break;case scope.keys.BOTTOM:pan(0,-scope.keyPanSpeed),needsUpdate=!0;break;case scope.keys.LEFT:pan(scope.keyPanSpeed,0),needsUpdate=!0;break;case scope.keys.RIGHT:pan(-scope.keyPanSpeed,0),needsUpdate=!0;break}needsUpdate&&(event.preventDefault(),scope.update())}function handleTouchStartRotate(){if(pointers.length==1)rotateStart.set(pointers[0].pageX,pointers[0].pageY);else{const x2=.5*(pointers[0].pageX+pointers[1].pageX),y2=.5*(pointers[0].pageY+pointers[1].pageY);rotateStart.set(x2,y2)}}function handleTouchStartPan(){if(pointers.length==1)panStart.set(pointers[0].pageX,pointers[0].pageY);else{const x2=.5*(pointers[0].pageX+pointers[1].pageX),y2=.5*(pointers[0].pageY+pointers[1].pageY);panStart.set(x2,y2)}}function handleTouchStartDolly(){const dx=pointers[0].pageX-pointers[1].pageX,dy=pointers[0].pageY-pointers[1].pageY,distance2=Math.sqrt(dx*dx+dy*dy);dollyStart.set(0,distance2)}function handleTouchStartDollyPan(){scope.enableZoom&&handleTouchStartDolly(),scope.enablePan&&handleTouchStartPan()}function handleTouchStartDollyRotate(){scope.enableZoom&&handleTouchStartDolly(),scope.enableRotate&&handleTouchStartRotate()}function handleTouchMoveRotate(event){if(pointers.length==1)rotateEnd.set(event.pageX,event.pageY);else{const position=getSecondPointerPosition(event),x2=.5*(event.pageX+position.x),y2=.5*(event.pageY+position.y);rotateEnd.set(x2,y2)}rotateDelta.subVectors(rotateEnd,rotateStart).multiplyScalar(scope.rotateSpeed);const element=scope.domElement;element&&(rotateLeft(2*Math.PI*rotateDelta.x/element.clientHeight),rotateUp(2*Math.PI*rotateDelta.y/element.clientHeight)),rotateStart.copy(rotateEnd)}function handleTouchMovePan(event){if(pointers.length==1)panEnd.set(event.pageX,event.pageY);else{const position=getSecondPointerPosition(event),x2=.5*(event.pageX+position.x),y2=.5*(event.pageY+position.y);panEnd.set(x2,y2)}panDelta.subVectors(panEnd,panStart).multiplyScalar(scope.panSpeed),pan(panDelta.x,panDelta.y),panStart.copy(panEnd)}function handleTouchMoveDolly(event){const position=getSecondPointerPosition(event),dx=event.pageX-position.x,dy=event.pageY-position.y,distance2=Math.sqrt(dx*dx+dy*dy);dollyEnd.set(0,distance2),dollyDelta.set(0,Math.pow(dollyEnd.y/dollyStart.y,scope.zoomSpeed)),dollyOut(dollyDelta.y),dollyStart.copy(dollyEnd)}function handleTouchMoveDollyPan(event){scope.enableZoom&&handleTouchMoveDolly(event),scope.enablePan&&handleTouchMovePan(event)}function handleTouchMoveDollyRotate(event){scope.enableZoom&&handleTouchMoveDolly(event),scope.enableRotate&&handleTouchMoveRotate(event)}function onPointerDown(event){var _a2,_b2;scope.enabled!==!1&&(pointers.length===0&&((_a2=scope.domElement)==null||_a2.ownerDocument.addEventListener("pointermove",onPointerMove),(_b2=scope.domElement)==null||_b2.ownerDocument.addEventListener("pointerup",onPointerUp)),addPointer(event),event.pointerType==="touch"?onTouchStart(event):onMouseDown(event))}function onPointerMove(event){scope.enabled!==!1&&(event.pointerType==="touch"?onTouchMove(event):onMouseMove(event))}function onPointerUp(event){var _a2,_b2,_c;removePointer(event),pointers.length===0&&((_a2=scope.domElement)==null||_a2.releasePointerCapture(event.pointerId),(_b2=scope.domElement)==null||_b2.ownerDocument.removeEventListener("pointermove",onPointerMove),(_c=scope.domElement)==null||_c.ownerDocument.removeEventListener("pointerup",onPointerUp)),scope.dispatchEvent(endEvent),state=STATE.NONE}function onPointerCancel(event){removePointer(event)}function onMouseDown(event){let mouseAction;switch(event.button){case 0:mouseAction=scope.mouseButtons.LEFT;break;case 1:mouseAction=scope.mouseButtons.MIDDLE;break;case 2:mouseAction=scope.mouseButtons.RIGHT;break;default:mouseAction=-1}switch(mouseAction){case MOUSE.DOLLY:if(scope.enableZoom===!1)return;handleMouseDownDolly(event),state=STATE.DOLLY;break;case MOUSE.ROTATE:if(event.ctrlKey||event.metaKey||event.shiftKey){if(scope.enablePan===!1)return;handleMouseDownPan(event),state=STATE.PAN}else{if(scope.enableRotate===!1)return;handleMouseDownRotate(event),state=STATE.ROTATE}break;case MOUSE.PAN:if(event.ctrlKey||event.metaKey||event.shiftKey){if(scope.enableRotate===!1)return;handleMouseDownRotate(event),state=STATE.ROTATE}else{if(scope.enablePan===!1)return;handleMouseDownPan(event),state=STATE.PAN}break;default:state=STATE.NONE}state!==STATE.NONE&&scope.dispatchEvent(startEvent)}function onMouseMove(event){if(scope.enabled!==!1)switch(state){case STATE.ROTATE:if(scope.enableRotate===!1)return;handleMouseMoveRotate(event);break;case STATE.DOLLY:if(scope.enableZoom===!1)return;handleMouseMoveDolly(event);break;case STATE.PAN:if(scope.enablePan===!1)return;handleMouseMovePan(event);break}}function onMouseWheel(event){scope.enabled===!1||scope.enableZoom===!1||state!==STATE.NONE&&state!==STATE.ROTATE||(event.preventDefault(),scope.dispatchEvent(startEvent),handleMouseWheel(event),scope.dispatchEvent(endEvent))}function onKeyDown(event){scope.enabled===!1||scope.enablePan===!1||handleKeyDown(event)}function onTouchStart(event){switch(trackPointer(event),pointers.length){case 1:switch(scope.touches.ONE){case TOUCH.ROTATE:if(scope.enableRotate===!1)return;handleTouchStartRotate(),state=STATE.TOUCH_ROTATE;break;case TOUCH.PAN:if(scope.enablePan===!1)return;handleTouchStartPan(),state=STATE.TOUCH_PAN;break;default:state=STATE.NONE}break;case 2:switch(scope.touches.TWO){case TOUCH.DOLLY_PAN:if(scope.enableZoom===!1&&scope.enablePan===!1)return;handleTouchStartDollyPan(),state=STATE.TOUCH_DOLLY_PAN;break;case TOUCH.DOLLY_ROTATE:if(scope.enableZoom===!1&&scope.enableRotate===!1)return;handleTouchStartDollyRotate(),state=STATE.TOUCH_DOLLY_ROTATE;break;default:state=STATE.NONE}break;default:state=STATE.NONE}state!==STATE.NONE&&scope.dispatchEvent(startEvent)}function onTouchMove(event){switch(trackPointer(event),state){case STATE.TOUCH_ROTATE:if(scope.enableRotate===!1)return;handleTouchMoveRotate(event),scope.update();break;case STATE.TOUCH_PAN:if(scope.enablePan===!1)return;handleTouchMovePan(event),scope.update();break;case STATE.TOUCH_DOLLY_PAN:if(scope.enableZoom===!1&&scope.enablePan===!1)return;handleTouchMoveDollyPan(event),scope.update();break;case STATE.TOUCH_DOLLY_ROTATE:if(scope.enableZoom===!1&&scope.enableRotate===!1)return;handleTouchMoveDollyRotate(event),scope.update();break;default:state=STATE.NONE}}function onContextMenu(event){scope.enabled!==!1&&event.preventDefault()}function addPointer(event){pointers.push(event)}function removePointer(event){delete pointerPositions[event.pointerId];for(let i2=0;i2<pointers.length;i2++)if(pointers[i2].pointerId==event.pointerId){pointers.splice(i2,1);return}}function trackPointer(event){let position=pointerPositions[event.pointerId];position===void 0&&(position=new Vector2,pointerPositions[event.pointerId]=position),position.set(event.pageX,event.pageY)}function getSecondPointerPosition(event){const pointer=event.pointerId===pointers[0].pointerId?pointers[1]:pointers[0];return pointerPositions[pointer.pointerId]}domElement!==void 0&&this.connect(domElement),this.update()}};class GLTFLoader extends Loader{constructor(manager){super(manager),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(parser){return new GLTFMaterialsClearcoatExtension(parser)}),this.register(function(parser){return new GLTFTextureBasisUExtension(parser)}),this.register(function(parser){return new GLTFTextureWebPExtension(parser)}),this.register(function(parser){return new GLTFTextureAVIFExtension(parser)}),this.register(function(parser){return new GLTFMaterialsSheenExtension(parser)}),this.register(function(parser){return new GLTFMaterialsTransmissionExtension(parser)}),this.register(function(parser){return new GLTFMaterialsVolumeExtension(parser)}),this.register(function(parser){return new GLTFMaterialsIorExtension(parser)}),this.register(function(parser){return new GLTFMaterialsEmissiveStrengthExtension(parser)}),this.register(function(parser){return new GLTFMaterialsSpecularExtension(parser)}),this.register(function(parser){return new GLTFMaterialsIridescenceExtension(parser)}),this.register(function(parser){return new GLTFMaterialsAnisotropyExtension(parser)}),this.register(function(parser){return new GLTFLightsExtension(parser)}),this.register(function(parser){return new GLTFMeshoptCompression(parser)}),this.register(function(parser){return new GLTFMeshGpuInstancing(parser)})}load(url,onLoad,onProgress,onError){const scope=this;let resourcePath;this.resourcePath!==""?resourcePath=this.resourcePath:this.path!==""?resourcePath=this.path:resourcePath=LoaderUtils.extractUrlBase(url),this.manager.itemStart(url);const _onError=function(e2){onError?onError(e2):console.error(e2),scope.manager.itemError(url),scope.manager.itemEnd(url)},loader=new FileLoader(this.manager);loader.setPath(this.path),loader.setResponseType("arraybuffer"),loader.setRequestHeader(this.requestHeader),loader.setWithCredentials(this.withCredentials),loader.load(url,function(data){try{scope.parse(data,resourcePath,function(gltf){onLoad(gltf),scope.manager.itemEnd(url)},_onError)}catch(e2){_onError(e2)}},onProgress,_onError)}setDRACOLoader(dracoLoader2){return this.dracoLoader=dracoLoader2,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(ktx2Loader){return this.ktx2Loader=ktx2Loader,this}setMeshoptDecoder(meshoptDecoder){return this.meshoptDecoder=meshoptDecoder,this}register(callback){return this.pluginCallbacks.indexOf(callback)===-1&&this.pluginCallbacks.push(callback),this}unregister(callback){return this.pluginCallbacks.indexOf(callback)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback),1),this}parse(data,path2,onLoad,onError){let json;const extensions2={},plugins={};if(typeof data=="string")json=JSON.parse(data);else if(data instanceof ArrayBuffer)if(LoaderUtils.decodeText(new Uint8Array(data.slice(0,4)))===BINARY_EXTENSION_HEADER_MAGIC){try{extensions2[EXTENSIONS.KHR_BINARY_GLTF]=new GLTFBinaryExtension(data)}catch(error){onError&&onError(error);return}json=JSON.parse(extensions2[EXTENSIONS.KHR_BINARY_GLTF].content)}else json=JSON.parse(LoaderUtils.decodeText(new Uint8Array(data)));else json=data;if(json.asset===void 0||json.asset.version[0]<2){onError&&onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const parser=new GLTFParser(json,{path:path2||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});parser.fileLoader.setRequestHeader(this.requestHeader);for(let i2=0;i2<this.pluginCallbacks.length;i2++){const plugin=this.pluginCallbacks[i2](parser);plugins[plugin.name]=plugin,extensions2[plugin.name]=!0}if(json.extensionsUsed)for(let i2=0;i2<json.extensionsUsed.length;++i2){const extensionName=json.extensionsUsed[i2],extensionsRequired=json.extensionsRequired||[];switch(extensionName){case EXTENSIONS.KHR_MATERIALS_UNLIT:extensions2[extensionName]=new GLTFMaterialsUnlitExtension;break;case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:extensions2[extensionName]=new GLTFDracoMeshCompressionExtension(json,this.dracoLoader);break;case EXTENSIONS.KHR_TEXTURE_TRANSFORM:extensions2[extensionName]=new GLTFTextureTransformExtension;break;case EXTENSIONS.KHR_MESH_QUANTIZATION:extensions2[extensionName]=new GLTFMeshQuantizationExtension;break;default:extensionsRequired.indexOf(extensionName)>=0&&plugins[extensionName]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+extensionName+'".')}}parser.setExtensions(extensions2),parser.setPlugins(plugins),parser.parse(onLoad,onError)}parseAsync(data,path2){const scope=this;return new Promise(function(resolve2,reject){scope.parse(data,path2,resolve2,reject)})}}function GLTFRegistry(){let objects={};return{get:function(key){return objects[key]},add:function(key,object){objects[key]=object},remove:function(key){delete objects[key]},removeAll:function(){objects={}}}}const EXTENSIONS={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class GLTFLightsExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const parser=this.parser,nodeDefs=this.parser.json.nodes||[];for(let nodeIndex=0,nodeLength=nodeDefs.length;nodeIndex<nodeLength;nodeIndex++){const nodeDef=nodeDefs[nodeIndex];nodeDef.extensions&&nodeDef.extensions[this.name]&&nodeDef.extensions[this.name].light!==void 0&&parser._addNodeRef(this.cache,nodeDef.extensions[this.name].light)}}_loadLight(lightIndex){const parser=this.parser,cacheKey="light:"+lightIndex;let dependency=parser.cache.get(cacheKey);if(dependency)return dependency;const json=parser.json,lightDef=((json.extensions&&json.extensions[this.name]||{}).lights||[])[lightIndex];let lightNode;const color2=new Color(16777215);lightDef.color!==void 0&&color2.fromArray(lightDef.color);const range=lightDef.range!==void 0?lightDef.range:0;switch(lightDef.type){case"directional":lightNode=new DirectionalLight(color2),lightNode.target.position.set(0,0,-1),lightNode.add(lightNode.target);break;case"point":lightNode=new PointLight(color2),lightNode.distance=range;break;case"spot":lightNode=new SpotLight(color2),lightNode.distance=range,lightDef.spot=lightDef.spot||{},lightDef.spot.innerConeAngle=lightDef.spot.innerConeAngle!==void 0?lightDef.spot.innerConeAngle:0,lightDef.spot.outerConeAngle=lightDef.spot.outerConeAngle!==void 0?lightDef.spot.outerConeAngle:Math.PI/4,lightNode.angle=lightDef.spot.outerConeAngle,lightNode.penumbra=1-lightDef.spot.innerConeAngle/lightDef.spot.outerConeAngle,lightNode.target.position.set(0,0,-1),lightNode.add(lightNode.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+lightDef.type)}return lightNode.position.set(0,0,0),lightNode.decay=2,assignExtrasToUserData(lightNode,lightDef),lightDef.intensity!==void 0&&(lightNode.intensity=lightDef.intensity),lightNode.name=parser.createUniqueName(lightDef.name||"light_"+lightIndex),dependency=Promise.resolve(lightNode),parser.cache.add(cacheKey,dependency),dependency}getDependency(type,index){if(type==="light")return this._loadLight(index)}createNodeAttachment(nodeIndex){const self2=this,parser=this.parser,nodeDef=parser.json.nodes[nodeIndex],lightIndex=(nodeDef.extensions&&nodeDef.extensions[this.name]||{}).light;return lightIndex===void 0?null:this._loadLight(lightIndex).then(function(light){return parser._getNodeRef(self2.cache,lightIndex,light)})}}class GLTFMaterialsUnlitExtension{constructor(){this.name=EXTENSIONS.KHR_MATERIALS_UNLIT}getMaterialType(){return MeshBasicMaterial}extendParams(materialParams,materialDef,parser){const pending=[];materialParams.color=new Color(1,1,1),materialParams.opacity=1;const metallicRoughness=materialDef.pbrMetallicRoughness;if(metallicRoughness){if(Array.isArray(metallicRoughness.baseColorFactor)){const array=metallicRoughness.baseColorFactor;materialParams.color.fromArray(array),materialParams.opacity=array[3]}metallicRoughness.baseColorTexture!==void 0&&pending.push(parser.assignTexture(materialParams,"map",metallicRoughness.baseColorTexture,3001))}return Promise.all(pending)}}class GLTFMaterialsEmissiveStrengthExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(materialIndex,materialParams){const materialDef=this.parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const emissiveStrength=materialDef.extensions[this.name].emissiveStrength;return emissiveStrength!==void 0&&(materialParams.emissiveIntensity=emissiveStrength),Promise.resolve()}}class GLTFMaterialsClearcoatExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_CLEARCOAT}getMaterialType(materialIndex){const materialDef=this.parser.json.materials[materialIndex];return!materialDef.extensions||!materialDef.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(materialIndex,materialParams){const parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const pending=[],extension=materialDef.extensions[this.name];if(extension.clearcoatFactor!==void 0&&(materialParams.clearcoat=extension.clearcoatFactor),extension.clearcoatTexture!==void 0&&pending.push(parser.assignTexture(materialParams,"clearcoatMap",extension.clearcoatTexture)),extension.clearcoatRoughnessFactor!==void 0&&(materialParams.clearcoatRoughness=extension.clearcoatRoughnessFactor),extension.clearcoatRoughnessTexture!==void 0&&pending.push(parser.assignTexture(materialParams,"clearcoatRoughnessMap",extension.clearcoatRoughnessTexture)),extension.clearcoatNormalTexture!==void 0&&(pending.push(parser.assignTexture(materialParams,"clearcoatNormalMap",extension.clearcoatNormalTexture)),extension.clearcoatNormalTexture.scale!==void 0)){const scale2=extension.clearcoatNormalTexture.scale;materialParams.clearcoatNormalScale=new Vector2(scale2,scale2)}return Promise.all(pending)}}class GLTFMaterialsIridescenceExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_IRIDESCENCE}getMaterialType(materialIndex){const materialDef=this.parser.json.materials[materialIndex];return!materialDef.extensions||!materialDef.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(materialIndex,materialParams){const parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const pending=[],extension=materialDef.extensions[this.name];return extension.iridescenceFactor!==void 0&&(materialParams.iridescence=extension.iridescenceFactor),extension.iridescenceTexture!==void 0&&pending.push(parser.assignTexture(materialParams,"iridescenceMap",extension.iridescenceTexture)),extension.iridescenceIor!==void 0&&(materialParams.iridescenceIOR=extension.iridescenceIor),materialParams.iridescenceThicknessRange===void 0&&(materialParams.iridescenceThicknessRange=[100,400]),extension.iridescenceThicknessMinimum!==void 0&&(materialParams.iridescenceThicknessRange[0]=extension.iridescenceThicknessMinimum),extension.iridescenceThicknessMaximum!==void 0&&(materialParams.iridescenceThicknessRange[1]=extension.iridescenceThicknessMaximum),extension.iridescenceThicknessTexture!==void 0&&pending.push(parser.assignTexture(materialParams,"iridescenceThicknessMap",extension.iridescenceThicknessTexture)),Promise.all(pending)}}class GLTFMaterialsSheenExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_SHEEN}getMaterialType(materialIndex){const materialDef=this.parser.json.materials[materialIndex];return!materialDef.extensions||!materialDef.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(materialIndex,materialParams){const parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const pending=[];materialParams.sheenColor=new Color(0,0,0),materialParams.sheenRoughness=0,materialParams.sheen=1;const extension=materialDef.extensions[this.name];return extension.sheenColorFactor!==void 0&&materialParams.sheenColor.fromArray(extension.sheenColorFactor),extension.sheenRoughnessFactor!==void 0&&(materialParams.sheenRoughness=extension.sheenRoughnessFactor),extension.sheenColorTexture!==void 0&&pending.push(parser.assignTexture(materialParams,"sheenColorMap",extension.sheenColorTexture,3001)),extension.sheenRoughnessTexture!==void 0&&pending.push(parser.assignTexture(materialParams,"sheenRoughnessMap",extension.sheenRoughnessTexture)),Promise.all(pending)}}class GLTFMaterialsTransmissionExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_TRANSMISSION}getMaterialType(materialIndex){const materialDef=this.parser.json.materials[materialIndex];return!materialDef.extensions||!materialDef.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(materialIndex,materialParams){const parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const pending=[],extension=materialDef.extensions[this.name];return extension.transmissionFactor!==void 0&&(materialParams.transmission=extension.transmissionFactor),extension.transmissionTexture!==void 0&&pending.push(parser.assignTexture(materialParams,"transmissionMap",extension.transmissionTexture)),Promise.all(pending)}}class GLTFMaterialsVolumeExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_VOLUME}getMaterialType(materialIndex){const materialDef=this.parser.json.materials[materialIndex];return!materialDef.extensions||!materialDef.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(materialIndex,materialParams){const parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const pending=[],extension=materialDef.extensions[this.name];materialParams.thickness=extension.thicknessFactor!==void 0?extension.thicknessFactor:0,extension.thicknessTexture!==void 0&&pending.push(parser.assignTexture(materialParams,"thicknessMap",extension.thicknessTexture)),materialParams.attenuationDistance=extension.attenuationDistance||1/0;const colorArray=extension.attenuationColor||[1,1,1];return materialParams.attenuationColor=new Color(colorArray[0],colorArray[1],colorArray[2]),Promise.all(pending)}}class GLTFMaterialsIorExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_IOR}getMaterialType(materialIndex){const materialDef=this.parser.json.materials[materialIndex];return!materialDef.extensions||!materialDef.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(materialIndex,materialParams){const materialDef=this.parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const extension=materialDef.extensions[this.name];return materialParams.ior=extension.ior!==void 0?extension.ior:1.5,Promise.resolve()}}class GLTFMaterialsSpecularExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_SPECULAR}getMaterialType(materialIndex){const materialDef=this.parser.json.materials[materialIndex];return!materialDef.extensions||!materialDef.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(materialIndex,materialParams){const parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const pending=[],extension=materialDef.extensions[this.name];materialParams.specularIntensity=extension.specularFactor!==void 0?extension.specularFactor:1,extension.specularTexture!==void 0&&pending.push(parser.assignTexture(materialParams,"specularIntensityMap",extension.specularTexture));const colorArray=extension.specularColorFactor||[1,1,1];return materialParams.specularColor=new Color(colorArray[0],colorArray[1],colorArray[2]),extension.specularColorTexture!==void 0&&pending.push(parser.assignTexture(materialParams,"specularColorMap",extension.specularColorTexture,3001)),Promise.all(pending)}}class GLTFMaterialsAnisotropyExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_MATERIALS_ANISOTROPY}getMaterialType(materialIndex){const materialDef=this.parser.json.materials[materialIndex];return!materialDef.extensions||!materialDef.extensions[this.name]?null:MeshPhysicalMaterial}extendMaterialParams(materialIndex,materialParams){const parser=this.parser,materialDef=parser.json.materials[materialIndex];if(!materialDef.extensions||!materialDef.extensions[this.name])return Promise.resolve();const pending=[],extension=materialDef.extensions[this.name];return extension.anisotropyStrength!==void 0&&(materialParams.anisotropy=extension.anisotropyStrength),extension.anisotropyRotation!==void 0&&(materialParams.anisotropyRotation=extension.anisotropyRotation),extension.anisotropyTexture!==void 0&&pending.push(parser.assignTexture(materialParams,"anisotropyMap",extension.anisotropyTexture)),Promise.all(pending)}}class GLTFTextureBasisUExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.KHR_TEXTURE_BASISU}loadTexture(textureIndex){const parser=this.parser,json=parser.json,textureDef=json.textures[textureIndex];if(!textureDef.extensions||!textureDef.extensions[this.name])return null;const extension=textureDef.extensions[this.name],loader=parser.options.ktx2Loader;if(!loader){if(json.extensionsRequired&&json.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return parser.loadTextureImage(textureIndex,extension.source,loader)}}class GLTFTextureWebPExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(textureIndex){const name=this.name,parser=this.parser,json=parser.json,textureDef=json.textures[textureIndex];if(!textureDef.extensions||!textureDef.extensions[name])return null;const extension=textureDef.extensions[name],source=json.images[extension.source];let loader=parser.textureLoader;if(source.uri){const handler=parser.options.manager.getHandler(source.uri);handler!==null&&(loader=handler)}return this.detectSupport().then(function(isSupported){if(isSupported)return parser.loadTextureImage(textureIndex,extension.source,loader);if(json.extensionsRequired&&json.extensionsRequired.indexOf(name)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return parser.loadTexture(textureIndex)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(resolve2){const image=new Image;image.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",image.onload=image.onerror=function(){resolve2(image.height===1)}})),this.isSupported}}class GLTFTextureAVIFExtension{constructor(parser){this.parser=parser,this.name=EXTENSIONS.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(textureIndex){const name=this.name,parser=this.parser,json=parser.json,textureDef=json.textures[textureIndex];if(!textureDef.extensions||!textureDef.extensions[name])return null;const extension=textureDef.extensions[name],source=json.images[extension.source];let loader=parser.textureLoader;if(source.uri){const handler=parser.options.manager.getHandler(source.uri);handler!==null&&(loader=handler)}return this.detectSupport().then(function(isSupported){if(isSupported)return parser.loadTextureImage(textureIndex,extension.source,loader);if(json.extensionsRequired&&json.extensionsRequired.indexOf(name)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return parser.loadTexture(textureIndex)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(resolve2){const image=new Image;image.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",image.onload=image.onerror=function(){resolve2(image.height===1)}})),this.isSupported}}class GLTFMeshoptCompression{constructor(parser){this.name=EXTENSIONS.EXT_MESHOPT_COMPRESSION,this.parser=parser}loadBufferView(index){const json=this.parser.json,bufferView=json.bufferViews[index];if(bufferView.extensions&&bufferView.extensions[this.name]){const extensionDef=bufferView.extensions[this.name],buffer=this.parser.getDependency("buffer",extensionDef.buffer),decoder=this.parser.options.meshoptDecoder;if(!decoder||!decoder.supported){if(json.extensionsRequired&&json.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return buffer.then(function(res){const byteOffset=extensionDef.byteOffset||0,byteLength=extensionDef.byteLength||0,count=extensionDef.count,stride=extensionDef.byteStride,source=new Uint8Array(res,byteOffset,byteLength);return decoder.decodeGltfBufferAsync?decoder.decodeGltfBufferAsync(count,stride,source,extensionDef.mode,extensionDef.filter).then(function(res2){return res2.buffer}):decoder.ready.then(function(){const result=new ArrayBuffer(count*stride);return decoder.decodeGltfBuffer(new Uint8Array(result),count,stride,source,extensionDef.mode,extensionDef.filter),result})})}else return null}}class GLTFMeshGpuInstancing{constructor(parser){this.name=EXTENSIONS.EXT_MESH_GPU_INSTANCING,this.parser=parser}createNodeMesh(nodeIndex){const json=this.parser.json,nodeDef=json.nodes[nodeIndex];if(!nodeDef.extensions||!nodeDef.extensions[this.name]||nodeDef.mesh===void 0)return null;const meshDef=json.meshes[nodeDef.mesh];for(const primitive of meshDef.primitives)if(primitive.mode!==WEBGL_CONSTANTS.TRIANGLES&&primitive.mode!==WEBGL_CONSTANTS.TRIANGLE_STRIP&&primitive.mode!==WEBGL_CONSTANTS.TRIANGLE_FAN&&primitive.mode!==void 0)return null;const attributesDef=nodeDef.extensions[this.name].attributes,pending=[],attributes={};for(const key in attributesDef)pending.push(this.parser.getDependency("accessor",attributesDef[key]).then(accessor=>(attributes[key]=accessor,attributes[key])));return pending.length<1?null:(pending.push(this.parser.createNodeMesh(nodeIndex)),Promise.all(pending).then(results=>{const nodeObject=results.pop(),meshes=nodeObject.isGroup?nodeObject.children:[nodeObject],count=results[0].count,instancedMeshes=[];for(const mesh of meshes){const m2=new Matrix4,p2=new Vector3,q=new Quaternion,s2=new Vector3(1,1,1),instancedMesh=new InstancedMesh(mesh.geometry,mesh.material,count);for(let i2=0;i2<count;i2++)attributes.TRANSLATION&&p2.fromBufferAttribute(attributes.TRANSLATION,i2),attributes.ROTATION&&q.fromBufferAttribute(attributes.ROTATION,i2),attributes.SCALE&&s2.fromBufferAttribute(attributes.SCALE,i2),instancedMesh.setMatrixAt(i2,m2.compose(p2,q,s2));for(const attributeName in attributes)attributeName!=="TRANSLATION"&&attributeName!=="ROTATION"&&attributeName!=="SCALE"&&mesh.geometry.setAttribute(attributeName,attributes[attributeName]);Object3D.prototype.copy.call(instancedMesh,mesh),this.parser.assignFinalMaterial(instancedMesh),instancedMeshes.push(instancedMesh)}return nodeObject.isGroup?(nodeObject.clear(),nodeObject.add(...instancedMeshes),nodeObject):instancedMeshes[0]}))}}const BINARY_EXTENSION_HEADER_MAGIC="glTF",BINARY_EXTENSION_HEADER_LENGTH=12,BINARY_EXTENSION_CHUNK_TYPES={JSON:1313821514,BIN:5130562};class GLTFBinaryExtension{constructor(data){this.name=EXTENSIONS.KHR_BINARY_GLTF,this.content=null,this.body=null;const headerView=new DataView(data,0,BINARY_EXTENSION_HEADER_LENGTH);if(this.header={magic:LoaderUtils.decodeText(new Uint8Array(data.slice(0,4))),version:headerView.getUint32(4,!0),length:headerView.getUint32(8,!0)},this.header.magic!==BINARY_EXTENSION_HEADER_MAGIC)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const chunkContentsLength=this.header.length-BINARY_EXTENSION_HEADER_LENGTH,chunkView=new DataView(data,BINARY_EXTENSION_HEADER_LENGTH);let chunkIndex=0;for(;chunkIndex<chunkContentsLength;){const chunkLength=chunkView.getUint32(chunkIndex,!0);chunkIndex+=4;const chunkType=chunkView.getUint32(chunkIndex,!0);if(chunkIndex+=4,chunkType===BINARY_EXTENSION_CHUNK_TYPES.JSON){const contentArray=new Uint8Array(data,BINARY_EXTENSION_HEADER_LENGTH+chunkIndex,chunkLength);this.content=LoaderUtils.decodeText(contentArray)}else if(chunkType===BINARY_EXTENSION_CHUNK_TYPES.BIN){const byteOffset=BINARY_EXTENSION_HEADER_LENGTH+chunkIndex;this.body=data.slice(byteOffset,byteOffset+chunkLength)}chunkIndex+=chunkLength}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class GLTFDracoMeshCompressionExtension{constructor(json,dracoLoader2){if(!dracoLoader2)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=EXTENSIONS.KHR_DRACO_MESH_COMPRESSION,this.json=json,this.dracoLoader=dracoLoader2,this.dracoLoader.preload()}decodePrimitive(primitive,parser){const json=this.json,dracoLoader2=this.dracoLoader,bufferViewIndex=primitive.extensions[this.name].bufferView,gltfAttributeMap=primitive.extensions[this.name].attributes,threeAttributeMap={},attributeNormalizedMap={},attributeTypeMap={};for(const attributeName in gltfAttributeMap){const threeAttributeName=ATTRIBUTES[attributeName]||attributeName.toLowerCase();threeAttributeMap[threeAttributeName]=gltfAttributeMap[attributeName]}for(const attributeName in primitive.attributes){const threeAttributeName=ATTRIBUTES[attributeName]||attributeName.toLowerCase();if(gltfAttributeMap[attributeName]!==void 0){const accessorDef=json.accessors[primitive.attributes[attributeName]],componentType=WEBGL_COMPONENT_TYPES[accessorDef.componentType];attributeTypeMap[threeAttributeName]=componentType.name,attributeNormalizedMap[threeAttributeName]=accessorDef.normalized===!0}}return parser.getDependency("bufferView",bufferViewIndex).then(function(bufferView){return new Promise(function(resolve2){dracoLoader2.decodeDracoFile(bufferView,function(geometry){for(const attributeName in geometry.attributes){const attribute=geometry.attributes[attributeName],normalized=attributeNormalizedMap[attributeName];normalized!==void 0&&(attribute.normalized=normalized)}resolve2(geometry)},threeAttributeMap,attributeTypeMap)})})}}class GLTFTextureTransformExtension{constructor(){this.name=EXTENSIONS.KHR_TEXTURE_TRANSFORM}extendTexture(texture,transform){return(transform.texCoord===void 0||transform.texCoord===texture.channel)&&transform.offset===void 0&&transform.rotation===void 0&&transform.scale===void 0||(texture=texture.clone(),transform.texCoord!==void 0&&(texture.channel=transform.texCoord),transform.offset!==void 0&&texture.offset.fromArray(transform.offset),transform.rotation!==void 0&&(texture.rotation=transform.rotation),transform.scale!==void 0&&texture.repeat.fromArray(transform.scale),texture.needsUpdate=!0),texture}}class GLTFMeshQuantizationExtension{constructor(){this.name=EXTENSIONS.KHR_MESH_QUANTIZATION}}class GLTFCubicSplineInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer)}copySampleValue_(index){const result=this.resultBuffer,values=this.sampleValues,valueSize=this.valueSize,offset=index*valueSize*3+valueSize;for(let i2=0;i2!==valueSize;i2++)result[i2]=values[offset+i2];return result}interpolate_(i1,t0,t2,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,stride2=stride*2,stride3=stride*3,td2=t1-t0,p2=(t2-t0)/td2,pp=p2*p2,ppp=pp*p2,offset1=i1*stride3,offset0=offset1-stride3,s2=-2*ppp+3*pp,s3=ppp-pp,s0=1-s2,s1=s3-pp+p2;for(let i2=0;i2!==stride;i2++){const p0=values[offset0+i2+stride],m0=values[offset0+i2+stride2]*td2,p1=values[offset1+i2+stride],m1=values[offset1+i2]*td2;result[i2]=s0*p0+s1*m0+s2*p1+s3*m1}return result}}const _q=new Quaternion;class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant{interpolate_(i1,t0,t2,t1){const result=super.interpolate_(i1,t0,t2,t1);return _q.fromArray(result).normalize().toArray(result),result}}const WEBGL_CONSTANTS={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},WEBGL_COMPONENT_TYPES={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},WEBGL_FILTERS={9728:NearestFilter,9729:LinearFilter,9984:NearestMipmapNearestFilter,9985:LinearMipmapNearestFilter,9986:NearestMipmapLinearFilter,9987:LinearMipmapLinearFilter},WEBGL_WRAPPINGS={33071:ClampToEdgeWrapping,33648:MirroredRepeatWrapping,10497:RepeatWrapping},WEBGL_TYPE_SIZES={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ATTRIBUTES={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",...version>=152?{TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3"}:{TEXCOORD_0:"uv",TEXCOORD_1:"uv2"},COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},PATH_PROPERTIES={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},INTERPOLATION={CUBICSPLINE:void 0,LINEAR:InterpolateLinear,STEP:InterpolateDiscrete},ALPHA_MODES={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function createDefaultMaterial(cache){return cache.DefaultMaterial===void 0&&(cache.DefaultMaterial=new MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:FrontSide})),cache.DefaultMaterial}function addUnknownExtensionsToUserData(knownExtensions,object,objectDef){for(const name in objectDef.extensions)knownExtensions[name]===void 0&&(object.userData.gltfExtensions=object.userData.gltfExtensions||{},object.userData.gltfExtensions[name]=objectDef.extensions[name])}function assignExtrasToUserData(object,gltfDef){gltfDef.extras!==void 0&&(typeof gltfDef.extras=="object"?Object.assign(object.userData,gltfDef.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+gltfDef.extras))}function addMorphTargets(geometry,targets,parser){let hasMorphPosition=!1,hasMorphNormal=!1,hasMorphColor=!1;for(let i2=0,il=targets.length;i2<il;i2++){const target=targets[i2];if(target.POSITION!==void 0&&(hasMorphPosition=!0),target.NORMAL!==void 0&&(hasMorphNormal=!0),target.COLOR_0!==void 0&&(hasMorphColor=!0),hasMorphPosition&&hasMorphNormal&&hasMorphColor)break}if(!hasMorphPosition&&!hasMorphNormal&&!hasMorphColor)return Promise.resolve(geometry);const pendingPositionAccessors=[],pendingNormalAccessors=[],pendingColorAccessors=[];for(let i2=0,il=targets.length;i2<il;i2++){const target=targets[i2];if(hasMorphPosition){const pendingAccessor=target.POSITION!==void 0?parser.getDependency("accessor",target.POSITION):geometry.attributes.position;pendingPositionAccessors.push(pendingAccessor)}if(hasMorphNormal){const pendingAccessor=target.NORMAL!==void 0?parser.getDependency("accessor",target.NORMAL):geometry.attributes.normal;pendingNormalAccessors.push(pendingAccessor)}if(hasMorphColor){const pendingAccessor=target.COLOR_0!==void 0?parser.getDependency("accessor",target.COLOR_0):geometry.attributes.color;pendingColorAccessors.push(pendingAccessor)}}return Promise.all([Promise.all(pendingPositionAccessors),Promise.all(pendingNormalAccessors),Promise.all(pendingColorAccessors)]).then(function(accessors){const morphPositions=accessors[0],morphNormals=accessors[1],morphColors=accessors[2];return hasMorphPosition&&(geometry.morphAttributes.position=morphPositions),hasMorphNormal&&(geometry.morphAttributes.normal=morphNormals),hasMorphColor&&(geometry.morphAttributes.color=morphColors),geometry.morphTargetsRelative=!0,geometry})}function updateMorphTargets(mesh,meshDef){if(mesh.updateMorphTargets(),meshDef.weights!==void 0)for(let i2=0,il=meshDef.weights.length;i2<il;i2++)mesh.morphTargetInfluences[i2]=meshDef.weights[i2];if(meshDef.extras&&Array.isArray(meshDef.extras.targetNames)){const targetNames=meshDef.extras.targetNames;if(mesh.morphTargetInfluences.length===targetNames.length){mesh.morphTargetDictionary={};for(let i2=0,il=targetNames.length;i2<il;i2++)mesh.morphTargetDictionary[targetNames[i2]]=i2}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function createPrimitiveKey(primitiveDef){let geometryKey;const dracoExtension=primitiveDef.extensions&&primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];if(dracoExtension?geometryKey="draco:"+dracoExtension.bufferView+":"+dracoExtension.indices+":"+createAttributesKey(dracoExtension.attributes):geometryKey=primitiveDef.indices+":"+createAttributesKey(primitiveDef.attributes)+":"+primitiveDef.mode,primitiveDef.targets!==void 0)for(let i2=0,il=primitiveDef.targets.length;i2<il;i2++)geometryKey+=":"+createAttributesKey(primitiveDef.targets[i2]);return geometryKey}function createAttributesKey(attributes){let attributesKey="";const keys2=Object.keys(attributes).sort();for(let i2=0,il=keys2.length;i2<il;i2++)attributesKey+=keys2[i2]+":"+attributes[keys2[i2]]+";";return attributesKey}function getNormalizedComponentScale(constructor){switch(constructor){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function getImageURIMimeType(uri){return uri.search(/\.jpe?g($|\?)/i)>0||uri.search(/^data\:image\/jpeg/)===0?"image/jpeg":uri.search(/\.webp($|\?)/i)>0||uri.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const _identityMatrix=new Matrix4;class GLTFParser{constructor(json={},options={}){this.json=json,this.extensions={},this.plugins={},this.options=options,this.cache=new GLTFRegistry,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let isSafari=!1,isFirefox=!1,firefoxVersion=-1;typeof navigator<"u"&&typeof navigator.userAgent<"u"&&(isSafari=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,isFirefox=navigator.userAgent.indexOf("Firefox")>-1,firefoxVersion=isFirefox?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||isSafari||isFirefox&&firefoxVersion<98?this.textureLoader=new TextureLoader(this.options.manager):this.textureLoader=new ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(extensions2){this.extensions=extensions2}setPlugins(plugins){this.plugins=plugins}parse(onLoad,onError){const parser=this,json=this.json,extensions2=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(ext){return ext._markDefs&&ext._markDefs()}),Promise.all(this._invokeAll(function(ext){return ext.beforeRoot&&ext.beforeRoot()})).then(function(){return Promise.all([parser.getDependencies("scene"),parser.getDependencies("animation"),parser.getDependencies("camera")])}).then(function(dependencies){const result={scene:dependencies[0][json.scene||0],scenes:dependencies[0],animations:dependencies[1],cameras:dependencies[2],asset:json.asset,parser,userData:{}};addUnknownExtensionsToUserData(extensions2,result,json),assignExtrasToUserData(result,json),Promise.all(parser._invokeAll(function(ext){return ext.afterRoot&&ext.afterRoot(result)})).then(function(){onLoad(result)})}).catch(onError)}_markDefs(){const nodeDefs=this.json.nodes||[],skinDefs=this.json.skins||[],meshDefs=this.json.meshes||[];for(let skinIndex=0,skinLength=skinDefs.length;skinIndex<skinLength;skinIndex++){const joints=skinDefs[skinIndex].joints;for(let i2=0,il=joints.length;i2<il;i2++)nodeDefs[joints[i2]].isBone=!0}for(let nodeIndex=0,nodeLength=nodeDefs.length;nodeIndex<nodeLength;nodeIndex++){const nodeDef=nodeDefs[nodeIndex];nodeDef.mesh!==void 0&&(this._addNodeRef(this.meshCache,nodeDef.mesh),nodeDef.skin!==void 0&&(meshDefs[nodeDef.mesh].isSkinnedMesh=!0)),nodeDef.camera!==void 0&&this._addNodeRef(this.cameraCache,nodeDef.camera)}}_addNodeRef(cache,index){index!==void 0&&(cache.refs[index]===void 0&&(cache.refs[index]=cache.uses[index]=0),cache.refs[index]++)}_getNodeRef(cache,index,object){if(cache.refs[index]<=1)return object;const ref=object.clone(),updateMappings=(original,clone)=>{const mappings=this.associations.get(original);mappings!=null&&this.associations.set(clone,mappings);for(const[i2,child]of original.children.entries())updateMappings(child,clone.children[i2])};return updateMappings(object,ref),ref.name+="_instance_"+cache.uses[index]++,ref}_invokeOne(func){const extensions2=Object.values(this.plugins);extensions2.push(this);for(let i2=0;i2<extensions2.length;i2++){const result=func(extensions2[i2]);if(result)return result}return null}_invokeAll(func){const extensions2=Object.values(this.plugins);extensions2.unshift(this);const pending=[];for(let i2=0;i2<extensions2.length;i2++){const result=func(extensions2[i2]);result&&pending.push(result)}return pending}getDependency(type,index){const cacheKey=type+":"+index;let dependency=this.cache.get(cacheKey);if(!dependency){switch(type){case"scene":dependency=this.loadScene(index);break;case"node":dependency=this._invokeOne(function(ext){return ext.loadNode&&ext.loadNode(index)});break;case"mesh":dependency=this._invokeOne(function(ext){return ext.loadMesh&&ext.loadMesh(index)});break;case"accessor":dependency=this.loadAccessor(index);break;case"bufferView":dependency=this._invokeOne(function(ext){return ext.loadBufferView&&ext.loadBufferView(index)});break;case"buffer":dependency=this.loadBuffer(index);break;case"material":dependency=this._invokeOne(function(ext){return ext.loadMaterial&&ext.loadMaterial(index)});break;case"texture":dependency=this._invokeOne(function(ext){return ext.loadTexture&&ext.loadTexture(index)});break;case"skin":dependency=this.loadSkin(index);break;case"animation":dependency=this._invokeOne(function(ext){return ext.loadAnimation&&ext.loadAnimation(index)});break;case"camera":dependency=this.loadCamera(index);break;default:if(dependency=this._invokeOne(function(ext){return ext!=this&&ext.getDependency&&ext.getDependency(type,index)}),!dependency)throw new Error("Unknown type: "+type);break}this.cache.add(cacheKey,dependency)}return dependency}getDependencies(type){let dependencies=this.cache.get(type);if(!dependencies){const parser=this,defs=this.json[type+(type==="mesh"?"es":"s")]||[];dependencies=Promise.all(defs.map(function(def,index){return parser.getDependency(type,index)})),this.cache.add(type,dependencies)}return dependencies}loadBuffer(bufferIndex){const bufferDef=this.json.buffers[bufferIndex],loader=this.fileLoader;if(bufferDef.type&&bufferDef.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+bufferDef.type+" buffer type is not supported.");if(bufferDef.uri===void 0&&bufferIndex===0)return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);const options=this.options;return new Promise(function(resolve2,reject){loader.load(LoaderUtils.resolveURL(bufferDef.uri,options.path),resolve2,void 0,function(){reject(new Error('THREE.GLTFLoader: Failed to load buffer "'+bufferDef.uri+'".'))})})}loadBufferView(bufferViewIndex){const bufferViewDef=this.json.bufferViews[bufferViewIndex];return this.getDependency("buffer",bufferViewDef.buffer).then(function(buffer){const byteLength=bufferViewDef.byteLength||0,byteOffset=bufferViewDef.byteOffset||0;return buffer.slice(byteOffset,byteOffset+byteLength)})}loadAccessor(accessorIndex){const parser=this,json=this.json,accessorDef=this.json.accessors[accessorIndex];if(accessorDef.bufferView===void 0&&accessorDef.sparse===void 0){const itemSize=WEBGL_TYPE_SIZES[accessorDef.type],TypedArray=WEBGL_COMPONENT_TYPES[accessorDef.componentType],normalized=accessorDef.normalized===!0,array=new TypedArray(accessorDef.count*itemSize);return Promise.resolve(new BufferAttribute(array,itemSize,normalized))}const pendingBufferViews=[];return accessorDef.bufferView!==void 0?pendingBufferViews.push(this.getDependency("bufferView",accessorDef.bufferView)):pendingBufferViews.push(null),accessorDef.sparse!==void 0&&(pendingBufferViews.push(this.getDependency("bufferView",accessorDef.sparse.indices.bufferView)),pendingBufferViews.push(this.getDependency("bufferView",accessorDef.sparse.values.bufferView))),Promise.all(pendingBufferViews).then(function(bufferViews){const bufferView=bufferViews[0],itemSize=WEBGL_TYPE_SIZES[accessorDef.type],TypedArray=WEBGL_COMPONENT_TYPES[accessorDef.componentType],elementBytes=TypedArray.BYTES_PER_ELEMENT,itemBytes=elementBytes*itemSize,byteOffset=accessorDef.byteOffset||0,byteStride=accessorDef.bufferView!==void 0?json.bufferViews[accessorDef.bufferView].byteStride:void 0,normalized=accessorDef.normalized===!0;let array,bufferAttribute;if(byteStride&&byteStride!==itemBytes){const ibSlice=Math.floor(byteOffset/byteStride),ibCacheKey="InterleavedBuffer:"+accessorDef.bufferView+":"+accessorDef.componentType+":"+ibSlice+":"+accessorDef.count;let ib=parser.cache.get(ibCacheKey);ib||(array=new TypedArray(bufferView,ibSlice*byteStride,accessorDef.count*byteStride/elementBytes),ib=new InterleavedBuffer(array,byteStride/elementBytes),parser.cache.add(ibCacheKey,ib)),bufferAttribute=new InterleavedBufferAttribute(ib,itemSize,byteOffset%byteStride/elementBytes,normalized)}else bufferView===null?array=new TypedArray(accessorDef.count*itemSize):array=new TypedArray(bufferView,byteOffset,accessorDef.count*itemSize),bufferAttribute=new BufferAttribute(array,itemSize,normalized);if(accessorDef.sparse!==void 0){const itemSizeIndices=WEBGL_TYPE_SIZES.SCALAR,TypedArrayIndices=WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType],byteOffsetIndices=accessorDef.sparse.indices.byteOffset||0,byteOffsetValues=accessorDef.sparse.values.byteOffset||0,sparseIndices=new TypedArrayIndices(bufferViews[1],byteOffsetIndices,accessorDef.sparse.count*itemSizeIndices),sparseValues=new TypedArray(bufferViews[2],byteOffsetValues,accessorDef.sparse.count*itemSize);bufferView!==null&&(bufferAttribute=new BufferAttribute(bufferAttribute.array.slice(),bufferAttribute.itemSize,bufferAttribute.normalized));for(let i2=0,il=sparseIndices.length;i2<il;i2++){const index=sparseIndices[i2];if(bufferAttribute.setX(index,sparseValues[i2*itemSize]),itemSize>=2&&bufferAttribute.setY(index,sparseValues[i2*itemSize+1]),itemSize>=3&&bufferAttribute.setZ(index,sparseValues[i2*itemSize+2]),itemSize>=4&&bufferAttribute.setW(index,sparseValues[i2*itemSize+3]),itemSize>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return bufferAttribute})}loadTexture(textureIndex){const json=this.json,options=this.options,sourceIndex=json.textures[textureIndex].source,sourceDef=json.images[sourceIndex];let loader=this.textureLoader;if(sourceDef.uri){const handler=options.manager.getHandler(sourceDef.uri);handler!==null&&(loader=handler)}return this.loadTextureImage(textureIndex,sourceIndex,loader)}loadTextureImage(textureIndex,sourceIndex,loader){const parser=this,json=this.json,textureDef=json.textures[textureIndex],sourceDef=json.images[sourceIndex],cacheKey=(sourceDef.uri||sourceDef.bufferView)+":"+textureDef.sampler;if(this.textureCache[cacheKey])return this.textureCache[cacheKey];const promise=this.loadImageSource(sourceIndex,loader).then(function(texture){texture.flipY=!1,texture.name=textureDef.name||sourceDef.name||"",texture.name===""&&typeof sourceDef.uri=="string"&&sourceDef.uri.startsWith("data:image/")===!1&&(texture.name=sourceDef.uri);const sampler=(json.samplers||{})[textureDef.sampler]||{};return texture.magFilter=WEBGL_FILTERS[sampler.magFilter]||LinearFilter,texture.minFilter=WEBGL_FILTERS[sampler.minFilter]||LinearMipmapLinearFilter,texture.wrapS=WEBGL_WRAPPINGS[sampler.wrapS]||RepeatWrapping,texture.wrapT=WEBGL_WRAPPINGS[sampler.wrapT]||RepeatWrapping,parser.associations.set(texture,{textures:textureIndex}),texture}).catch(function(){return null});return this.textureCache[cacheKey]=promise,promise}loadImageSource(sourceIndex,loader){const parser=this,json=this.json,options=this.options;if(this.sourceCache[sourceIndex]!==void 0)return this.sourceCache[sourceIndex].then(texture=>texture.clone());const sourceDef=json.images[sourceIndex],URL2=self.URL||self.webkitURL;let sourceURI=sourceDef.uri||"",isObjectURL=!1;if(sourceDef.bufferView!==void 0)sourceURI=parser.getDependency("bufferView",sourceDef.bufferView).then(function(bufferView){isObjectURL=!0;const blob=new Blob([bufferView],{type:sourceDef.mimeType});return sourceURI=URL2.createObjectURL(blob),sourceURI});else if(sourceDef.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+sourceIndex+" is missing URI and bufferView");const promise=Promise.resolve(sourceURI).then(function(sourceURI2){return new Promise(function(resolve2,reject){let onLoad=resolve2;loader.isImageBitmapLoader===!0&&(onLoad=function(imageBitmap){const texture=new Texture(imageBitmap);texture.needsUpdate=!0,resolve2(texture)}),loader.load(LoaderUtils.resolveURL(sourceURI2,options.path),onLoad,void 0,reject)})}).then(function(texture){return isObjectURL===!0&&URL2.revokeObjectURL(sourceURI),texture.userData.mimeType=sourceDef.mimeType||getImageURIMimeType(sourceDef.uri),texture}).catch(function(error){throw console.error("THREE.GLTFLoader: Couldn't load texture",sourceURI),error});return this.sourceCache[sourceIndex]=promise,promise}assignTexture(materialParams,mapName,mapDef,encoding){const parser=this;return this.getDependency("texture",mapDef.index).then(function(texture){if(!texture)return null;if(mapDef.texCoord!==void 0&&mapDef.texCoord>0&&(texture=texture.clone(),texture.channel=mapDef.texCoord),parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]){const transform=mapDef.extensions!==void 0?mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]:void 0;if(transform){const gltfReference=parser.associations.get(texture);texture=parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture,transform),parser.associations.set(texture,gltfReference)}}return encoding!==void 0&&("colorSpace"in texture?texture.colorSpace=encoding===3001?"srgb":"srgb-linear":texture.encoding=encoding),materialParams[mapName]=texture,texture})}assignFinalMaterial(mesh){const geometry=mesh.geometry;let material=mesh.material;const useDerivativeTangents=geometry.attributes.tangent===void 0,useVertexColors=geometry.attributes.color!==void 0,useFlatShading=geometry.attributes.normal===void 0;if(mesh.isPoints){const cacheKey="PointsMaterial:"+material.uuid;let pointsMaterial=this.cache.get(cacheKey);pointsMaterial||(pointsMaterial=new PointsMaterial,Material.prototype.copy.call(pointsMaterial,material),pointsMaterial.color.copy(material.color),pointsMaterial.map=material.map,pointsMaterial.sizeAttenuation=!1,this.cache.add(cacheKey,pointsMaterial)),material=pointsMaterial}else if(mesh.isLine){const cacheKey="LineBasicMaterial:"+material.uuid;let lineMaterial=this.cache.get(cacheKey);lineMaterial||(lineMaterial=new LineBasicMaterial,Material.prototype.copy.call(lineMaterial,material),lineMaterial.color.copy(material.color),lineMaterial.map=material.map,this.cache.add(cacheKey,lineMaterial)),material=lineMaterial}if(useDerivativeTangents||useVertexColors||useFlatShading){let cacheKey="ClonedMaterial:"+material.uuid+":";useDerivativeTangents&&(cacheKey+="derivative-tangents:"),useVertexColors&&(cacheKey+="vertex-colors:"),useFlatShading&&(cacheKey+="flat-shading:");let cachedMaterial=this.cache.get(cacheKey);cachedMaterial||(cachedMaterial=material.clone(),useVertexColors&&(cachedMaterial.vertexColors=!0),useFlatShading&&(cachedMaterial.flatShading=!0),useDerivativeTangents&&(cachedMaterial.normalScale&&(cachedMaterial.normalScale.y*=-1),cachedMaterial.clearcoatNormalScale&&(cachedMaterial.clearcoatNormalScale.y*=-1)),this.cache.add(cacheKey,cachedMaterial),this.associations.set(cachedMaterial,this.associations.get(material))),material=cachedMaterial}mesh.material=material}getMaterialType(){return MeshStandardMaterial}loadMaterial(materialIndex){const parser=this,json=this.json,extensions2=this.extensions,materialDef=json.materials[materialIndex];let materialType;const materialParams={},materialExtensions=materialDef.extensions||{},pending=[];if(materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]){const kmuExtension=extensions2[EXTENSIONS.KHR_MATERIALS_UNLIT];materialType=kmuExtension.getMaterialType(),pending.push(kmuExtension.extendParams(materialParams,materialDef,parser))}else{const metallicRoughness=materialDef.pbrMetallicRoughness||{};if(materialParams.color=new Color(1,1,1),materialParams.opacity=1,Array.isArray(metallicRoughness.baseColorFactor)){const array=metallicRoughness.baseColorFactor;materialParams.color.fromArray(array),materialParams.opacity=array[3]}metallicRoughness.baseColorTexture!==void 0&&pending.push(parser.assignTexture(materialParams,"map",metallicRoughness.baseColorTexture,3001)),materialParams.metalness=metallicRoughness.metallicFactor!==void 0?metallicRoughness.metallicFactor:1,materialParams.roughness=metallicRoughness.roughnessFactor!==void 0?metallicRoughness.roughnessFactor:1,metallicRoughness.metallicRoughnessTexture!==void 0&&(pending.push(parser.assignTexture(materialParams,"metalnessMap",metallicRoughness.metallicRoughnessTexture)),pending.push(parser.assignTexture(materialParams,"roughnessMap",metallicRoughness.metallicRoughnessTexture))),materialType=this._invokeOne(function(ext){return ext.getMaterialType&&ext.getMaterialType(materialIndex)}),pending.push(Promise.all(this._invokeAll(function(ext){return ext.extendMaterialParams&&ext.extendMaterialParams(materialIndex,materialParams)})))}materialDef.doubleSided===!0&&(materialParams.side=DoubleSide);const alphaMode=materialDef.alphaMode||ALPHA_MODES.OPAQUE;if(alphaMode===ALPHA_MODES.BLEND?(materialParams.transparent=!0,materialParams.depthWrite=!1):(materialParams.transparent=!1,alphaMode===ALPHA_MODES.MASK&&(materialParams.alphaTest=materialDef.alphaCutoff!==void 0?materialDef.alphaCutoff:.5)),materialDef.normalTexture!==void 0&&materialType!==MeshBasicMaterial&&(pending.push(parser.assignTexture(materialParams,"normalMap",materialDef.normalTexture)),materialParams.normalScale=new Vector2(1,1),materialDef.normalTexture.scale!==void 0)){const scale2=materialDef.normalTexture.scale;materialParams.normalScale.set(scale2,scale2)}return materialDef.occlusionTexture!==void 0&&materialType!==MeshBasicMaterial&&(pending.push(parser.assignTexture(materialParams,"aoMap",materialDef.occlusionTexture)),materialDef.occlusionTexture.strength!==void 0&&(materialParams.aoMapIntensity=materialDef.occlusionTexture.strength)),materialDef.emissiveFactor!==void 0&&materialType!==MeshBasicMaterial&&(materialParams.emissive=new Color().fromArray(materialDef.emissiveFactor)),materialDef.emissiveTexture!==void 0&&materialType!==MeshBasicMaterial&&pending.push(parser.assignTexture(materialParams,"emissiveMap",materialDef.emissiveTexture,3001)),Promise.all(pending).then(function(){const material=new materialType(materialParams);return materialDef.name&&(material.name=materialDef.name),assignExtrasToUserData(material,materialDef),parser.associations.set(material,{materials:materialIndex}),materialDef.extensions&&addUnknownExtensionsToUserData(extensions2,material,materialDef),material})}createUniqueName(originalName){const sanitizedName=PropertyBinding.sanitizeNodeName(originalName||"");return sanitizedName in this.nodeNamesUsed?sanitizedName+"_"+ ++this.nodeNamesUsed[sanitizedName]:(this.nodeNamesUsed[sanitizedName]=0,sanitizedName)}loadGeometries(primitives){const parser=this,extensions2=this.extensions,cache=this.primitiveCache;function createDracoPrimitive(primitive){return extensions2[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive,parser).then(function(geometry){return addPrimitiveAttributes(geometry,primitive,parser)})}const pending=[];for(let i2=0,il=primitives.length;i2<il;i2++){const primitive=primitives[i2],cacheKey=createPrimitiveKey(primitive),cached=cache[cacheKey];if(cached)pending.push(cached.promise);else{let geometryPromise;primitive.extensions&&primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]?geometryPromise=createDracoPrimitive(primitive):geometryPromise=addPrimitiveAttributes(new BufferGeometry,primitive,parser),cache[cacheKey]={primitive,promise:geometryPromise},pending.push(geometryPromise)}}return Promise.all(pending)}loadMesh(meshIndex){const parser=this,json=this.json,extensions2=this.extensions,meshDef=json.meshes[meshIndex],primitives=meshDef.primitives,pending=[];for(let i2=0,il=primitives.length;i2<il;i2++){const material=primitives[i2].material===void 0?createDefaultMaterial(this.cache):this.getDependency("material",primitives[i2].material);pending.push(material)}return pending.push(parser.loadGeometries(primitives)),Promise.all(pending).then(function(results){const materials=results.slice(0,results.length-1),geometries=results[results.length-1],meshes=[];for(let i2=0,il=geometries.length;i2<il;i2++){const geometry=geometries[i2],primitive=primitives[i2];let mesh;const material=materials[i2];if(primitive.mode===WEBGL_CONSTANTS.TRIANGLES||primitive.mode===WEBGL_CONSTANTS.TRIANGLE_STRIP||primitive.mode===WEBGL_CONSTANTS.TRIANGLE_FAN||primitive.mode===void 0)mesh=meshDef.isSkinnedMesh===!0?new SkinnedMesh(geometry,material):new Mesh(geometry,material),mesh.isSkinnedMesh===!0&&mesh.normalizeSkinWeights(),primitive.mode===WEBGL_CONSTANTS.TRIANGLE_STRIP?mesh.geometry=toTrianglesDrawMode(mesh.geometry,TriangleStripDrawMode):primitive.mode===WEBGL_CONSTANTS.TRIANGLE_FAN&&(mesh.geometry=toTrianglesDrawMode(mesh.geometry,TriangleFanDrawMode));else if(primitive.mode===WEBGL_CONSTANTS.LINES)mesh=new LineSegments(geometry,material);else if(primitive.mode===WEBGL_CONSTANTS.LINE_STRIP)mesh=new Line(geometry,material);else if(primitive.mode===WEBGL_CONSTANTS.LINE_LOOP)mesh=new LineLoop(geometry,material);else if(primitive.mode===WEBGL_CONSTANTS.POINTS)mesh=new Points(geometry,material);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+primitive.mode);Object.keys(mesh.geometry.morphAttributes).length>0&&updateMorphTargets(mesh,meshDef),mesh.name=parser.createUniqueName(meshDef.name||"mesh_"+meshIndex),assignExtrasToUserData(mesh,meshDef),primitive.extensions&&addUnknownExtensionsToUserData(extensions2,mesh,primitive),parser.assignFinalMaterial(mesh),meshes.push(mesh)}for(let i2=0,il=meshes.length;i2<il;i2++)parser.associations.set(meshes[i2],{meshes:meshIndex,primitives:i2});if(meshes.length===1)return meshDef.extensions&&addUnknownExtensionsToUserData(extensions2,meshes[0],meshDef),meshes[0];const group=new Group;meshDef.extensions&&addUnknownExtensionsToUserData(extensions2,group,meshDef),parser.associations.set(group,{meshes:meshIndex});for(let i2=0,il=meshes.length;i2<il;i2++)group.add(meshes[i2]);return group})}loadCamera(cameraIndex){let camera;const cameraDef=this.json.cameras[cameraIndex],params=cameraDef[cameraDef.type];if(!params){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return cameraDef.type==="perspective"?camera=new PerspectiveCamera$1(MathUtils.radToDeg(params.yfov),params.aspectRatio||1,params.znear||1,params.zfar||2e6):cameraDef.type==="orthographic"&&(camera=new OrthographicCamera(-params.xmag,params.xmag,params.ymag,-params.ymag,params.znear,params.zfar)),cameraDef.name&&(camera.name=this.createUniqueName(cameraDef.name)),assignExtrasToUserData(camera,cameraDef),Promise.resolve(camera)}loadSkin(skinIndex){const skinDef=this.json.skins[skinIndex],pending=[];for(let i2=0,il=skinDef.joints.length;i2<il;i2++)pending.push(this._loadNodeShallow(skinDef.joints[i2]));return skinDef.inverseBindMatrices!==void 0?pending.push(this.getDependency("accessor",skinDef.inverseBindMatrices)):pending.push(null),Promise.all(pending).then(function(results){const inverseBindMatrices=results.pop(),jointNodes=results,bones=[],boneInverses=[];for(let i2=0,il=jointNodes.length;i2<il;i2++){const jointNode=jointNodes[i2];if(jointNode){bones.push(jointNode);const mat=new Matrix4;inverseBindMatrices!==null&&mat.fromArray(inverseBindMatrices.array,i2*16),boneInverses.push(mat)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',skinDef.joints[i2])}return new Skeleton(bones,boneInverses)})}loadAnimation(animationIndex){const animationDef=this.json.animations[animationIndex],animationName=animationDef.name?animationDef.name:"animation_"+animationIndex,pendingNodes=[],pendingInputAccessors=[],pendingOutputAccessors=[],pendingSamplers=[],pendingTargets=[];for(let i2=0,il=animationDef.channels.length;i2<il;i2++){const channel=animationDef.channels[i2],sampler=animationDef.samplers[channel.sampler],target=channel.target,name=target.node,input=animationDef.parameters!==void 0?animationDef.parameters[sampler.input]:sampler.input,output=animationDef.parameters!==void 0?animationDef.parameters[sampler.output]:sampler.output;target.node!==void 0&&(pendingNodes.push(this.getDependency("node",name)),pendingInputAccessors.push(this.getDependency("accessor",input)),pendingOutputAccessors.push(this.getDependency("accessor",output)),pendingSamplers.push(sampler),pendingTargets.push(target))}return Promise.all([Promise.all(pendingNodes),Promise.all(pendingInputAccessors),Promise.all(pendingOutputAccessors),Promise.all(pendingSamplers),Promise.all(pendingTargets)]).then(function(dependencies){const nodes=dependencies[0],inputAccessors=dependencies[1],outputAccessors=dependencies[2],samplers=dependencies[3],targets=dependencies[4],tracks=[];for(let i2=0,il=nodes.length;i2<il;i2++){const node=nodes[i2],inputAccessor=inputAccessors[i2],outputAccessor=outputAccessors[i2],sampler=samplers[i2],target=targets[i2];if(node===void 0)continue;node.updateMatrix();let TypedKeyframeTrack;switch(PATH_PROPERTIES[target.path]){case PATH_PROPERTIES.weights:TypedKeyframeTrack=NumberKeyframeTrack;break;case PATH_PROPERTIES.rotation:TypedKeyframeTrack=QuaternionKeyframeTrack;break;case PATH_PROPERTIES.position:case PATH_PROPERTIES.scale:default:TypedKeyframeTrack=VectorKeyframeTrack;break}const targetName=node.name?node.name:node.uuid,interpolation=sampler.interpolation!==void 0?INTERPOLATION[sampler.interpolation]:InterpolateLinear,targetNames=[];PATH_PROPERTIES[target.path]===PATH_PROPERTIES.weights?node.traverse(function(object){object.morphTargetInfluences&&targetNames.push(object.name?object.name:object.uuid)}):targetNames.push(targetName);let outputArray=outputAccessor.array;if(outputAccessor.normalized){const scale2=getNormalizedComponentScale(outputArray.constructor),scaled=new Float32Array(outputArray.length);for(let j2=0,jl=outputArray.length;j2<jl;j2++)scaled[j2]=outputArray[j2]*scale2;outputArray=scaled}for(let j2=0,jl=targetNames.length;j2<jl;j2++){const track=new TypedKeyframeTrack(targetNames[j2]+"."+PATH_PROPERTIES[target.path],inputAccessor.array,outputArray,interpolation);sampler.interpolation==="CUBICSPLINE"&&(track.createInterpolant=function(result){const interpolantType=this instanceof QuaternionKeyframeTrack?GLTFCubicSplineQuaternionInterpolant:GLTFCubicSplineInterpolant;return new interpolantType(this.times,this.values,this.getValueSize()/3,result)},track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),tracks.push(track)}}return new AnimationClip(animationName,void 0,tracks)})}createNodeMesh(nodeIndex){const json=this.json,parser=this,nodeDef=json.nodes[nodeIndex];return nodeDef.mesh===void 0?null:parser.getDependency("mesh",nodeDef.mesh).then(function(mesh){const node=parser._getNodeRef(parser.meshCache,nodeDef.mesh,mesh);return nodeDef.weights!==void 0&&node.traverse(function(o2){if(o2.isMesh)for(let i2=0,il=nodeDef.weights.length;i2<il;i2++)o2.morphTargetInfluences[i2]=nodeDef.weights[i2]}),node})}loadNode(nodeIndex){const json=this.json,parser=this,nodeDef=json.nodes[nodeIndex],nodePending=parser._loadNodeShallow(nodeIndex),childPending=[],childrenDef=nodeDef.children||[];for(let i2=0,il=childrenDef.length;i2<il;i2++)childPending.push(parser.getDependency("node",childrenDef[i2]));const skeletonPending=nodeDef.skin===void 0?Promise.resolve(null):parser.getDependency("skin",nodeDef.skin);return Promise.all([nodePending,Promise.all(childPending),skeletonPending]).then(function(results){const node=results[0],children=results[1],skeleton=results[2];skeleton!==null&&node.traverse(function(mesh){mesh.isSkinnedMesh&&mesh.bind(skeleton,_identityMatrix)});for(let i2=0,il=children.length;i2<il;i2++)node.add(children[i2]);return node})}_loadNodeShallow(nodeIndex){const json=this.json,extensions2=this.extensions,parser=this;if(this.nodeCache[nodeIndex]!==void 0)return this.nodeCache[nodeIndex];const nodeDef=json.nodes[nodeIndex],nodeName=nodeDef.name?parser.createUniqueName(nodeDef.name):"",pending=[],meshPromise=parser._invokeOne(function(ext){return ext.createNodeMesh&&ext.createNodeMesh(nodeIndex)});return meshPromise&&pending.push(meshPromise),nodeDef.camera!==void 0&&pending.push(parser.getDependency("camera",nodeDef.camera).then(function(camera){return parser._getNodeRef(parser.cameraCache,nodeDef.camera,camera)})),parser._invokeAll(function(ext){return ext.createNodeAttachment&&ext.createNodeAttachment(nodeIndex)}).forEach(function(promise){pending.push(promise)}),this.nodeCache[nodeIndex]=Promise.all(pending).then(function(objects){let node;if(nodeDef.isBone===!0?node=new Bone:objects.length>1?node=new Group:objects.length===1?node=objects[0]:node=new Object3D,node!==objects[0])for(let i2=0,il=objects.length;i2<il;i2++)node.add(objects[i2]);if(nodeDef.name&&(node.userData.name=nodeDef.name,node.name=nodeName),assignExtrasToUserData(node,nodeDef),nodeDef.extensions&&addUnknownExtensionsToUserData(extensions2,node,nodeDef),nodeDef.matrix!==void 0){const matrix=new Matrix4;matrix.fromArray(nodeDef.matrix),node.applyMatrix4(matrix)}else nodeDef.translation!==void 0&&node.position.fromArray(nodeDef.translation),nodeDef.rotation!==void 0&&node.quaternion.fromArray(nodeDef.rotation),nodeDef.scale!==void 0&&node.scale.fromArray(nodeDef.scale);return parser.associations.has(node)||parser.associations.set(node,{}),parser.associations.get(node).nodes=nodeIndex,node}),this.nodeCache[nodeIndex]}loadScene(sceneIndex){const extensions2=this.extensions,sceneDef=this.json.scenes[sceneIndex],parser=this,scene2=new Group;sceneDef.name&&(scene2.name=parser.createUniqueName(sceneDef.name)),assignExtrasToUserData(scene2,sceneDef),sceneDef.extensions&&addUnknownExtensionsToUserData(extensions2,scene2,sceneDef);const nodeIds=sceneDef.nodes||[],pending=[];for(let i2=0,il=nodeIds.length;i2<il;i2++)pending.push(parser.getDependency("node",nodeIds[i2]));return Promise.all(pending).then(function(nodes){for(let i2=0,il=nodes.length;i2<il;i2++)scene2.add(nodes[i2]);const reduceAssociations=node=>{const reducedAssociations=new Map;for(const[key,value]of parser.associations)(key instanceof Material||key instanceof Texture)&&reducedAssociations.set(key,value);return node.traverse(node2=>{const mappings=parser.associations.get(node2);mappings!=null&&reducedAssociations.set(node2,mappings)}),reducedAssociations};return parser.associations=reduceAssociations(scene2),scene2})}}function computeBounds(geometry,primitiveDef,parser){const attributes=primitiveDef.attributes,box=new Box3;if(attributes.POSITION!==void 0){const accessor=parser.json.accessors[attributes.POSITION],min=accessor.min,max2=accessor.max;if(min!==void 0&&max2!==void 0){if(box.set(new Vector3(min[0],min[1],min[2]),new Vector3(max2[0],max2[1],max2[2])),accessor.normalized){const boxScale=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);box.min.multiplyScalar(boxScale),box.max.multiplyScalar(boxScale)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const targets=primitiveDef.targets;if(targets!==void 0){const maxDisplacement=new Vector3,vector=new Vector3;for(let i2=0,il=targets.length;i2<il;i2++){const target=targets[i2];if(target.POSITION!==void 0){const accessor=parser.json.accessors[target.POSITION],min=accessor.min,max2=accessor.max;if(min!==void 0&&max2!==void 0){if(vector.setX(Math.max(Math.abs(min[0]),Math.abs(max2[0]))),vector.setY(Math.max(Math.abs(min[1]),Math.abs(max2[1]))),vector.setZ(Math.max(Math.abs(min[2]),Math.abs(max2[2]))),accessor.normalized){const boxScale=getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);vector.multiplyScalar(boxScale)}maxDisplacement.max(vector)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}box.expandByVector(maxDisplacement)}geometry.boundingBox=box;const sphere=new Sphere;box.getCenter(sphere.center),sphere.radius=box.min.distanceTo(box.max)/2,geometry.boundingSphere=sphere}function addPrimitiveAttributes(geometry,primitiveDef,parser){const attributes=primitiveDef.attributes,pending=[];function assignAttributeAccessor(accessorIndex,attributeName){return parser.getDependency("accessor",accessorIndex).then(function(accessor){geometry.setAttribute(attributeName,accessor)})}for(const gltfAttributeName in attributes){const threeAttributeName=ATTRIBUTES[gltfAttributeName]||gltfAttributeName.toLowerCase();threeAttributeName in geometry.attributes||pending.push(assignAttributeAccessor(attributes[gltfAttributeName],threeAttributeName))}if(primitiveDef.indices!==void 0&&!geometry.index){const accessor=parser.getDependency("accessor",primitiveDef.indices).then(function(accessor2){geometry.setIndex(accessor2)});pending.push(accessor)}return assignExtrasToUserData(geometry,primitiveDef),computeBounds(geometry,primitiveDef,parser),Promise.all(pending).then(function(){return primitiveDef.targets!==void 0?addMorphTargets(geometry,primitiveDef.targets,parser):geometry})}const HorizontalBlurShader={uniforms:{tDiffuse:{value:null},h:{value:1/512}},vertexShader:`
      varying vec2 vUv;

      void main() {

        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
  `,fragmentShader:`
    uniform sampler2D tDiffuse;
    uniform float h;

    varying vec2 vUv;

    void main() {

    	vec4 sum = vec4( 0.0 );

    	sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;
    	sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;

    	gl_FragColor = sum;

    }
  `},VerticalBlurShader={uniforms:{tDiffuse:{value:null},v:{value:1/512}},vertexShader:`
    varying vec2 vUv;

    void main() {

      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }
  `,fragmentShader:`

  uniform sampler2D tDiffuse;
  uniform float v;

  varying vec2 vUv;

  void main() {

    vec4 sum = vec4( 0.0 );

    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;
    sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;

    gl_FragColor = sum;

  }
  `};function findSpan(p2,u2,U){const n=U.length-p2-1;if(u2>=U[n])return n-1;if(u2<=U[p2])return p2;let low=p2,high=n,mid=Math.floor((low+high)/2);for(;u2<U[mid]||u2>=U[mid+1];)u2<U[mid]?high=mid:low=mid,mid=Math.floor((low+high)/2);return mid}function calcBasisFunctions(span,u2,p2,U){const N=[],left=[],right=[];N[0]=1;for(let j2=1;j2<=p2;++j2){left[j2]=u2-U[span+1-j2],right[j2]=U[span+j2]-u2;let saved=0;for(let r2=0;r2<j2;++r2){const rv=right[r2+1],lv=left[j2-r2],temp=N[r2]/(rv+lv);N[r2]=saved+rv*temp,saved=lv*temp}N[j2]=saved}return N}function calcBSplinePoint(p2,U,P2,u2){const span=findSpan(p2,u2,U),N=calcBasisFunctions(span,u2,p2,U),C=new Vector4(0,0,0,0);for(let j2=0;j2<=p2;++j2){const point=P2[span-p2+j2],Nj=N[j2],wNj=point.w*Nj;C.x+=point.x*wNj,C.y+=point.y*wNj,C.z+=point.z*wNj,C.w+=point.w*Nj}return C}function calcBasisFunctionDerivatives(span,u2,p2,n,U){const zeroArr=[];for(let i2=0;i2<=p2;++i2)zeroArr[i2]=0;const ders=[];for(let i2=0;i2<=n;++i2)ders[i2]=zeroArr.slice(0);const ndu=[];for(let i2=0;i2<=p2;++i2)ndu[i2]=zeroArr.slice(0);ndu[0][0]=1;const left=zeroArr.slice(0),right=zeroArr.slice(0);for(let j2=1;j2<=p2;++j2){left[j2]=u2-U[span+1-j2],right[j2]=U[span+j2]-u2;let saved=0;for(let r22=0;r22<j2;++r22){const rv=right[r22+1],lv=left[j2-r22];ndu[j2][r22]=rv+lv;const temp=ndu[r22][j2-1]/ndu[j2][r22];ndu[r22][j2]=saved+rv*temp,saved=lv*temp}ndu[j2][j2]=saved}for(let j2=0;j2<=p2;++j2)ders[0][j2]=ndu[j2][p2];for(let r22=0;r22<=p2;++r22){let s1=0,s2=1;const a2=[];for(let i2=0;i2<=p2;++i2)a2[i2]=zeroArr.slice(0);a2[0][0]=1;for(let k2=1;k2<=n;++k2){let d2=0;const rk=r22-k2,pk=p2-k2;r22>=k2&&(a2[s2][0]=a2[s1][0]/ndu[pk+1][rk],d2=a2[s2][0]*ndu[rk][pk]);const j1=rk>=-1?1:-rk,j2=r22-1<=pk?k2-1:p2-r22;for(let j32=j1;j32<=j2;++j32)a2[s2][j32]=(a2[s1][j32]-a2[s1][j32-1])/ndu[pk+1][rk+j32],d2+=a2[s2][j32]*ndu[rk+j32][pk];r22<=pk&&(a2[s2][k2]=-a2[s1][k2-1]/ndu[pk+1][r22],d2+=a2[s2][k2]*ndu[r22][pk]),ders[k2][r22]=d2;const j3=s1;s1=s2,s2=j3}}let r2=p2;for(let k2=1;k2<=n;++k2){for(let j2=0;j2<=p2;++j2)ders[k2][j2]*=r2;r2*=p2-k2}return ders}function calcBSplineDerivatives(p2,U,P2,u2,nd){const du=nd<p2?nd:p2,CK=[],span=findSpan(p2,u2,U),nders=calcBasisFunctionDerivatives(span,u2,p2,du,U),Pw=[];for(let i2=0;i2<P2.length;++i2){const point=P2[i2].clone(),w2=point.w;point.x*=w2,point.y*=w2,point.z*=w2,Pw[i2]=point}for(let k2=0;k2<=du;++k2){const point=Pw[span-p2].clone().multiplyScalar(nders[k2][0]);for(let j2=1;j2<=p2;++j2)point.add(Pw[span-p2+j2].clone().multiplyScalar(nders[k2][j2]));CK[k2]=point}for(let k2=du+1;k2<=nd+1;++k2)CK[k2]=new Vector4(0,0,0);return CK}function calcKoverI(k2,i2){let nom=1;for(let j2=2;j2<=k2;++j2)nom*=j2;let denom=1;for(let j2=2;j2<=i2;++j2)denom*=j2;for(let j2=2;j2<=k2-i2;++j2)denom*=j2;return nom/denom}function calcRationalCurveDerivatives(Pders){const nd=Pders.length,Aders=[],wders=[];for(let i2=0;i2<nd;++i2){const point=Pders[i2];Aders[i2]=new Vector3(point.x,point.y,point.z),wders[i2]=point.w}const CK=[];for(let k2=0;k2<nd;++k2){const v4=Aders[k2].clone();for(let i2=1;i2<=k2;++i2)v4.sub(CK[k2-i2].clone().multiplyScalar(calcKoverI(k2,i2)*wders[i2]));CK[k2]=v4.divideScalar(wders[0])}return CK}function calcNURBSDerivatives(p2,U,P2,u2,nd){const Pders=calcBSplineDerivatives(p2,U,P2,u2,nd);return calcRationalCurveDerivatives(Pders)}class NURBSCurve extends Curve{constructor(degree,knots,controlPoints,startKnot,endKnot){super(),this.degree=degree,this.knots=knots,this.controlPoints=[],this.startKnot=startKnot||0,this.endKnot=endKnot||this.knots.length-1;for(let i2=0;i2<controlPoints.length;++i2){const point=controlPoints[i2];this.controlPoints[i2]=new Vector4(point.x,point.y,point.z,point.w)}}getPoint(t2,optionalTarget){const point=optionalTarget||new Vector3,u2=this.knots[this.startKnot]+t2*(this.knots[this.endKnot]-this.knots[this.startKnot]),hpoint=calcBSplinePoint(this.degree,this.knots,this.controlPoints,u2);return hpoint.w!=1&&hpoint.divideScalar(hpoint.w),point.set(hpoint.x,hpoint.y,hpoint.z)}getTangent(t2,optionalTarget){const tangent=optionalTarget||new Vector3,u2=this.knots[0]+t2*(this.knots[this.knots.length-1]-this.knots[0]),ders=calcNURBSDerivatives(this.degree,this.knots,this.controlPoints,u2,1);return tangent.copy(ders[1]).normalize(),tangent}}let fbxTree,connections,sceneGraph;class FBXLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){const scope=this,path2=scope.path===""?LoaderUtils.extractUrlBase(url):scope.path,loader=new FileLoader(this.manager);loader.setPath(scope.path),loader.setResponseType("arraybuffer"),loader.setRequestHeader(scope.requestHeader),loader.setWithCredentials(scope.withCredentials),loader.load(url,function(buffer){try{onLoad(scope.parse(buffer,path2))}catch(e2){onError?onError(e2):console.error(e2),scope.manager.itemError(url)}},onProgress,onError)}parse(FBXBuffer,path2){if(isFbxFormatBinary(FBXBuffer))fbxTree=new BinaryParser().parse(FBXBuffer);else{const FBXText=convertArrayBufferToString(FBXBuffer);if(!isFbxFormatASCII(FBXText))throw new Error("THREE.FBXLoader: Unknown format.");if(getFbxVersion(FBXText)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+getFbxVersion(FBXText));fbxTree=new TextParser().parse(FBXText)}const textureLoader=new TextureLoader(this.manager).setPath(this.resourcePath||path2).setCrossOrigin(this.crossOrigin);return new FBXTreeParser(textureLoader,this.manager).parse(fbxTree)}}class FBXTreeParser{constructor(textureLoader,manager){this.textureLoader=textureLoader,this.manager=manager}parse(){connections=this.parseConnections();const images=this.parseImages(),textures=this.parseTextures(images),materials=this.parseMaterials(textures),deformers=this.parseDeformers(),geometryMap=new GeometryParser().parse(deformers);return this.parseScene(deformers,geometryMap,materials),sceneGraph}parseConnections(){const connectionMap=new Map;return"Connections"in fbxTree&&fbxTree.Connections.connections.forEach(function(rawConnection){const fromID=rawConnection[0],toID=rawConnection[1],relationship=rawConnection[2];connectionMap.has(fromID)||connectionMap.set(fromID,{parents:[],children:[]});const parentRelationship={ID:toID,relationship};connectionMap.get(fromID).parents.push(parentRelationship),connectionMap.has(toID)||connectionMap.set(toID,{parents:[],children:[]});const childRelationship={ID:fromID,relationship};connectionMap.get(toID).children.push(childRelationship)}),connectionMap}parseImages(){const images={},blobs={};if("Video"in fbxTree.Objects){const videoNodes=fbxTree.Objects.Video;for(const nodeID in videoNodes){const videoNode=videoNodes[nodeID],id2=parseInt(nodeID);if(images[id2]=videoNode.RelativeFilename||videoNode.Filename,"Content"in videoNode){const arrayBufferContent=videoNode.Content instanceof ArrayBuffer&&videoNode.Content.byteLength>0,base64Content=typeof videoNode.Content=="string"&&videoNode.Content!=="";if(arrayBufferContent||base64Content){const image=this.parseImage(videoNodes[nodeID]);blobs[videoNode.RelativeFilename||videoNode.Filename]=image}}}}for(const id2 in images){const filename=images[id2];blobs[filename]!==void 0?images[id2]=blobs[filename]:images[id2]=images[id2].split("\\").pop()}return images}parseImage(videoNode){const content=videoNode.Content,fileName=videoNode.RelativeFilename||videoNode.Filename,extension=fileName.slice(fileName.lastIndexOf(".")+1).toLowerCase();let type;switch(extension){case"bmp":type="image/bmp";break;case"jpg":case"jpeg":type="image/jpeg";break;case"png":type="image/png";break;case"tif":type="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",fileName),type="image/tga";break;default:console.warn('FBXLoader: Image type "'+extension+'" is not supported.');return}if(typeof content=="string")return"data:"+type+";base64,"+content;{const array=new Uint8Array(content);return window.URL.createObjectURL(new Blob([array],{type}))}}parseTextures(images){const textureMap=new Map;if("Texture"in fbxTree.Objects){const textureNodes=fbxTree.Objects.Texture;for(const nodeID in textureNodes){const texture=this.parseTexture(textureNodes[nodeID],images);textureMap.set(parseInt(nodeID),texture)}}return textureMap}parseTexture(textureNode,images){const texture=this.loadTexture(textureNode,images);texture.ID=textureNode.id,texture.name=textureNode.attrName;const wrapModeU=textureNode.WrapModeU,wrapModeV=textureNode.WrapModeV,valueU=wrapModeU!==void 0?wrapModeU.value:0,valueV=wrapModeV!==void 0?wrapModeV.value:0;if(texture.wrapS=valueU===0?RepeatWrapping:ClampToEdgeWrapping,texture.wrapT=valueV===0?RepeatWrapping:ClampToEdgeWrapping,"Scaling"in textureNode){const values=textureNode.Scaling.value;texture.repeat.x=values[0],texture.repeat.y=values[1]}return texture}loadTexture(textureNode,images){let fileName;const currentPath=this.textureLoader.path,children=connections.get(textureNode.id).children;children!==void 0&&children.length>0&&images[children[0].ID]!==void 0&&(fileName=images[children[0].ID],(fileName.indexOf("blob:")===0||fileName.indexOf("data:")===0)&&this.textureLoader.setPath(void 0));let texture;const extension=textureNode.FileName.slice(-3).toLowerCase();if(extension==="tga"){const loader=this.manager.getHandler(".tga");loader===null?(console.warn("FBXLoader: TGA loader not found, creating placeholder texture for",textureNode.RelativeFilename),texture=new Texture):(loader.setPath(this.textureLoader.path),texture=loader.load(fileName))}else extension==="psd"?(console.warn("FBXLoader: PSD textures are not supported, creating placeholder texture for",textureNode.RelativeFilename),texture=new Texture):texture=this.textureLoader.load(fileName);return this.textureLoader.setPath(currentPath),texture}parseMaterials(textureMap){const materialMap=new Map;if("Material"in fbxTree.Objects){const materialNodes=fbxTree.Objects.Material;for(const nodeID in materialNodes){const material=this.parseMaterial(materialNodes[nodeID],textureMap);material!==null&&materialMap.set(parseInt(nodeID),material)}}return materialMap}parseMaterial(materialNode,textureMap){const ID=materialNode.id,name=materialNode.attrName;let type=materialNode.ShadingModel;if(typeof type=="object"&&(type=type.value),!connections.has(ID))return null;const parameters=this.parseParameters(materialNode,textureMap,ID);let material;switch(type.toLowerCase()){case"phong":material=new MeshPhongMaterial;break;case"lambert":material=new MeshLambertMaterial;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',type),material=new MeshPhongMaterial;break}return material.setValues(parameters),material.name=name,material}parseParameters(materialNode,textureMap,ID){const parameters={};materialNode.BumpFactor&&(parameters.bumpScale=materialNode.BumpFactor.value),materialNode.Diffuse?parameters.color=new Color().fromArray(materialNode.Diffuse.value):materialNode.DiffuseColor&&(materialNode.DiffuseColor.type==="Color"||materialNode.DiffuseColor.type==="ColorRGB")&&(parameters.color=new Color().fromArray(materialNode.DiffuseColor.value)),materialNode.DisplacementFactor&&(parameters.displacementScale=materialNode.DisplacementFactor.value),materialNode.Emissive?parameters.emissive=new Color().fromArray(materialNode.Emissive.value):materialNode.EmissiveColor&&(materialNode.EmissiveColor.type==="Color"||materialNode.EmissiveColor.type==="ColorRGB")&&(parameters.emissive=new Color().fromArray(materialNode.EmissiveColor.value)),materialNode.EmissiveFactor&&(parameters.emissiveIntensity=parseFloat(materialNode.EmissiveFactor.value)),materialNode.Opacity&&(parameters.opacity=parseFloat(materialNode.Opacity.value)),parameters.opacity<1&&(parameters.transparent=!0),materialNode.ReflectionFactor&&(parameters.reflectivity=materialNode.ReflectionFactor.value),materialNode.Shininess&&(parameters.shininess=materialNode.Shininess.value),materialNode.Specular?parameters.specular=new Color().fromArray(materialNode.Specular.value):materialNode.SpecularColor&&materialNode.SpecularColor.type==="Color"&&(parameters.specular=new Color().fromArray(materialNode.SpecularColor.value));const scope=this;return connections.get(ID).children.forEach(function(child){const type=child.relationship;switch(type){case"Bump":parameters.bumpMap=scope.getTexture(textureMap,child.ID);break;case"Maya|TEX_ao_map":parameters.aoMap=scope.getTexture(textureMap,child.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":parameters.map=scope.getTexture(textureMap,child.ID),parameters.map!==void 0&&("colorSpace"in parameters.map?parameters.map.colorSpace="srgb":parameters.map.encoding=3001);break;case"DisplacementColor":parameters.displacementMap=scope.getTexture(textureMap,child.ID);break;case"EmissiveColor":parameters.emissiveMap=scope.getTexture(textureMap,child.ID),parameters.emissiveMap!==void 0&&("colorSpace"in parameters.emissiveMap?parameters.emissiveMap.colorSpace="srgb":parameters.emissiveMap.encoding=3001);break;case"NormalMap":case"Maya|TEX_normal_map":parameters.normalMap=scope.getTexture(textureMap,child.ID);break;case"ReflectionColor":parameters.envMap=scope.getTexture(textureMap,child.ID),parameters.envMap!==void 0&&(parameters.envMap.mapping=EquirectangularReflectionMapping,"colorSpace"in parameters.envMap?parameters.envMap.colorSpace="srgb":parameters.envMap.encoding=3001);break;case"SpecularColor":parameters.specularMap=scope.getTexture(textureMap,child.ID),parameters.specularMap!==void 0&&("colorSpace"in parameters.specularMap?parameters.specularMap.colorSpace="srgb":parameters.specularMap.encoding=3001);break;case"TransparentColor":case"TransparencyFactor":parameters.alphaMap=scope.getTexture(textureMap,child.ID),parameters.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",type);break}}),parameters}getTexture(textureMap,id2){return"LayeredTexture"in fbxTree.Objects&&id2 in fbxTree.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),id2=connections.get(id2).children[0].ID),textureMap.get(id2)}parseDeformers(){const skeletons={},morphTargets={};if("Deformer"in fbxTree.Objects){const DeformerNodes=fbxTree.Objects.Deformer;for(const nodeID in DeformerNodes){const deformerNode=DeformerNodes[nodeID],relationships=connections.get(parseInt(nodeID));if(deformerNode.attrType==="Skin"){const skeleton=this.parseSkeleton(relationships,DeformerNodes);skeleton.ID=nodeID,relationships.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),skeleton.geometryID=relationships.parents[0].ID,skeletons[nodeID]=skeleton}else if(deformerNode.attrType==="BlendShape"){const morphTarget={id:nodeID};morphTarget.rawTargets=this.parseMorphTargets(relationships,DeformerNodes),morphTarget.id=nodeID,relationships.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),morphTargets[nodeID]=morphTarget}}}return{skeletons,morphTargets}}parseSkeleton(relationships,deformerNodes){const rawBones=[];return relationships.children.forEach(function(child){const boneNode=deformerNodes[child.ID];if(boneNode.attrType!=="Cluster")return;const rawBone={ID:child.ID,indices:[],weights:[],transformLink:new Matrix4().fromArray(boneNode.TransformLink.a)};"Indexes"in boneNode&&(rawBone.indices=boneNode.Indexes.a,rawBone.weights=boneNode.Weights.a),rawBones.push(rawBone)}),{rawBones,bones:[]}}parseMorphTargets(relationships,deformerNodes){const rawMorphTargets=[];for(let i2=0;i2<relationships.children.length;i2++){const child=relationships.children[i2],morphTargetNode=deformerNodes[child.ID],rawMorphTarget={name:morphTargetNode.attrName,initialWeight:morphTargetNode.DeformPercent,id:morphTargetNode.id,fullWeights:morphTargetNode.FullWeights.a};if(morphTargetNode.attrType!=="BlendShapeChannel")return;rawMorphTarget.geoID=connections.get(parseInt(child.ID)).children.filter(function(child2){return child2.relationship===void 0})[0].ID,rawMorphTargets.push(rawMorphTarget)}return rawMorphTargets}parseScene(deformers,geometryMap,materialMap){sceneGraph=new Group;const modelMap=this.parseModels(deformers.skeletons,geometryMap,materialMap),modelNodes=fbxTree.Objects.Model,scope=this;modelMap.forEach(function(model){const modelNode=modelNodes[model.ID];scope.setLookAtProperties(model,modelNode),connections.get(model.ID).parents.forEach(function(connection){const parent=modelMap.get(connection.ID);parent!==void 0&&parent.add(model)}),model.parent===null&&sceneGraph.add(model)}),this.bindSkeleton(deformers.skeletons,geometryMap,modelMap),this.createAmbientLight(),sceneGraph.traverse(function(node){if(node.userData.transformData){node.parent&&(node.userData.transformData.parentMatrix=node.parent.matrix,node.userData.transformData.parentMatrixWorld=node.parent.matrixWorld);const transform=generateTransform(node.userData.transformData);node.applyMatrix4(transform),node.updateWorldMatrix()}});const animations2=new AnimationParser().parse();sceneGraph.children.length===1&&sceneGraph.children[0].isGroup&&(sceneGraph.children[0].animations=animations2,sceneGraph=sceneGraph.children[0]),sceneGraph.animations=animations2}parseModels(skeletons,geometryMap,materialMap){const modelMap=new Map,modelNodes=fbxTree.Objects.Model;for(const nodeID in modelNodes){const id2=parseInt(nodeID),node=modelNodes[nodeID],relationships=connections.get(id2);let model=this.buildSkeleton(relationships,skeletons,id2,node.attrName);if(!model){switch(node.attrType){case"Camera":model=this.createCamera(relationships);break;case"Light":model=this.createLight(relationships);break;case"Mesh":model=this.createMesh(relationships,geometryMap,materialMap);break;case"NurbsCurve":model=this.createCurve(relationships,geometryMap);break;case"LimbNode":case"Root":model=new Bone;break;case"Null":default:model=new Group;break}model.name=node.attrName?PropertyBinding.sanitizeNodeName(node.attrName):"",model.ID=id2}this.getTransformData(model,node),modelMap.set(id2,model)}return modelMap}buildSkeleton(relationships,skeletons,id2,name){let bone=null;return relationships.parents.forEach(function(parent){for(const ID in skeletons){const skeleton=skeletons[ID];skeleton.rawBones.forEach(function(rawBone,i2){if(rawBone.ID===parent.ID){const subBone=bone;bone=new Bone,bone.matrixWorld.copy(rawBone.transformLink),bone.name=name?PropertyBinding.sanitizeNodeName(name):"",bone.ID=id2,skeleton.bones[i2]=bone,subBone!==null&&bone.add(subBone)}})}}),bone}createCamera(relationships){let model,cameraAttribute;if(relationships.children.forEach(function(child){const attr=fbxTree.Objects.NodeAttribute[child.ID];attr!==void 0&&(cameraAttribute=attr)}),cameraAttribute===void 0)model=new Object3D;else{let type=0;cameraAttribute.CameraProjectionType!==void 0&&cameraAttribute.CameraProjectionType.value===1&&(type=1);let nearClippingPlane=1;cameraAttribute.NearPlane!==void 0&&(nearClippingPlane=cameraAttribute.NearPlane.value/1e3);let farClippingPlane=1e3;cameraAttribute.FarPlane!==void 0&&(farClippingPlane=cameraAttribute.FarPlane.value/1e3);let width=window.innerWidth,height=window.innerHeight;cameraAttribute.AspectWidth!==void 0&&cameraAttribute.AspectHeight!==void 0&&(width=cameraAttribute.AspectWidth.value,height=cameraAttribute.AspectHeight.value);const aspect2=width/height;let fov2=45;cameraAttribute.FieldOfView!==void 0&&(fov2=cameraAttribute.FieldOfView.value);const focalLength=cameraAttribute.FocalLength?cameraAttribute.FocalLength.value:null;switch(type){case 0:model=new PerspectiveCamera$1(fov2,aspect2,nearClippingPlane,farClippingPlane),focalLength!==null&&model.setFocalLength(focalLength);break;case 1:model=new OrthographicCamera(-width/2,width/2,height/2,-height/2,nearClippingPlane,farClippingPlane);break;default:console.warn("THREE.FBXLoader: Unknown camera type "+type+"."),model=new Object3D;break}}return model}createLight(relationships){let model,lightAttribute;if(relationships.children.forEach(function(child){const attr=fbxTree.Objects.NodeAttribute[child.ID];attr!==void 0&&(lightAttribute=attr)}),lightAttribute===void 0)model=new Object3D;else{let type;lightAttribute.LightType===void 0?type=0:type=lightAttribute.LightType.value;let color2=16777215;lightAttribute.Color!==void 0&&(color2=new Color().fromArray(lightAttribute.Color.value));let intensity=lightAttribute.Intensity===void 0?1:lightAttribute.Intensity.value/100;lightAttribute.CastLightOnObject!==void 0&&lightAttribute.CastLightOnObject.value===0&&(intensity=0);let distance2=0;lightAttribute.FarAttenuationEnd!==void 0&&(lightAttribute.EnableFarAttenuation!==void 0&&lightAttribute.EnableFarAttenuation.value===0?distance2=0:distance2=lightAttribute.FarAttenuationEnd.value);const decay=1;switch(type){case 0:model=new PointLight(color2,intensity,distance2,decay);break;case 1:model=new DirectionalLight(color2,intensity);break;case 2:let angle=Math.PI/3;lightAttribute.InnerAngle!==void 0&&(angle=MathUtils.degToRad(lightAttribute.InnerAngle.value));let penumbra=0;lightAttribute.OuterAngle!==void 0&&(penumbra=MathUtils.degToRad(lightAttribute.OuterAngle.value),penumbra=Math.max(penumbra,1)),model=new SpotLight(color2,intensity,distance2,angle,penumbra,decay);break;default:console.warn("THREE.FBXLoader: Unknown light type "+lightAttribute.LightType.value+", defaulting to a PointLight."),model=new PointLight(color2,intensity);break}lightAttribute.CastShadows!==void 0&&lightAttribute.CastShadows.value===1&&(model.castShadow=!0)}return model}createMesh(relationships,geometryMap,materialMap){let model,geometry=null,material=null;const materials=[];return relationships.children.forEach(function(child){geometryMap.has(child.ID)&&(geometry=geometryMap.get(child.ID)),materialMap.has(child.ID)&&materials.push(materialMap.get(child.ID))}),materials.length>1?material=materials:materials.length>0?material=materials[0]:(material=new MeshPhongMaterial({color:13421772}),materials.push(material)),"color"in geometry.attributes&&materials.forEach(function(material2){material2.vertexColors=!0}),geometry.FBX_Deformer?(model=new SkinnedMesh(geometry,material),model.normalizeSkinWeights()):model=new Mesh(geometry,material),model}createCurve(relationships,geometryMap){const geometry=relationships.children.reduce(function(geo,child){return geometryMap.has(child.ID)&&(geo=geometryMap.get(child.ID)),geo},null),material=new LineBasicMaterial({color:3342591,linewidth:1});return new Line(geometry,material)}getTransformData(model,modelNode){const transformData={};"InheritType"in modelNode&&(transformData.inheritType=parseInt(modelNode.InheritType.value)),"RotationOrder"in modelNode?transformData.eulerOrder=getEulerOrder(modelNode.RotationOrder.value):transformData.eulerOrder="ZYX","Lcl_Translation"in modelNode&&(transformData.translation=modelNode.Lcl_Translation.value),"PreRotation"in modelNode&&(transformData.preRotation=modelNode.PreRotation.value),"Lcl_Rotation"in modelNode&&(transformData.rotation=modelNode.Lcl_Rotation.value),"PostRotation"in modelNode&&(transformData.postRotation=modelNode.PostRotation.value),"Lcl_Scaling"in modelNode&&(transformData.scale=modelNode.Lcl_Scaling.value),"ScalingOffset"in modelNode&&(transformData.scalingOffset=modelNode.ScalingOffset.value),"ScalingPivot"in modelNode&&(transformData.scalingPivot=modelNode.ScalingPivot.value),"RotationOffset"in modelNode&&(transformData.rotationOffset=modelNode.RotationOffset.value),"RotationPivot"in modelNode&&(transformData.rotationPivot=modelNode.RotationPivot.value),model.userData.transformData=transformData}setLookAtProperties(model,modelNode){"LookAtProperty"in modelNode&&connections.get(model.ID).children.forEach(function(child){if(child.relationship==="LookAtProperty"){const lookAtTarget=fbxTree.Objects.Model[child.ID];if("Lcl_Translation"in lookAtTarget){const pos=lookAtTarget.Lcl_Translation.value;model.target!==void 0?(model.target.position.fromArray(pos),sceneGraph.add(model.target)):model.lookAt(new Vector3().fromArray(pos))}}})}bindSkeleton(skeletons,geometryMap,modelMap){const bindMatrices=this.parsePoseNodes();for(const ID in skeletons){const skeleton=skeletons[ID];connections.get(parseInt(skeleton.ID)).parents.forEach(function(parent){if(geometryMap.has(parent.ID)){const geoID=parent.ID;connections.get(geoID).parents.forEach(function(geoConnParent){modelMap.has(geoConnParent.ID)&&modelMap.get(geoConnParent.ID).bind(new Skeleton(skeleton.bones),bindMatrices[geoConnParent.ID])})}})}}parsePoseNodes(){const bindMatrices={};if("Pose"in fbxTree.Objects){const BindPoseNode=fbxTree.Objects.Pose;for(const nodeID in BindPoseNode)if(BindPoseNode[nodeID].attrType==="BindPose"&&BindPoseNode[nodeID].NbPoseNodes>0){const poseNodes=BindPoseNode[nodeID].PoseNode;Array.isArray(poseNodes)?poseNodes.forEach(function(poseNode){bindMatrices[poseNode.Node]=new Matrix4().fromArray(poseNode.Matrix.a)}):bindMatrices[poseNodes.Node]=new Matrix4().fromArray(poseNodes.Matrix.a)}}return bindMatrices}createAmbientLight(){if("GlobalSettings"in fbxTree&&"AmbientColor"in fbxTree.GlobalSettings){const ambientColor=fbxTree.GlobalSettings.AmbientColor.value,r2=ambientColor[0],g2=ambientColor[1],b2=ambientColor[2];if(r2!==0||g2!==0||b2!==0){const color2=new Color(r2,g2,b2);sceneGraph.add(new AmbientLight(color2,1))}}}}class GeometryParser{parse(deformers){const geometryMap=new Map;if("Geometry"in fbxTree.Objects){const geoNodes=fbxTree.Objects.Geometry;for(const nodeID in geoNodes){const relationships=connections.get(parseInt(nodeID)),geo=this.parseGeometry(relationships,geoNodes[nodeID],deformers);geometryMap.set(parseInt(nodeID),geo)}}return geometryMap}parseGeometry(relationships,geoNode,deformers){switch(geoNode.attrType){case"Mesh":return this.parseMeshGeometry(relationships,geoNode,deformers);case"NurbsCurve":return this.parseNurbsGeometry(geoNode)}}parseMeshGeometry(relationships,geoNode,deformers){const skeletons=deformers.skeletons,morphTargets=[],modelNodes=relationships.parents.map(function(parent){return fbxTree.Objects.Model[parent.ID]});if(modelNodes.length===0)return;const skeleton=relationships.children.reduce(function(skeleton2,child){return skeletons[child.ID]!==void 0&&(skeleton2=skeletons[child.ID]),skeleton2},null);relationships.children.forEach(function(child){deformers.morphTargets[child.ID]!==void 0&&morphTargets.push(deformers.morphTargets[child.ID])});const modelNode=modelNodes[0],transformData={};"RotationOrder"in modelNode&&(transformData.eulerOrder=getEulerOrder(modelNode.RotationOrder.value)),"InheritType"in modelNode&&(transformData.inheritType=parseInt(modelNode.InheritType.value)),"GeometricTranslation"in modelNode&&(transformData.translation=modelNode.GeometricTranslation.value),"GeometricRotation"in modelNode&&(transformData.rotation=modelNode.GeometricRotation.value),"GeometricScaling"in modelNode&&(transformData.scale=modelNode.GeometricScaling.value);const transform=generateTransform(transformData);return this.genGeometry(geoNode,skeleton,morphTargets,transform)}genGeometry(geoNode,skeleton,morphTargets,preTransform){const geo=new BufferGeometry;geoNode.attrName&&(geo.name=geoNode.attrName);const geoInfo=this.parseGeoNode(geoNode,skeleton),buffers=this.genBuffers(geoInfo),positionAttribute=new Float32BufferAttribute(buffers.vertex,3);if(positionAttribute.applyMatrix4(preTransform),geo.setAttribute("position",positionAttribute),buffers.colors.length>0&&geo.setAttribute("color",new Float32BufferAttribute(buffers.colors,3)),skeleton&&(geo.setAttribute("skinIndex",new Uint16BufferAttribute(buffers.weightsIndices,4)),geo.setAttribute("skinWeight",new Float32BufferAttribute(buffers.vertexWeights,4)),geo.FBX_Deformer=skeleton),buffers.normal.length>0){const normalMatrix=new Matrix3().getNormalMatrix(preTransform),normalAttribute=new Float32BufferAttribute(buffers.normal,3);normalAttribute.applyNormalMatrix(normalMatrix),geo.setAttribute("normal",normalAttribute)}if(buffers.uvs.forEach(function(uvBuffer,i2){let name="uv"+(i2+1).toString();i2===0&&(name="uv"),geo.setAttribute(name,new Float32BufferAttribute(buffers.uvs[i2],2))}),geoInfo.material&&geoInfo.material.mappingType!=="AllSame"){let prevMaterialIndex=buffers.materialIndex[0],startIndex=0;if(buffers.materialIndex.forEach(function(currentIndex,i2){currentIndex!==prevMaterialIndex&&(geo.addGroup(startIndex,i2-startIndex,prevMaterialIndex),prevMaterialIndex=currentIndex,startIndex=i2)}),geo.groups.length>0){const lastGroup=geo.groups[geo.groups.length-1],lastIndex=lastGroup.start+lastGroup.count;lastIndex!==buffers.materialIndex.length&&geo.addGroup(lastIndex,buffers.materialIndex.length-lastIndex,prevMaterialIndex)}geo.groups.length===0&&geo.addGroup(0,buffers.materialIndex.length,buffers.materialIndex[0])}return this.addMorphTargets(geo,geoNode,morphTargets,preTransform),geo}parseGeoNode(geoNode,skeleton){const geoInfo={};if(geoInfo.vertexPositions=geoNode.Vertices!==void 0?geoNode.Vertices.a:[],geoInfo.vertexIndices=geoNode.PolygonVertexIndex!==void 0?geoNode.PolygonVertexIndex.a:[],geoNode.LayerElementColor&&(geoInfo.color=this.parseVertexColors(geoNode.LayerElementColor[0])),geoNode.LayerElementMaterial&&(geoInfo.material=this.parseMaterialIndices(geoNode.LayerElementMaterial[0])),geoNode.LayerElementNormal&&(geoInfo.normal=this.parseNormals(geoNode.LayerElementNormal[0])),geoNode.LayerElementUV){geoInfo.uv=[];let i2=0;for(;geoNode.LayerElementUV[i2];)geoNode.LayerElementUV[i2].UV&&geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i2])),i2++}return geoInfo.weightTable={},skeleton!==null&&(geoInfo.skeleton=skeleton,skeleton.rawBones.forEach(function(rawBone,i2){rawBone.indices.forEach(function(index,j2){geoInfo.weightTable[index]===void 0&&(geoInfo.weightTable[index]=[]),geoInfo.weightTable[index].push({id:i2,weight:rawBone.weights[j2]})})})),geoInfo}genBuffers(geoInfo){const buffers={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let polygonIndex=0,faceLength=0,displayedWeightsWarning=!1,facePositionIndexes=[],faceNormals=[],faceColors=[],faceUVs=[],faceWeights=[],faceWeightIndices=[];const scope=this;return geoInfo.vertexIndices.forEach(function(vertexIndex,polygonVertexIndex){let materialIndex,endOfFace=!1;vertexIndex<0&&(vertexIndex=vertexIndex^-1,endOfFace=!0);let weightIndices=[],weights=[];if(facePositionIndexes.push(vertexIndex*3,vertexIndex*3+1,vertexIndex*3+2),geoInfo.color){const data=getData(polygonVertexIndex,polygonIndex,vertexIndex,geoInfo.color);faceColors.push(data[0],data[1],data[2])}if(geoInfo.skeleton){if(geoInfo.weightTable[vertexIndex]!==void 0&&geoInfo.weightTable[vertexIndex].forEach(function(wt){weights.push(wt.weight),weightIndices.push(wt.id)}),weights.length>4){displayedWeightsWarning||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),displayedWeightsWarning=!0);const wIndex=[0,0,0,0],Weight=[0,0,0,0];weights.forEach(function(weight,weightIndex){let currentWeight=weight,currentIndex=weightIndices[weightIndex];Weight.forEach(function(comparedWeight,comparedWeightIndex,comparedWeightArray){if(currentWeight>comparedWeight){comparedWeightArray[comparedWeightIndex]=currentWeight,currentWeight=comparedWeight;const tmp2=wIndex[comparedWeightIndex];wIndex[comparedWeightIndex]=currentIndex,currentIndex=tmp2}})}),weightIndices=wIndex,weights=Weight}for(;weights.length<4;)weights.push(0),weightIndices.push(0);for(let i2=0;i2<4;++i2)faceWeights.push(weights[i2]),faceWeightIndices.push(weightIndices[i2])}if(geoInfo.normal){const data=getData(polygonVertexIndex,polygonIndex,vertexIndex,geoInfo.normal);faceNormals.push(data[0],data[1],data[2])}geoInfo.material&&geoInfo.material.mappingType!=="AllSame"&&(materialIndex=getData(polygonVertexIndex,polygonIndex,vertexIndex,geoInfo.material)[0]),geoInfo.uv&&geoInfo.uv.forEach(function(uv,i2){const data=getData(polygonVertexIndex,polygonIndex,vertexIndex,uv);faceUVs[i2]===void 0&&(faceUVs[i2]=[]),faceUVs[i2].push(data[0]),faceUVs[i2].push(data[1])}),faceLength++,endOfFace&&(scope.genFace(buffers,geoInfo,facePositionIndexes,materialIndex,faceNormals,faceColors,faceUVs,faceWeights,faceWeightIndices,faceLength),polygonIndex++,faceLength=0,facePositionIndexes=[],faceNormals=[],faceColors=[],faceUVs=[],faceWeights=[],faceWeightIndices=[])}),buffers}genFace(buffers,geoInfo,facePositionIndexes,materialIndex,faceNormals,faceColors,faceUVs,faceWeights,faceWeightIndices,faceLength){for(let i2=2;i2<faceLength;i2++)buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i2-1)*3]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i2-1)*3+1]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i2-1)*3+2]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2*3]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2*3+1]]),buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i2*3+2]]),geoInfo.skeleton&&(buffers.vertexWeights.push(faceWeights[0]),buffers.vertexWeights.push(faceWeights[1]),buffers.vertexWeights.push(faceWeights[2]),buffers.vertexWeights.push(faceWeights[3]),buffers.vertexWeights.push(faceWeights[(i2-1)*4]),buffers.vertexWeights.push(faceWeights[(i2-1)*4+1]),buffers.vertexWeights.push(faceWeights[(i2-1)*4+2]),buffers.vertexWeights.push(faceWeights[(i2-1)*4+3]),buffers.vertexWeights.push(faceWeights[i2*4]),buffers.vertexWeights.push(faceWeights[i2*4+1]),buffers.vertexWeights.push(faceWeights[i2*4+2]),buffers.vertexWeights.push(faceWeights[i2*4+3]),buffers.weightsIndices.push(faceWeightIndices[0]),buffers.weightsIndices.push(faceWeightIndices[1]),buffers.weightsIndices.push(faceWeightIndices[2]),buffers.weightsIndices.push(faceWeightIndices[3]),buffers.weightsIndices.push(faceWeightIndices[(i2-1)*4]),buffers.weightsIndices.push(faceWeightIndices[(i2-1)*4+1]),buffers.weightsIndices.push(faceWeightIndices[(i2-1)*4+2]),buffers.weightsIndices.push(faceWeightIndices[(i2-1)*4+3]),buffers.weightsIndices.push(faceWeightIndices[i2*4]),buffers.weightsIndices.push(faceWeightIndices[i2*4+1]),buffers.weightsIndices.push(faceWeightIndices[i2*4+2]),buffers.weightsIndices.push(faceWeightIndices[i2*4+3])),geoInfo.color&&(buffers.colors.push(faceColors[0]),buffers.colors.push(faceColors[1]),buffers.colors.push(faceColors[2]),buffers.colors.push(faceColors[(i2-1)*3]),buffers.colors.push(faceColors[(i2-1)*3+1]),buffers.colors.push(faceColors[(i2-1)*3+2]),buffers.colors.push(faceColors[i2*3]),buffers.colors.push(faceColors[i2*3+1]),buffers.colors.push(faceColors[i2*3+2])),geoInfo.material&&geoInfo.material.mappingType!=="AllSame"&&(buffers.materialIndex.push(materialIndex),buffers.materialIndex.push(materialIndex),buffers.materialIndex.push(materialIndex)),geoInfo.normal&&(buffers.normal.push(faceNormals[0]),buffers.normal.push(faceNormals[1]),buffers.normal.push(faceNormals[2]),buffers.normal.push(faceNormals[(i2-1)*3]),buffers.normal.push(faceNormals[(i2-1)*3+1]),buffers.normal.push(faceNormals[(i2-1)*3+2]),buffers.normal.push(faceNormals[i2*3]),buffers.normal.push(faceNormals[i2*3+1]),buffers.normal.push(faceNormals[i2*3+2])),geoInfo.uv&&geoInfo.uv.forEach(function(uv,j2){buffers.uvs[j2]===void 0&&(buffers.uvs[j2]=[]),buffers.uvs[j2].push(faceUVs[j2][0]),buffers.uvs[j2].push(faceUVs[j2][1]),buffers.uvs[j2].push(faceUVs[j2][(i2-1)*2]),buffers.uvs[j2].push(faceUVs[j2][(i2-1)*2+1]),buffers.uvs[j2].push(faceUVs[j2][i2*2]),buffers.uvs[j2].push(faceUVs[j2][i2*2+1])})}addMorphTargets(parentGeo,parentGeoNode,morphTargets,preTransform){if(morphTargets.length===0)return;parentGeo.morphTargetsRelative=!0,parentGeo.morphAttributes.position=[];const scope=this;morphTargets.forEach(function(morphTarget){morphTarget.rawTargets.forEach(function(rawTarget){const morphGeoNode=fbxTree.Objects.Geometry[rawTarget.geoID];morphGeoNode!==void 0&&scope.genMorphGeometry(parentGeo,parentGeoNode,morphGeoNode,preTransform,rawTarget.name)})})}genMorphGeometry(parentGeo,parentGeoNode,morphGeoNode,preTransform,name){const vertexIndices=parentGeoNode.PolygonVertexIndex!==void 0?parentGeoNode.PolygonVertexIndex.a:[],morphPositionsSparse=morphGeoNode.Vertices!==void 0?morphGeoNode.Vertices.a:[],indices=morphGeoNode.Indexes!==void 0?morphGeoNode.Indexes.a:[],length=parentGeo.attributes.position.count*3,morphPositions=new Float32Array(length);for(let i2=0;i2<indices.length;i2++){const morphIndex=indices[i2]*3;morphPositions[morphIndex]=morphPositionsSparse[i2*3],morphPositions[morphIndex+1]=morphPositionsSparse[i2*3+1],morphPositions[morphIndex+2]=morphPositionsSparse[i2*3+2]}const morphGeoInfo={vertexIndices,vertexPositions:morphPositions},morphBuffers=this.genBuffers(morphGeoInfo),positionAttribute=new Float32BufferAttribute(morphBuffers.vertex,3);positionAttribute.name=name||morphGeoNode.attrName,positionAttribute.applyMatrix4(preTransform),parentGeo.morphAttributes.position.push(positionAttribute)}parseNormals(NormalNode){const mappingType=NormalNode.MappingInformationType,referenceType=NormalNode.ReferenceInformationType,buffer=NormalNode.Normals.a;let indexBuffer=[];return referenceType==="IndexToDirect"&&("NormalIndex"in NormalNode?indexBuffer=NormalNode.NormalIndex.a:"NormalsIndex"in NormalNode&&(indexBuffer=NormalNode.NormalsIndex.a)),{dataSize:3,buffer,indices:indexBuffer,mappingType,referenceType}}parseUVs(UVNode){const mappingType=UVNode.MappingInformationType,referenceType=UVNode.ReferenceInformationType,buffer=UVNode.UV.a;let indexBuffer=[];return referenceType==="IndexToDirect"&&(indexBuffer=UVNode.UVIndex.a),{dataSize:2,buffer,indices:indexBuffer,mappingType,referenceType}}parseVertexColors(ColorNode){const mappingType=ColorNode.MappingInformationType,referenceType=ColorNode.ReferenceInformationType,buffer=ColorNode.Colors.a;let indexBuffer=[];return referenceType==="IndexToDirect"&&(indexBuffer=ColorNode.ColorIndex.a),{dataSize:4,buffer,indices:indexBuffer,mappingType,referenceType}}parseMaterialIndices(MaterialNode){const mappingType=MaterialNode.MappingInformationType,referenceType=MaterialNode.ReferenceInformationType;if(mappingType==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType};const materialIndexBuffer=MaterialNode.Materials.a,materialIndices=[];for(let i2=0;i2<materialIndexBuffer.length;++i2)materialIndices.push(i2);return{dataSize:1,buffer:materialIndexBuffer,indices:materialIndices,mappingType,referenceType}}parseNurbsGeometry(geoNode){if(NURBSCurve===void 0)return console.error("THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry."),new BufferGeometry;const order=parseInt(geoNode.Order);if(isNaN(order))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",geoNode.Order,geoNode.id),new BufferGeometry;const degree=order-1,knots=geoNode.KnotVector.a,controlPoints=[],pointsValues=geoNode.Points.a;for(let i2=0,l2=pointsValues.length;i2<l2;i2+=4)controlPoints.push(new Vector4().fromArray(pointsValues,i2));let startKnot,endKnot;if(geoNode.Form==="Closed")controlPoints.push(controlPoints[0]);else if(geoNode.Form==="Periodic"){startKnot=degree,endKnot=knots.length-1-startKnot;for(let i2=0;i2<degree;++i2)controlPoints.push(controlPoints[i2])}const points=new NURBSCurve(degree,knots,controlPoints,startKnot,endKnot).getPoints(controlPoints.length*12);return new BufferGeometry().setFromPoints(points)}}class AnimationParser{parse(){const animationClips=[],rawClips=this.parseClips();if(rawClips!==void 0)for(const key in rawClips){const rawClip=rawClips[key],clip=this.addClip(rawClip);animationClips.push(clip)}return animationClips}parseClips(){if(fbxTree.Objects.AnimationCurve===void 0)return;const curveNodesMap=this.parseAnimationCurveNodes();this.parseAnimationCurves(curveNodesMap);const layersMap=this.parseAnimationLayers(curveNodesMap);return this.parseAnimStacks(layersMap)}parseAnimationCurveNodes(){const rawCurveNodes=fbxTree.Objects.AnimationCurveNode,curveNodesMap=new Map;for(const nodeID in rawCurveNodes){const rawCurveNode=rawCurveNodes[nodeID];if(rawCurveNode.attrName.match(/S|R|T|DeformPercent/)!==null){const curveNode={id:rawCurveNode.id,attr:rawCurveNode.attrName,curves:{}};curveNodesMap.set(curveNode.id,curveNode)}}return curveNodesMap}parseAnimationCurves(curveNodesMap){const rawCurves=fbxTree.Objects.AnimationCurve;for(const nodeID in rawCurves){const animationCurve={id:rawCurves[nodeID].id,times:rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),values:rawCurves[nodeID].KeyValueFloat.a},relationships=connections.get(animationCurve.id);if(relationships!==void 0){const animationCurveID=relationships.parents[0].ID,animationCurveRelationship=relationships.parents[0].relationship;animationCurveRelationship.match(/X/)?curveNodesMap.get(animationCurveID).curves.x=animationCurve:animationCurveRelationship.match(/Y/)?curveNodesMap.get(animationCurveID).curves.y=animationCurve:animationCurveRelationship.match(/Z/)?curveNodesMap.get(animationCurveID).curves.z=animationCurve:animationCurveRelationship.match(/d|DeformPercent/)&&curveNodesMap.has(animationCurveID)&&(curveNodesMap.get(animationCurveID).curves.morph=animationCurve)}}}parseAnimationLayers(curveNodesMap){const rawLayers=fbxTree.Objects.AnimationLayer,layersMap=new Map;for(const nodeID in rawLayers){const layerCurveNodes=[],connection=connections.get(parseInt(nodeID));connection!==void 0&&(connection.children.forEach(function(child,i2){if(curveNodesMap.has(child.ID)){const curveNode=curveNodesMap.get(child.ID);if(curveNode.curves.x!==void 0||curveNode.curves.y!==void 0||curveNode.curves.z!==void 0){if(layerCurveNodes[i2]===void 0){const modelID=connections.get(child.ID).parents.filter(function(parent){return parent.relationship!==void 0})[0].ID;if(modelID!==void 0){const rawModel=fbxTree.Objects.Model[modelID.toString()];if(rawModel===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",child);return}const node={modelName:rawModel.attrName?PropertyBinding.sanitizeNodeName(rawModel.attrName):"",ID:rawModel.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};sceneGraph.traverse(function(child2){child2.ID===rawModel.id&&(node.transform=child2.matrix,child2.userData.transformData&&(node.eulerOrder=child2.userData.transformData.eulerOrder))}),node.transform||(node.transform=new Matrix4),"PreRotation"in rawModel&&(node.preRotation=rawModel.PreRotation.value),"PostRotation"in rawModel&&(node.postRotation=rawModel.PostRotation.value),layerCurveNodes[i2]=node}}layerCurveNodes[i2]&&(layerCurveNodes[i2][curveNode.attr]=curveNode)}else if(curveNode.curves.morph!==void 0){if(layerCurveNodes[i2]===void 0){const deformerID=connections.get(child.ID).parents.filter(function(parent){return parent.relationship!==void 0})[0].ID,morpherID=connections.get(deformerID).parents[0].ID,geoID=connections.get(morpherID).parents[0].ID,modelID=connections.get(geoID).parents[0].ID,rawModel=fbxTree.Objects.Model[modelID],node={modelName:rawModel.attrName?PropertyBinding.sanitizeNodeName(rawModel.attrName):"",morphName:fbxTree.Objects.Deformer[deformerID].attrName};layerCurveNodes[i2]=node}layerCurveNodes[i2][curveNode.attr]=curveNode}}}),layersMap.set(parseInt(nodeID),layerCurveNodes))}return layersMap}parseAnimStacks(layersMap){const rawStacks=fbxTree.Objects.AnimationStack,rawClips={};for(const nodeID in rawStacks){const children=connections.get(parseInt(nodeID)).children;children.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const layer=layersMap.get(children[0].ID);rawClips[nodeID]={name:rawStacks[nodeID].attrName,layer}}return rawClips}addClip(rawClip){let tracks=[];const scope=this;return rawClip.layer.forEach(function(rawTracks){tracks=tracks.concat(scope.generateTracks(rawTracks))}),new AnimationClip(rawClip.name,-1,tracks)}generateTracks(rawTracks){const tracks=[];let initialPosition=new Vector3,initialRotation=new Quaternion,initialScale=new Vector3;if(rawTracks.transform&&rawTracks.transform.decompose(initialPosition,initialRotation,initialScale),initialPosition=initialPosition.toArray(),initialRotation=new Euler().setFromQuaternion(initialRotation,rawTracks.eulerOrder).toArray(),initialScale=initialScale.toArray(),rawTracks.T!==void 0&&Object.keys(rawTracks.T.curves).length>0){const positionTrack=this.generateVectorTrack(rawTracks.modelName,rawTracks.T.curves,initialPosition,"position");positionTrack!==void 0&&tracks.push(positionTrack)}if(rawTracks.R!==void 0&&Object.keys(rawTracks.R.curves).length>0){const rotationTrack=this.generateRotationTrack(rawTracks.modelName,rawTracks.R.curves,initialRotation,rawTracks.preRotation,rawTracks.postRotation,rawTracks.eulerOrder);rotationTrack!==void 0&&tracks.push(rotationTrack)}if(rawTracks.S!==void 0&&Object.keys(rawTracks.S.curves).length>0){const scaleTrack=this.generateVectorTrack(rawTracks.modelName,rawTracks.S.curves,initialScale,"scale");scaleTrack!==void 0&&tracks.push(scaleTrack)}if(rawTracks.DeformPercent!==void 0){const morphTrack=this.generateMorphTrack(rawTracks);morphTrack!==void 0&&tracks.push(morphTrack)}return tracks}generateVectorTrack(modelName,curves,initialValue,type){const times=this.getTimesForAllAxes(curves),values=this.getKeyframeTrackValues(times,curves,initialValue);return new VectorKeyframeTrack(modelName+"."+type,times,values)}generateRotationTrack(modelName,curves,initialValue,preRotation,postRotation,eulerOrder){curves.x!==void 0&&(this.interpolateRotations(curves.x),curves.x.values=curves.x.values.map(MathUtils.degToRad)),curves.y!==void 0&&(this.interpolateRotations(curves.y),curves.y.values=curves.y.values.map(MathUtils.degToRad)),curves.z!==void 0&&(this.interpolateRotations(curves.z),curves.z.values=curves.z.values.map(MathUtils.degToRad));const times=this.getTimesForAllAxes(curves),values=this.getKeyframeTrackValues(times,curves,initialValue);preRotation!==void 0&&(preRotation=preRotation.map(MathUtils.degToRad),preRotation.push(eulerOrder),preRotation=new Euler().fromArray(preRotation),preRotation=new Quaternion().setFromEuler(preRotation)),postRotation!==void 0&&(postRotation=postRotation.map(MathUtils.degToRad),postRotation.push(eulerOrder),postRotation=new Euler().fromArray(postRotation),postRotation=new Quaternion().setFromEuler(postRotation).invert());const quaternion=new Quaternion,euler=new Euler,quaternionValues=[];for(let i2=0;i2<values.length;i2+=3)euler.set(values[i2],values[i2+1],values[i2+2],eulerOrder),quaternion.setFromEuler(euler),preRotation!==void 0&&quaternion.premultiply(preRotation),postRotation!==void 0&&quaternion.multiply(postRotation),quaternion.toArray(quaternionValues,i2/3*4);return new QuaternionKeyframeTrack(modelName+".quaternion",times,quaternionValues)}generateMorphTrack(rawTracks){const curves=rawTracks.DeformPercent.curves.morph,values=curves.values.map(function(val){return val/100}),morphNum=sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];return new NumberKeyframeTrack(rawTracks.modelName+".morphTargetInfluences["+morphNum+"]",curves.times,values)}getTimesForAllAxes(curves){let times=[];if(curves.x!==void 0&&(times=times.concat(curves.x.times)),curves.y!==void 0&&(times=times.concat(curves.y.times)),curves.z!==void 0&&(times=times.concat(curves.z.times)),times=times.sort(function(a2,b2){return a2-b2}),times.length>1){let targetIndex=1,lastValue=times[0];for(let i2=1;i2<times.length;i2++){const currentValue=times[i2];currentValue!==lastValue&&(times[targetIndex]=currentValue,lastValue=currentValue,targetIndex++)}times=times.slice(0,targetIndex)}return times}getKeyframeTrackValues(times,curves,initialValue){const prevValue=initialValue,values=[];let xIndex=-1,yIndex=-1,zIndex=-1;return times.forEach(function(time){if(curves.x&&(xIndex=curves.x.times.indexOf(time)),curves.y&&(yIndex=curves.y.times.indexOf(time)),curves.z&&(zIndex=curves.z.times.indexOf(time)),xIndex!==-1){const xValue=curves.x.values[xIndex];values.push(xValue),prevValue[0]=xValue}else values.push(prevValue[0]);if(yIndex!==-1){const yValue=curves.y.values[yIndex];values.push(yValue),prevValue[1]=yValue}else values.push(prevValue[1]);if(zIndex!==-1){const zValue=curves.z.values[zIndex];values.push(zValue),prevValue[2]=zValue}else values.push(prevValue[2])}),values}interpolateRotations(curve){for(let i2=1;i2<curve.values.length;i2++){const initialValue=curve.values[i2-1],valuesSpan=curve.values[i2]-initialValue,absoluteSpan=Math.abs(valuesSpan);if(absoluteSpan>=180){const numSubIntervals=absoluteSpan/180,step=valuesSpan/numSubIntervals;let nextValue=initialValue+step;const initialTime=curve.times[i2-1],interval=(curve.times[i2]-initialTime)/numSubIntervals;let nextTime=initialTime+interval;const interpolatedTimes=[],interpolatedValues=[];for(;nextTime<curve.times[i2];)interpolatedTimes.push(nextTime),nextTime+=interval,interpolatedValues.push(nextValue),nextValue+=step;curve.times=inject(curve.times,i2,interpolatedTimes),curve.values=inject(curve.values,i2,interpolatedValues)}}}}class TextParser{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(node){this.nodeStack.push(node),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(val,name){this.currentProp=val,this.currentPropName=name}parse(text){this.currentIndent=0,this.allNodes=new FBXTree,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const scope=this,split=text.split(/[\r\n]+/);return split.forEach(function(line,i2){const matchComment=line.match(/^[\s\t]*;/),matchEmpty=line.match(/^[\s\t]*$/);if(matchComment||matchEmpty)return;const matchBeginning=line.match("^\\t{"+scope.currentIndent+"}(\\w+):(.*){",""),matchProperty=line.match("^\\t{"+scope.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),matchEnd=line.match("^\\t{"+(scope.currentIndent-1)+"}}");matchBeginning?scope.parseNodeBegin(line,matchBeginning):matchProperty?scope.parseNodeProperty(line,matchProperty,split[++i2]):matchEnd?scope.popStack():line.match(/^[^\s\t}]/)&&scope.parseNodePropertyContinued(line)}),this.allNodes}parseNodeBegin(line,property){const nodeName=property[1].trim().replace(/^"/,"").replace(/"$/,""),nodeAttrs=property[2].split(",").map(function(attr){return attr.trim().replace(/^"/,"").replace(/"$/,"")}),node={name:nodeName},attrs=this.parseNodeAttr(nodeAttrs),currentNode=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(nodeName,node):nodeName in currentNode?(nodeName==="PoseNode"?currentNode.PoseNode.push(node):currentNode[nodeName].id!==void 0&&(currentNode[nodeName]={},currentNode[nodeName][currentNode[nodeName].id]=currentNode[nodeName]),attrs.id!==""&&(currentNode[nodeName][attrs.id]=node)):typeof attrs.id=="number"?(currentNode[nodeName]={},currentNode[nodeName][attrs.id]=node):nodeName!=="Properties70"&&(nodeName==="PoseNode"?currentNode[nodeName]=[node]:currentNode[nodeName]=node),typeof attrs.id=="number"&&(node.id=attrs.id),attrs.name!==""&&(node.attrName=attrs.name),attrs.type!==""&&(node.attrType=attrs.type),this.pushStack(node)}parseNodeAttr(attrs){let id2=attrs[0];attrs[0]!==""&&(id2=parseInt(attrs[0]),isNaN(id2)&&(id2=attrs[0]));let name="",type="";return attrs.length>1&&(name=attrs[1].replace(/^(\w+)::/,""),type=attrs[2]),{id:id2,name,type}}parseNodeProperty(line,property,contentLine){let propName=property[1].replace(/^"/,"").replace(/"$/,"").trim(),propValue=property[2].replace(/^"/,"").replace(/"$/,"").trim();propName==="Content"&&propValue===","&&(propValue=contentLine.replace(/"/g,"").replace(/,$/,"").trim());const currentNode=this.getCurrentNode();if(currentNode.name==="Properties70"){this.parseNodeSpecialProperty(line,propName,propValue);return}if(propName==="C"){const connProps=propValue.split(",").slice(1),from=parseInt(connProps[0]),to=parseInt(connProps[1]);let rest=propValue.split(",").slice(3);rest=rest.map(function(elem){return elem.trim().replace(/^"/,"")}),propName="connections",propValue=[from,to],append(propValue,rest),currentNode[propName]===void 0&&(currentNode[propName]=[])}propName==="Node"&&(currentNode.id=propValue),propName in currentNode&&Array.isArray(currentNode[propName])?currentNode[propName].push(propValue):propName!=="a"?currentNode[propName]=propValue:currentNode.a=propValue,this.setCurrentProp(currentNode,propName),propName==="a"&&propValue.slice(-1)!==","&&(currentNode.a=parseNumberArray(propValue))}parseNodePropertyContinued(line){const currentNode=this.getCurrentNode();currentNode.a+=line,line.slice(-1)!==","&&(currentNode.a=parseNumberArray(currentNode.a))}parseNodeSpecialProperty(line,propName,propValue){const props=propValue.split('",').map(function(prop){return prop.trim().replace(/^\"/,"").replace(/\s/,"_")}),innerPropName=props[0],innerPropType1=props[1],innerPropType2=props[2],innerPropFlag=props[3];let innerPropValue=props[4];switch(innerPropType1){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":innerPropValue=parseFloat(innerPropValue);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":innerPropValue=parseNumberArray(innerPropValue);break}this.getPrevNode()[innerPropName]={type:innerPropType1,type2:innerPropType2,flag:innerPropFlag,value:innerPropValue},this.setCurrentProp(this.getPrevNode(),innerPropName)}}class BinaryParser{parse(buffer){const reader=new BinaryReader(buffer);reader.skip(23);const version2=reader.getUint32();if(version2<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+version2);const allNodes=new FBXTree;for(;!this.endOfContent(reader);){const node=this.parseNode(reader,version2);node!==null&&allNodes.add(node.name,node)}return allNodes}endOfContent(reader){return reader.size()%16===0?(reader.getOffset()+160+16&-16)>=reader.size():reader.getOffset()+160+16>=reader.size()}parseNode(reader,version2){const node={},endOffset=version2>=7500?reader.getUint64():reader.getUint32(),numProperties=version2>=7500?reader.getUint64():reader.getUint32();version2>=7500?reader.getUint64():reader.getUint32();const nameLen=reader.getUint8(),name=reader.getString(nameLen);if(endOffset===0)return null;const propertyList=[];for(let i2=0;i2<numProperties;i2++)propertyList.push(this.parseProperty(reader));const id2=propertyList.length>0?propertyList[0]:"",attrName=propertyList.length>1?propertyList[1]:"",attrType=propertyList.length>2?propertyList[2]:"";for(node.singleProperty=numProperties===1&&reader.getOffset()===endOffset;endOffset>reader.getOffset();){const subNode=this.parseNode(reader,version2);subNode!==null&&this.parseSubNode(name,node,subNode)}return node.propertyList=propertyList,typeof id2=="number"&&(node.id=id2),attrName!==""&&(node.attrName=attrName),attrType!==""&&(node.attrType=attrType),name!==""&&(node.name=name),node}parseSubNode(name,node,subNode){if(subNode.singleProperty===!0){const value=subNode.propertyList[0];Array.isArray(value)?(node[subNode.name]=subNode,subNode.a=value):node[subNode.name]=value}else if(name==="Connections"&&subNode.name==="C"){const array=[];subNode.propertyList.forEach(function(property,i2){i2!==0&&array.push(property)}),node.connections===void 0&&(node.connections=[]),node.connections.push(array)}else if(subNode.name==="Properties70")Object.keys(subNode).forEach(function(key){node[key]=subNode[key]});else if(name==="Properties70"&&subNode.name==="P"){let innerPropName=subNode.propertyList[0],innerPropType1=subNode.propertyList[1];const innerPropType2=subNode.propertyList[2],innerPropFlag=subNode.propertyList[3];let innerPropValue;innerPropName.indexOf("Lcl ")===0&&(innerPropName=innerPropName.replace("Lcl ","Lcl_")),innerPropType1.indexOf("Lcl ")===0&&(innerPropType1=innerPropType1.replace("Lcl ","Lcl_")),innerPropType1==="Color"||innerPropType1==="ColorRGB"||innerPropType1==="Vector"||innerPropType1==="Vector3D"||innerPropType1.indexOf("Lcl_")===0?innerPropValue=[subNode.propertyList[4],subNode.propertyList[5],subNode.propertyList[6]]:innerPropValue=subNode.propertyList[4],node[innerPropName]={type:innerPropType1,type2:innerPropType2,flag:innerPropFlag,value:innerPropValue}}else node[subNode.name]===void 0?typeof subNode.id=="number"?(node[subNode.name]={},node[subNode.name][subNode.id]=subNode):node[subNode.name]=subNode:subNode.name==="PoseNode"?(Array.isArray(node[subNode.name])||(node[subNode.name]=[node[subNode.name]]),node[subNode.name].push(subNode)):node[subNode.name][subNode.id]===void 0&&(node[subNode.name][subNode.id]=subNode)}parseProperty(reader){const type=reader.getString(1);let length;switch(type){case"C":return reader.getBoolean();case"D":return reader.getFloat64();case"F":return reader.getFloat32();case"I":return reader.getInt32();case"L":return reader.getInt64();case"R":return length=reader.getUint32(),reader.getArrayBuffer(length);case"S":return length=reader.getUint32(),reader.getString(length);case"Y":return reader.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const arrayLength=reader.getUint32(),encoding=reader.getUint32(),compressedLength=reader.getUint32();if(encoding===0)switch(type){case"b":case"c":return reader.getBooleanArray(arrayLength);case"d":return reader.getFloat64Array(arrayLength);case"f":return reader.getFloat32Array(arrayLength);case"i":return reader.getInt32Array(arrayLength);case"l":return reader.getInt64Array(arrayLength)}const data=unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength))),reader2=new BinaryReader(data.buffer);switch(type){case"b":case"c":return reader2.getBooleanArray(arrayLength);case"d":return reader2.getFloat64Array(arrayLength);case"f":return reader2.getFloat32Array(arrayLength);case"i":return reader2.getInt32Array(arrayLength);case"l":return reader2.getInt64Array(arrayLength)}default:throw new Error("THREE.FBXLoader: Unknown property type "+type)}}}class BinaryReader{constructor(buffer,littleEndian){this.dv=new DataView(buffer),this.offset=0,this.littleEndian=littleEndian!==void 0?littleEndian:!0}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(length){this.offset+=length}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(size){const a2=[];for(let i2=0;i2<size;i2++)a2.push(this.getBoolean());return a2}getUint8(){const value=this.dv.getUint8(this.offset);return this.offset+=1,value}getInt16(){const value=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,value}getInt32(){const value=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,value}getInt32Array(size){const a2=[];for(let i2=0;i2<size;i2++)a2.push(this.getInt32());return a2}getUint32(){const value=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,value}getInt64(){let low,high;return this.littleEndian?(low=this.getUint32(),high=this.getUint32()):(high=this.getUint32(),low=this.getUint32()),high&2147483648?(high=~high&4294967295,low=~low&4294967295,low===4294967295&&(high=high+1&4294967295),low=low+1&4294967295,-(high*4294967296+low)):high*4294967296+low}getInt64Array(size){const a2=[];for(let i2=0;i2<size;i2++)a2.push(this.getInt64());return a2}getUint64(){let low,high;return this.littleEndian?(low=this.getUint32(),high=this.getUint32()):(high=this.getUint32(),low=this.getUint32()),high*4294967296+low}getFloat32(){const value=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,value}getFloat32Array(size){const a2=[];for(let i2=0;i2<size;i2++)a2.push(this.getFloat32());return a2}getFloat64(){const value=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,value}getFloat64Array(size){const a2=[];for(let i2=0;i2<size;i2++)a2.push(this.getFloat64());return a2}getArrayBuffer(size){const value=this.dv.buffer.slice(this.offset,this.offset+size);return this.offset+=size,value}getString(size){let a2=[];for(let i2=0;i2<size;i2++)a2[i2]=this.getUint8();const nullByte=a2.indexOf(0);return nullByte>=0&&(a2=a2.slice(0,nullByte)),LoaderUtils.decodeText(new Uint8Array(a2))}}class FBXTree{add(key,val){this[key]=val}}function isFbxFormatBinary(buffer){const CORRECT="Kaydara FBX Binary  \0";return buffer.byteLength>=CORRECT.length&&CORRECT===convertArrayBufferToString(buffer,0,CORRECT.length)}function isFbxFormatASCII(text){const CORRECT=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let cursor=0;function read(offset){const result=text[offset-1];return text=text.slice(cursor+offset),cursor++,result}for(let i2=0;i2<CORRECT.length;++i2)if(read(1)===CORRECT[i2])return!1;return!0}function getFbxVersion(text){const versionRegExp=/FBXVersion: (\d+)/,match=text.match(versionRegExp);if(match)return parseInt(match[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function convertFBXTimeToSeconds(time){return time/46186158e3}const dataArray=[];function getData(polygonVertexIndex,polygonIndex,vertexIndex,infoObject){let index;switch(infoObject.mappingType){case"ByPolygonVertex":index=polygonVertexIndex;break;case"ByPolygon":index=polygonIndex;break;case"ByVertice":index=vertexIndex;break;case"AllSame":index=infoObject.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+infoObject.mappingType)}infoObject.referenceType==="IndexToDirect"&&(index=infoObject.indices[index]);const from=index*infoObject.dataSize,to=from+infoObject.dataSize;return slice(dataArray,infoObject.buffer,from,to)}const tempEuler=new Euler,tempVec=new Vector3;function generateTransform(transformData){const lTranslationM=new Matrix4,lPreRotationM=new Matrix4,lRotationM=new Matrix4,lPostRotationM=new Matrix4,lScalingM=new Matrix4,lScalingPivotM=new Matrix4,lScalingOffsetM=new Matrix4,lRotationOffsetM=new Matrix4,lRotationPivotM=new Matrix4,lParentGX=new Matrix4,lParentLX=new Matrix4,lGlobalT=new Matrix4,inheritType=transformData.inheritType?transformData.inheritType:0;if(transformData.translation&&lTranslationM.setPosition(tempVec.fromArray(transformData.translation)),transformData.preRotation){const array=transformData.preRotation.map(MathUtils.degToRad);array.push(transformData.eulerOrder),lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array))}if(transformData.rotation){const array=transformData.rotation.map(MathUtils.degToRad);array.push(transformData.eulerOrder),lRotationM.makeRotationFromEuler(tempEuler.fromArray(array))}if(transformData.postRotation){const array=transformData.postRotation.map(MathUtils.degToRad);array.push(transformData.eulerOrder),lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array)),lPostRotationM.invert()}transformData.scale&&lScalingM.scale(tempVec.fromArray(transformData.scale)),transformData.scalingOffset&&lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset)),transformData.scalingPivot&&lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot)),transformData.rotationOffset&&lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset)),transformData.rotationPivot&&lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot)),transformData.parentMatrixWorld&&(lParentLX.copy(transformData.parentMatrix),lParentGX.copy(transformData.parentMatrixWorld));const lLRM=lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM),lParentGRM=new Matrix4;lParentGRM.extractRotation(lParentGX);const lParentTM=new Matrix4;lParentTM.copyPosition(lParentGX);const lParentGRSM=lParentTM.clone().invert().multiply(lParentGX),lParentGSM=lParentGRM.clone().invert().multiply(lParentGRSM),lLSM=lScalingM,lGlobalRS=new Matrix4;if(inheritType===0)lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);else if(inheritType===1)lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);else{const lParentLSM_inv=new Matrix4().scale(new Vector3().setFromMatrixScale(lParentLX)).clone().invert(),lParentGSM_noLocal=lParentGSM.clone().multiply(lParentLSM_inv);lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM)}const lRotationPivotM_inv=lRotationPivotM.clone().invert(),lScalingPivotM_inv=lScalingPivotM.clone().invert();let lTransform=lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);const lLocalTWithAllPivotAndOffsetInfo=new Matrix4().copyPosition(lTransform),lGlobalTranslation=lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);return lGlobalT.copyPosition(lGlobalTranslation),lTransform=lGlobalT.clone().multiply(lGlobalRS),lTransform.premultiply(lParentGX.invert()),lTransform}function getEulerOrder(order){order=order||0;const enums=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return order===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),enums[0]):enums[order]}function parseNumberArray(value){return value.split(",").map(function(val){return parseFloat(val)})}function convertArrayBufferToString(buffer,from,to){return from===void 0&&(from=0),to===void 0&&(to=buffer.byteLength),LoaderUtils.decodeText(new Uint8Array(buffer,from,to))}function append(a2,b2){for(let i2=0,j2=a2.length,l2=b2.length;i2<l2;i2++,j2++)a2[j2]=b2[i2]}function slice(a2,b2,from,to){for(let i2=from,j2=0;i2<to;i2++,j2++)a2[j2]=b2[i2];return a2}function inject(a1,index,a2){return a1.slice(0,index).concat(a2).concat(a1.slice(index))}class SVGLoader extends Loader{constructor(manager){super(manager),this.defaultDPI=90,this.defaultUnit="px"}load(url,onLoad,onProgress,onError){const scope=this,loader=new FileLoader(scope.manager);loader.setPath(scope.path),loader.setRequestHeader(scope.requestHeader),loader.setWithCredentials(scope.withCredentials),loader.load(url,function(text){try{onLoad(scope.parse(text))}catch(e2){onError?onError(e2):console.error(e2),scope.manager.itemError(url)}},onProgress,onError)}parse(text){const scope=this;function parseNode(node,style){if(node.nodeType!==1)return;const transform=getNodeTransform(node);let traverseChildNodes=!0,path2=null;switch(node.nodeName){case"svg":break;case"style":parseCSSStylesheet(node);break;case"g":style=parseStyle(node,style);break;case"path":style=parseStyle(node,style),node.hasAttribute("d")&&(path2=parsePathNode(node));break;case"rect":style=parseStyle(node,style),path2=parseRectNode(node);break;case"polygon":style=parseStyle(node,style),path2=parsePolygonNode(node);break;case"polyline":style=parseStyle(node,style),path2=parsePolylineNode(node);break;case"circle":style=parseStyle(node,style),path2=parseCircleNode(node);break;case"ellipse":style=parseStyle(node,style),path2=parseEllipseNode(node);break;case"line":style=parseStyle(node,style),path2=parseLineNode(node);break;case"defs":traverseChildNodes=!1;break;case"mask":traverseChildNodes=!1;break;case"use":style=parseStyle(node,style);const usedNodeId=node.href.baseVal.substring(1),usedNode=node.viewportElement.getElementById(usedNodeId);usedNode?parseNode(usedNode,style):console.warn("SVGLoader: 'use node' references non-existent node id: "+usedNodeId);break}if(path2&&(style.fill!==void 0&&style.fill!=="none"&&path2.color.setStyle(style.fill),transformPath(path2,currentTransform),paths2.push(path2),path2.userData={node,style}),traverseChildNodes){const nodes=node.childNodes;for(let i2=0;i2<nodes.length;i2++)parseNode(nodes[i2],style)}transform&&(transformStack.pop(),transformStack.length>0?currentTransform.copy(transformStack[transformStack.length-1]):currentTransform.identity())}function parsePathNode(node){const path2=new ShapePath,point=new Vector2,control=new Vector2,firstPoint=new Vector2;let isFirstPoint=!0,doSetFirstPoint=!1;const commands=node.getAttribute("d").match(/[a-df-z][^a-df-z]*/gi);for(let i2=0,l2=commands.length;i2<l2;i2++){const command=commands[i2],type=command.charAt(0),data2=command.substr(1).trim();isFirstPoint===!0&&(doSetFirstPoint=!0,isFirstPoint=!1);let numbers;switch(type){case"M":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2+=2)point.x=numbers[j2+0],point.y=numbers[j2+1],control.x=point.x,control.y=point.y,j2===0?path2.moveTo(point.x,point.y):path2.lineTo(point.x,point.y),j2===0&&firstPoint.copy(point);break;case"H":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2++)point.x=numbers[j2],control.x=point.x,control.y=point.y,path2.lineTo(point.x,point.y),j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point);break;case"V":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2++)point.y=numbers[j2],control.x=point.x,control.y=point.y,path2.lineTo(point.x,point.y),j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point);break;case"L":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2+=2)point.x=numbers[j2+0],point.y=numbers[j2+1],control.x=point.x,control.y=point.y,path2.lineTo(point.x,point.y),j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point);break;case"C":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2+=6)path2.bezierCurveTo(numbers[j2+0],numbers[j2+1],numbers[j2+2],numbers[j2+3],numbers[j2+4],numbers[j2+5]),control.x=numbers[j2+2],control.y=numbers[j2+3],point.x=numbers[j2+4],point.y=numbers[j2+5],j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point);break;case"S":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2+=4)path2.bezierCurveTo(getReflection(point.x,control.x),getReflection(point.y,control.y),numbers[j2+0],numbers[j2+1],numbers[j2+2],numbers[j2+3]),control.x=numbers[j2+0],control.y=numbers[j2+1],point.x=numbers[j2+2],point.y=numbers[j2+3],j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point);break;case"Q":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2+=4)path2.quadraticCurveTo(numbers[j2+0],numbers[j2+1],numbers[j2+2],numbers[j2+3]),control.x=numbers[j2+0],control.y=numbers[j2+1],point.x=numbers[j2+2],point.y=numbers[j2+3],j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point);break;case"T":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2+=2){const rx=getReflection(point.x,control.x),ry=getReflection(point.y,control.y);path2.quadraticCurveTo(rx,ry,numbers[j2+0],numbers[j2+1]),control.x=rx,control.y=ry,point.x=numbers[j2+0],point.y=numbers[j2+1],j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point)}break;case"A":numbers=parseFloats(data2,[3,4],7);for(let j2=0,jl=numbers.length;j2<jl;j2+=7){if(numbers[j2+5]==point.x&&numbers[j2+6]==point.y)continue;const start=point.clone();point.x=numbers[j2+5],point.y=numbers[j2+6],control.x=point.x,control.y=point.y,parseArcCommand(path2,numbers[j2],numbers[j2+1],numbers[j2+2],numbers[j2+3],numbers[j2+4],start,point),j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point)}break;case"m":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2+=2)point.x+=numbers[j2+0],point.y+=numbers[j2+1],control.x=point.x,control.y=point.y,j2===0?path2.moveTo(point.x,point.y):path2.lineTo(point.x,point.y),j2===0&&firstPoint.copy(point);break;case"h":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2++)point.x+=numbers[j2],control.x=point.x,control.y=point.y,path2.lineTo(point.x,point.y),j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point);break;case"v":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2++)point.y+=numbers[j2],control.x=point.x,control.y=point.y,path2.lineTo(point.x,point.y),j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point);break;case"l":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2+=2)point.x+=numbers[j2+0],point.y+=numbers[j2+1],control.x=point.x,control.y=point.y,path2.lineTo(point.x,point.y),j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point);break;case"c":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2+=6)path2.bezierCurveTo(point.x+numbers[j2+0],point.y+numbers[j2+1],point.x+numbers[j2+2],point.y+numbers[j2+3],point.x+numbers[j2+4],point.y+numbers[j2+5]),control.x=point.x+numbers[j2+2],control.y=point.y+numbers[j2+3],point.x+=numbers[j2+4],point.y+=numbers[j2+5],j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point);break;case"s":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2+=4)path2.bezierCurveTo(getReflection(point.x,control.x),getReflection(point.y,control.y),point.x+numbers[j2+0],point.y+numbers[j2+1],point.x+numbers[j2+2],point.y+numbers[j2+3]),control.x=point.x+numbers[j2+0],control.y=point.y+numbers[j2+1],point.x+=numbers[j2+2],point.y+=numbers[j2+3],j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point);break;case"q":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2+=4)path2.quadraticCurveTo(point.x+numbers[j2+0],point.y+numbers[j2+1],point.x+numbers[j2+2],point.y+numbers[j2+3]),control.x=point.x+numbers[j2+0],control.y=point.y+numbers[j2+1],point.x+=numbers[j2+2],point.y+=numbers[j2+3],j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point);break;case"t":numbers=parseFloats(data2);for(let j2=0,jl=numbers.length;j2<jl;j2+=2){const rx=getReflection(point.x,control.x),ry=getReflection(point.y,control.y);path2.quadraticCurveTo(rx,ry,point.x+numbers[j2+0],point.y+numbers[j2+1]),control.x=rx,control.y=ry,point.x=point.x+numbers[j2+0],point.y=point.y+numbers[j2+1],j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point)}break;case"a":numbers=parseFloats(data2,[3,4],7);for(let j2=0,jl=numbers.length;j2<jl;j2+=7){if(numbers[j2+5]==0&&numbers[j2+6]==0)continue;const start=point.clone();point.x+=numbers[j2+5],point.y+=numbers[j2+6],control.x=point.x,control.y=point.y,parseArcCommand(path2,numbers[j2],numbers[j2+1],numbers[j2+2],numbers[j2+3],numbers[j2+4],start,point),j2===0&&doSetFirstPoint===!0&&firstPoint.copy(point)}break;case"Z":case"z":path2.currentPath.autoClose=!0,path2.currentPath.curves.length>0&&(point.copy(firstPoint),path2.currentPath.currentPoint.copy(point),isFirstPoint=!0);break;default:console.warn(command)}doSetFirstPoint=!1}return path2}function parseCSSStylesheet(node){if(!(!node.sheet||!node.sheet.cssRules||!node.sheet.cssRules.length))for(let i2=0;i2<node.sheet.cssRules.length;i2++){const stylesheet=node.sheet.cssRules[i2];if(stylesheet.type!==1)continue;const selectorList=stylesheet.selectorText.split(/,/gm).filter(Boolean).map(i22=>i22.trim());for(let j2=0;j2<selectorList.length;j2++)stylesheets[selectorList[j2]]=Object.assign(stylesheets[selectorList[j2]]||{},stylesheet.style)}}function parseArcCommand(path2,rx,ry,x_axis_rotation,large_arc_flag,sweep_flag,start,end){if(rx==0||ry==0){path2.lineTo(end.x,end.y);return}x_axis_rotation=x_axis_rotation*Math.PI/180,rx=Math.abs(rx),ry=Math.abs(ry);const dx2=(start.x-end.x)/2,dy2=(start.y-end.y)/2,x1p=Math.cos(x_axis_rotation)*dx2+Math.sin(x_axis_rotation)*dy2,y1p=-Math.sin(x_axis_rotation)*dx2+Math.cos(x_axis_rotation)*dy2;let rxs=rx*rx,rys=ry*ry;const x1ps=x1p*x1p,y1ps=y1p*y1p,cr=x1ps/rxs+y1ps/rys;if(cr>1){const s2=Math.sqrt(cr);rx=s2*rx,ry=s2*ry,rxs=rx*rx,rys=ry*ry}const dq=rxs*y1ps+rys*x1ps,pq=(rxs*rys-dq)/dq;let q=Math.sqrt(Math.max(0,pq));large_arc_flag===sweep_flag&&(q=-q);const cxp=q*rx*y1p/ry,cyp=-q*ry*x1p/rx,cx=Math.cos(x_axis_rotation)*cxp-Math.sin(x_axis_rotation)*cyp+(start.x+end.x)/2,cy=Math.sin(x_axis_rotation)*cxp+Math.cos(x_axis_rotation)*cyp+(start.y+end.y)/2,theta=svgAngle(1,0,(x1p-cxp)/rx,(y1p-cyp)/ry),delta=svgAngle((x1p-cxp)/rx,(y1p-cyp)/ry,(-x1p-cxp)/rx,(-y1p-cyp)/ry)%(Math.PI*2);path2.currentPath.absellipse(cx,cy,rx,ry,theta,theta+delta,sweep_flag===0,x_axis_rotation)}function svgAngle(ux,uy,vx,vy){const dot=ux*vx+uy*vy,len=Math.sqrt(ux*ux+uy*uy)*Math.sqrt(vx*vx+vy*vy);let ang=Math.acos(Math.max(-1,Math.min(1,dot/len)));return ux*vy-uy*vx<0&&(ang=-ang),ang}function parseRectNode(node){const x2=parseFloatWithUnits(node.getAttribute("x")||0),y2=parseFloatWithUnits(node.getAttribute("y")||0),rx=parseFloatWithUnits(node.getAttribute("rx")||node.getAttribute("ry")||0),ry=parseFloatWithUnits(node.getAttribute("ry")||node.getAttribute("rx")||0),w2=parseFloatWithUnits(node.getAttribute("width")),h2=parseFloatWithUnits(node.getAttribute("height")),bci=1-.551915024494,path2=new ShapePath;return path2.moveTo(x2+rx,y2),path2.lineTo(x2+w2-rx,y2),(rx!==0||ry!==0)&&path2.bezierCurveTo(x2+w2-rx*bci,y2,x2+w2,y2+ry*bci,x2+w2,y2+ry),path2.lineTo(x2+w2,y2+h2-ry),(rx!==0||ry!==0)&&path2.bezierCurveTo(x2+w2,y2+h2-ry*bci,x2+w2-rx*bci,y2+h2,x2+w2-rx,y2+h2),path2.lineTo(x2+rx,y2+h2),(rx!==0||ry!==0)&&path2.bezierCurveTo(x2+rx*bci,y2+h2,x2,y2+h2-ry*bci,x2,y2+h2-ry),path2.lineTo(x2,y2+ry),(rx!==0||ry!==0)&&path2.bezierCurveTo(x2,y2+ry*bci,x2+rx*bci,y2,x2+rx,y2),path2}function parsePolygonNode(node){function iterator(match,a2,b2){const x2=parseFloatWithUnits(a2),y2=parseFloatWithUnits(b2);index===0?path2.moveTo(x2,y2):path2.lineTo(x2,y2),index++}const regex=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,path2=new ShapePath;let index=0;return node.getAttribute("points").replace(regex,iterator),path2.currentPath.autoClose=!0,path2}function parsePolylineNode(node){function iterator(match,a2,b2){const x2=parseFloatWithUnits(a2),y2=parseFloatWithUnits(b2);index===0?path2.moveTo(x2,y2):path2.lineTo(x2,y2),index++}const regex=/(-?[\d\.?]+)[,|\s](-?[\d\.?]+)/g,path2=new ShapePath;let index=0;return node.getAttribute("points").replace(regex,iterator),path2.currentPath.autoClose=!1,path2}function parseCircleNode(node){const x2=parseFloatWithUnits(node.getAttribute("cx")||0),y2=parseFloatWithUnits(node.getAttribute("cy")||0),r2=parseFloatWithUnits(node.getAttribute("r")||0),subpath=new Path;subpath.absarc(x2,y2,r2,0,Math.PI*2);const path2=new ShapePath;return path2.subPaths.push(subpath),path2}function parseEllipseNode(node){const x2=parseFloatWithUnits(node.getAttribute("cx")||0),y2=parseFloatWithUnits(node.getAttribute("cy")||0),rx=parseFloatWithUnits(node.getAttribute("rx")||0),ry=parseFloatWithUnits(node.getAttribute("ry")||0),subpath=new Path;subpath.absellipse(x2,y2,rx,ry,0,Math.PI*2);const path2=new ShapePath;return path2.subPaths.push(subpath),path2}function parseLineNode(node){const x1=parseFloatWithUnits(node.getAttribute("x1")||0),y1=parseFloatWithUnits(node.getAttribute("y1")||0),x2=parseFloatWithUnits(node.getAttribute("x2")||0),y2=parseFloatWithUnits(node.getAttribute("y2")||0),path2=new ShapePath;return path2.moveTo(x1,y1),path2.lineTo(x2,y2),path2.currentPath.autoClose=!1,path2}function parseStyle(node,style){style=Object.assign({},style);let stylesheetStyles={};if(node.hasAttribute("class")){const classSelectors=node.getAttribute("class").split(/\s/).filter(Boolean).map(i2=>i2.trim());for(let i2=0;i2<classSelectors.length;i2++)stylesheetStyles=Object.assign(stylesheetStyles,stylesheets["."+classSelectors[i2]])}node.hasAttribute("id")&&(stylesheetStyles=Object.assign(stylesheetStyles,stylesheets["#"+node.getAttribute("id")]));function addStyle(svgName,jsName,adjustFunction){adjustFunction===void 0&&(adjustFunction=function(v4){return v4.startsWith("url")&&console.warn("SVGLoader: url access in attributes is not implemented."),v4}),node.hasAttribute(svgName)&&(style[jsName]=adjustFunction(node.getAttribute(svgName))),stylesheetStyles[svgName]&&(style[jsName]=adjustFunction(stylesheetStyles[svgName])),node.style&&node.style[svgName]!==""&&(style[jsName]=adjustFunction(node.style[svgName]))}function clamp2(v4){return Math.max(0,Math.min(1,parseFloatWithUnits(v4)))}function positive(v4){return Math.max(0,parseFloatWithUnits(v4))}return addStyle("fill","fill"),addStyle("fill-opacity","fillOpacity",clamp2),addStyle("fill-rule","fillRule"),addStyle("opacity","opacity",clamp2),addStyle("stroke","stroke"),addStyle("stroke-opacity","strokeOpacity",clamp2),addStyle("stroke-width","strokeWidth",positive),addStyle("stroke-linejoin","strokeLineJoin"),addStyle("stroke-linecap","strokeLineCap"),addStyle("stroke-miterlimit","strokeMiterLimit",positive),addStyle("visibility","visibility"),style}function getReflection(a2,b2){return a2-(b2-a2)}function parseFloats(input,flags,stride){if(typeof input!="string")throw new TypeError("Invalid input: "+typeof input);const RE={SEPARATOR:/[ \t\r\n\,.\-+]/,WHITESPACE:/[ \t\r\n]/,DIGIT:/[\d]/,SIGN:/[-+]/,POINT:/\./,COMMA:/,/,EXP:/e/i,FLAGS:/[01]/},SEP=0,INT=1,FLOAT=2,EXP=3;let state=SEP,seenComma=!0,number2="",exponent="";const result=[];function throwSyntaxError(current2,i2,partial){const error=new SyntaxError('Unexpected character "'+current2+'" at index '+i2+".");throw error.partial=partial,error}function newNumber(){number2!==""&&(exponent===""?result.push(Number(number2)):result.push(Number(number2)*Math.pow(10,Number(exponent)))),number2="",exponent=""}let current;const length=input.length;for(let i2=0;i2<length;i2++){if(current=input[i2],Array.isArray(flags)&&flags.includes(result.length%stride)&&RE.FLAGS.test(current)){state=INT,number2=current,newNumber();continue}if(state===SEP){if(RE.WHITESPACE.test(current))continue;if(RE.DIGIT.test(current)||RE.SIGN.test(current)){state=INT,number2=current;continue}if(RE.POINT.test(current)){state=FLOAT,number2=current;continue}RE.COMMA.test(current)&&(seenComma&&throwSyntaxError(current,i2,result),seenComma=!0)}if(state===INT){if(RE.DIGIT.test(current)){number2+=current;continue}if(RE.POINT.test(current)){number2+=current,state=FLOAT;continue}if(RE.EXP.test(current)){state=EXP;continue}RE.SIGN.test(current)&&number2.length===1&&RE.SIGN.test(number2[0])&&throwSyntaxError(current,i2,result)}if(state===FLOAT){if(RE.DIGIT.test(current)){number2+=current;continue}if(RE.EXP.test(current)){state=EXP;continue}RE.POINT.test(current)&&number2[number2.length-1]==="."&&throwSyntaxError(current,i2,result)}if(state===EXP){if(RE.DIGIT.test(current)){exponent+=current;continue}if(RE.SIGN.test(current)){if(exponent===""){exponent+=current;continue}exponent.length===1&&RE.SIGN.test(exponent)&&throwSyntaxError(current,i2,result)}}RE.WHITESPACE.test(current)?(newNumber(),state=SEP,seenComma=!1):RE.COMMA.test(current)?(newNumber(),state=SEP,seenComma=!0):RE.SIGN.test(current)?(newNumber(),state=INT,number2=current):RE.POINT.test(current)?(newNumber(),state=FLOAT,number2=current):throwSyntaxError(current,i2,result)}return newNumber(),result}const units=["mm","cm","in","pt","pc","px"],unitConversion2={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:72/6,pc:1,px:-1},px:{px:1}};function parseFloatWithUnits(string){let theUnit="px";if(typeof string=="string"||string instanceof String)for(let i2=0,n=units.length;i2<n;i2++){const u2=units[i2];if(string.endsWith(u2)){theUnit=u2,string=string.substring(0,string.length-u2.length);break}}let scale2;return theUnit==="px"&&scope.defaultUnit!=="px"?scale2=unitConversion2.in[scope.defaultUnit]/scope.defaultDPI:(scale2=unitConversion2[theUnit][scope.defaultUnit],scale2<0&&(scale2=unitConversion2[theUnit].in*scope.defaultDPI)),scale2*parseFloat(string)}function getNodeTransform(node){if(!(node.hasAttribute("transform")||node.nodeName==="use"&&(node.hasAttribute("x")||node.hasAttribute("y"))))return null;const transform=parseNodeTransform(node);return transformStack.length>0&&transform.premultiply(transformStack[transformStack.length-1]),currentTransform.copy(transform),transformStack.push(transform),transform}function parseNodeTransform(node){const transform=new Matrix3,currentTransform2=tempTransform0;if(node.nodeName==="use"&&(node.hasAttribute("x")||node.hasAttribute("y"))){const tx=parseFloatWithUnits(node.getAttribute("x")),ty=parseFloatWithUnits(node.getAttribute("y"));transform.translate(tx,ty)}if(node.hasAttribute("transform")){const transformsTexts=node.getAttribute("transform").split(")");for(let tIndex=transformsTexts.length-1;tIndex>=0;tIndex--){const transformText=transformsTexts[tIndex].trim();if(transformText==="")continue;const openParPos=transformText.indexOf("("),closeParPos=transformText.length;if(openParPos>0&&openParPos<closeParPos){const transformType=transformText.substr(0,openParPos),array=parseFloats(transformText.substr(openParPos+1,closeParPos-openParPos-1));switch(currentTransform2.identity(),transformType){case"translate":if(array.length>=1){const tx=array[0];let ty=tx;array.length>=2&&(ty=array[1]),currentTransform2.translate(tx,ty)}break;case"rotate":if(array.length>=1){let angle=0,cx=0,cy=0;angle=-array[0]*Math.PI/180,array.length>=3&&(cx=array[1],cy=array[2]),tempTransform1.identity().translate(-cx,-cy),tempTransform2.identity().rotate(angle),tempTransform3.multiplyMatrices(tempTransform2,tempTransform1),tempTransform1.identity().translate(cx,cy),currentTransform2.multiplyMatrices(tempTransform1,tempTransform3)}break;case"scale":if(array.length>=1){const scaleX=array[0];let scaleY=scaleX;array.length>=2&&(scaleY=array[1]),currentTransform2.scale(scaleX,scaleY)}break;case"skewX":array.length===1&&currentTransform2.set(1,Math.tan(array[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":array.length===1&&currentTransform2.set(1,0,0,Math.tan(array[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":array.length===6&&currentTransform2.set(array[0],array[2],array[4],array[1],array[3],array[5],0,0,1);break}}transform.premultiply(currentTransform2)}}return transform}function transformPath(path2,m2){function transfVec2(v22){tempV3.set(v22.x,v22.y,1).applyMatrix3(m2),v22.set(tempV3.x,tempV3.y)}const isRotated=isTransformRotated(m2),subPaths=path2.subPaths;for(let i2=0,n=subPaths.length;i2<n;i2++){const curves=subPaths[i2].curves;for(let j2=0;j2<curves.length;j2++){const curve=curves[j2];curve.isLineCurve?(transfVec2(curve.v1),transfVec2(curve.v2)):curve.isCubicBezierCurve?(transfVec2(curve.v0),transfVec2(curve.v1),transfVec2(curve.v2),transfVec2(curve.v3)):curve.isQuadraticBezierCurve?(transfVec2(curve.v0),transfVec2(curve.v1),transfVec2(curve.v2)):curve.isEllipseCurve&&(isRotated&&console.warn("SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented."),tempV2.set(curve.aX,curve.aY),transfVec2(tempV2),curve.aX=tempV2.x,curve.aY=tempV2.y,curve.xRadius*=getTransformScaleX(m2),curve.yRadius*=getTransformScaleY(m2))}}}function isTransformRotated(m2){return m2.elements[1]!==0||m2.elements[3]!==0}function getTransformScaleX(m2){const te=m2.elements;return Math.sqrt(te[0]*te[0]+te[1]*te[1])}function getTransformScaleY(m2){const te=m2.elements;return Math.sqrt(te[3]*te[3]+te[4]*te[4])}const paths2=[],stylesheets={},transformStack=[],tempTransform0=new Matrix3,tempTransform1=new Matrix3,tempTransform2=new Matrix3,tempTransform3=new Matrix3,tempV2=new Vector2,tempV3=new Vector3,currentTransform=new Matrix3,xml=new DOMParser().parseFromString(text,"image/svg+xml");return parseNode(xml.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4}),{paths:paths2,xml:xml.documentElement}}static createShapes(shapePath){const IntersectionLocationType={ORIGIN:0,DESTINATION:1,BETWEEN:2,LEFT:3,RIGHT:4,BEHIND:5,BEYOND:6},classifyResult={loc:IntersectionLocationType.ORIGIN,t:0};function findEdgeIntersection(a0,a1,b0,b1){const x1=a0.x,x2=a1.x,x3=b0.x,x4=b1.x,y1=a0.y,y2=a1.y,y3=b0.y,y4=b1.y,nom1=(x4-x3)*(y1-y3)-(y4-y3)*(x1-x3),nom2=(x2-x1)*(y1-y3)-(y2-y1)*(x1-x3),denom=(y4-y3)*(x2-x1)-(x4-x3)*(y2-y1),t1=nom1/denom,t2=nom2/denom;if(denom===0&&nom1!==0||t1<=0||t1>=1||t2<0||t2>1)return null;if(nom1===0&&denom===0){for(let i2=0;i2<2;i2++)if(classifyPoint(i2===0?b0:b1,a0,a1),classifyResult.loc==IntersectionLocationType.ORIGIN){const point=i2===0?b0:b1;return{x:point.x,y:point.y,t:classifyResult.t}}else if(classifyResult.loc==IntersectionLocationType.BETWEEN){const x5=+(x1+classifyResult.t*(x2-x1)).toPrecision(10),y5=+(y1+classifyResult.t*(y2-y1)).toPrecision(10);return{x:x5,y:y5,t:classifyResult.t}}return null}else{for(let i2=0;i2<2;i2++)if(classifyPoint(i2===0?b0:b1,a0,a1),classifyResult.loc==IntersectionLocationType.ORIGIN){const point=i2===0?b0:b1;return{x:point.x,y:point.y,t:classifyResult.t}}const x5=+(x1+t1*(x2-x1)).toPrecision(10),y5=+(y1+t1*(y2-y1)).toPrecision(10);return{x:x5,y:y5,t:t1}}}function classifyPoint(p2,edgeStart,edgeEnd){const ax=edgeEnd.x-edgeStart.x,ay=edgeEnd.y-edgeStart.y,bx=p2.x-edgeStart.x,by=p2.y-edgeStart.y,sa=ax*by-bx*ay;if(p2.x===edgeStart.x&&p2.y===edgeStart.y){classifyResult.loc=IntersectionLocationType.ORIGIN,classifyResult.t=0;return}if(p2.x===edgeEnd.x&&p2.y===edgeEnd.y){classifyResult.loc=IntersectionLocationType.DESTINATION,classifyResult.t=1;return}if(sa<-Number.EPSILON){classifyResult.loc=IntersectionLocationType.LEFT;return}if(sa>Number.EPSILON){classifyResult.loc=IntersectionLocationType.RIGHT;return}if(ax*bx<0||ay*by<0){classifyResult.loc=IntersectionLocationType.BEHIND;return}if(Math.sqrt(ax*ax+ay*ay)<Math.sqrt(bx*bx+by*by)){classifyResult.loc=IntersectionLocationType.BEYOND;return}let t2;ax!==0?t2=bx/ax:t2=by/ay,classifyResult.loc=IntersectionLocationType.BETWEEN,classifyResult.t=t2}function getIntersections(path1,path2){const intersectionsRaw=[],intersections=[];for(let index=1;index<path1.length;index++){const path1EdgeStart=path1[index-1],path1EdgeEnd=path1[index];for(let index2=1;index2<path2.length;index2++){const path2EdgeStart=path2[index2-1],path2EdgeEnd=path2[index2],intersection=findEdgeIntersection(path1EdgeStart,path1EdgeEnd,path2EdgeStart,path2EdgeEnd);intersection!==null&&intersectionsRaw.find(i2=>i2.t<=intersection.t+Number.EPSILON&&i2.t>=intersection.t-Number.EPSILON)===void 0&&(intersectionsRaw.push(intersection),intersections.push(new Vector2(intersection.x,intersection.y)))}}return intersections}function getScanlineIntersections(scanline,boundingBox,paths2){const center=new Vector2;boundingBox.getCenter(center);const allIntersections=[];return paths2.forEach(path2=>{path2.boundingBox.containsPoint(center)&&getIntersections(scanline,path2.points).forEach(p2=>{allIntersections.push({identifier:path2.identifier,isCW:path2.isCW,point:p2})})}),allIntersections.sort((i1,i2)=>i1.point.x-i2.point.x),allIntersections}function isHoleTo(simplePath,allPaths,scanlineMinX2,scanlineMaxX2,_fillRule){(_fillRule==null||_fillRule==="")&&(_fillRule="nonzero");const centerBoundingBox=new Vector2;simplePath.boundingBox.getCenter(centerBoundingBox);const scanline=[new Vector2(scanlineMinX2,centerBoundingBox.y),new Vector2(scanlineMaxX2,centerBoundingBox.y)],scanlineIntersections=getScanlineIntersections(scanline,simplePath.boundingBox,allPaths);scanlineIntersections.sort((i1,i22)=>i1.point.x-i22.point.x);const baseIntersections=[],otherIntersections=[];scanlineIntersections.forEach(i22=>{i22.identifier===simplePath.identifier?baseIntersections.push(i22):otherIntersections.push(i22)});const firstXOfPath=baseIntersections[0].point.x,stack=[];let i2=0;for(;i2<otherIntersections.length&&otherIntersections[i2].point.x<firstXOfPath;)stack.length>0&&stack[stack.length-1]===otherIntersections[i2].identifier?stack.pop():stack.push(otherIntersections[i2].identifier),i2++;if(stack.push(simplePath.identifier),_fillRule==="evenodd"){const isHole=stack.length%2===0,isHoleFor=stack[stack.length-2];return{identifier:simplePath.identifier,isHole,for:isHoleFor}}else if(_fillRule==="nonzero"){let isHole=!0,isHoleFor=null,lastCWValue=null;for(let i22=0;i22<stack.length;i22++){const identifier2=stack[i22];isHole?(lastCWValue=allPaths[identifier2].isCW,isHole=!1,isHoleFor=identifier2):lastCWValue!==allPaths[identifier2].isCW&&(lastCWValue=allPaths[identifier2].isCW,isHole=!0)}return{identifier:simplePath.identifier,isHole,for:isHoleFor}}else console.warn('fill-rule: "'+_fillRule+'" is currently not implemented.')}let identifier=0,scanlineMinX=999999999,scanlineMaxX=-999999999,simplePaths=shapePath.subPaths.map(p2=>{const points=p2.getPoints();let maxY=-999999999,minY=999999999,maxX=-999999999,minX=999999999;for(let i2=0;i2<points.length;i2++){const p22=points[i2];p22.y>maxY&&(maxY=p22.y),p22.y<minY&&(minY=p22.y),p22.x>maxX&&(maxX=p22.x),p22.x<minX&&(minX=p22.x)}return scanlineMaxX<=maxX&&(scanlineMaxX=maxX+1),scanlineMinX>=minX&&(scanlineMinX=minX-1),{curves:p2.curves,points,isCW:ShapeUtils.isClockWise(points),identifier:identifier++,boundingBox:new Box2(new Vector2(minX,minY),new Vector2(maxX,maxY))}});simplePaths=simplePaths.filter(sp=>sp.points.length>1);const isAHole=simplePaths.map(p2=>isHoleTo(p2,simplePaths,scanlineMinX,scanlineMaxX,shapePath.userData.style.fillRule)),shapesToReturn=[];return simplePaths.forEach(p2=>{if(!isAHole[p2.identifier].isHole){const shape=new Shape;shape.curves=p2.curves,isAHole.filter(h2=>h2.isHole&&h2.for===p2.identifier).forEach(h2=>{const hole=simplePaths[h2.identifier],path2=new Path;path2.curves=hole.curves,shape.holes.push(path2)}),shapesToReturn.push(shape)}}),shapesToReturn}static getStrokeStyle(width,color2,lineJoin,lineCap,miterLimit){return width=width!==void 0?width:1,color2=color2!==void 0?color2:"#000",lineJoin=lineJoin!==void 0?lineJoin:"miter",lineCap=lineCap!==void 0?lineCap:"butt",miterLimit=miterLimit!==void 0?miterLimit:4,{strokeColor:color2,strokeWidth:width,strokeLineJoin:lineJoin,strokeLineCap:lineCap,strokeMiterLimit:miterLimit}}static pointsToStroke(points,style,arcDivisions,minDistance){const vertices=[],normals=[],uvs=[];if(SVGLoader.pointsToStrokeWithBuffers(points,style,arcDivisions,minDistance,vertices,normals,uvs)===0)return null;const geometry=new BufferGeometry;return geometry.setAttribute("position",new Float32BufferAttribute(vertices,3)),geometry.setAttribute("normal",new Float32BufferAttribute(normals,3)),geometry.setAttribute("uv",new Float32BufferAttribute(uvs,2)),geometry}static pointsToStrokeWithBuffers(points,style,arcDivisions,minDistance,vertices,normals,uvs,vertexOffset){const tempV2_1=new Vector2,tempV2_2=new Vector2,tempV2_3=new Vector2,tempV2_4=new Vector2,tempV2_5=new Vector2,tempV2_6=new Vector2,tempV2_7=new Vector2,lastPointL=new Vector2,lastPointR=new Vector2,point0L=new Vector2,point0R=new Vector2,currentPointL=new Vector2,currentPointR=new Vector2,nextPointL=new Vector2,nextPointR=new Vector2,innerPoint=new Vector2,outerPoint=new Vector2;arcDivisions=arcDivisions!==void 0?arcDivisions:12,minDistance=minDistance!==void 0?minDistance:.001,vertexOffset=vertexOffset!==void 0?vertexOffset:0,points=removeDuplicatedPoints(points);const numPoints=points.length;if(numPoints<2)return 0;const isClosed=points[0].equals(points[numPoints-1]);let currentPoint,previousPoint=points[0],nextPoint;const strokeWidth2=style.strokeWidth/2,deltaU=1/(numPoints-1);let u0=0,u1,innerSideModified,joinIsOnLeftSide,isMiter,initialJoinIsOnLeftSide=!1,numVertices=0,currentCoordinate=vertexOffset*3,currentCoordinateUV=vertexOffset*2;getNormal(points[0],points[1],tempV2_1).multiplyScalar(strokeWidth2),lastPointL.copy(points[0]).sub(tempV2_1),lastPointR.copy(points[0]).add(tempV2_1),point0L.copy(lastPointL),point0R.copy(lastPointR);for(let iPoint=1;iPoint<numPoints;iPoint++){currentPoint=points[iPoint],iPoint===numPoints-1?isClosed?nextPoint=points[1]:nextPoint=void 0:nextPoint=points[iPoint+1];const normal1=tempV2_1;if(getNormal(previousPoint,currentPoint,normal1),tempV2_3.copy(normal1).multiplyScalar(strokeWidth2),currentPointL.copy(currentPoint).sub(tempV2_3),currentPointR.copy(currentPoint).add(tempV2_3),u1=u0+deltaU,innerSideModified=!1,nextPoint!==void 0){getNormal(currentPoint,nextPoint,tempV2_2),tempV2_3.copy(tempV2_2).multiplyScalar(strokeWidth2),nextPointL.copy(currentPoint).sub(tempV2_3),nextPointR.copy(currentPoint).add(tempV2_3),joinIsOnLeftSide=!0,tempV2_3.subVectors(nextPoint,previousPoint),normal1.dot(tempV2_3)<0&&(joinIsOnLeftSide=!1),iPoint===1&&(initialJoinIsOnLeftSide=joinIsOnLeftSide),tempV2_3.subVectors(nextPoint,currentPoint),tempV2_3.normalize();const dot=Math.abs(normal1.dot(tempV2_3));if(dot!==0){const miterSide=strokeWidth2/dot;tempV2_3.multiplyScalar(-miterSide),tempV2_4.subVectors(currentPoint,previousPoint),tempV2_5.copy(tempV2_4).setLength(miterSide).add(tempV2_3),innerPoint.copy(tempV2_5).negate();const miterLength2=tempV2_5.length(),segmentLengthPrev=tempV2_4.length();tempV2_4.divideScalar(segmentLengthPrev),tempV2_6.subVectors(nextPoint,currentPoint);const segmentLengthNext=tempV2_6.length();switch(tempV2_6.divideScalar(segmentLengthNext),tempV2_4.dot(innerPoint)<segmentLengthPrev&&tempV2_6.dot(innerPoint)<segmentLengthNext&&(innerSideModified=!0),outerPoint.copy(tempV2_5).add(currentPoint),innerPoint.add(currentPoint),isMiter=!1,innerSideModified?joinIsOnLeftSide?(nextPointR.copy(innerPoint),currentPointR.copy(innerPoint)):(nextPointL.copy(innerPoint),currentPointL.copy(innerPoint)):makeSegmentTriangles(),style.strokeLineJoin){case"bevel":makeSegmentWithBevelJoin(joinIsOnLeftSide,innerSideModified,u1);break;case"round":createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide,innerSideModified),joinIsOnLeftSide?makeCircularSector(currentPoint,currentPointL,nextPointL,u1,0):makeCircularSector(currentPoint,nextPointR,currentPointR,u1,1);break;case"miter":case"miter-clip":default:const miterFraction=strokeWidth2*style.strokeMiterLimit/miterLength2;if(miterFraction<1)if(style.strokeLineJoin!=="miter-clip"){makeSegmentWithBevelJoin(joinIsOnLeftSide,innerSideModified,u1);break}else createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide,innerSideModified),joinIsOnLeftSide?(tempV2_6.subVectors(outerPoint,currentPointL).multiplyScalar(miterFraction).add(currentPointL),tempV2_7.subVectors(outerPoint,nextPointL).multiplyScalar(miterFraction).add(nextPointL),addVertex(currentPointL,u1,0),addVertex(tempV2_6,u1,0),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(tempV2_6,u1,0),addVertex(tempV2_7,u1,0),addVertex(currentPoint,u1,.5),addVertex(tempV2_7,u1,0),addVertex(nextPointL,u1,0)):(tempV2_6.subVectors(outerPoint,currentPointR).multiplyScalar(miterFraction).add(currentPointR),tempV2_7.subVectors(outerPoint,nextPointR).multiplyScalar(miterFraction).add(nextPointR),addVertex(currentPointR,u1,1),addVertex(tempV2_6,u1,1),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(tempV2_6,u1,1),addVertex(tempV2_7,u1,1),addVertex(currentPoint,u1,.5),addVertex(tempV2_7,u1,1),addVertex(nextPointR,u1,1));else innerSideModified?(joinIsOnLeftSide?(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(outerPoint,u1,0),addVertex(lastPointR,u0,1),addVertex(outerPoint,u1,0),addVertex(innerPoint,u1,1)):(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(outerPoint,u1,1),addVertex(lastPointL,u0,0),addVertex(innerPoint,u1,0),addVertex(outerPoint,u1,1)),joinIsOnLeftSide?nextPointL.copy(outerPoint):nextPointR.copy(outerPoint)):joinIsOnLeftSide?(addVertex(currentPointL,u1,0),addVertex(outerPoint,u1,0),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(outerPoint,u1,0),addVertex(nextPointL,u1,0)):(addVertex(currentPointR,u1,1),addVertex(outerPoint,u1,1),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(outerPoint,u1,1),addVertex(nextPointR,u1,1)),isMiter=!0;break}}else makeSegmentTriangles()}else makeSegmentTriangles();!isClosed&&iPoint===numPoints-1&&addCapGeometry(points[0],point0L,point0R,joinIsOnLeftSide,!0,u0),u0=u1,previousPoint=currentPoint,lastPointL.copy(nextPointL),lastPointR.copy(nextPointR)}if(!isClosed)addCapGeometry(currentPoint,currentPointL,currentPointR,joinIsOnLeftSide,!1,u1);else if(innerSideModified&&vertices){let lastOuter=outerPoint,lastInner=innerPoint;initialJoinIsOnLeftSide!==joinIsOnLeftSide&&(lastOuter=innerPoint,lastInner=outerPoint),joinIsOnLeftSide?(isMiter||initialJoinIsOnLeftSide)&&(lastInner.toArray(vertices,0*3),lastInner.toArray(vertices,3*3),isMiter&&lastOuter.toArray(vertices,1*3)):(isMiter||!initialJoinIsOnLeftSide)&&(lastInner.toArray(vertices,1*3),lastInner.toArray(vertices,3*3),isMiter&&lastOuter.toArray(vertices,0*3))}return numVertices;function getNormal(p1,p2,result){return result.subVectors(p2,p1),result.set(-result.y,result.x).normalize()}function addVertex(position,u2,v4){vertices&&(vertices[currentCoordinate]=position.x,vertices[currentCoordinate+1]=position.y,vertices[currentCoordinate+2]=0,normals&&(normals[currentCoordinate]=0,normals[currentCoordinate+1]=0,normals[currentCoordinate+2]=1),currentCoordinate+=3,uvs&&(uvs[currentCoordinateUV]=u2,uvs[currentCoordinateUV+1]=v4,currentCoordinateUV+=2)),numVertices+=3}function makeCircularSector(center,p1,p2,u2,v4){tempV2_1.copy(p1).sub(center).normalize(),tempV2_2.copy(p2).sub(center).normalize();let angle=Math.PI;const dot=tempV2_1.dot(tempV2_2);Math.abs(dot)<1&&(angle=Math.abs(Math.acos(dot))),angle/=arcDivisions,tempV2_3.copy(p1);for(let i2=0,il=arcDivisions-1;i2<il;i2++)tempV2_4.copy(tempV2_3).rotateAround(center,angle),addVertex(tempV2_3,u2,v4),addVertex(tempV2_4,u2,v4),addVertex(center,u2,.5),tempV2_3.copy(tempV2_4);addVertex(tempV2_4,u2,v4),addVertex(p2,u2,v4),addVertex(center,u2,.5)}function makeSegmentTriangles(){addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointL,u1,0),addVertex(lastPointR,u0,1),addVertex(currentPointL,u1,1),addVertex(currentPointR,u1,0)}function makeSegmentWithBevelJoin(joinIsOnLeftSide2,innerSideModified2,u2){innerSideModified2?joinIsOnLeftSide2?(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointL,u1,0),addVertex(lastPointR,u0,1),addVertex(currentPointL,u1,0),addVertex(innerPoint,u1,1),addVertex(currentPointL,u2,0),addVertex(nextPointL,u2,0),addVertex(innerPoint,u2,.5)):(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointR,u1,1),addVertex(lastPointL,u0,0),addVertex(innerPoint,u1,0),addVertex(currentPointR,u1,1),addVertex(currentPointR,u2,1),addVertex(nextPointR,u2,0),addVertex(innerPoint,u2,.5)):joinIsOnLeftSide2?(addVertex(currentPointL,u2,0),addVertex(nextPointL,u2,0),addVertex(currentPoint,u2,.5)):(addVertex(currentPointR,u2,1),addVertex(nextPointR,u2,0),addVertex(currentPoint,u2,.5))}function createSegmentTrianglesWithMiddleSection(joinIsOnLeftSide2,innerSideModified2){innerSideModified2&&(joinIsOnLeftSide2?(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointL,u1,0),addVertex(lastPointR,u0,1),addVertex(currentPointL,u1,0),addVertex(innerPoint,u1,1),addVertex(currentPointL,u0,0),addVertex(currentPoint,u1,.5),addVertex(innerPoint,u1,1),addVertex(currentPoint,u1,.5),addVertex(nextPointL,u0,0),addVertex(innerPoint,u1,1)):(addVertex(lastPointR,u0,1),addVertex(lastPointL,u0,0),addVertex(currentPointR,u1,1),addVertex(lastPointL,u0,0),addVertex(innerPoint,u1,0),addVertex(currentPointR,u1,1),addVertex(currentPointR,u0,1),addVertex(innerPoint,u1,0),addVertex(currentPoint,u1,.5),addVertex(currentPoint,u1,.5),addVertex(innerPoint,u1,0),addVertex(nextPointR,u0,1)))}function addCapGeometry(center,p1,p2,joinIsOnLeftSide2,start,u2){switch(style.strokeLineCap){case"round":start?makeCircularSector(center,p2,p1,u2,.5):makeCircularSector(center,p1,p2,u2,.5);break;case"square":if(start)tempV2_1.subVectors(p1,center),tempV2_2.set(tempV2_1.y,-tempV2_1.x),tempV2_3.addVectors(tempV2_1,tempV2_2).add(center),tempV2_4.subVectors(tempV2_2,tempV2_1).add(center),joinIsOnLeftSide2?(tempV2_3.toArray(vertices,1*3),tempV2_4.toArray(vertices,0*3),tempV2_4.toArray(vertices,3*3)):(tempV2_3.toArray(vertices,1*3),tempV2_3.toArray(vertices,3*3),tempV2_4.toArray(vertices,0*3));else{tempV2_1.subVectors(p2,center),tempV2_2.set(tempV2_1.y,-tempV2_1.x),tempV2_3.addVectors(tempV2_1,tempV2_2).add(center),tempV2_4.subVectors(tempV2_2,tempV2_1).add(center);const vl=vertices.length;joinIsOnLeftSide2?(tempV2_3.toArray(vertices,vl-1*3),tempV2_4.toArray(vertices,vl-2*3),tempV2_4.toArray(vertices,vl-4*3)):(tempV2_3.toArray(vertices,vl-2*3),tempV2_4.toArray(vertices,vl-1*3),tempV2_4.toArray(vertices,vl-4*3))}break}}function removeDuplicatedPoints(points2){let dupPoints=!1;for(let i2=1,n=points2.length-1;i2<n;i2++)if(points2[i2].distanceTo(points2[i2+1])<minDistance){dupPoints=!0;break}if(!dupPoints)return points2;const newPoints=[];newPoints.push(points2[0]);for(let i2=1,n=points2.length-1;i2<n;i2++)points2[i2].distanceTo(points2[i2+1])>=minDistance&&newPoints.push(points2[i2]);return newPoints.push(points2[points2.length-1]),newPoints}}}const _taskCache=new WeakMap;class DRACOLoader extends Loader{constructor(manager){super(manager),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(path2){return this.decoderPath=path2,this}setDecoderConfig(config){return this.decoderConfig=config,this}setWorkerLimit(workerLimit){return this.workerLimit=workerLimit,this}load(url,onLoad,onProgress,onError){const loader=new FileLoader(this.manager);loader.setPath(this.path),loader.setResponseType("arraybuffer"),loader.setRequestHeader(this.requestHeader),loader.setWithCredentials(this.withCredentials),loader.load(url,buffer=>{const taskConfig={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(buffer,taskConfig).then(onLoad).catch(onError)},onProgress,onError)}decodeDracoFile(buffer,callback,attributeIDs,attributeTypes){const taskConfig={attributeIDs:attributeIDs||this.defaultAttributeIDs,attributeTypes:attributeTypes||this.defaultAttributeTypes,useUniqueIDs:!!attributeIDs};this.decodeGeometry(buffer,taskConfig).then(callback)}decodeGeometry(buffer,taskConfig){for(const attribute in taskConfig.attributeTypes){const type=taskConfig.attributeTypes[attribute];type.BYTES_PER_ELEMENT!==void 0&&(taskConfig.attributeTypes[attribute]=type.name)}const taskKey=JSON.stringify(taskConfig);if(_taskCache.has(buffer)){const cachedTask=_taskCache.get(buffer);if(cachedTask.key===taskKey)return cachedTask.promise;if(buffer.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let worker;const taskID=this.workerNextTaskID++,taskCost=buffer.byteLength,geometryPending=this._getWorker(taskID,taskCost).then(_worker=>(worker=_worker,new Promise((resolve2,reject)=>{worker._callbacks[taskID]={resolve:resolve2,reject},worker.postMessage({type:"decode",id:taskID,taskConfig,buffer},[buffer])}))).then(message=>this._createGeometry(message.geometry));return geometryPending.catch(()=>!0).then(()=>{worker&&taskID&&this._releaseTask(worker,taskID)}),_taskCache.set(buffer,{key:taskKey,promise:geometryPending}),geometryPending}_createGeometry(geometryData){const geometry=new BufferGeometry;geometryData.index&&geometry.setIndex(new BufferAttribute(geometryData.index.array,1));for(let i2=0;i2<geometryData.attributes.length;i2++){const attribute=geometryData.attributes[i2],name=attribute.name,array=attribute.array,itemSize=attribute.itemSize;geometry.setAttribute(name,new BufferAttribute(array,itemSize))}return geometry}_loadLibrary(url,responseType){const loader=new FileLoader(this.manager);return loader.setPath(this.decoderPath),loader.setResponseType(responseType),loader.setWithCredentials(this.withCredentials),new Promise((resolve2,reject)=>{loader.load(url,resolve2,void 0,reject)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const useJS=typeof WebAssembly!="object"||this.decoderConfig.type==="js",librariesPending=[];return useJS?librariesPending.push(this._loadLibrary("draco_decoder.js","text")):(librariesPending.push(this._loadLibrary("draco_wasm_wrapper.js","text")),librariesPending.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(librariesPending).then(libraries=>{const jsContent=libraries[0];useJS||(this.decoderConfig.wasmBinary=libraries[1]);const fn=DRACOWorker.toString(),body=["/* draco decoder */",jsContent,"","/* worker */",fn.substring(fn.indexOf("{")+1,fn.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([body]))}),this.decoderPending}_getWorker(taskID,taskCost){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const worker2=new Worker(this.workerSourceURL);worker2._callbacks={},worker2._taskCosts={},worker2._taskLoad=0,worker2.postMessage({type:"init",decoderConfig:this.decoderConfig}),worker2.onmessage=function(e2){const message=e2.data;switch(message.type){case"decode":worker2._callbacks[message.id].resolve(message);break;case"error":worker2._callbacks[message.id].reject(message);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+message.type+'"')}},this.workerPool.push(worker2)}else this.workerPool.sort(function(a2,b2){return a2._taskLoad>b2._taskLoad?-1:1});const worker=this.workerPool[this.workerPool.length-1];return worker._taskCosts[taskID]=taskCost,worker._taskLoad+=taskCost,worker})}_releaseTask(worker,taskID){worker._taskLoad-=worker._taskCosts[taskID],delete worker._callbacks[taskID],delete worker._taskCosts[taskID]}debug(){console.log("Task load: ",this.workerPool.map(worker=>worker._taskLoad))}dispose(){for(let i2=0;i2<this.workerPool.length;++i2)this.workerPool[i2].terminate();return this.workerPool.length=0,this}}function DRACOWorker(){let decoderConfig,decoderPending;onmessage=function(e2){const message=e2.data;switch(message.type){case"init":decoderConfig=message.decoderConfig,decoderPending=new Promise(function(resolve2){decoderConfig.onModuleLoaded=function(draco){resolve2({draco})},DracoDecoderModule(decoderConfig)});break;case"decode":const buffer=message.buffer,taskConfig=message.taskConfig;decoderPending.then(module=>{const draco=module.draco,decoder=new draco.Decoder,decoderBuffer=new draco.DecoderBuffer;decoderBuffer.Init(new Int8Array(buffer),buffer.byteLength);try{const geometry=decodeGeometry(draco,decoder,decoderBuffer,taskConfig),buffers=geometry.attributes.map(attr=>attr.array.buffer);geometry.index&&buffers.push(geometry.index.array.buffer),self.postMessage({type:"decode",id:message.id,geometry},buffers)}catch(error){console.error(error),self.postMessage({type:"error",id:message.id,error:error.message})}finally{draco.destroy(decoderBuffer),draco.destroy(decoder)}});break}};function decodeGeometry(draco,decoder,decoderBuffer,taskConfig){const attributeIDs=taskConfig.attributeIDs,attributeTypes=taskConfig.attributeTypes;let dracoGeometry,decodingStatus;const geometryType=decoder.GetEncodedGeometryType(decoderBuffer);if(geometryType===draco.TRIANGULAR_MESH)dracoGeometry=new draco.Mesh,decodingStatus=decoder.DecodeBufferToMesh(decoderBuffer,dracoGeometry);else if(geometryType===draco.POINT_CLOUD)dracoGeometry=new draco.PointCloud,decodingStatus=decoder.DecodeBufferToPointCloud(decoderBuffer,dracoGeometry);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!decodingStatus.ok()||dracoGeometry.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+decodingStatus.error_msg());const geometry={index:null,attributes:[]};for(const attributeName in attributeIDs){const attributeType=self[attributeTypes[attributeName]];let attribute,attributeID;if(taskConfig.useUniqueIDs)attributeID=attributeIDs[attributeName],attribute=decoder.GetAttributeByUniqueId(dracoGeometry,attributeID);else{if(attributeID=decoder.GetAttributeId(dracoGeometry,draco[attributeIDs[attributeName]]),attributeID===-1)continue;attribute=decoder.GetAttribute(dracoGeometry,attributeID)}geometry.attributes.push(decodeAttribute(draco,decoder,dracoGeometry,attributeName,attributeType,attribute))}return geometryType===draco.TRIANGULAR_MESH&&(geometry.index=decodeIndex(draco,decoder,dracoGeometry)),draco.destroy(dracoGeometry),geometry}function decodeIndex(draco,decoder,dracoGeometry){const numIndices=dracoGeometry.num_faces()*3,byteLength=numIndices*4,ptr=draco._malloc(byteLength);decoder.GetTrianglesUInt32Array(dracoGeometry,byteLength,ptr);const index=new Uint32Array(draco.HEAPF32.buffer,ptr,numIndices).slice();return draco._free(ptr),{array:index,itemSize:1}}function decodeAttribute(draco,decoder,dracoGeometry,attributeName,attributeType,attribute){const numComponents=attribute.num_components(),numValues=dracoGeometry.num_points()*numComponents,byteLength=numValues*attributeType.BYTES_PER_ELEMENT,dataType=getDracoDataType(draco,attributeType),ptr=draco._malloc(byteLength);decoder.GetAttributeDataArrayForAllPoints(dracoGeometry,attribute,dataType,byteLength,ptr);const array=new attributeType(draco.HEAPF32.buffer,ptr,numValues).slice();return draco._free(ptr),{name:attributeName,array,itemSize:numComponents}}function getDracoDataType(draco,attributeType){switch(attributeType){case Float32Array:return draco.DT_FLOAT32;case Int8Array:return draco.DT_INT8;case Int16Array:return draco.DT_INT16;case Int32Array:return draco.DT_INT32;case Uint8Array:return draco.DT_UINT8;case Uint16Array:return draco.DT_UINT16;case Uint32Array:return draco.DT_UINT32}}}let generated;const MeshoptDecoder=()=>{if(generated)return generated;const wasm_base="B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",wasm_simd="B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",detector=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),wasmpack=new Uint8Array([32,0,65,253,3,1,2,34,4,106,6,5,11,8,7,20,13,33,12,16,128,9,116,64,19,113,127,15,10,21,22,14,255,66,24,54,136,107,18,23,192,26,114,118,132,17,77,101,130,144,27,87,131,44,45,74,156,154,70,167]);if(typeof WebAssembly!="object")return{supported:!1};let wasm=wasm_base;WebAssembly.validate(detector)&&(wasm=wasm_simd);let instance;const promise=WebAssembly.instantiate(unpack(wasm),{}).then(result=>{instance=result.instance,instance.exports.__wasm_call_ctors()});function unpack(data){const result=new Uint8Array(data.length);for(let i2=0;i2<data.length;++i2){const ch=data.charCodeAt(i2);result[i2]=ch>96?ch-71:ch>64?ch-65:ch>47?ch+4:ch>46?63:62}let write=0;for(let i2=0;i2<data.length;++i2)result[write++]=result[i2]<60?wasmpack[result[i2]]:(result[i2]-60)*64+result[++i2];return result.buffer.slice(0,write)}function decode(fun,target,count,size,source,filter2){const sbrk=instance.exports.sbrk,count4=count+3&-4,tp=sbrk(count4*size),sp=sbrk(source.length),heap=new Uint8Array(instance.exports.memory.buffer);heap.set(source,sp);const res=fun(tp,count,size,sp,source.length);if(res===0&&filter2&&filter2(tp,count4,size),target.set(heap.subarray(tp,tp+count*size)),sbrk(tp-sbrk(0)),res!==0)throw new Error(`Malformed buffer data: ${res}`)}const filters={0:"",1:"meshopt_decodeFilterOct",2:"meshopt_decodeFilterQuat",3:"meshopt_decodeFilterExp",NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},decoders={0:"meshopt_decodeVertexBuffer",1:"meshopt_decodeIndexBuffer",2:"meshopt_decodeIndexSequence",ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"};return generated={ready:promise,supported:!0,decodeVertexBuffer(target,count,size,source,filter2){decode(instance.exports.meshopt_decodeVertexBuffer,target,count,size,source,instance.exports[filters[filter2]])},decodeIndexBuffer(target,count,size,source){decode(instance.exports.meshopt_decodeIndexBuffer,target,count,size,source)},decodeIndexSequence(target,count,size,source){decode(instance.exports.meshopt_decodeIndexSequence,target,count,size,source)},decodeGltfBuffer(target,count,size,source,mode,filter2){decode(instance.exports[decoders[mode]],target,count,size,source,instance.exports[filters[filter2]])}},generated},Svg=reactExports.forwardRef(function({src,skipFill,skipStrokes,fillMaterial,strokeMaterial,fillMeshProps,strokeMeshProps,...props},ref){const svg=useLoader(SVGLoader,src.startsWith("<svg")?`data:image/svg+xml;utf8,${src}`:src),strokeGeometries=reactExports.useMemo(()=>skipStrokes?[]:svg.paths.map(path2=>{var _path$userData;return((_path$userData=path2.userData)==null?void 0:_path$userData.style.stroke)===void 0||path2.userData.style.stroke==="none"?null:path2.subPaths.map(subPath=>SVGLoader.pointsToStroke(subPath.getPoints(),path2.userData.style))}),[svg,skipStrokes]);return reactExports.useEffect(()=>()=>strokeGeometries.forEach(group=>group&&group.map(g2=>g2.dispose())),[strokeGeometries]),reactExports.createElement("object3D",_extends({ref},props),reactExports.createElement("object3D",{scale:[1,-1,1]},svg.paths.map((path2,p2)=>{var _path$userData2,_path$userData3;return reactExports.createElement(reactExports.Fragment,{key:p2},!skipFill&&((_path$userData2=path2.userData)==null?void 0:_path$userData2.style.fill)!==void 0&&path2.userData.style.fill!=="none"&&SVGLoader.createShapes(path2).map((shape,s2)=>reactExports.createElement("mesh",_extends({key:s2},fillMeshProps),reactExports.createElement("shapeGeometry",{args:[shape]}),reactExports.createElement("meshBasicMaterial",_extends({color:path2.userData.style.fill,opacity:path2.userData.style.fillOpacity,transparent:!0,side:DoubleSide,depthWrite:!1},fillMaterial)))),!skipStrokes&&((_path$userData3=path2.userData)==null?void 0:_path$userData3.style.stroke)!==void 0&&path2.userData.style.stroke!=="none"&&path2.subPaths.map((_subPath,s2)=>reactExports.createElement("mesh",_extends({key:s2,geometry:strokeGeometries[p2][s2]},strokeMeshProps),reactExports.createElement("meshBasicMaterial",_extends({color:path2.userData.style.stroke,opacity:path2.userData.style.strokeOpacity,transparent:!0,side:DoubleSide,depthWrite:!1},strokeMaterial)))))})))});let dracoLoader=null,decoderPath="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function extensions(useDraco,useMeshopt,extendLoader){return loader=>{extendLoader&&extendLoader(loader),useDraco&&(dracoLoader||(dracoLoader=new DRACOLoader),dracoLoader.setDecoderPath(typeof useDraco=="string"?useDraco:decoderPath),loader.setDRACOLoader(dracoLoader)),useMeshopt&&loader.setMeshoptDecoder(typeof MeshoptDecoder=="function"?MeshoptDecoder():MeshoptDecoder)}}function useGLTF(path2,useDraco=!0,useMeshOpt=!0,extendLoader){return useLoader(GLTFLoader,path2,extensions(useDraco,useMeshOpt,extendLoader))}useGLTF.preload=(path2,useDraco=!0,useMeshOpt=!0,extendLoader)=>useLoader.preload(GLTFLoader,path2,extensions(useDraco,useMeshOpt,extendLoader));useGLTF.clear=input=>useLoader.clear(GLTFLoader,input);useGLTF.setDecoderPath=path2=>{decoderPath=path2};function useFBO(width,height,settings){const size=useThree(state=>state.size),viewport=useThree(state=>state.viewport),_width=typeof width=="number"?width:size.width*viewport.dpr,_height=typeof height=="number"?height:size.height*viewport.dpr,_settings=(typeof width=="number"?settings:width)||{},{samples=0,depth,...targetSettings}=_settings,target=reactExports.useMemo(()=>{const target2=new WebGLRenderTarget(_width,_height,{minFilter:LinearFilter,magFilter:LinearFilter,type:HalfFloatType,...targetSettings});return depth&&(target2.depthTexture=new DepthTexture(_width,_height,FloatType)),target2.samples=samples,target2},[]);return reactExports.useLayoutEffect(()=>{target.setSize(_width,_height),samples&&(target.samples=samples)},[samples,target,_width,_height]),reactExports.useEffect(()=>()=>target.dispose(),[]),target}const isFunction=node=>typeof node=="function",PerspectiveCamera2=reactExports.forwardRef(({envMap,resolution=256,frames=1/0,makeDefault,children,...props},ref)=>{const set=useThree(({set:set2})=>set2),camera=useThree(({camera:camera2})=>camera2),size=useThree(({size:size2})=>size2),cameraRef=reactExports.useRef(null),groupRef=reactExports.useRef(null),fbo=useFBO(resolution);reactExports.useLayoutEffect(()=>{props.manual||(cameraRef.current.aspect=size.width/size.height)},[size,props]),reactExports.useLayoutEffect(()=>{cameraRef.current.updateProjectionMatrix()});let count=0,oldEnvMap=null;const functional=isFunction(children);return useFrame(state=>{functional&&(frames===1/0||count<frames)&&(groupRef.current.visible=!1,state.gl.setRenderTarget(fbo),oldEnvMap=state.scene.background,envMap&&(state.scene.background=envMap),state.gl.render(state.scene,cameraRef.current),state.scene.background=oldEnvMap,state.gl.setRenderTarget(null),groupRef.current.visible=!0,count++)}),reactExports.useLayoutEffect(()=>{if(makeDefault){const oldCam=camera;return set(()=>({camera:cameraRef.current})),()=>set(()=>({camera:oldCam}))}},[cameraRef,makeDefault,set]),reactExports.createElement(reactExports.Fragment,null,reactExports.createElement("perspectiveCamera",_extends({ref:mergeRefs([cameraRef,ref])},props),!functional&&children),reactExports.createElement("group",{ref:groupRef},functional&&children(fbo.texture)))}),OrbitControls2=reactExports.forwardRef(({makeDefault,camera,regress,domElement,enableDamping=!0,keyEvents=!1,onChange,onStart,onEnd,...restProps},ref)=>{const invalidate2=useThree(state=>state.invalidate),defaultCamera=useThree(state=>state.camera),gl=useThree(state=>state.gl),events=useThree(state=>state.events),setEvents=useThree(state=>state.setEvents),set=useThree(state=>state.set),get=useThree(state=>state.get),performance2=useThree(state=>state.performance),explCamera=camera||defaultCamera,explDomElement=domElement||events.connected||gl.domElement,controls=reactExports.useMemo(()=>new OrbitControls$1(explCamera),[explCamera]);return useFrame(()=>{controls.enabled&&controls.update()},-1),reactExports.useEffect(()=>(keyEvents&&controls.connect(keyEvents===!0?explDomElement:keyEvents),controls.connect(explDomElement),()=>void controls.dispose()),[keyEvents,explDomElement,regress,controls,invalidate2]),reactExports.useEffect(()=>{const callback=e2=>{invalidate2(),regress&&performance2.regress(),onChange&&onChange(e2)},onStartCb=e2=>{onStart&&onStart(e2)},onEndCb=e2=>{onEnd&&onEnd(e2)};return controls.addEventListener("change",callback),controls.addEventListener("start",onStartCb),controls.addEventListener("end",onEndCb),()=>{controls.removeEventListener("start",onStartCb),controls.removeEventListener("end",onEndCb),controls.removeEventListener("change",callback)}},[onChange,onStart,onEnd,controls,invalidate2,setEvents]),reactExports.useEffect(()=>{if(makeDefault){const old=get().controls;return set({controls}),()=>set({controls:old})}},[makeDefault,controls]),reactExports.createElement("primitive",_extends({ref,object:controls,enableDamping},restProps))});function useFBX(path2){return useLoader(FBXLoader,path2)}useFBX.preload=path2=>useLoader.preload(FBXLoader,path2);useFBX.clear=input=>useLoader.clear(FBXLoader,input);function useAnimations(clips,root){const ref=reactExports.useRef(),[actualRef]=reactExports.useState(()=>root?root instanceof Object3D?{current:root}:root:ref),[mixer]=reactExports.useState(()=>new AnimationMixer(void 0));reactExports.useLayoutEffect(()=>{root&&(actualRef.current=root instanceof Object3D?root:root.current),mixer._root=actualRef.current});const lazyActions=reactExports.useRef({}),api=reactExports.useMemo(()=>{const actions={};return clips.forEach(clip=>Object.defineProperty(actions,clip.name,{enumerable:!0,get(){if(actualRef.current)return lazyActions.current[clip.name]||(lazyActions.current[clip.name]=mixer.clipAction(clip,actualRef.current))},configurable:!0})),{ref:actualRef,clips,actions,names:clips.map(c2=>c2.name),mixer}},[clips]);return useFrame((state,delta)=>mixer.update(delta)),reactExports.useEffect(()=>{const currentRoot=actualRef.current;return()=>{lazyActions.current={},mixer.stopAllAction(),Object.values(api.actions).forEach(action=>{currentRoot&&mixer.uncacheAction(action,currentRoot)})}},[clips]),api}const Center=reactExports.forwardRef(function({children,disable,disableX,disableY,disableZ,left,right,top,bottom,front,back,onCentered,precise=!0,cacheKey=0,...props},fRef){const ref=reactExports.useRef(null),outer=reactExports.useRef(null),inner=reactExports.useRef(null);return reactExports.useLayoutEffect(()=>{outer.current.matrixWorld.identity();const box3=new Box3().setFromObject(inner.current,precise),center=new Vector3,sphere=new Sphere,width=box3.max.x-box3.min.x,height=box3.max.y-box3.min.y,depth=box3.max.z-box3.min.z;box3.getCenter(center),box3.getBoundingSphere(sphere);const vAlign=top?height/2:bottom?-height/2:0,hAlign=left?-width/2:right?width/2:0,dAlign=front?depth/2:back?-depth/2:0;outer.current.position.set(disable||disableX?0:-center.x+hAlign,disable||disableY?0:-center.y+vAlign,disable||disableZ?0:-center.z+dAlign),typeof onCentered<"u"&&onCentered({parent:ref.current.parent,container:ref.current,width,height,depth,boundingBox:box3,boundingSphere:sphere,center,verticalAlignment:vAlign,horizontalAlignment:hAlign,depthAlignment:dAlign})},[cacheKey,onCentered,top,left,front,disable,disableX,disableY,disableZ,precise,right,bottom,back]),reactExports.useImperativeHandle(fRef,()=>ref.current,[]),reactExports.createElement("group",_extends({ref},props),reactExports.createElement("group",{ref:outer},reactExports.createElement("group",{ref:inner},children)))}),ContactShadows=reactExports.forwardRef(({scale:scale2=10,frames=1/0,opacity=1,width=1,height=1,blur=1,near=0,far=10,resolution=512,smooth=!0,color:color2="#000000",depthWrite=!1,renderOrder,...props},fref)=>{const ref=reactExports.useRef(null),scene2=useThree(state=>state.scene),gl=useThree(state=>state.gl),shadowCamera=reactExports.useRef(null);width=width*(Array.isArray(scale2)?scale2[0]:scale2||1),height=height*(Array.isArray(scale2)?scale2[1]:scale2||1);const[renderTarget,planeGeometry,depthMaterial,blurPlane,horizontalBlurMaterial,verticalBlurMaterial,renderTargetBlur]=reactExports.useMemo(()=>{const renderTarget2=new WebGLRenderTarget(resolution,resolution),renderTargetBlur2=new WebGLRenderTarget(resolution,resolution);renderTargetBlur2.texture.generateMipmaps=renderTarget2.texture.generateMipmaps=!1;const planeGeometry2=new PlaneGeometry(width,height).rotateX(Math.PI/2),blurPlane2=new Mesh(planeGeometry2),depthMaterial2=new MeshDepthMaterial;depthMaterial2.depthTest=depthMaterial2.depthWrite=!1,depthMaterial2.onBeforeCompile=shader=>{shader.uniforms={...shader.uniforms,ucolor:{value:new Color(color2)}},shader.fragmentShader=shader.fragmentShader.replace("void main() {",`uniform vec3 ucolor;
           void main() {
          `),shader.fragmentShader=shader.fragmentShader.replace("vec4( vec3( 1.0 - fragCoordZ ), opacity );","vec4( ucolor * fragCoordZ * 2.0, ( 1.0 - fragCoordZ ) * 1.0 );")};const horizontalBlurMaterial2=new ShaderMaterial(HorizontalBlurShader),verticalBlurMaterial2=new ShaderMaterial(VerticalBlurShader);return verticalBlurMaterial2.depthTest=horizontalBlurMaterial2.depthTest=!1,[renderTarget2,planeGeometry2,depthMaterial2,blurPlane2,horizontalBlurMaterial2,verticalBlurMaterial2,renderTargetBlur2]},[resolution,width,height,scale2,color2]),blurShadows=blur2=>{blurPlane.visible=!0,blurPlane.material=horizontalBlurMaterial,horizontalBlurMaterial.uniforms.tDiffuse.value=renderTarget.texture,horizontalBlurMaterial.uniforms.h.value=blur2*1/256,gl.setRenderTarget(renderTargetBlur),gl.render(blurPlane,shadowCamera.current),blurPlane.material=verticalBlurMaterial,verticalBlurMaterial.uniforms.tDiffuse.value=renderTargetBlur.texture,verticalBlurMaterial.uniforms.v.value=blur2*1/256,gl.setRenderTarget(renderTarget),gl.render(blurPlane,shadowCamera.current),blurPlane.visible=!1};let count=0,initialBackground,initialOverrideMaterial;return useFrame(()=>{shadowCamera.current&&(frames===1/0||count<frames)&&(count++,initialBackground=scene2.background,initialOverrideMaterial=scene2.overrideMaterial,ref.current.visible=!1,scene2.background=null,scene2.overrideMaterial=depthMaterial,gl.setRenderTarget(renderTarget),gl.render(scene2,shadowCamera.current),blurShadows(blur),smooth&&blurShadows(blur*.4),gl.setRenderTarget(null),ref.current.visible=!0,scene2.overrideMaterial=initialOverrideMaterial,scene2.background=initialBackground)}),reactExports.useImperativeHandle(fref,()=>ref.current,[]),reactExports.createElement("group",_extends({"rotation-x":Math.PI/2},props,{ref}),reactExports.createElement("mesh",{renderOrder,geometry:planeGeometry,scale:[1,-1,1],rotation:[-Math.PI/2,0,0]},reactExports.createElement("meshBasicMaterial",{transparent:!0,map:renderTarget.texture,opacity,depthWrite})),reactExports.createElement("orthographicCamera",{ref:shadowCamera,args:[-width/2,width/2,height/2,-height/2,near,far]}))});function i(){throw new Error("Cycle detected")}var t=Symbol.for("preact-signals");function r(){if(v>1)v--;else{for(var i2,t2=!1;f!==void 0;){var r2=f;for(f=void 0,e++;r2!==void 0;){var n=r2.o;if(r2.o=void 0,r2.f&=-3,!(8&r2.f)&&l$1(r2))try{r2.c()}catch(r3){t2||(i2=r3,t2=!0)}r2=n}}if(e=0,v--,t2)throw i2}}var o=void 0,f=void 0,v=0,e=0,u=0;function c(i2){if(o!==void 0){var t2=i2.n;if(t2===void 0||t2.t!==o)return t2={i:0,S:i2,p:o.s,n:void 0,t:o,e:void 0,x:void 0,r:t2},o.s!==void 0&&(o.s.n=t2),o.s=t2,i2.n=t2,32&o.f&&i2.S(t2),t2;if(t2.i===-1)return t2.i=0,t2.n!==void 0&&(t2.n.p=t2.p,t2.p!==void 0&&(t2.p.n=t2.n),t2.p=o.s,t2.n=void 0,o.s.n=t2,o.s=t2),t2}}function d$1(i2){this.v=i2,this.i=0,this.n=void 0,this.t=void 0}d$1.prototype.brand=t;d$1.prototype.h=function(){return!0};d$1.prototype.S=function(i2){this.t!==i2&&i2.e===void 0&&(i2.x=this.t,this.t!==void 0&&(this.t.e=i2),this.t=i2)};d$1.prototype.U=function(i2){if(this.t!==void 0){var t2=i2.e,r2=i2.x;t2!==void 0&&(t2.x=r2,i2.e=void 0),r2!==void 0&&(r2.e=t2,i2.x=void 0),i2===this.t&&(this.t=r2)}};d$1.prototype.subscribe=function(i2){var t2=this;return O$1(function(){var r2=t2.value,n=32&this.f;this.f&=-33;try{i2(r2)}finally{this.f|=n}})};d$1.prototype.valueOf=function(){return this.value};d$1.prototype.toString=function(){return this.value+""};d$1.prototype.toJSON=function(){return this.value};d$1.prototype.peek=function(){return this.v};Object.defineProperty(d$1.prototype,"value",{get:function(){var i2=c(this);return i2!==void 0&&(i2.i=this.i),this.v},set:function(t2){if(o instanceof _&&function(){throw new Error("Computed cannot have side-effects")}(),t2!==this.v){e>100&&i(),this.v=t2,this.i++,u++,v++;try{for(var n=this.t;n!==void 0;n=n.x)n.t.N()}finally{r()}}}});function a(i2){return new d$1(i2)}function l$1(i2){for(var t2=i2.s;t2!==void 0;t2=t2.n)if(t2.S.i!==t2.i||!t2.S.h()||t2.S.i!==t2.i)return!0;return!1}function y$1(i2){for(var t2=i2.s;t2!==void 0;t2=t2.n){var r2=t2.S.n;if(r2!==void 0&&(t2.r=r2),t2.S.n=t2,t2.i=-1,t2.n===void 0){i2.s=t2;break}}}function w(i2){for(var t2=i2.s,r2=void 0;t2!==void 0;){var n=t2.p;t2.i===-1?(t2.S.U(t2),n!==void 0&&(n.n=t2.n),t2.n!==void 0&&(t2.n.p=n)):r2=t2,t2.S.n=t2.r,t2.r!==void 0&&(t2.r=void 0),t2=n}i2.s=r2}function _(i2){d$1.call(this,void 0),this.x=i2,this.s=void 0,this.g=u-1,this.f=4}(_.prototype=new d$1).h=function(){if(this.f&=-3,1&this.f)return!1;if((36&this.f)==32||(this.f&=-5,this.g===u))return!0;if(this.g=u,this.f|=1,this.i>0&&!l$1(this))return this.f&=-2,!0;var i2=o;try{y$1(this),o=this;var t2=this.x();(16&this.f||this.v!==t2||this.i===0)&&(this.v=t2,this.f&=-17,this.i++)}catch(i3){this.v=i3,this.f|=16,this.i++}return o=i2,w(this),this.f&=-2,!0};_.prototype.S=function(i2){if(this.t===void 0){this.f|=36;for(var t2=this.s;t2!==void 0;t2=t2.n)t2.S.S(t2)}d$1.prototype.S.call(this,i2)};_.prototype.U=function(i2){if(this.t!==void 0&&(d$1.prototype.U.call(this,i2),this.t===void 0)){this.f&=-33;for(var t2=this.s;t2!==void 0;t2=t2.n)t2.S.U(t2)}};_.prototype.N=function(){if(!(2&this.f)){this.f|=6;for(var i2=this.t;i2!==void 0;i2=i2.x)i2.t.N()}};_.prototype.peek=function(){if(this.h()||i(),16&this.f)throw this.v;return this.v};Object.defineProperty(_.prototype,"value",{get:function(){1&this.f&&i();var t2=c(this);if(this.h(),t2!==void 0&&(t2.i=this.i),16&this.f)throw this.v;return this.v}});function g$1(i2){var t2=i2.u;if(i2.u=void 0,typeof t2=="function"){v++;var n=o;o=void 0;try{t2()}catch(t3){throw i2.f&=-2,i2.f|=8,b$1(i2),t3}finally{o=n,r()}}}function b$1(i2){for(var t2=i2.s;t2!==void 0;t2=t2.n)t2.S.U(t2);i2.x=void 0,i2.s=void 0,g$1(i2)}function x$1(i2){if(o!==this)throw new Error("Out-of-order effect");w(this),o=i2,this.f&=-2,8&this.f&&b$1(this),r()}function E(i2){this.x=i2,this.u=void 0,this.s=void 0,this.o=void 0,this.f=32}E.prototype.c=function(){var i2=this.S();try{if(8&this.f||this.x===void 0)return;var t2=this.x();typeof t2=="function"&&(this.u=t2)}finally{i2()}};E.prototype.S=function(){1&this.f&&i(),this.f|=1,this.f&=-9,g$1(this),y$1(this),v++;var t2=o;return o=this,x$1.bind(this,t2)};E.prototype.N=function(){2&this.f||(this.f|=2,this.o=f,f=this)};E.prototype.d=function(){this.f|=8,1&this.f||b$1(this)};function O$1(i2){var t2=new E(i2);try{t2.c()}catch(i3){throw t2.d(),i3}return t2.d.bind(t2)}var shim={exports:{}},useSyncExternalStoreShim_development={};/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(){typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart=="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);var React=reactExports,ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;function error(format){{for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++)args[_key2-1]=arguments[_key2];printWarning("error",format,args)}}function printWarning(level,format,args){{var ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame,stack=ReactDebugCurrentFrame.getStackAddendum();stack!==""&&(format+="%s",args=args.concat([stack]));var argsWithFormat=args.map(function(item){return String(item)});argsWithFormat.unshift("Warning: "+format),Function.prototype.apply.call(console[level],console,argsWithFormat)}}function is2(x2,y2){return x2===y2&&(x2!==0||1/x2===1/y2)||x2!==x2&&y2!==y2}var objectIs=typeof Object.is=="function"?Object.is:is2,useState=React.useState,useEffect=React.useEffect,useLayoutEffect=React.useLayoutEffect,useDebugValue=React.useDebugValue,didWarnOld18Alpha=!1,didWarnUncachedGetSnapshot=!1;function useSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){didWarnOld18Alpha||React.startTransition!==void 0&&(didWarnOld18Alpha=!0,error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));var value=getSnapshot();if(!didWarnUncachedGetSnapshot){var cachedValue=getSnapshot();objectIs(value,cachedValue)||(error("The result of getSnapshot should be cached to avoid an infinite loop"),didWarnUncachedGetSnapshot=!0)}var _useState=useState({inst:{value,getSnapshot}}),inst=_useState[0].inst,forceUpdate=_useState[1];return useLayoutEffect(function(){inst.value=value,inst.getSnapshot=getSnapshot,checkIfSnapshotChanged(inst)&&forceUpdate({inst})},[subscribe,value,getSnapshot]),useEffect(function(){checkIfSnapshotChanged(inst)&&forceUpdate({inst});var handleStoreChange=function(){checkIfSnapshotChanged(inst)&&forceUpdate({inst})};return subscribe(handleStoreChange)},[subscribe]),useDebugValue(value),value}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot,prevValue=inst.value;try{var nextValue=latestGetSnapshot();return!objectIs(prevValue,nextValue)}catch{return!0}}function useSyncExternalStore$1(subscribe,getSnapshot,getServerSnapshot){return getSnapshot()}var canUseDOM=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u",isServerEnvironment=!canUseDOM,shim2=isServerEnvironment?useSyncExternalStore$1:useSyncExternalStore,useSyncExternalStore$2=React.useSyncExternalStore!==void 0?React.useSyncExternalStore:shim2;useSyncExternalStoreShim_development.useSyncExternalStore=useSyncExternalStore$2,typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"&&typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop=="function"&&__REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error)})();shim.exports=useSyncExternalStoreShim_development;var shimExports=shim.exports,jsxRuntime={exports:{}},reactJsxRuntime_development={};/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(){var React=reactExports,REACT_ELEMENT_TYPE=Symbol.for("react.element"),REACT_PORTAL_TYPE=Symbol.for("react.portal"),REACT_FRAGMENT_TYPE=Symbol.for("react.fragment"),REACT_STRICT_MODE_TYPE=Symbol.for("react.strict_mode"),REACT_PROFILER_TYPE=Symbol.for("react.profiler"),REACT_PROVIDER_TYPE=Symbol.for("react.provider"),REACT_CONTEXT_TYPE=Symbol.for("react.context"),REACT_FORWARD_REF_TYPE=Symbol.for("react.forward_ref"),REACT_SUSPENSE_TYPE=Symbol.for("react.suspense"),REACT_SUSPENSE_LIST_TYPE=Symbol.for("react.suspense_list"),REACT_MEMO_TYPE=Symbol.for("react.memo"),REACT_LAZY_TYPE=Symbol.for("react.lazy"),REACT_OFFSCREEN_TYPE=Symbol.for("react.offscreen"),MAYBE_ITERATOR_SYMBOL=Symbol.iterator,FAUX_ITERATOR_SYMBOL="@@iterator";function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable!="object")return null;var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];return typeof maybeIterator=="function"?maybeIterator:null}var ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;function error(format){{for(var _len2=arguments.length,args=new Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++)args[_key2-1]=arguments[_key2];printWarning("error",format,args)}}function printWarning(level,format,args){{var ReactDebugCurrentFrame2=ReactSharedInternals.ReactDebugCurrentFrame,stack=ReactDebugCurrentFrame2.getStackAddendum();stack!==""&&(format+="%s",args=args.concat([stack]));var argsWithFormat=args.map(function(item){return String(item)});argsWithFormat.unshift("Warning: "+format),Function.prototype.apply.call(console[level],console,argsWithFormat)}}var enableScopeAPI=!1,enableCacheElement=!1,enableTransitionTracing=!1,enableLegacyHidden=!1,enableDebugTracing=!1,REACT_MODULE_REFERENCE;REACT_MODULE_REFERENCE=Symbol.for("react.module.reference");function isValidElementType(type){return!!(typeof type=="string"||typeof type=="function"||type===REACT_FRAGMENT_TYPE||type===REACT_PROFILER_TYPE||enableDebugTracing||type===REACT_STRICT_MODE_TYPE||type===REACT_SUSPENSE_TYPE||type===REACT_SUSPENSE_LIST_TYPE||enableLegacyHidden||type===REACT_OFFSCREEN_TYPE||enableScopeAPI||enableCacheElement||enableTransitionTracing||typeof type=="object"&&type!==null&&(type.$$typeof===REACT_LAZY_TYPE||type.$$typeof===REACT_MEMO_TYPE||type.$$typeof===REACT_PROVIDER_TYPE||type.$$typeof===REACT_CONTEXT_TYPE||type.$$typeof===REACT_FORWARD_REF_TYPE||type.$$typeof===REACT_MODULE_REFERENCE||type.getModuleId!==void 0))}function getWrappedName(outerType,innerType,wrapperName){var displayName=outerType.displayName;if(displayName)return displayName;var functionName=innerType.displayName||innerType.name||"";return functionName!==""?wrapperName+"("+functionName+")":wrapperName}function getContextName(type){return type.displayName||"Context"}function getComponentNameFromType(type){if(type==null)return null;if(typeof type.tag=="number"&&error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."),typeof type=="function")return type.displayName||type.name||null;if(typeof type=="string")return type;switch(type){case REACT_FRAGMENT_TYPE:return"Fragment";case REACT_PORTAL_TYPE:return"Portal";case REACT_PROFILER_TYPE:return"Profiler";case REACT_STRICT_MODE_TYPE:return"StrictMode";case REACT_SUSPENSE_TYPE:return"Suspense";case REACT_SUSPENSE_LIST_TYPE:return"SuspenseList"}if(typeof type=="object")switch(type.$$typeof){case REACT_CONTEXT_TYPE:var context2=type;return getContextName(context2)+".Consumer";case REACT_PROVIDER_TYPE:var provider=type;return getContextName(provider._context)+".Provider";case REACT_FORWARD_REF_TYPE:return getWrappedName(type,type.render,"ForwardRef");case REACT_MEMO_TYPE:var outerName=type.displayName||null;return outerName!==null?outerName:getComponentNameFromType(type.type)||"Memo";case REACT_LAZY_TYPE:{var lazyComponent=type,payload=lazyComponent._payload,init=lazyComponent._init;try{return getComponentNameFromType(init(payload))}catch{return null}}}return null}var assign=Object.assign,disabledDepth=0,prevLog,prevInfo,prevWarn,prevError,prevGroup,prevGroupCollapsed,prevGroupEnd;function disabledLog(){}disabledLog.__reactDisabledLog=!0;function disableLogs(){{if(disabledDepth===0){prevLog=console.log,prevInfo=console.info,prevWarn=console.warn,prevError=console.error,prevGroup=console.group,prevGroupCollapsed=console.groupCollapsed,prevGroupEnd=console.groupEnd;var props={configurable:!0,enumerable:!0,value:disabledLog,writable:!0};Object.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props})}disabledDepth++}}function reenableLogs(){{if(disabledDepth--,disabledDepth===0){var props={configurable:!0,enumerable:!0,writable:!0};Object.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})})}disabledDepth<0&&error("disabledDepth fell below zero. This is a bug in React. Please file an issue.")}}var ReactCurrentDispatcher2=ReactSharedInternals.ReactCurrentDispatcher,prefix;function describeBuiltInComponentFrame(name,source,ownerFn){{if(prefix===void 0)try{throw Error()}catch(x2){var match=x2.stack.trim().match(/\n( *(at )?)/);prefix=match&&match[1]||""}return`
`+prefix+name}}var reentry=!1,componentFrameCache;{var PossiblyWeakMap=typeof WeakMap=="function"?WeakMap:Map;componentFrameCache=new PossiblyWeakMap}function describeNativeComponentFrame(fn,construct){if(!fn||reentry)return"";{var frame2=componentFrameCache.get(fn);if(frame2!==void 0)return frame2}var control;reentry=!0;var previousPrepareStackTrace=Error.prepareStackTrace;Error.prepareStackTrace=void 0;var previousDispatcher;previousDispatcher=ReactCurrentDispatcher2.current,ReactCurrentDispatcher2.current=null,disableLogs();try{if(construct){var Fake=function(){throw Error()};if(Object.defineProperty(Fake.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(Fake,[])}catch(x2){control=x2}Reflect.construct(fn,[],Fake)}else{try{Fake.call()}catch(x2){control=x2}fn.call(Fake.prototype)}}else{try{throw Error()}catch(x2){control=x2}fn()}}catch(sample){if(sample&&control&&typeof sample.stack=="string"){for(var sampleLines=sample.stack.split(`
`),controlLines=control.stack.split(`
`),s2=sampleLines.length-1,c2=controlLines.length-1;s2>=1&&c2>=0&&sampleLines[s2]!==controlLines[c2];)c2--;for(;s2>=1&&c2>=0;s2--,c2--)if(sampleLines[s2]!==controlLines[c2]){if(s2!==1||c2!==1)do if(s2--,c2--,c2<0||sampleLines[s2]!==controlLines[c2]){var _frame=`
`+sampleLines[s2].replace(" at new "," at ");return fn.displayName&&_frame.includes("<anonymous>")&&(_frame=_frame.replace("<anonymous>",fn.displayName)),typeof fn=="function"&&componentFrameCache.set(fn,_frame),_frame}while(s2>=1&&c2>=0);break}}}finally{reentry=!1,ReactCurrentDispatcher2.current=previousDispatcher,reenableLogs(),Error.prepareStackTrace=previousPrepareStackTrace}var name=fn?fn.displayName||fn.name:"",syntheticFrame=name?describeBuiltInComponentFrame(name):"";return typeof fn=="function"&&componentFrameCache.set(fn,syntheticFrame),syntheticFrame}function describeFunctionComponentFrame(fn,source,ownerFn){return describeNativeComponentFrame(fn,!1)}function shouldConstruct(Component){var prototype=Component.prototype;return!!(prototype&&prototype.isReactComponent)}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(type==null)return"";if(typeof type=="function")return describeNativeComponentFrame(type,shouldConstruct(type));if(typeof type=="string")return describeBuiltInComponentFrame(type);switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame("Suspense");case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame("SuspenseList")}if(typeof type=="object")switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return describeFunctionComponentFrame(type.render);case REACT_MEMO_TYPE:return describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:{var lazyComponent=type,payload=lazyComponent._payload,init=lazyComponent._init;try{return describeUnknownElementTypeFrameInDEV(init(payload),source,ownerFn)}catch{}}}return""}var hasOwnProperty=Object.prototype.hasOwnProperty,loggedTypeFailures={},ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement(element){if(element){var owner=element._owner,stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame.setExtraStackFrame(stack)}else ReactDebugCurrentFrame.setExtraStackFrame(null)}function checkPropTypes(typeSpecs,values,location,componentName,element){{var has=Function.call.bind(hasOwnProperty);for(var typeSpecName in typeSpecs)if(has(typeSpecs,typeSpecName)){var error$1=void 0;try{if(typeof typeSpecs[typeSpecName]!="function"){var err=Error((componentName||"React class")+": "+location+" type `"+typeSpecName+"` is invalid; it must be a function, usually from the `prop-types` package, but received `"+typeof typeSpecs[typeSpecName]+"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");throw err.name="Invariant Violation",err}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(ex){error$1=ex}error$1&&!(error$1 instanceof Error)&&(setCurrentlyValidatingElement(element),error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).",componentName||"React class",location,typeSpecName,typeof error$1),setCurrentlyValidatingElement(null)),error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)&&(loggedTypeFailures[error$1.message]=!0,setCurrentlyValidatingElement(element),error("Failed %s type: %s",location,error$1.message),setCurrentlyValidatingElement(null))}}}var isArrayImpl=Array.isArray;function isArray(a2){return isArrayImpl(a2)}function typeName(value){{var hasToStringTag=typeof Symbol=="function"&&Symbol.toStringTag,type=hasToStringTag&&value[Symbol.toStringTag]||value.constructor.name||"Object";return type}}function willCoercionThrow(value){try{return testStringCoercion(value),!1}catch{return!0}}function testStringCoercion(value){return""+value}function checkKeyStringCoercion(value){if(willCoercionThrow(value))return error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.",typeName(value)),testStringCoercion(value)}var ReactCurrentOwner2=ReactSharedInternals.ReactCurrentOwner,RESERVED_PROPS={key:!0,ref:!0,__self:!0,__source:!0},specialPropKeyWarningShown,specialPropRefWarningShown,didWarnAboutStringRefs;didWarnAboutStringRefs={};function hasValidRef(config){if(hasOwnProperty.call(config,"ref")){var getter=Object.getOwnPropertyDescriptor(config,"ref").get;if(getter&&getter.isReactWarning)return!1}return config.ref!==void 0}function hasValidKey(config){if(hasOwnProperty.call(config,"key")){var getter=Object.getOwnPropertyDescriptor(config,"key").get;if(getter&&getter.isReactWarning)return!1}return config.key!==void 0}function warnIfStringRefCannotBeAutoConverted(config,self2){if(typeof config.ref=="string"&&ReactCurrentOwner2.current&&self2&&ReactCurrentOwner2.current.stateNode!==self2){var componentName=getComponentNameFromType(ReactCurrentOwner2.current.type);didWarnAboutStringRefs[componentName]||(error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',getComponentNameFromType(ReactCurrentOwner2.current.type),config.ref),didWarnAboutStringRefs[componentName]=!0)}}function defineKeyPropWarningGetter(props,displayName){{var warnAboutAccessingKey=function(){specialPropKeyWarningShown||(specialPropKeyWarningShown=!0,error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)",displayName))};warnAboutAccessingKey.isReactWarning=!0,Object.defineProperty(props,"key",{get:warnAboutAccessingKey,configurable:!0})}}function defineRefPropWarningGetter(props,displayName){{var warnAboutAccessingRef=function(){specialPropRefWarningShown||(specialPropRefWarningShown=!0,error("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)",displayName))};warnAboutAccessingRef.isReactWarning=!0,Object.defineProperty(props,"ref",{get:warnAboutAccessingRef,configurable:!0})}}var ReactElement=function(type,key,ref,self2,source,owner,props){var element={$$typeof:REACT_ELEMENT_TYPE,type,key,ref,props,_owner:owner};return element._store={},Object.defineProperty(element._store,"validated",{configurable:!1,enumerable:!1,writable:!0,value:!1}),Object.defineProperty(element,"_self",{configurable:!1,enumerable:!1,writable:!1,value:self2}),Object.defineProperty(element,"_source",{configurable:!1,enumerable:!1,writable:!1,value:source}),Object.freeze&&(Object.freeze(element.props),Object.freeze(element)),element};function jsxDEV(type,config,maybeKey,source,self2){{var propName,props={},key=null,ref=null;maybeKey!==void 0&&(checkKeyStringCoercion(maybeKey),key=""+maybeKey),hasValidKey(config)&&(checkKeyStringCoercion(config.key),key=""+config.key),hasValidRef(config)&&(ref=config.ref,warnIfStringRefCannotBeAutoConverted(config,self2));for(propName in config)hasOwnProperty.call(config,propName)&&!RESERVED_PROPS.hasOwnProperty(propName)&&(props[propName]=config[propName]);if(type&&type.defaultProps){var defaultProps=type.defaultProps;for(propName in defaultProps)props[propName]===void 0&&(props[propName]=defaultProps[propName])}if(key||ref){var displayName=typeof type=="function"?type.displayName||type.name||"Unknown":type;key&&defineKeyPropWarningGetter(props,displayName),ref&&defineRefPropWarningGetter(props,displayName)}return ReactElement(type,key,ref,self2,source,ReactCurrentOwner2.current,props)}}var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner,ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame;function setCurrentlyValidatingElement$1(element){if(element){var owner=element._owner,stack=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame$1.setExtraStackFrame(stack)}else ReactDebugCurrentFrame$1.setExtraStackFrame(null)}var propTypesMisspellWarningShown;propTypesMisspellWarningShown=!1;function isValidElement(object){return typeof object=="object"&&object!==null&&object.$$typeof===REACT_ELEMENT_TYPE}function getDeclarationErrorAddendum(){{if(ReactCurrentOwner$1.current){var name=getComponentNameFromType(ReactCurrentOwner$1.current.type);if(name)return`

Check the render method of \``+name+"`."}return""}}function getSourceInfoErrorAddendum(source){{if(source!==void 0){var fileName=source.fileName.replace(/^.*[\\\/]/,""),lineNumber=source.lineNumber;return`

Check your code at `+fileName+":"+lineNumber+"."}return""}}var ownerHasKeyUseWarning={};function getCurrentComponentErrorInfo(parentType){{var info=getDeclarationErrorAddendum();if(!info){var parentName=typeof parentType=="string"?parentType:parentType.displayName||parentType.name;parentName&&(info=`

Check the top-level render call using <`+parentName+">.")}return info}}function validateExplicitKey(element,parentType){{if(!element._store||element._store.validated||element.key!=null)return;element._store.validated=!0;var currentComponentErrorInfo=getCurrentComponentErrorInfo(parentType);if(ownerHasKeyUseWarning[currentComponentErrorInfo])return;ownerHasKeyUseWarning[currentComponentErrorInfo]=!0;var childOwner="";element&&element._owner&&element._owner!==ReactCurrentOwner$1.current&&(childOwner=" It was passed a child from "+getComponentNameFromType(element._owner.type)+"."),setCurrentlyValidatingElement$1(element),error('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.',currentComponentErrorInfo,childOwner),setCurrentlyValidatingElement$1(null)}}function validateChildKeys(node,parentType){{if(typeof node!="object")return;if(isArray(node))for(var i2=0;i2<node.length;i2++){var child=node[i2];isValidElement(child)&&validateExplicitKey(child,parentType)}else if(isValidElement(node))node._store&&(node._store.validated=!0);else if(node){var iteratorFn=getIteratorFn(node);if(typeof iteratorFn=="function"&&iteratorFn!==node.entries)for(var iterator=iteratorFn.call(node),step;!(step=iterator.next()).done;)isValidElement(step.value)&&validateExplicitKey(step.value,parentType)}}}function validatePropTypes(element){{var type=element.type;if(type==null||typeof type=="string")return;var propTypes;if(typeof type=="function")propTypes=type.propTypes;else if(typeof type=="object"&&(type.$$typeof===REACT_FORWARD_REF_TYPE||type.$$typeof===REACT_MEMO_TYPE))propTypes=type.propTypes;else return;if(propTypes){var name=getComponentNameFromType(type);checkPropTypes(propTypes,element.props,"prop",name,element)}else if(type.PropTypes!==void 0&&!propTypesMisspellWarningShown){propTypesMisspellWarningShown=!0;var _name=getComponentNameFromType(type);error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?",_name||"Unknown")}typeof type.getDefaultProps=="function"&&!type.getDefaultProps.isReactClassApproved&&error("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.")}}function validateFragmentProps(fragment2){{for(var keys2=Object.keys(fragment2.props),i2=0;i2<keys2.length;i2++){var key=keys2[i2];if(key!=="children"&&key!=="key"){setCurrentlyValidatingElement$1(fragment2),error("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",key),setCurrentlyValidatingElement$1(null);break}}fragment2.ref!==null&&(setCurrentlyValidatingElement$1(fragment2),error("Invalid attribute `ref` supplied to `React.Fragment`."),setCurrentlyValidatingElement$1(null))}}function jsxWithValidation(type,props,key,isStaticChildren,source,self2){{var validType=isValidElementType(type);if(!validType){var info="";(type===void 0||typeof type=="object"&&type!==null&&Object.keys(type).length===0)&&(info+=" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");var sourceInfo=getSourceInfoErrorAddendum(source);sourceInfo?info+=sourceInfo:info+=getDeclarationErrorAddendum();var typeString;type===null?typeString="null":isArray(type)?typeString="array":type!==void 0&&type.$$typeof===REACT_ELEMENT_TYPE?(typeString="<"+(getComponentNameFromType(type.type)||"Unknown")+" />",info=" Did you accidentally export a JSX literal instead of a component?"):typeString=typeof type,error("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s",typeString,info)}var element=jsxDEV(type,props,key,source,self2);if(element==null)return element;if(validType){var children=props.children;if(children!==void 0)if(isStaticChildren)if(isArray(children)){for(var i2=0;i2<children.length;i2++)validateChildKeys(children[i2],type);Object.freeze&&Object.freeze(children)}else error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");else validateChildKeys(children,type)}return type===REACT_FRAGMENT_TYPE?validateFragmentProps(element):validatePropTypes(element),element}}function jsxWithValidationStatic(type,props,key){return jsxWithValidation(type,props,key,!0)}function jsxWithValidationDynamic(type,props,key){return jsxWithValidation(type,props,key,!1)}var jsx=jsxWithValidationDynamic,jsxs=jsxWithValidationStatic;reactJsxRuntime_development.Fragment=REACT_FRAGMENT_TYPE,reactJsxRuntime_development.jsx=jsx,reactJsxRuntime_development.jsxs=jsxs})();jsxRuntime.exports=reactJsxRuntime_development;var jsxRuntimeExports=jsxRuntime.exports;const l=getDefaultExportFromCjs(jsxRuntimeExports);var m=Symbol.for("react.element");Promise.prototype.then.bind(Promise.resolve());Object.defineProperties(d$1.prototype,{$$typeof:{configurable:!0,value:m},type:{configurable:!0,value:function(n){return n.data.value}},props:{configurable:!0,get:function(){return{data:this}}},ref:{configurable:!0,value:null}});var p=Symbol.for("react.element");function b(e2){return typeof e2!="function"?e2:function(r2,t2){if(typeof r2=="string"&&t2)for(var u2 in t2){var i2=t2[u2];u2!=="children"&&i2 instanceof d$1&&(t2[u2]=i2.value)}return e2.call.apply(e2,[e2,r2,t2].concat([].slice.call(arguments,2)))}}var g,d=Symbol.dispose||Symbol.for("Symbol.dispose");function y(n){g&&g(),g=n&&n.effect.S()}var h,S=function(){return y()},j=Promise.prototype.then.bind(Promise.resolve());Object.defineProperties(d$1.prototype,{$$typeof:{configurable:!0,value:p},type:{configurable:!0,value:function(n){return n.data.value}},props:{configurable:!0,get:function(){return{data:this}}},ref:{configurable:!0,value:null}});var x=null,P=!1,$=null,O=new Map;function k(n){if(!n)return 1;var e2,r2=O.get(n);if(r2!==void 0)return r2;var t2=n.useCallback.toString();if(n.useReducer===n.useEffect)e2=1;else if(n.useEffect===n.useImperativeHandle)e2=32;else if(/Invalid/.test(t2))e2=2;else if(/updateCallback/.test(t2)||/\[0\]/.test(t2)&&/\[1\]/.test(t2)){var u2=n.useReducer.toString();/rerenderReducer/.test(u2)||/return\s*\[\w+,/.test(u2)?e2=16:e2=8}else e2=4;return O.set(n,e2),e2}(function(){Object.defineProperty(reactExports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentDispatcher,"current",{get:function(){return $},set:function(n){if(P)$=n;else{var e2=k($),r2=k(n);if($=n,function(n2,e3){return 1&n2&&28&e3?!0:2&n2||2&e3?!1:!!(16&e3)}(e2,r2))P=!0,x=function(){S(),h||(h=j(function(){h=void 0,S()}));var n2=reactExports.useRef();n2.current==null&&(n2.current=function(){var n3,e4,r3,u3=0,i2=O$1(function(){e4=this});return e4.c=function(){u3=u3+1|0,r3&&r3()},(n3={effect:e4,subscribe:function(n4){return r3=n4,function(){u3=u3+1|0,r3=void 0,i2()}},getSnapshot:function(){return u3},f:function(){S()}})[d]=function(){S()},n3}());var e3=n2.current;return shimExports.useSyncExternalStore(e3.subscribe,e3.getSnapshot,e3.getSnapshot),y(e3),e3}(),P=!1;else if(function(n2,e3){return!!(28&n2&&1&e3)}(e2,r2)){var u2;(u2=x)==null||u2.f(),x=null}}}}),function(){var n=l,e2=s;u$1.createElement=b(u$1.createElement),e2.jsx&&(e2.jsx=b(e2.jsx)),n.jsx&&(n.jsx=b(n.jsx)),e2.jsxs&&(e2.jsxs=b(e2.jsxs)),n.jsxs&&(n.jsxs=b(n.jsxs)),e2.jsxDEV&&(e2.jsxDEV=b(e2.jsxDEV)),n.jsxDEV&&(n.jsxDEV=b(n.jsxDEV))}()})();const scene=a("home"),setScene=s2=>scene.value=s2,isModalVisible=a(!1),modalContent=a(null),closeModal=()=>(isModalVisible.value=!1,activeSkill.value=""),openModal=content=>(isModalVisible.value=!0,modalContent.value=content),activeSkill=a(""),setActiveSkill=s2=>activeSkill.value=s2;const Badges=()=>jsxDevRuntimeExports.jsxDEV(AnimatePresence,{children:scene.value==="home"&&jsxDevRuntimeExports.jsxDEV(motion.div,{className:"badges",children:[jsxDevRuntimeExports.jsxDEV(motion.span,{variants:{hidden:{height:0},visible:{height:"2.9rem",transition:{delay:.4,duration:.35,ease:"easeInOut"}},exit:{height:0,transition:{delay:0,duration:.35,ease:"easeInOut"}}},initial:"hidden",animate:"visible",exit:"exit"},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Badges/index.tsx",lineNumber:9,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV(motion.p,{initial:{x:200},animate:{x:0},exit:{x:200},transition:{delay:.25,duration:.25,ease:"easeInOut"},children:[jsxDevRuntimeExports.jsxDEV("b",{children:"FRONT"},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Badges/index.tsx",lineNumber:33,columnNumber:21},globalThis),jsxDevRuntimeExports.jsxDEV("br",{},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Badges/index.tsx",lineNumber:34,columnNumber:21},globalThis),"END"]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Badges/index.tsx",lineNumber:27,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV(motion.p,{initial:{x:200},animate:{x:0},exit:{x:200},transition:{delay:.35,duration:.25,ease:"easeInOut"},children:[jsxDevRuntimeExports.jsxDEV("b",{children:"BACK"},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Badges/index.tsx",lineNumber:43,columnNumber:21},globalThis),jsxDevRuntimeExports.jsxDEV("br",{},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Badges/index.tsx",lineNumber:44,columnNumber:21},globalThis),"END"]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Badges/index.tsx",lineNumber:37,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV(motion.p,{initial:{x:200},animate:{x:0},exit:{x:200},transition:{delay:.45,duration:.25,ease:"easeInOut"},children:[jsxDevRuntimeExports.jsxDEV("b",{children:"DESIGN"},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Badges/index.tsx",lineNumber:53,columnNumber:21},globalThis),jsxDevRuntimeExports.jsxDEV("br",{},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Badges/index.tsx",lineNumber:54,columnNumber:21},globalThis),"UI/UX"]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Badges/index.tsx",lineNumber:47,columnNumber:17},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Badges/index.tsx",lineNumber:8,columnNumber:13},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Badges/index.tsx",lineNumber:6,columnNumber:5},globalThis),paths={cross:"M13.647 15L3.824 5.177 5.46 3.539l9.823 9.824 9.824-9.824 1.637 1.637L16.922 15l9.823 9.823-1.637 1.638-9.824-9.824-9.823 9.824-1.638-1.637L13.648 15z",email:"M3 2a1 1 0 00-1 1v3.42l13 7.428L28 6.42V3a1 1 0 00-1-1H3zm25 6.723l-13 7.429L2 8.723V23a1 1 0 001 1h24a1 1 0 001-1V8.723zM.879.88A3 3 0 013 0h24a3 3 0 013 3v20a3 3 0 01-3 3H3a3 3 0 01-3-3V3A3 3 0 01.879.879z",linkedin:"M3 2a1 1 0 00-1 1v24a1 1 0 001 1h24a1 1 0 001-1V3a1 1 0 00-1-1H3zM.879.879A3 3 0 013 0h24a3 3 0 013 3v24a3 3 0 01-3 3H3a3 3 0 01-3-3V3A3 3 0 01.879.879zM10 10H8V8h2v2zM8 22V12h2v10H8zm6-5v5h-2V12h2v1a5 5 0 018 4v5h-2v-5a3 3 0 00-6 0z",whatsapp:"M15 0c4 0 7.8 1.6 10.6 4.4C28.4 7.2 30 11 30 15s-1.6 7.8-4.4 10.6C22.8 28.4 19 30 15 30c-3 0-6-.9-8.5-2.6l-5.1 2.5c-.2.1-.4.1-.6.1-.2 0-.4-.1-.5-.3-.2-.1-.3-.3-.3-.5s0-.5.1-.6l2.5-5.1C1 21.1 0 18.1 0 15c0-4 1.6-7.8 4.4-10.6C7.2 1.6 11 0 15 0zm5 27c1.6-.6 3-1.6 4.2-2.8 1.2-1.2 2.2-2.6 2.8-4.2.7-1.6 1-3.3 1-5 0-1.7-.3-3.4-1-5-.6-1.6-1.6-3-2.8-4.2C23 4.6 21.6 3.7 20 3c-1.6-.7-3.3-1-5-1-3.4 0-6.8 1.4-9.2 3.8C3.4 8.2 2 11.6 2 15c0 2.8.9 5.6 2.6 7.8l.4.5-.3.6-1.5 2.9 2.9-1.5.6-.3.5.4c2.2 1.7 5 2.6 7.8 2.6 1.7 0 3.4-.3 5-1zm.1-10.5c.5.1 1 .3 1.4.6.4.3.7.7 1 1.2.2.5.2 1 .2 1.5-.1.5-.2 1-.5 1.401l-.3.4c-.05.05-.125.1-.2.15-.075.05-.15.1-.2.15-.2.1-.3.1-.5.1h-2c-2.9 0-5.7-1.1-7.8-3.2C9.2 16.7 8 13.9 8 11V9c0-.2 0-.4.1-.5l.3-.3.3-.4c.4-.3.9-.5 1.4-.5.5-.1 1 0 1.5.2s.9.5 1.2.9c.3.4.5.9.6 1.4l.3 1.7c.1.6 0 1.2-.2 1.7s-.6 1-1.1 1.3l-1.3.9c.4.7.9 1.3 1.5 1.9.5.6 1.2 1.1 1.9 1.5l.9-1.3c.3-.5.8-.9 1.3-1.1.6-.2 1.1-.3 1.7-.2l1.7.3zM10 9.5V11c0 .9.1 1.7.3 2.6l1-.7c.2-.1.3-.2.4-.4.1-.2.1-.4.1-.6l-.3-1.7c0-.2-.1-.399-.2-.499-.1-.1-.2-.2-.4-.3-.2-.1-.3-.1-.5-.1a.503.503 0 01-.2.1.503.503 0 00-.2.1zM19 20h1.5c0-.04.017-.1.037-.168.029-.097.063-.214.063-.331 0-.2 0-.3-.1-.5s-.2-.3-.3-.4a2.555 2.555 0 01-.143-.078c-.118-.069-.21-.122-.357-.122l-1.6-.3H18c-.1 0-.3 0-.5.1-.03.03-.07.06-.113.094-.099.076-.217.166-.287.306l-.7 1c.9.3 1.7.4 2.6.4z"},Icon=({color:color2="--color-base1000",name})=>{const path2=paths[name];return jsxDevRuntimeExports.jsxDEV("svg",{className:"icon",width:30,height:30,viewBox:"0 0 30 30",xmlns:"http://www.w3.org/2000/svg",fill:`var(${color2}`,children:jsxDevRuntimeExports.jsxDEV("path",{fillRule:"evenodd",clipRule:"evenodd",d:path2,fill:"inherit"},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Icon/index.tsx",lineNumber:20,columnNumber:13},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Icon/index.tsx",lineNumber:12,columnNumber:9},globalThis)};const useWindowSize=()=>{const{width:w2,height:h2}=screen,[windowSize,setWindowSize]=reactExports.useState({height:h2,width:w2,isSmartphone:w2<640,isTablet:w2>=640&&w2<1024,isLaptop:w2>=1024&&w2<1279,isHD:w2>=1280&&w2<1919,isFHD:w2>=1920&&w2<2560,isQHD:w2>=2560&&w2<3840,isUHD:w2>=3840,isHorizontal:w2>h2,isVertical:h2>w2}),handleResize=()=>{setWindowSize(prev=>({...prev,width:window.innerWidth,height:window.innerHeight,isHorizontal:window.innerWidth>window.innerHeight,isVertical:window.innerHeight>window.innerWidth}))};return reactExports.useEffect(()=>typeof window<"u"?(window.addEventListener("resize",handleResize),handleResize(),()=>window.removeEventListener("resize",handleResize)):()=>{},[]),windowSize},Job=({job})=>{const[trigger,setTrigger]=reactExports.useState(!0),[time,setTime]=reactExports.useState(null),{isSmartphone,isTablet}=useWindowSize(),{company,logo,period,roles,stack,text,website}=job;return reactExports.useEffect(()=>{clearTimeout(time),setTrigger(!1);const debounce2=setTimeout(()=>setTrigger(!0),100);setTime(debounce2)},[modalContent.value]),jsxDevRuntimeExports.jsxDEV(AnimatePresence,{children:trigger&&jsxDevRuntimeExports.jsxDEV(motion.section,{className:"job",initial:isSmartphone||isTablet?{}:{opacity:0,y:-200},animate:isSmartphone||isTablet?{}:{opacity:1,y:0},exit:isSmartphone||isTablet?{}:{opacity:0,y:200},children:[isSmartphone||isTablet?jsxDevRuntimeExports.jsxDEV("div",{className:"job-head",children:[jsxDevRuntimeExports.jsxDEV("img",{src:`${logo}.jpg`,alt:`${company} logo`},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:37,columnNumber:29},globalThis),jsxDevRuntimeExports.jsxDEV("h2",{children:company},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:38,columnNumber:29},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:36,columnNumber:25},globalThis):jsxDevRuntimeExports.jsxDEV(jsxDevRuntimeExports.Fragment,{children:[jsxDevRuntimeExports.jsxDEV("img",{src:`${logo}.jpg`,alt:`${company} logo`},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:42,columnNumber:29},globalThis),jsxDevRuntimeExports.jsxDEV("h2",{children:company},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:43,columnNumber:29},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:41,columnNumber:25},globalThis),jsxDevRuntimeExports.jsxDEV("div",{className:"job-items",children:[jsxDevRuntimeExports.jsxDEV("div",{className:"job-item",children:[jsxDevRuntimeExports.jsxDEV("h4",{children:"Roles:"},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:48,columnNumber:29},globalThis),jsxDevRuntimeExports.jsxDEV("span",{children:roles},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:49,columnNumber:29},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:47,columnNumber:25},globalThis),jsxDevRuntimeExports.jsxDEV("div",{className:"job-item",children:[jsxDevRuntimeExports.jsxDEV("h4",{children:"Period:"},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:52,columnNumber:29},globalThis),jsxDevRuntimeExports.jsxDEV("span",{children:period},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:53,columnNumber:29},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:51,columnNumber:25},globalThis),website&&jsxDevRuntimeExports.jsxDEV("div",{className:"job-item",children:[jsxDevRuntimeExports.jsxDEV("h4",{children:"Website:"},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:57,columnNumber:33},globalThis),jsxDevRuntimeExports.jsxDEV("a",{href:website,rel:"noreferrer",target:"_blank",children:website},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:58,columnNumber:33},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:56,columnNumber:29},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:46,columnNumber:21},globalThis),jsxDevRuntimeExports.jsxDEV("div",{className:"job-item",children:[jsxDevRuntimeExports.jsxDEV("h4",{children:"Stack:"},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:65,columnNumber:25},globalThis),jsxDevRuntimeExports.jsxDEV("ul",{children:[stack.map(item=>jsxDevRuntimeExports.jsxDEV("li",{children:item},`${company}-${item}`,!1,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:68,columnNumber:33},globalThis)),jsxDevRuntimeExports.jsxDEV("li",{children:"and more"},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:70,columnNumber:29},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:66,columnNumber:25},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:64,columnNumber:21},globalThis),jsxDevRuntimeExports.jsxDEV("p",{children:text},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:73,columnNumber:21},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:29,columnNumber:17},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Job/index.tsx",lineNumber:27,columnNumber:9},globalThis)},Logo=({baseColor="--color-base1000",dotColor="--color-primary",onClick})=>jsxDevRuntimeExports.jsxDEV("svg",{width:28,height:30,viewBox:"0 0 28 30",fill:"none",xmlns:"http://www.w3.org/2000/svg",className:"logo",onClick,children:[jsxDevRuntimeExports.jsxDEV("path",{d:"M6.31 5.165C8.218 2.195 11.576.71 16.384.71v6.31a8.414 8.414 0 00-1.538-.16c-2.58 0-4.595.76-6.044 2.28-1.45 1.485-2.174 3.641-2.174 6.47v13.732H0V1.029h6.31v4.136z",fill:`var(${baseColor})`},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Logo/index.tsx",lineNumber:21,columnNumber:9},globalThis),jsxDevRuntimeExports.jsxDEV("path",{d:"M22.265 29.308c-1.201 0-2.227-.407-3.075-1.22-.848-.848-1.273-1.909-1.273-3.181 0-1.308.407-2.369 1.22-3.182.848-.813 1.891-1.22 3.128-1.22 1.238 0 2.263.407 3.076 1.22.848.813 1.272 1.874 1.272 3.182 0 1.272-.424 2.333-1.272 3.181-.849.813-1.874 1.22-3.076 1.22z",fill:`var(${dotColor})`},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Logo/index.tsx",lineNumber:25,columnNumber:9},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Logo/index.tsx",lineNumber:12,columnNumber:5},globalThis);const modalRoot=document.getElementById("modal"),Modal=()=>{const{width,height,isSmartphone,isTablet}=useWindowSize();return reactExports.useEffect(()=>{closeModal()},[scene.value]),reactDomExports.createPortal(jsxDevRuntimeExports.jsxDEV(AnimatePresence,{children:isModalVisible.value&&jsxDevRuntimeExports.jsxDEV(motion.section,{className:"modal",initial:isSmartphone||isTablet?{x:width,opacity:0}:{x:width,y:-height/7,scale:2,rotate:-30,opacity:0},animate:isSmartphone||isTablet?{x:0,opacity:1,transition:{duration:.3,ease:"easeOut"}}:{x:0,y:0,scale:1,rotate:0,opacity:1,transition:{duration:.3,ease:"easeOut"}},exit:isSmartphone||isTablet?{x:width,opacity:0,transition:{duration:.5,ease:"easeIn"}}:{x:width,y:-height/7,scale:2,rotate:-30,opacity:0,transition:{duration:.75,ease:"easeIn"}},children:[jsxDevRuntimeExports.jsxDEV("button",{title:"close",type:"button",onClick:closeModal,children:jsxDevRuntimeExports.jsxDEV(Icon,{name:"cross"},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Modal/index.tsx",lineNumber:71,columnNumber:25},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Modal/index.tsx",lineNumber:70,columnNumber:21},globalThis),jsxDevRuntimeExports.jsxDEV("div",{className:"modal-content",children:modalContent},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Modal/index.tsx",lineNumber:73,columnNumber:21},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Modal/index.tsx",lineNumber:21,columnNumber:17},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Modal/index.tsx",lineNumber:19,columnNumber:9},globalThis),modalRoot)},path="/rcf.svg",Name=()=>{const groupRef=reactExports.useRef(null),{isSmartphone,isTablet,isHorizontal,isLaptop}=useWindowSize(),scale2=isLaptop&&isHorizontal?8e-4:isSmartphone||isTablet?.001:8e-4;return useFrame(()=>{groupRef.current.rotation.z+=Math.PI/300}),jsxDevRuntimeExports.jsxDEV("group",{ref:groupRef,position:isLaptop&&isHorizontal?[0,0,-.5]:isSmartphone||isTablet?[0,.6,-.5]:[0,-.04,-.5],children:jsxDevRuntimeExports.jsxDEV(Center,{children:jsxDevRuntimeExports.jsxDEV(Svg,{name:"name",scale:[scale2,scale2,scale2],src:path},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Name/index.tsx",lineNumber:29,columnNumber:17},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Name/index.tsx",lineNumber:28,columnNumber:13},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Name/index.tsx",lineNumber:18,columnNumber:9},globalThis)},file1="animations/Idle.fbx",file2="animations/Music.fbx",file3="animations/Neutral.fbx",file4="animations/OpenArms.fbx",Ricardo=props=>{const{nodes,materials}=useGLTF("models/ricardo_white4.glb");useGLTF.preload("models/ricardo_white4.glb"),useFBX.preload(file1),useFBX.preload(file2),useFBX.preload(file3),useFBX.preload(file4);const[animation,setAnimation]=reactExports.useState("idle"),[time,setTime]=reactExports.useState(null),[fadeoutTime,setFadeoutTime]=reactExports.useState(null),group=reactExports.useRef(),{isSmartphone,isTablet,isHorizontal,isLaptop}=useWindowSize(),{animations:idleAnimation}=useFBX(file1),{animations:musicAnimation}=useFBX(file2),{animations:neutralAnimation}=useFBX(file3),{animations:openArmsAnimation}=useFBX(file4);idleAnimation[0].name="idle",musicAnimation[0].name="music",neutralAnimation[0].name="neutral",openArmsAnimation[0].name="openarms";const{actions}=useAnimations([idleAnimation[0],musicAnimation[0],neutralAnimation[0],openArmsAnimation[0]],group);return reactExports.useEffect(()=>{const item=actions[animation];if(item){clearTimeout(time),clearTimeout(fadeoutTime);const next=animation==="idle"?"music":animation==="music"?"openarms":animation==="openarms"?"neutral":"idle",debounce2=setTimeout(()=>setAnimation(next),item._clip.duration*1e3),fadeout=setTimeout(()=>{var _a2;return(_a2=actions[animation])==null?void 0:_a2.fadeOut(2.5)},item._clip.duration*1e3-2500);setTime(debounce2),setFadeoutTime(fadeout)}},[animation]),reactExports.useEffect(()=>{var _a2;return(_a2=actions[animation])==null||_a2.fadeIn(2.5).play(),()=>{var _a3;return(_a3=actions[animation])==null?void 0:_a3.fadeOut(2.5)}},[actions]),jsxDevRuntimeExports.jsxDEV("group",{...props,dispose:null,ref:group,children:jsxDevRuntimeExports.jsxDEV("group",{position:isLaptop&&isHorizontal?[0,-Math.PI/2,0]:isSmartphone||isTablet?[0,-Math.PI/3.25,0]:[0,-Math.PI/2,0],children:[jsxDevRuntimeExports.jsxDEV("skinnedMesh",{name:"EyeLeft",geometry:nodes.EyeLeft.geometry,material:materials.Wolf3D_Eye,skeleton:nodes.EyeLeft.skeleton,morphTargetDictionary:nodes.EyeLeft.morphTargetDictionary,morphTargetInfluences:nodes.EyeLeft.morphTargetInfluences},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Ricardo/index.tsx",lineNumber:84,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("skinnedMesh",{name:"EyeRight",geometry:nodes.EyeRight.geometry,material:materials.Wolf3D_Eye,skeleton:nodes.EyeRight.skeleton,morphTargetDictionary:nodes.EyeRight.morphTargetDictionary,morphTargetInfluences:nodes.EyeRight.morphTargetInfluences},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Ricardo/index.tsx",lineNumber:92,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("skinnedMesh",{name:"Wolf3D_Beard",geometry:nodes.Wolf3D_Beard.geometry,material:materials.Wolf3D_Beard,skeleton:nodes.Wolf3D_Beard.skeleton,morphTargetDictionary:nodes.Wolf3D_Beard.morphTargetDictionary,morphTargetInfluences:nodes.Wolf3D_Beard.morphTargetInfluences},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Ricardo/index.tsx",lineNumber:100,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("skinnedMesh",{name:"Wolf3D_Body",geometry:nodes.Wolf3D_Body.geometry,material:materials.Wolf3D_Body,skeleton:nodes.Wolf3D_Body.skeleton,morphTargetDictionary:nodes.Wolf3D_Body.morphTargetDictionary,morphTargetInfluences:nodes.Wolf3D_Body.morphTargetInfluences},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Ricardo/index.tsx",lineNumber:108,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("skinnedMesh",{geometry:nodes.Wolf3D_Glasses.geometry,material:materials.Wolf3D_Glasses,skeleton:nodes.Wolf3D_Glasses.skeleton},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Ricardo/index.tsx",lineNumber:116,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("skinnedMesh",{geometry:nodes.Wolf3D_Hair.geometry,material:materials.Wolf3D_Hair,skeleton:nodes.Wolf3D_Hair.skeleton},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Ricardo/index.tsx",lineNumber:121,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("skinnedMesh",{name:"Wolf3D_Head",geometry:nodes.Wolf3D_Head.geometry,material:materials.Wolf3D_Skin,skeleton:nodes.Wolf3D_Head.skeleton,morphTargetDictionary:nodes.Wolf3D_Head.morphTargetDictionary,morphTargetInfluences:nodes.Wolf3D_Head.morphTargetInfluences},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Ricardo/index.tsx",lineNumber:126,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("skinnedMesh",{name:"Wolf3D_Outfit_Bottom",geometry:nodes.Wolf3D_Outfit_Bottom.geometry,material:materials.Wolf3D_Outfit_Bottom,skeleton:nodes.Wolf3D_Outfit_Bottom.skeleton,morphTargetDictionary:nodes.Wolf3D_Outfit_Bottom.morphTargetDictionary,morphTargetInfluences:nodes.Wolf3D_Outfit_Bottom.morphTargetInfluences},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Ricardo/index.tsx",lineNumber:134,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("skinnedMesh",{name:"Wolf3D_Outfit_Footwear",geometry:nodes.Wolf3D_Outfit_Footwear.geometry,material:materials.Wolf3D_Outfit_Footwear,skeleton:nodes.Wolf3D_Outfit_Footwear.skeleton,morphTargetDictionary:nodes.Wolf3D_Outfit_Footwear.morphTargetDictionary,morphTargetInfluences:nodes.Wolf3D_Outfit_Footwear.morphTargetInfluences},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Ricardo/index.tsx",lineNumber:142,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("skinnedMesh",{name:"Wolf3D_Outfit_Top",geometry:nodes.Wolf3D_Outfit_Top.geometry,material:materials.Wolf3D_Outfit_Top,skeleton:nodes.Wolf3D_Outfit_Top.skeleton,morphTargetDictionary:nodes.Wolf3D_Outfit_Top.morphTargetDictionary,morphTargetInfluences:nodes.Wolf3D_Outfit_Top.morphTargetInfluences},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Ricardo/index.tsx",lineNumber:150,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("skinnedMesh",{name:"Wolf3D_Teeth",geometry:nodes.Wolf3D_Teeth.geometry,material:materials.Wolf3D_Teeth,skeleton:nodes.Wolf3D_Teeth.skeleton,morphTargetDictionary:nodes.Wolf3D_Teeth.morphTargetDictionary,morphTargetInfluences:nodes.Wolf3D_Teeth.morphTargetInfluences},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Ricardo/index.tsx",lineNumber:158,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("primitive",{object:nodes.Hips},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Ricardo/index.tsx",lineNumber:166,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV(ContactShadows,{opacity:.3,scale:10,blur:1,far:10,resolution:256,color:"#000000"},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Ricardo/index.tsx",lineNumber:167,columnNumber:17},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Ricardo/index.tsx",lineNumber:75,columnNumber:13},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Ricardo/index.tsx",lineNumber:74,columnNumber:9},globalThis)},NavCamera=({control,position,useMouse})=>{const controlVec=new Vector3(control[0],control[1],control[2]),positionVec=new Vector3(position[0],position[1],position[2]),standVec=new Vector3,[time,setTime]=reactExports.useState(null),[lookAt,setLookAt]=reactExports.useState(!0),{isSmartphone,isTablet}=useWindowSize(),factor=isSmartphone||isTablet?2:3;reactExports.useEffect(()=>{if(scene.value==="home"){clearTimeout(time);const debounce2=setTimeout(()=>setLookAt(!0),1e3);setTime(debounce2)}else setLookAt(!1)},[scene.value]),useFrame(({controls,camera,mouse})=>{var _a2;(_a2=controls==null?void 0:controls.target)==null||_a2.lerp(controlVec,.18),camera.position.lerp(positionVec,.12),useMouse&&lookAt&&(standVec.set(mouse.x*factor,mouse.y*factor,camera.position.z*1),camera.position.lerp(standVec,.4),camera.lookAt(0,0,0))})},Scene2=({children})=>{const[position,setPosition]=reactExports.useState([0,1.5,9]),[control,setControl]=reactExports.useState([0,1.5,9]),[useMouse,setUseMouse]=reactExports.useState(!0),{isSmartphone,isTablet,isLaptop,isHorizontal}=useWindowSize();reactExports.useEffect(()=>{scene.value==="home"?(setPosition([0,1.5,9]),setControl([0,0,0]),setUseMouse(!0)):useMouse&&(setPosition(isLaptop&&isHorizontal?[0,0,80]:isSmartphone?[0,0,80]:isTablet?[0,0,60]:[0,1.5,30]),setControl(isLaptop&&isHorizontal?[-5,3,0]:isSmartphone?[-5,11,0]:isTablet?[-5,7,0]:[-1.3,-.55,0]),setUseMouse(!1))},[scene.value]);const Loader2=()=>{const{progress:progress2}=useProgress();return jsxDevRuntimeExports.jsxDEV(Html,{wrapperClass:"loader",as:"section",children:[jsxDevRuntimeExports.jsxDEV("p",{children:"LOADING..."},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Scene/index.tsx",lineNumber:85,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("section",{className:"progress_bar",children:[jsxDevRuntimeExports.jsxDEV("h1",{children:`${Math.ceil(progress2)}%`},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Scene/index.tsx",lineNumber:87,columnNumber:21},globalThis),jsxDevRuntimeExports.jsxDEV("span",{className:"progress",style:{width:`${progress2}%`}},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Scene/index.tsx",lineNumber:88,columnNumber:21},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Scene/index.tsx",lineNumber:86,columnNumber:17},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Scene/index.tsx",lineNumber:84,columnNumber:13},globalThis)};return jsxDevRuntimeExports.jsxDEV(Canvas2,{className:"canvas",shadows:!0,children:jsxDevRuntimeExports.jsxDEV(reactExports.Suspense,{fallback:jsxDevRuntimeExports.jsxDEV(Loader2,{},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Scene/index.tsx",lineNumber:96,columnNumber:33},globalThis),children:[jsxDevRuntimeExports.jsxDEV(PerspectiveCamera2,{makeDefault:!0,position:[0,1.5,9],fov:isLaptop&&isHorizontal?5:isSmartphone?18:isTablet?16:5},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Scene/index.tsx",lineNumber:97,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV(OrbitControls2,{makeDefault:!0,target:[0,0,0],enablePan:scene.value!=="home",enableRotate:!1,enableZoom:!1},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Scene/index.tsx",lineNumber:102,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("pointLight",{position:[-1,2.5,1],color:"blue",intensity:300,power:500},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Scene/index.tsx",lineNumber:109,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("pointLight",{position:[1,2.5,-1],color:"pink",intensity:300,power:500},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Scene/index.tsx",lineNumber:110,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("pointLight",{position:[0,2.5,-1],color:"white",intensity:100,power:500},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Scene/index.tsx",lineNumber:111,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("ambientLight",{intensity:1.5},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Scene/index.tsx",lineNumber:112,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV(NavCamera,{control,position,useMouse},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Scene/index.tsx",lineNumber:113,columnNumber:17},globalThis),children]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Scene/index.tsx",lineNumber:96,columnNumber:13},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Scene/index.tsx",lineNumber:95,columnNumber:9},globalThis)},designerSince=2008,programmerSince=2011,designerExperience=new Date().getFullYear()-designerSince,programmerExperience=new Date().getFullYear()-programmerSince,socialLinks=[{icon:"linkedin",link:"https://www.linkedin.com/in/ricardo-colombo-ferreira/"},{icon:"whatsapp",link:"https://wa.me/351913627070"}],navLinks=["about","career","skills"],about={heading:"Problem-solving is the key word of both worlds:",texts:[`Hi, my name is Ricardo and I'm a developer/designer. I combine my ${designerExperience} years design experience with ${programmerExperience} years front-end experience to create applications and experiences for both: users and developers.`,"My front-end career began in 2011, after finishing a web design course I started developing web pages and newsletters using HTML and CSS at the agency where I was working at the time. In 2014, I began working with WordPress, and in 2018, I landed my first full-time front-end dev position.","I consider myself fortunate to love both my work and the role I play in this world. I'm creative and passionate about bringing ideas to life, always striving to apply best practices in both user and devs experience."]},career=[{logo:"sendible",company:"Sendible UK",period:"NOW - 2022",roles:"UI/UX developer & Front-end engineer",website:"https://www.sendible.com",stack:["React","Typescript","Storybook","Jest","React Query","Styled Components","StencilJS","Web Components","Lottie","Framer Motion","Figma"],text:"I was hired to create and maintain the company’s component library and design system, aiming to accelerate development, standardize systems, and enhance both developer and user experiences. Here, I’ve found an incredible team, a supportive environment, and the freedom to grow. I’m also contributing to a new application that's set to transform how agencies around the world operate."},{logo:"beyond",company:"Beyond Solutions",period:"2022 - 2021",roles:"UI/UX developer & Front-end engineer",website:"https://www.imaginebeyond.com.br",stack:["React","Next","Typescript","Storybook","Jest","Styled Components","Lottie","Figma"],text:"At Beyond, I had the privilege of working on three important projects. One was the creation of a company-wide design system using React, TypeScript, and Storybook to ensure the best experience for both developers and users. The second was building a portal with Next.js for the giant Brazilian bank BTG, followed by the opportunity to join the ranks of EIS Group."},{logo:"skore",company:"Skore (UOL EdTech)",period:"2021 - 2020",roles:"UX/UI Designer & Front-end developer",website:"https://uoledtech.com.br",stack:["VueJS","Nuxt","Javascript","Sass","Storybook","React","Lottie","Figma"],text:"At Skore, I’ve played two roles: designer and developer. Here, I’ve applied creativity and solid UX/design practices to help create and evolve products, using low and high-fidelity prototypes in Figma and Adobe XD, then developing them with Nuxt and Vue.js. At Skore, I also created my first design system."},{logo:"beforeti",company:"Before TI",period:"2020 - 2018",roles:"UX/UI Designer & Front-end developer",website:"https://www.before.com.br",stack:["VueJS","Nuxt","Javascript","Sass","Figma"],text:"At Before, I had an amazing environment to grow. I've learned so many things and worked across many different areas, creating various designs and special projects for one of Brazil’s largest telecom companies: Vivo."},{logo:"toricco",company:"Tô Ricco",period:"2018",roles:"UX/UI Designer & Front-end developer",website:"https://toricco.com.br",stack:["React Native","Javascript","HTML","Sass","Figma"],text:"Tô Ricco was a very special company in my life. It marked my career transition from agencies to tech, bringing a new mindset and a lot to learn — it was love at first sight! At Tô Ricco, I created many designs and built my first React Native application alongside the other four members of our small team."},{logo:"ad",company:"Ad Agencies",period:"2008 - 2018",roles:"Web + Motion Designer & Creative Director",stack:["Javascript","HTML","CSS","Figma","Wordpress","Photoshop","Illustrator","Animate","After Effects"],text:"I've worked for many agencies in that period, starting as a arte final and scaling up until becoming a creative director. During that period I've created countless arts and animations for the most varied types of customers and also developed some websites using pure HTML, CSS, Javascript and Wordpress."}],skills=[{icon:"REACT",name:"React & React Native",since:"2018",projects:"40+",text:"React and Vue.js are my favorite libraries for front-end development, and React is the one I’ve used most over the last 5 years. I first worked with React Native in 2018 at Tô Ricco, and since then I’ve developed many different projects and apps using both React and React Native."},{icon:"TYPESCRIPT",name:"Javascript & Typescript",since:"2014",projects:"Lost the count",text:"The first time I tried JavaScript was in 2014, but it only became a daily tool in 2018 when I joined Tô Ricco. I was always fascinated by JS, but in 2020 I discovered TypeScript — and it was love at first sight. Since then, I haven’t started a single project without it."},{icon:"VUEJS",name:"VueJS",since:"2018",projects:"30+",text:"I worked for three straight years with Vue.js and Nuxt.js, from 2018 to 2021. In terms of development experience, Vue.js is my favorite — it’s so easy and predictable to use… I just love it."},{icon:"STORYBOOK",name:"Storybook",since:"2021",projects:"5",text:"Storybook is one of my best friends. It's a must when I develop a component library and design system. With typescript, styled-components and jest we can achieve an amazing dev experience for the users and developers."},{icon:"FIGMA",name:"Figma",since:"2018",projects:"Lost the count",text:"There's not much to say. I use Figma in every single project I work on since 2018. It's a must ❤️."},{icon:"NESTJS",name:"NestJS",since:"2023",projects:"2",text:"As a new backend developer, I found in NestJS the perfect friend to create my API's. As a TS backend framework, Nest allows me to use all my TS/frontend experience to develop typesafe API's. I'm just loving it!"},{icon:"NUXT",name:"NuxtJS",since:"2019",projects:"15+",text:"For a long time Nuxt was my favorite framework to develop frontends. With it I've created many VueJS project for the companies I've worked for and freelances. It's just amazing."},{icon:"NEXT",name:"NextJS",since:"2021",projects:"5",text:"Just like Nuxt, it makes the development experience so easy for React projects. I've developed a project for the brazilian bank BTG Pactual and 4 other freelance projects in the past."},{icon:"REACTQUERY",name:"React Query",since:"2022",projects:"3",text:"This is another best friend. I was first introduced to React Query at Sendible and I've been using it in every medium/big project since then."},{icon:"STENCIL",name:"StencilJS & Web Components",since:"2020",projects:"1",text:"Oh boy! I just love this guy. With StencilJS and Storybook we can create a framework agnostic component library/design system using webcomponents. Do you see the power it holds? Unfortunately I havent't had the opportunity to create big project using that stack yet, only proof of concepts."},{icon:"JEST",name:"Jest",since:"2020",projects:"10+",text:"I've been using Jest to test my frontends, backends and design systems since I've learned it back in 2020. You know, creating tests slows down development but prevents many bugs later."},{icon:"STYLEDCOMPONENTS",name:"Styled Components",since:"2020",projects:"10+",text:"This is another big friend. CSS-IN-JS with Typescript provides an amazing development experience. In design systems it's just amazing, it provides all the typesafety and syntax highlight the developers needs and it's amazing to control themes. It's a must!"},{icon:"GRAPHQL",name:"GraphQl",since:"2020",projects:"3",text:"I've worked on 3 projects that used GraphQl. Unfortunately I didn't have the opportunity to use it in any project since 2021."},{icon:"SASS",name:"CSS & SASS",since:"2011",projects:"Lost the count",text:"As a designer I can say I love styling, it's the place I shine. I don't measure efforts to make a design look exactely how it was idealized. I've learned CSS with HTML back in 2011 and SASS around 2016. Even if I use Styled-components, I write the code just like SASS."},{icon:"LOTTIE",name:"Lottie",since:"2019",projects:"Lost the count",text:"I've been using Airbnb's Lottie to crete animations to use on my projects since I've learned it in 2019. With Lottie you can create After Effect animations and export then as JSON files in your apps."},{icon:"FRAMER",name:"Framer Motion",since:"2020",projects:"Lost the count",text:"Framer motion makes our life easier when creation animations and interactions in our app. I use it on almost every project."},{icon:"THREEJS",name:"ThreeJS & React Fiber",since:"2022",projects:"2",text:"This lib is the core of this portfolio. With ThreeJS you can create amazing 3D applications. Unfortunately I don't have much opportunities to use it."},{icon:"REDUX",name:"Signal, Redux, Vuex, Pinia",since:"2018",projects:"Lost the count",text:"My favorite tool for store management are those described above, but recently recently I'm loving Signals... it's ridiculously simple and safe."},{icon:"BLENDER",name:"Blender",since:"2022",projects:"10+",text:"I'm still learning the ways of 3D modelling, but been able to achieve every goal so far."},{icon:"CC",name:"Photoshop, After Effects, Etc",since:"2005",projects:"Lost the count",text:"I've been using Adobe Creative Cloud programs since the college back in 2005. My favorites are: Photoshop, Illustrator and After Effects."}];const Sidebar=()=>jsxDevRuntimeExports.jsxDEV("aside",{children:[jsxDevRuntimeExports.jsxDEV("button",{className:"home-button",children:jsxDevRuntimeExports.jsxDEV(Logo,{onClick:()=>setScene("home")},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Sidebar/index.tsx",lineNumber:9,columnNumber:13},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Sidebar/index.tsx",lineNumber:8,columnNumber:9},globalThis),jsxDevRuntimeExports.jsxDEV("nav",{children:navLinks.map(link=>jsxDevRuntimeExports.jsxDEV("button",{className:scene.value===link?"active":"",onClick:()=>setScene(link),title:link,children:link},link,!1,{fileName:"D:/projetos/rdsign/src/components/Sidebar/index.tsx",lineNumber:13,columnNumber:17},globalThis))},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Sidebar/index.tsx",lineNumber:11,columnNumber:9},globalThis),jsxDevRuntimeExports.jsxDEV("div",{className:"social",children:socialLinks.map(({icon,link})=>jsxDevRuntimeExports.jsxDEV("a",{href:link,rel:"noreferrer",target:"_blank",children:jsxDevRuntimeExports.jsxDEV(Icon,{name:icon},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Sidebar/index.tsx",lineNumber:26,columnNumber:21},globalThis)},icon,!1,{fileName:"D:/projetos/rdsign/src/components/Sidebar/index.tsx",lineNumber:25,columnNumber:17},globalThis))},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Sidebar/index.tsx",lineNumber:23,columnNumber:9},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Sidebar/index.tsx",lineNumber:7,columnNumber:5},globalThis),Skill=({skill})=>{const{name,icon,projects,since,text}=skill,{isSmartphone,isTablet}=useWindowSize();return jsxDevRuntimeExports.jsxDEV("section",{className:"job",children:[isSmartphone||isTablet?jsxDevRuntimeExports.jsxDEV("div",{className:"job-head",children:[jsxDevRuntimeExports.jsxDEV("img",{src:`/logos/${icon}.png`,alt:`${name} logo`},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Skill/index.tsx",lineNumber:16,columnNumber:21},globalThis),jsxDevRuntimeExports.jsxDEV("h2",{children:name},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Skill/index.tsx",lineNumber:17,columnNumber:21},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Skill/index.tsx",lineNumber:15,columnNumber:17},globalThis):jsxDevRuntimeExports.jsxDEV(jsxDevRuntimeExports.Fragment,{children:[jsxDevRuntimeExports.jsxDEV("img",{src:`/logos/${icon}.png`,alt:`${name} logo`},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Skill/index.tsx",lineNumber:21,columnNumber:21},globalThis),jsxDevRuntimeExports.jsxDEV("h2",{children:name},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Skill/index.tsx",lineNumber:22,columnNumber:21},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Skill/index.tsx",lineNumber:20,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("div",{className:"job-item",children:[jsxDevRuntimeExports.jsxDEV("h4",{children:"Since:"},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Skill/index.tsx",lineNumber:26,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("span",{children:since},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Skill/index.tsx",lineNumber:27,columnNumber:17},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Skill/index.tsx",lineNumber:25,columnNumber:13},globalThis),jsxDevRuntimeExports.jsxDEV("div",{className:"job-item",children:[jsxDevRuntimeExports.jsxDEV("h4",{children:"Number of projects:"},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Skill/index.tsx",lineNumber:30,columnNumber:17},globalThis),jsxDevRuntimeExports.jsxDEV("span",{children:projects},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Skill/index.tsx",lineNumber:31,columnNumber:17},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Skill/index.tsx",lineNumber:29,columnNumber:13},globalThis),jsxDevRuntimeExports.jsxDEV("p",{children:text},void 0,!1,{fileName:"D:/projetos/rdsign/src/components/Skill/index.tsx",lineNumber:33,columnNumber:13},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/components/Skill/index.tsx",lineNumber:13,columnNumber:9},globalThis)};const About=()=>{const{width,height,isHorizontal,isSmartphone,isTablet,isLaptop}=useWindowSize(),title1=isSmartphone||isTablet?"DESIGN":"DESIGN & ",title2=isSmartphone||isTablet?"& DEV":"PROGRAMMING",title3="DESIGN & DEV",title=jsxDevRuntimeExports.jsxDEV(jsxDevRuntimeExports.Fragment,{children:isHorizontal&&(isSmartphone||isTablet||isLaptop)?jsxDevRuntimeExports.jsxDEV("span",{style:{display:"flex"},children:title3.split("").map((char,index)=>jsxDevRuntimeExports.jsxDEV(motion.h1,{variants:{hidden:{y:-index*(height/20),opacity:0,x:-width/3},visible:{y:0,opacity:1,x:0}},initial:"hidden",animate:"visible",transition:{delay:1+index*.02,duration:1,ease:"anticipate"},children:[index===6&&jsxDevRuntimeExports.jsxDEV(jsxDevRuntimeExports.Fragment,{children:" "},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:38,columnNumber:45},globalThis),char]},`title3-${index}`,!0,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:20,columnNumber:25},globalThis))},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:18,columnNumber:17},globalThis):jsxDevRuntimeExports.jsxDEV(jsxDevRuntimeExports.Fragment,{children:[jsxDevRuntimeExports.jsxDEV("span",{style:{display:"flex"},children:title1.split("").map((char,index)=>jsxDevRuntimeExports.jsxDEV(motion.h1,{variants:{hidden:{y:-index*(height/20),opacity:0,x:-width/3},visible:{y:0,opacity:1,x:0}},initial:"hidden",animate:"visible",transition:{delay:1+index*.02,duration:1,ease:"anticipate"},children:[index===6&&jsxDevRuntimeExports.jsxDEV(jsxDevRuntimeExports.Fragment,{children:" "},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:65,columnNumber:49},globalThis),char]},`title1-${index}`,!0,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:47,columnNumber:29},globalThis))},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:45,columnNumber:21},globalThis),jsxDevRuntimeExports.jsxDEV("span",{style:{display:"flex"},children:title2.split("").map((char,index)=>jsxDevRuntimeExports.jsxDEV(motion.h1,{variants:{hidden:{y:index*(height/20),opacity:0,x:width/3},visible:{y:0,opacity:1,x:0}},initial:"hidden",animate:"visible",transition:{delay:1.25+index*.02,duration:1,ease:"anticipate"},children:char},`title2-${index}`,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:72,columnNumber:29},globalThis))},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:70,columnNumber:21},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:44,columnNumber:17},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:16,columnNumber:9},globalThis);return jsxDevRuntimeExports.jsxDEV(Html,{wrapperClass:"about content",as:"section",children:jsxDevRuntimeExports.jsxDEV(AnimatePresence,{children:scene.value==="about"&&jsxDevRuntimeExports.jsxDEV(motion.section,{exit:{x:width/5,opacity:0},transition:{duration:.33,ease:"easeInOut"},children:[jsxDevRuntimeExports.jsxDEV(AnimateChangeInHeight,{transition:{delay:0,duration:1,ease:"easeIn"},children:jsxDevRuntimeExports.jsxDEV(motion.h2,{variants:{hidden:{y:height/9},visible:{y:0}},initial:"hidden",animate:"visible",transition:{delay:0,duration:1,ease:"anticipate"},children:about.heading},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:110,columnNumber:29},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:107,columnNumber:25},globalThis),jsxDevRuntimeExports.jsxDEV(AnimateChangeInHeight,{transition:{delay:1,duration:1,ease:"easeInOut"},children:title},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:122,columnNumber:25},globalThis),jsxDevRuntimeExports.jsxDEV(AnimateChangeInHeight,{transition:{delay:3.5,duration:.5,ease:"easeInOut"},children:jsxDevRuntimeExports.jsxDEV(motion.p,{variants:{hidden:{y:-height/2},visible:{y:0}},initial:"hidden",animate:"visible",transition:{duration:.75},children:about.texts[0]},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:130,columnNumber:29},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:127,columnNumber:25},globalThis),jsxDevRuntimeExports.jsxDEV(AnimateChangeInHeight,{transition:{delay:3.55,duration:.5,ease:"easeInOut"},children:jsxDevRuntimeExports.jsxDEV("p",{children:about.texts[1]},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:147,columnNumber:29},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:144,columnNumber:25},globalThis),jsxDevRuntimeExports.jsxDEV(AnimateChangeInHeight,{transition:{delay:3.6,duration:.5,ease:"easeInOut"},children:jsxDevRuntimeExports.jsxDEV(motion.p,{variants:{hidden:{y:height/2},visible:{y:0}},initial:"hidden",animate:"visible",transition:{duration:.75},children:about.texts[2]},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:152,columnNumber:29},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:149,columnNumber:25},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:103,columnNumber:21},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:101,columnNumber:13},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/About/index.tsx",lineNumber:100,columnNumber:9},globalThis)};const Career=()=>{const{width,height}=useWindowSize(),handleModal=job=>{openModal(jsxDevRuntimeExports.jsxDEV(Job,{job},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/Career/index.tsx",lineNumber:13,columnNumber:19},globalThis))};return jsxDevRuntimeExports.jsxDEV(Html,{wrapperClass:"career content",as:"section",children:jsxDevRuntimeExports.jsxDEV(AnimatePresence,{children:scene.value==="career"&&jsxDevRuntimeExports.jsxDEV(motion.ul,{className:"cropper",initial:{opacity:0,y:-height/3},animate:{opacity:1,y:0},exit:{opacity:0,y:height/3},transition:{duration:.25,ease:"easeInOut"},children:career.map((job,index)=>jsxDevRuntimeExports.jsxDEV(motion.li,{onClick:()=>handleModal(job),variants:{hidden:{opacity:0,x:width/3},visible:{opacity:1,x:0}},initial:"hidden",animate:"visible",transition:{duration:.35,delay:.25+index*.05,ease:"easeOut"},children:[jsxDevRuntimeExports.jsxDEV("h3",{children:[job.period,jsxDevRuntimeExports.jsxDEV("b",{children:` ${job.company}`},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/Career/index.tsx",lineNumber:45,columnNumber:37},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/scenes/Career/index.tsx",lineNumber:43,columnNumber:33},globalThis),jsxDevRuntimeExports.jsxDEV("p",{children:job.roles},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/Career/index.tsx",lineNumber:47,columnNumber:33},globalThis)]},job.company,!0,{fileName:"D:/projetos/rdsign/src/scenes/Career/index.tsx",lineNumber:28,columnNumber:29},globalThis))},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/Career/index.tsx",lineNumber:20,columnNumber:21},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/Career/index.tsx",lineNumber:18,columnNumber:13},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/Career/index.tsx",lineNumber:17,columnNumber:9},globalThis)},Home=()=>jsxDevRuntimeExports.jsxDEV("group",{children:[jsxDevRuntimeExports.jsxDEV("directionalLight",{position:[3.3,1,4.4],castShadow:!0},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/Home/index.tsx",lineNumber:5,columnNumber:9},globalThis),jsxDevRuntimeExports.jsxDEV(Ricardo,{},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/Home/index.tsx",lineNumber:6,columnNumber:9},globalThis),jsxDevRuntimeExports.jsxDEV(Name,{},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/Home/index.tsx",lineNumber:7,columnNumber:9},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/scenes/Home/index.tsx",lineNumber:4,columnNumber:5},globalThis);const Skills=()=>{const{width,height}=useWindowSize(),handleModal=skill=>{openModal(jsxDevRuntimeExports.jsxDEV(Skill,{skill},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/Skills/index.tsx",lineNumber:13,columnNumber:19},globalThis)),setActiveSkill(skill.name)};return jsxDevRuntimeExports.jsxDEV(Html,{wrapperClass:"skills content",as:"section",children:jsxDevRuntimeExports.jsxDEV(AnimatePresence,{children:scene.value==="skills"&&jsxDevRuntimeExports.jsxDEV(motion.ul,{className:"cropper",initial:{opacity:0,y:-height/3},animate:{opacity:1,y:0},exit:{opacity:0,y:height/3},transition:{duration:.25,ease:"easeInOut"},children:skills.map((skill,index)=>jsxDevRuntimeExports.jsxDEV(motion.li,{onClick:()=>handleModal(skill),variants:{hidden:{opacity:0,x:width/3},visible:{opacity:1,x:0}},initial:"hidden",animate:"visible",transition:{duration:.15,delay:.25+index*.015,ease:"easeOut"},title:skill.name,children:jsxDevRuntimeExports.jsxDEV("img",{src:`/logos/${skill.icon}.png`,alt:`${skill.name} logo`,className:activeSkill.value!==skill.name?"ns":""},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/Skills/index.tsx",lineNumber:45,columnNumber:33},globalThis)},skill.name,!1,{fileName:"D:/projetos/rdsign/src/scenes/Skills/index.tsx",lineNumber:29,columnNumber:29},globalThis))},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/Skills/index.tsx",lineNumber:21,columnNumber:21},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/Skills/index.tsx",lineNumber:19,columnNumber:13},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/scenes/Skills/index.tsx",lineNumber:18,columnNumber:9},globalThis)},App=()=>jsxDevRuntimeExports.jsxDEV("main",{children:[jsxDevRuntimeExports.jsxDEV(Sidebar,{},void 0,!1,{fileName:"D:/projetos/rdsign/src/App.tsx",lineNumber:6,columnNumber:9},globalThis),jsxDevRuntimeExports.jsxDEV(Badges,{},void 0,!1,{fileName:"D:/projetos/rdsign/src/App.tsx",lineNumber:7,columnNumber:9},globalThis),jsxDevRuntimeExports.jsxDEV(Scene2,{children:[jsxDevRuntimeExports.jsxDEV(Home,{},void 0,!1,{fileName:"D:/projetos/rdsign/src/App.tsx",lineNumber:9,columnNumber:13},globalThis),jsxDevRuntimeExports.jsxDEV(About,{},void 0,!1,{fileName:"D:/projetos/rdsign/src/App.tsx",lineNumber:10,columnNumber:13},globalThis),jsxDevRuntimeExports.jsxDEV(Career,{},void 0,!1,{fileName:"D:/projetos/rdsign/src/App.tsx",lineNumber:11,columnNumber:13},globalThis),jsxDevRuntimeExports.jsxDEV(Skills,{},void 0,!1,{fileName:"D:/projetos/rdsign/src/App.tsx",lineNumber:12,columnNumber:13},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/App.tsx",lineNumber:8,columnNumber:9},globalThis),jsxDevRuntimeExports.jsxDEV(Modal,{},void 0,!1,{fileName:"D:/projetos/rdsign/src/App.tsx",lineNumber:14,columnNumber:9},globalThis)]},void 0,!0,{fileName:"D:/projetos/rdsign/src/App.tsx",lineNumber:5,columnNumber:5},globalThis);createRoot$1(document.getElementById("root")).render(jsxDevRuntimeExports.jsxDEV(reactExports.StrictMode,{children:jsxDevRuntimeExports.jsxDEV(App,{},void 0,!1,{fileName:"D:/projetos/rdsign/src/main.tsx",lineNumber:8,columnNumber:9},globalThis)},void 0,!1,{fileName:"D:/projetos/rdsign/src/main.tsx",lineNumber:7,columnNumber:5},globalThis));
